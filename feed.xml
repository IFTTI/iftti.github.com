<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IT技术干货</title>
    <description>[IT技术干货iftti.com] @KernelHacks</description>
    <link>http://iftti.com/</link>
    <atom:link href="http://iftti.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 28 Jul 2014 00:46:45 +0800</pubDate>
    <lastBuildDate>Mon, 28 Jul 2014 00:46:45 +0800</lastBuildDate>
    <generator>Jekyll v2.1.0</generator>
    
      <item>
        <title>在 MacBook 上使用 PDL 绘图 </title>
        <description>

  
  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;之前在 Linux 服务器上使用 PDL，主要是一些矩阵函数，这次准备在个人电脑上使用 PDL，尤其是本身的绘图功能，其一目的就是导出 zabbix 中存储的监控数据，通过 PDL 绘图观察其季节性分布情况。&lt;/p&gt;

&lt;p&gt;不过在使用的时候，发现在 MacBook 上跑 PDL 还是有点上手难度的。和 pylab 不同，PDL 是使用了 X11 的，而 MacBook 最新的版本里，X11 已经不再是自带的了。所以需要单独去下载 &lt;a href=&quot;https://www.macupdate.com/app/mac/26593/xquartz&quot;&gt;XQuartz&lt;/a&gt; 安装包来提供 X11 支持。&lt;/p&gt;

&lt;p&gt;安装好了 XQuartz 以后，再安装 PDL::Graphics:: 名字空间下的几个模块就好办了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PDL::Graphics::Simple&lt;/li&gt;
  &lt;li&gt;PDL::Graphics::Gnuplot&lt;/li&gt;
  &lt;li&gt;PDL::Graphics::PGPLOT&lt;/li&gt;
  &lt;li&gt;PDL::Graphics::Prima&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外还有 PDL::Graphics::PLplot 等，不过通过 &lt;code&gt;port install plplot&lt;/code&gt; 安装的 plplot 没有 header 文件，所以 PDL::Graphics::PLplot 是安装不上的，既然前面已经有了不少，这里也就不再追求自己下载 plplot 源代码来安装了。&lt;/p&gt;

&lt;p&gt;PDL::Graphics::Simple 是 《PDL Book》开篇第一个示例就使用的模块，其实际就是按顺序尝试加载 &lt;code&gt;::Gnuplot&lt;/code&gt;、&lt;code&gt;::PGPLOT&lt;/code&gt;、&lt;code&gt;::PLplot&lt;/code&gt; 和 &lt;code&gt;::Prima&lt;/code&gt;。所以，保证有一个可用就好了。&lt;/p&gt;

&lt;p&gt;不过在我的 air 上实际的效果来看，perldl 命令在使用 子进程跟 gnuplot 交互的时候&lt;strong&gt;非常非常非常的慢！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好了，现在就可以运行程序了：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span class=&quot;c1&quot;&gt;#!/usr/bin/env perl&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;warnings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;feature&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;:5.16&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Path::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tiny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;YAML&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PDL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;PDL::Graphics::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGPLOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Zabbix2::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;config.yml&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slurp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zbconf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;zabbix&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zabbix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;nn&quot;&gt;Zabbix2::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://$zbconf-&amp;gt;{&#39;addr&#39;}/zabbix/api_jsonrpc.php&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$zabbix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;login&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zbconf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;user&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zbconf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;pass&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;vg&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;could not authenticate&#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$items&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zabbix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;Item&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;groupids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hostids&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11036&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;graphids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1824829&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$item&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@$items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;name&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$itemid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;itemid&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$itemid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$sitems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zabbix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_single&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&#39;Item&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;itemids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$itemid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$pdl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pdl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$sitems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;history&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time_from&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3600&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$pdl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里使用了 &lt;a href=&quot;https://metacpan.org/pod/Zabbix2::API&quot;&gt;Zabbix2::API&lt;/a&gt; 模块，相对比 &lt;a href=&quot;http://blog.zabbix.com/getting-started-with-zabbix-api/1381/&quot;&gt;zabbix 官方博客示例&lt;/a&gt;直接使用 &lt;a href=&quot;https://metacpan.org/pod/JSON::RPC&quot;&gt;JSON::RPC&lt;/a&gt; 模块，以及 python 的 pyzabbix 模块来说，Zabbix2::API 模块封装的非常好，history 是作为 item 对象的属性出现，而不是单独再请求一次 &lt;code&gt;history.get&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;另外，不知道为什么，使用 pyzabbix 模块就一直无法正常使用，而自己写 requests 和 json 却没问题。上面的 perl 脚本用 python 改写就是下面这样：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;Read item history from zabbix, and plot as histogram&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;matplotlib&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;np&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;matplotlib.mlab&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;mlab&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;plt&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;requests&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;json&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;datetime&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ZABBIX_URI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;http://test.zabbix.com/zabbix/api_jsonrpc.php&#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ZABBIX_USR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;user&#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ZABBIX_PWD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;pass&#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HOURS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;zabbixLogin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;user&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;password&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passwd&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zabbixCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;user.login&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;zabbixCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;jsonrpc&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;2.0&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;method&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;params&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;id&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;auth&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZABBIX_URI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dumps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;content-type&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;application/json-rpc&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;result&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;authId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zabbixLogin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZABBIX_USR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZABBIX_PWD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;Get Auth ID: &#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&#39;groupids&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&#39;hostids&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11036&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&#39;graphids&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1824829&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zabbixCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;item.get&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mktime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timetuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3600&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HOURS&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;Begin loop for history...&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;output&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;extend&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;history&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;itemids&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;itemid&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;time_from&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zabbixCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;history.get&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;history&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;value&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;history&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;figure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;item: &#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;itemid&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#  lline = numpy.percentile(v, 25)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#  uline = numpy.percentile(v, 75)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#  low = 2 * lline - uline&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#  up = 2 * uline - lline&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;figure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boxplot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sym&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;+&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;notch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;item: &#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;itemid&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


    &lt;hr&gt;
    
    &lt;hr&gt;
    


  &lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;






  &lt;/div&gt;

</description>
        <pubDate>Sun, 27 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-27-using-pdl-on-macbook-0a2e8590f.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-27-using-pdl-on-macbook-0a2e8590f.html</guid>
        
        
      </item>
    
      <item>
        <title>iOS开发如何提高</title>
        <description>
&lt;p&gt;&lt;img src=&quot;/images/devtang.com/79692bab05e21d2e6ef22c2bdacb7f5d.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;许多人在博客和微信上咨询我iOS开发如何提高，经过一番思考之后，我能想到如下一些提高的办法，我个人也是通过这些方法来提高的。&lt;/p&gt;

&lt;h2&gt;阅读博客&lt;/h2&gt;

&lt;p&gt;在现在这个碎片化阅读流行的年代，博客的风头早已被微博盖过。而我却坚持写作博客，并且大量地阅读同行的iOS开发博客。博客的文章长度通常在3000字左右，许多iOS开发知识都至少需要这样的篇幅才能完整地讲解清楚。并且博客相对于书籍来说，并没有较长的出版发行时间，所以阅读博客对于获取最新的iOS开发知识有着非常良好的效果。&lt;/p&gt;

&lt;p&gt;我自己精心整理了国内40多位iOS开发博主的博客地址列表：&lt;a href=&quot;https://github.com/tangqiaoboy/iOSBlogCN&quot;&gt;https://github.com/tangqiaoboy/iOSBlogCN&lt;/a&gt;，希望大家都能培养起阅读博客的习惯。&lt;/p&gt;

&lt;p&gt;国外也有很多优秀的iOS开发博客，他们整体质量比中文的博客更高，以下是一些推荐的博客地址列表：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;博客名 &lt;/th&gt;
&lt;th&gt; 博客地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;objc.io &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://www.objc.io/&quot;&gt;http://www.objc.io/&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ray Wenderlich&lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://www.raywenderlich.com&quot;&gt;http://www.raywenderlich.com&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iOS Developer Tips &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://iosdevelopertips.com/&quot;&gt;http://iosdevelopertips.com/&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iOS Dev Weekly &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://iosdevweekly.com/&quot;&gt;http://iosdevweekly.com/&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NSHipster &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://nshipster.com/&quot;&gt;http://nshipster.com/&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Bartosz Ciechanowski &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://ciechanowski.me&quot;&gt;http://ciechanowski.me&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Big Nerd Ranch Blog &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://blog.bignerdranch.com&quot;&gt;http://blog.bignerdranch.com&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Nils Hayat &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://nilsou.com/&quot;&gt;http://nilsou.com/&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;另外，使用博客RSS聚合工具（例如Feedly：&lt;a href=&quot;http://www.feedly.com/&quot;&gt;http://www.feedly.com/&lt;/a&gt;）可以获得更好的博客阅读体验。手机上也有很多优秀的博客阅读工具（我使用的是&lt;a href=&quot;http://newsify.co/&quot;&gt;Newsify&lt;/a&gt;）。合理地使用这些工具也可以将你在地铁上、睡觉前等碎片时间充分利用上。&lt;/p&gt;

&lt;h2&gt;读书&lt;/h2&gt;

&lt;p&gt;博客的内容通常只能详细讲解一个知识点，而书籍则能成体系地介绍整个知识树。相比国外，中国的书籍售价相当便宜，所以这其实是一个非常划算的提高的方式。建议大家每年至少坚持读完1本高质量的iOS开发书籍。&lt;/p&gt;

&lt;p&gt;去年出版的&lt;a href=&quot;http://as.wiley.com/WileyCDA/WileyTitle/productCd-1118818342.html&quot;&gt;《iOS 7 Programming Pushing the Limits》&lt;/a&gt; 以及  &lt;a href=&quot;http://item.jd.com/11258970.html&quot;&gt;《Objective-C高级编程：iOS与OS X多线程和内存管理》&lt;/a&gt; 都算是不错的进阶方面的读物。顺便打个广告，我自己也在写一本iOS进阶方面的图书，年底前应该能上市。&lt;/p&gt;

&lt;h2&gt;看WWDC视频&lt;/h2&gt;

&lt;p&gt;由于iOS开发在快速发展，每年苹果都会给我们带来很多新的知识。而对于这些知识，第一手的资料就是WWDC的视频。&lt;/p&gt;

&lt;p&gt;通常情况下，一个iOS开发的新知识首先会在WWDC上被苹果公开，然后3个月左右，会有国内外的博客介绍这些知识，再过半年左右，会有国外的图书介绍这些知识。所以如果想尽早地了解这些知识，那么只有通过WWDC的视频。&lt;/p&gt;

&lt;p&gt;现在每年的WWDC视频都会在会议过程中逐步放出，重要的视频会带有英文字幕。坚持阅读这些视频不但可以获得最新的iOS开发知识，还可以提高英文听力水平。&lt;/p&gt;

&lt;h2&gt;看苹果的官方文档&lt;/h2&gt;

&lt;p&gt;苹果的官方文档相当详尽，对于不熟悉的API，阅读官方文档也是最直接有效地方式。&lt;/p&gt;

&lt;p&gt;苹果的文档比较海量，适合选一些重点来阅读，比如人机交互指南就是必读的，而其它的内容可以遇到的时候作为重点资源来查阅。&lt;/p&gt;

&lt;h2&gt;看开源项目的代码&lt;/h2&gt;

&lt;p&gt;大家一定有这样的感受，很多时候用文字讲解半天，还不如写几行代码来得直观。阅读优秀的开源项目代码，不但可以学习到iOS开发本身的基本知识，还能学习到设计模式等软件架构上的知识。&lt;/p&gt;

&lt;p&gt;如果读者能够参与到开源项目的开发中，则能进一步提高自己的能力。&lt;/p&gt;

&lt;h2&gt;多写代码，多思考&lt;/h2&gt;

&lt;p&gt;知识的积累离不开实践和总结，我认为iOS代码量如果没有超过10万行，是不能称得上熟悉iOS开发的。某些在校的学生，仅仅做了几个C++的大作业，就在求职简历里面写上“精通C++”，则真是让人哭笑不得。&lt;/p&gt;

&lt;p&gt;在多写代码的同时，我们也要注意不要”重复造轮子”，尽量保证每次写的代码都能具有复用性。在代码结构因为业务需求需要变更时，及时重构，在不要留下技术债的同时，我们也要多思考如何设计应用架构，能够保证满足灵活多变的产品需求。&lt;/p&gt;

&lt;p&gt;在多次重构和思考的过程中，我们就会慢慢积累出一类问题的“最佳实践”方式，成为自己宝贵的经验。&lt;/p&gt;

&lt;h2&gt;多和同行交流&lt;/h2&gt;

&lt;p&gt;有些时候遇到一些难解的技术问题，和同行的几句交流就可能让你茅塞顿开。。另外常见的技术问题通常都有人以前遇到过，简单指导几句就能让你一下子找到正确的解决方向。&lt;/p&gt;

&lt;p&gt;国内开发者之间的交流，可以通过论坛，微博，QQ群等方式来进行。另外各大公司有时候会办技术沙龙，这也是一个认识同行的好机会。&lt;/p&gt;

&lt;p&gt;需要特别提醒的是，和国内开发者之前交流要注意讨论质量，有一些论坛和QQ群讨论质量相当低下，提的问题都是能通过简单Google获得的，这种社区一定要远离，以提高自己的沟通效率。&lt;/p&gt;

&lt;p&gt;除了在国内的技术社区交流，建议读者可以去国外的stackoverflow：&lt;a href=&quot;http://www.stackoverflow.com&quot;&gt;http://www.stackoverflow.com&lt;/a&gt;上提问或回答问题。&lt;/p&gt;

&lt;h2&gt;分享&lt;/h2&gt;

&lt;p&gt;值得尝试的分享方式有：发起一个开源项目、写技术博客、在技术会议上做报告。这几种方式都比较有挑战，但是如果能大胆尝试，肯定会有巨大的收获。&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-27-ios-levelup-tips-44de87aac.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-27-ios-levelup-tips-44de87aac.html</guid>
        
        
      </item>
    
      <item>
        <title>Chef入门（二）</title>
        <description>

	
	

	&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/a21eddb15b6ddbe9e395938fd299dee1.jpg&quot; title=&quot;Chef&quot; alt=&quot;Chef&quot;&gt;&lt;/p&gt;

&lt;p&gt;上一篇文章&lt;a href=&quot;/learn-chef-01.html&quot;&gt;Chef入门（一）&lt;/a&gt;我们介绍了Chef是什么、以及如何搭建Chef环境。这篇文章，我们介绍一下Chef中的一些概念以及如何编写&lt;a href=&quot;http://docs.getchef.com/chef_overview_cookbooks.html&quot;&gt;cookbook&lt;/a&gt;，并在此过程中部署一个Apache环境，通过本文你可以学到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建一个cookbook，并在其中添加recipe&lt;/li&gt;
&lt;li&gt;上传你的cookbook到Chef server&lt;/li&gt;
&lt;li&gt;配置node的run list&lt;/li&gt;
&lt;li&gt;在你的目标node上运行chef-client，执行cookbook中定义的操作。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;一些概念&lt;/h1&gt;

&lt;h2&gt;cookbook&lt;/h2&gt;

&lt;p&gt;cookbook是配置和策略的集合单元，它定义了一个场景，比如部署Apache环境。一个cookbook包含了很多组件来支持实现这个场景，以下是一个cookbook的目录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-rw-r--r--  1 weizhifeng  staff   495 Jul 21 11:01 CHANGELOG.md
-rw-r--r--@ 1 weizhifeng  staff  1536 Jul 21 11:01 README.md
drwxr-xr-x  2 weizhifeng  staff    68 Jul 21 11:01 attributes
drwxr-xr-x  2 weizhifeng  staff    68 Jul 21 11:01 definitions
drwxr-xr-x  3 weizhifeng  staff   102 Jul 21 11:01 files
drwxr-xr-x  2 weizhifeng  staff    68 Jul 21 11:01 libraries
-rw-r--r--@ 1 weizhifeng  staff   298 Jul 21 11:01 metadata.rb
drwxr-xr-x  2 weizhifeng  staff    68 Jul 21 11:01 providers
drwxr-xr-x  3 weizhifeng  staff   102 Jul 26 11:05 recipes
drwxr-xr-x  2 weizhifeng  staff    68 Jul 21 11:01 resources
drwxr-xr-x  3 weizhifeng  staff   102 Jul 21 11:01 templates
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;attributes：用来设置node的属性&lt;/li&gt;
&lt;li&gt;definitions：用来创建可以重用的resource集合&lt;/li&gt;
&lt;li&gt;files：一些需要的文件&lt;/li&gt;
&lt;li&gt;libraries：用来扩展chef-client或者添加一些helper到Ruby中&lt;/li&gt;
&lt;li&gt;metadata.rb：包含一些元数据，比如cookbook的名字、版本、支持的平台等等&lt;/li&gt;
&lt;li&gt;recipes：存储recipe，每个recipe指定了需要的resource以及这些resource执行的顺序&lt;/li&gt;
&lt;li&gt;resources：存储自定义的resource&lt;/li&gt;
&lt;li&gt;providers：存储自定义的provider&lt;/li&gt;
&lt;li&gt;templates：存储ruby模板语言描述的文件，用来解决复杂的配置场景&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;recipe&lt;/h2&gt;

&lt;p&gt;每个cookbook都会包含一到多个recipe（默认是default.rb）。一个recipe就是实现cookbook所描述场景的步骤。看以下这个简单的recipe：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package &#39;apache2&#39; do
  action :install
end

service &#39;apache2&#39; do
  action [ :enable, :start ]
end

cookbook_file &#39;/var/www/index.html&#39; do
  source &#39;index.html&#39;
  mode &#39;0644&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出这个recipe分为三个步骤，分别是安装apache2、启动apache2、拷贝文件。&lt;/p&gt;

&lt;h2&gt;resource和provider&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.getchef.com/chef/resources.html&quot;&gt;resource&lt;/a&gt;就是recipe中的配置项，可以是package、service、bash等等。provider就是为这些resource提供实现的程序。以编程语言来描述的话，resource定义了接口，provider提供了不同平台的实现。&lt;/p&gt;

&lt;h1&gt;实战&lt;/h1&gt;

&lt;p&gt;说了那么多概念，我们接下来在ubuntu上安装并配置Apache。&lt;/p&gt;

&lt;h2&gt;第一步：创建cookbook&lt;/h2&gt;

&lt;p&gt;在workstation中，我们通过&lt;a href=&quot;http://docs.opscode.com/knife.html&quot;&gt;knife&lt;/a&gt;来和Chef server进行交互。执行以下命令来创建一个cookbook。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/chef-repo
$ knife cookbook create apache-tutorial-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完成之后，在&lt;code&gt;~/chef-repo/cookbooks&lt;/code&gt;目录下会生成名为&lt;code&gt;apache-tutorial-1&lt;/code&gt;的cookbook。不过cookbook都是在本地的，还没有上传到Chef server。&lt;/p&gt;

&lt;h2&gt;第二步：编写recipe&lt;/h2&gt;

&lt;p&gt;当你创建了一个cookbook，Chef会帮你创建一个默认的recipe。用你的编辑器打开&lt;code&gt;~/chef-repo/cookbooks/apache-tutorial-1/recipes/default.rb&lt;/code&gt;。现在让我们来写一些ruby代码来执行以下的动作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装Apache&lt;/li&gt;
&lt;li&gt;启动Apache并且添加到开机启动&lt;/li&gt;
&lt;li&gt;配置home page&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;把以下代码添加到recipe中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package &#39;apache2&#39; do
  action :install
end

service &#39;apache2&#39; do
  action [ :enable, :start ]
end

cookbook_file &#39;/var/www/index.html&#39; do
  source &#39;index.html&#39;
  mode &#39;0644&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;第三步：添加文件资源&lt;/h2&gt;

&lt;p&gt;recipe的最后一步我们使用了&lt;a href=&quot;http://docs.opscode.com/resource_cookbook_file.html&quot;&gt;cookbook_file&lt;/a&gt;来拷贝home page。把以下内容添加到文件&lt;code&gt;~/chef-repo/cookbooks/apache-tutorial-1/files/default/index.html&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;第四步：上传cookbook&lt;/h2&gt;

&lt;p&gt;在你的chef-repo目录中执行以下命令来上传cookbook。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ knife cookbook upload apache-tutorial-1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;第五步：创建run list&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://learn.getchef.com/concepts/run-lists/&quot;&gt;run list&lt;/a&gt;定义了recipe的执行顺序，当前的例子中我们的run list中只有一个recipe。打开&lt;a href=&quot;http://manage.opscode.com&quot;&gt;manage.opscode.com&lt;/a&gt;，我们来配置run list。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/96c74b6968085a0b965e264aa5580207.jpg&quot; title=&quot;Chef&quot; alt=&quot;Chef&quot;&gt;&lt;/p&gt;

&lt;p&gt;然后从&lt;code&gt;Available Recipes&lt;/code&gt;中拖拽recipe到&lt;code&gt;Current Run List&lt;/code&gt;之中。然后点击&lt;code&gt;Save Run List&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/102b02c4239de93eb603a4c0cedeacba.jpg&quot; title=&quot;Chef&quot; alt=&quot;Chef&quot;&gt;&lt;/p&gt;

&lt;h2&gt;第六步：运行chef-client&lt;/h2&gt;

&lt;p&gt;接下来你需要执行&lt;a href=&quot;http://docs.opscode.com/essentials_chef_client.html&quot;&gt;chef-client&lt;/a&gt;来从Chef server获取最新的cookbook，并且在目标node上执行。你可以自己登录到node上，然后手动执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh chef@your.host
$ ssh sudo chef-client
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者使用knife。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ knife ssh your.host &#39;sudo chef-client&#39; -m -x chef -P chef
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-x&lt;/code&gt;表示username，&lt;code&gt;-P&lt;/code&gt;表示password。&lt;/p&gt;

&lt;p&gt;如果你使用的是vagrant，则执行如下命令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ knife ssh localhost &#39;sudo chef-client&#39; -m -x vagrant -P vagrant --ssh-port 2200
Starting Chef Client, version 11.12.8
resolving cookbooks for run list: [&quot;apache-tutorial-1&quot;]
Synchronizing Cookbooks:
  - apache-tutorial-1
Compiling Cookbooks...
Converging 3 resources
Recipe: apache-tutorial-1::default
  * package[apache2] action install (up to date)
  * service[apache2] action enable (up to date)
  * service[apache2] action start (up to date)
  * cookbook_file[/var/www/index.html] action create (up to date)

Running handlers:
Running handlers complete

Chef Client finished, 0/4 resources updated in 19.554803129 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等chef-client执行完成之后，你会发现Apache已经配置好并且运行了，并且把home page拷贝到了&lt;code&gt;/var/www/index.html&lt;/code&gt;，访问80端口应该可以看到home page的输出。&lt;/p&gt;

&lt;p&gt;至此我们已经创建了自己的cookbook，并在目标node上执行，更多的内容可以查看&lt;a href=&quot;http://docs.opscode.com/&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h1&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.getchef.com/chef_overview_cookbooks.html&quot;&gt;http://docs.getchef.com/chef_overview_cookbooks.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.getchef.com/legacy/tutorials/create-your-first-cookbook/&quot;&gt;http://learn.getchef.com/legacy/tutorials/create-your-first-cookbook/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.getchef.com/chef/resources.html&quot;&gt;http://docs.getchef.com/chef/resources.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


	(完)

	&lt;div class=&quot;post-info&quot;&gt;
		26 Jul 2014  
	
		
	
		
	&lt;/div&gt;
	
	&lt;!-- disqus start --&gt;
	
	
	&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;http://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;
&lt;/noscript&gt;
	
	&lt;!-- disqus end --&gt;

	&lt;!-- related start --&gt;
	
	&lt;!-- related end --&gt;

</description>
        <pubDate>Sat, 26 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-26-learn-chef-02.html-182938c79.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-26-learn-chef-02.html-182938c79.html</guid>
        
        
      </item>
    
      <item>
        <title>整形数据转换为字符串的研究</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;目前已经有多种将整形数据转换为字符串表达式的方法。虽然这些转换方法很少会遇到什么瓶颈，但是在分析特定应用的时候就有可能了。比如，在&lt;a title=&quot;Lawn&quot; href=&quot;http://lwan.ws/&quot; target=&quot;_blank&quot;&gt;Lwan&lt;/a&gt;里面构建响应头部的时候就经常会出现。&lt;/p&gt;
&lt;p&gt;就拿Lwan来说吧，最初是用snprintf()函数来转换数字。虽然在表面上这确实能起作用，但是却太没劲了。&lt;/p&gt;
&lt;p&gt;第二种方法是使用朴素算法：将原数连续与10相除，每次都把模转换成一个字符加在字符串后，当除到最后的余数为0时就停止并将字符串倒序得到最后的字符串。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: false&quot;&gt;// Code based on https://code.google.com/p/stringencoders/
size_t naive_uint32_to_str(uint32_t value, char *str) {
    char *wstr = str;
    // Conversion. Number is reversed.
    do
       *wstr++ = (char) decimal_digits[uvalue % 10];
    while (uvalue /= 10);
    *wstr = &#39;&#39;;
    // Reverse string
    strreverse(str, wstr - 1);
    return wstr - str;
}&lt;/pre&gt;
&lt;p&gt;这在一般情况下还是可以的，但倒转字符串的那一步总是令我困扰，为什么不直接向后写字符串呢?&lt;/p&gt;
&lt;p&gt;之后我就把Lawn的代码改写成了如下代码段。需要注意的是，无论sizeof(int32_t)是多少，我都把数字的最大的字节大小(包括终止符)设置成了MAX_INT的3倍。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: false&quot;&gt;#define INT_TO_STR_BUFFER_SIZE (3 * sizeof(int32_t))

char *lwan_uint32_to_str(uint32_t value,
            char buffer[static INT_TO_STR_BUFFER_SIZE],
            size_t *len) {
    char *p = buffer + INT_TO_STR_BUFFER_SIZE - 1;

    *p = &#39;&#39;;
    do {
        *--p = &quot;0123456789&quot;[value % 10];
    } while (value /= 10);

    size_t difference = (size_t)(p - buffer);
    *len = (size_t)(INT_TO_STR_BUFFER_SIZE - difference - 1;

    return p;
}&lt;/pre&gt;
&lt;p&gt;减少数组的写入操作使得算法速度明显加快。然而，在我修补刚才那个算法的时候我却犯了一个很多人都会尽量避免的错误：我让数组进行了额外的查询工作，在没有测试它的表现是否会更好的情况下就不管三七二十一提交了代码。如果使用查表法会比这快9%，噢！&lt;/p&gt;
&lt;p&gt;就在去年，Facebook的工程团队发布了一个更快的将整数转换成字符串的&lt;a title=&quot;函数&quot; href=&quot;https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920&quot; target=&quot;_blank&quot;&gt;函数&lt;/a&gt;。他们同样避免了将各个数字转换后形成的字符串转置的操作，并且他们把查表法运用得很好。&lt;/p&gt;
&lt;p&gt;这里的技巧就是，他们把这张表做成了从00到99的数值对，而不是简单的10个数字。这样就把除法运算的数量减少了一半，算法的性能得到很大的提升：比上面的代码段快了大概31%：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: false&quot;&gt;size_t facebook_uint32_to_str(uint32_t value, char *dst)
{
    static const char digits[201] =
        &quot;0001020304050607080910111213141516171819&quot;
        &quot;2021222324252627282930313233343536373839&quot;
        &quot;4041424344454647484950515253545556575859&quot;
        &quot;6061626364656667686970717273747576777879&quot;
        &quot;8081828384858687888990919293949596979899&quot;;
    size_t const length = digits10(value);
    size_t next = length - 1;
    while (value &amp;gt;= 100) {
        auto const i = (value % 100) * 2;
        value /= 100;
        dst[next] = digits[i + 1];
        dst[next - 1] = digits[i];
        next -= 2;
    }
    // Handle last 1-2 digits
    if (value &amp;lt; 10) {
        dst[next] = &#39;0&#39; + uint32_t(value);
    } else {
        auto i = uint32_t(value) * 2;
        dst[next] = digits[i + 1];
        dst[next - 1] = digits[i];
    }
    return length;
}&lt;/pre&gt;
&lt;p&gt;digits10()函数是另外一个使用特殊方式计算数字里面数字个数的函数。即使是高性能，我们也得想法防止一起调用这些东西：使用一个像numeric_limits&amp;lt;uint32_t&amp;gt;::digits10的常量来保持接口的一致性。这是可以实现的，因为dst缓存应该有足够的大小去容纳最大32位的无符号整型数据。&lt;/p&gt;
&lt;p&gt;这个函数基本上都是在把数字和10的次方相比较，并且当数字的位数超过了他们要比较的数的最大次方时就递归。由于这种实现细节，对于一个很小的数使用一个不变的长度并不会使速度得到显著的提升(比如一位或两位数字)；但如果你是出于优化的角度讲，那么使用一个常量并无大碍。如此，在我的机器上(一款搭载酷睿i7 2640M装有最新64位Arch Linux系统的笔记本)，它始终都会执行得更快：&lt;/p&gt;
&lt;div id=&quot;attachment_73982&quot; class=&quot;wp-caption alignnone&quot; style=&quot;width: 610px&quot;&gt;
&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/518b3804e42dfec09dc928ef21a38739.png&quot; rel=&quot;lightbox[73979]&quot; title=&quot;facebook_unit32_to_str()函数使用digits10()和常量值的相对速度&quot;&gt;&lt;img class=&quot;size-full wp-image-73982&quot; title=&quot;facebook_unit32_to_str()函数使用digits10()和常量值的相对速度&quot; alt=&quot;9V0PsPK&quot; src=&quot;/images/jobbole.com/ecbb24c54a151c9301fb6ad3fbeab730.jpg&quot; width=&quot;600&quot; height=&quot;371&quot;&gt;&lt;/a&gt;
&lt;p class=&quot;wp-caption-text&quot;&gt;facebook_unit32_to_str()函数使用digits10()和常量值的相对速度&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;上面这张图来源于我自己写的一个能够测试上面所有的整型转字符串方法的一个标准的程序。下面是一更完整的表，里面还和其它的一些方法进行了对比。&lt;/p&gt;
&lt;div id=&quot;attachment_73985&quot; class=&quot;wp-caption alignnone&quot; style=&quot;width: 610px&quot;&gt;
&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/531f1ea7fff6273f70d391ccff0af298.png&quot; rel=&quot;lightbox[73979]&quot; title=&quot;整形数据转换为字符串的研究&quot;&gt;&lt;img class=&quot;size-full wp-image-73985&quot; alt=&quot;b2enLNt&quot; src=&quot;/images/jobbole.com/f87cb7aa8b121de8ca5b0c94ae8ef0cd.jpg&quot; width=&quot;600&quot; height=&quot;371&quot;&gt;&lt;/a&gt;
&lt;p class=&quot;wp-caption-text&quot;&gt;省去了较大偏差的snprintf()函数，PS：它太慢了&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;不幸的是，本文存在这一个许可问题，它并不允许我使用Lawn的代码。这篇博客文章并没有提到这个许可。我是在《&lt;a title=&quot;https://mail-archives.apache.org/mod_mbox/apr-dev/200704.mbox/%3C344-65769@sneakemail.com%3E&quot; href=&quot;https://mail-archives.apache.org/mod_mbox/apr-dev/200704.mbox/%3C344-65769@sneakemail.com%3E&quot; target=&quot;_blank&quot;&gt;two-digit lookup table in places unrelated to Facebook&lt;/a&gt;》发现这个算法的，所以我并不确定到底是谁最先提出的。上面这些问题的很大的一个来源是&lt;a href=&quot;http://www.hackersdelight.org/&quot; target=&quot;_blank&quot;&gt;Hacker’s Delight&lt;/a&gt;网站，但是现在在那里却找不到了。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Sat, 26 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-26-73979-ecbf32eac.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-26-73979-ecbf32eac.html</guid>
        
        
      </item>
    
      <item>
        <title>Python 网页爬虫 &amp; 文本处理 &amp; 科学计算 &amp; 机器学习 &amp; 数据挖掘兵器谱</title>
        <description>

						&lt;p&gt;曾经因为&lt;a href=&quot;http://www.52nlp.cn/%E6%8E%A8%E8%8D%90%EF%BC%8D%E7%94%A8python%E8%BF%9B%E8%A1%8C%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%8D%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-nltk%E9%85%8D%E5%A5%97%E4%B9%A6&quot;&gt;NLTK&lt;/a&gt;的缘故开始学习Python，之后渐渐成为我工作中的第一辅助脚本语言，虽然开发语言是C/C++，但平时的很多文本数据处理任务都交给了Python。离开腾讯创业后，第一个作品&lt;a href=&quot;http://coursegraph.com/&quot;&gt;课程图谱&lt;/a&gt;也是选择了Python系的Flask框架，渐渐的将自己的绝大部分工作交给了Python。这些年来，接触和使用了很多Python工具包，特别是在文本处理，科学计算，机器学习和数据挖掘领域，有很多很多优秀的Python工具包可供使用，所以作为Pythoner，也是相当幸福的。其实如果仔细留意微博，你会发现很多这方面的分享，自己也Google了一下，发现也有同学总结了“&lt;a href=&quot;http://qxde01.blog.163.com/blog/static/67335744201368101922991/&quot;&gt;Python机器学习库&lt;/a&gt;”，不过总感觉缺少点什么。最近流行一个词，全栈工程师（full stack engineer），作为一个苦逼的创业者，天然的要把自己打造成一个full stack engineer，而这个过程中，这些Python工具包给自己提供了足够的火力，所以想起了这个系列。当然，这也仅仅是抛砖引玉，希望大家能提供更多的线索，来汇总整理一套Python网页爬虫，文本处理，科学计算，机器学习和数据挖掘的兵器谱。&lt;/p&gt;
&lt;p&gt;一、Python网页爬虫工具集&lt;/p&gt;
&lt;p&gt;一个真实的项目，一定是从获取数据开始的。无论文本处理，机器学习和数据挖掘，都需要数据，除了通过一些渠道购买或者下载的专业数据外，常常需要大家自己动手爬数据，这个时候，爬虫就显得格外重要了，幸好，Python提供了一批很不错的网页爬虫工具框架，既能爬取数据，也能获取和清洗数据，我们也就从这里开始了：&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://scrapy.org/&quot;&gt;Scrapy&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Scrapy, a fast high-level screen scraping and web crawling framework for Python.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;鼎鼎大名的Scrapy，相信不少同学都有耳闻，&lt;a href=&quot;http://coursegraph.com&quot;&gt;课程图谱&lt;/a&gt;中的很多课程都是依靠Scrapy抓去的，这方面的介绍文章有很多，推荐大牛pluskid早年的一篇文章：《&lt;a href=&quot;http://blog.pluskid.org/?p=366&quot;&gt;Scrapy 轻松定制网络爬虫&lt;/a&gt;》，历久弥新。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://scrapy.org/&quot;&gt;http://scrapy.org/&lt;/a&gt;&lt;br&gt;
Github代码页: &lt;a href=&quot;https://github.com/scrapy/scrapy&quot;&gt;https://github.com/scrapy/scrapy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/&quot;&gt;Beautiful Soup&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;You didn’t write that awful page. You’re just trying to get some data out of it. Beautiful Soup is here to help. Since 2004, it’s been saving programmers hours or days of work on quick-turnaround screen scraping projects.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;读书的时候通过《集体智慧编程》这本书知道Beautiful Soup的，后来也偶尔会用用，非常棒的一套工具。客观的说，Beautifu Soup不完全是一套爬虫工具，需要配合urllib使用，而是一套HTML/XML数据分析，清洗和获取工具。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/&quot;&gt;http://www.crummy.com/software/BeautifulSoup/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;https://github.com/grangier/python-goose&quot;&gt;Python-Goose&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Html Content / Article Extractor, web scrapping lib in Python&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/GravityLabs/goose&quot;&gt;Goose&lt;/a&gt;最早是用Java写得，后来用Scala重写，是一个Scala项目。Python-Goose用Python重写，依赖了Beautiful Soup。前段时间用过，感觉很不错，给定一个文章的URL, 获取文章的标题和内容很方便。&lt;/p&gt;
&lt;p&gt;Github主页：&lt;a href=&quot;https://github.com/grangier/python-goose&quot;&gt;https://github.com/grangier/python-goose&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二、Python文本处理工具集&lt;/p&gt;
&lt;p&gt;从网页上获取文本数据之后，依据任务的不同，就需要进行基本的文本处理了，譬如对于英文来说，需要基本的tokenize，对于中文，则需要常见的中文分词，进一步的话，无论英文中文，还可以词性标注，句法分析，关键词提取，文本分类，情感分析等等。这个方面，特别是面向英文领域，有很多优秀的工具包，我们一一道来。&lt;br&gt;
&lt;span id=&quot;more-6666&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://www.nltk.org/&quot;&gt;NLTK&lt;/a&gt; — Natural Language Toolkit&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;NLTK is a leading platform for building Python programs to work with human language data. It provides easy-to-use interfaces to over 50 corpora and lexical resources such as WordNet, along with a suite of text processing libraries for classification, tokenization, stemming, tagging, parsing, and semantic reasoning, and an active discussion forum.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;搞自然语言处理的同学应该没有人不知道NLTK吧，这里也就不多说了。不过推荐两本书籍给刚刚接触NLTK或者需要详细了解NLTK的同学: 一个是官方的《Natural Language Processing with Python》，以介绍NLTK里的功能用法为主，同时附带一些Python知识，同时国内陈涛同学友情翻译了一个中文版，这里可以看到：&lt;a href=&quot;http://www.52nlp.cn/%E6%8E%A8%E8%8D%90%EF%BC%8D%E7%94%A8python%E8%BF%9B%E8%A1%8C%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%8D%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-nltk%E9%85%8D%E5%A5%97%E4%B9%A6&quot;&gt;推荐《用Python进行自然语言处理》中文翻译-NLTK配套书&lt;/a&gt;；另外一本是《Python Text Processing with NLTK 2.0 Cookbook》，这本书要深入一些，会涉及到NLTK的代码结构，同时会介绍如何定制自己的语料和模型等，相当不错。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.nltk.org/&quot;&gt;http://www.nltk.org/&lt;/a&gt;&lt;br&gt;
Github代码页：&lt;a href=&quot;https://github.com/nltk/nltk&quot;&gt;https://github.com/nltk/nltk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://www.clips.ua.ac.be/pattern&quot;&gt;Pattern&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pattern is a web mining module for the Python programming language.&lt;/p&gt;
&lt;p&gt;It has tools for data mining (Google, Twitter and Wikipedia API, a web crawler, a HTML DOM parser), natural language processing (part-of-speech taggers, n-gram search, sentiment analysis, WordNet), machine learning (vector space model, clustering, SVM), network analysis and canvas visualization.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pattern由比利时安特卫普大学CLiPS实验室出品，客观的说，Pattern不仅仅是一套文本处理工具，它更是一套web数据挖掘工具，囊括了数据抓取模块（包括Google, Twitter, 维基百科的API，以及爬虫和HTML分析器），文本处理模块（词性标注，情感分析等），机器学习模块(VSM, 聚类，SVM）以及可视化模块等，可以说，Pattern的这一整套逻辑也是这篇文章的组织逻辑，不过这里我们暂且把Pattern放到文本处理部分。我个人主要使用的是它的英文处理模块&lt;a href=&quot;http://www.clips.ua.ac.be/pages/pattern-en&quot;&gt;Pattern.en&lt;/a&gt;, 有很多很不错的文本处理功能，包括基础的tokenize, 词性标注，句子切分，语法检查，拼写纠错，情感分析，句法分析等，相当不错。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.clips.ua.ac.be/pattern&quot;&gt;http://www.clips.ua.ac.be/pattern&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;http://textblob.readthedocs.org/en/dev/&quot;&gt;TextBlob&lt;/a&gt;: Simplified Text Processing&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;TextBlob is a Python (2 and 3) library for processing textual data. It provides a simple API for diving into common natural language processing (NLP) tasks such as part-of-speech tagging, noun phrase extraction, sentiment analysis, classification, translation, and more.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;TextBlob是一个很有意思的Python文本处理工具包，它其实是基于上面两个Python工具包NLKT和Pattern做了封装（TextBlob stands on the giant shoulders of NLTK and pattern, and plays nicely with both），同时提供了很多文本处理功能的接口，包括词性标注，名词短语提取，情感分析，文本分类，拼写检查等，甚至包括翻译和语言检测，不过这个是基于Google的API的，有调用次数限制。TextBlob相对比较年轻，有兴趣的同学可以关注。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://textblob.readthedocs.org/en/dev/&quot;&gt;http://textblob.readthedocs.org/en/dev/&lt;/a&gt;&lt;br&gt;
Github代码页：&lt;a href=&quot;https://github.com/sloria/textblob&quot;&gt;https://github.com/sloria/textblob&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;a href=&quot;http://www.clips.ua.ac.be/pages/MBSP&quot;&gt;MBSP&lt;/a&gt; for Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;MBSP is a text analysis system based on the TiMBL and MBT memory based learning applications developed at CLiPS and ILK. It provides tools for Tokenization and Sentence Splitting, Part of Speech Tagging, Chunking, Lemmatization, Relation Finding and Prepositional Phrase Attachment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;MBSP与Pattern同源，同出自比利时安特卫普大学CLiPS实验室，提供了Word Tokenization, 句子切分，词性标注，Chunking, Lemmatization，句法分析等基本的文本处理功能，感兴趣的同学可以关注。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.clips.ua.ac.be/pages/MBSP&quot;&gt;http://www.clips.ua.ac.be/pages/MBSP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;a href=&quot;http://radimrehurek.com/gensim/index.html&quot;&gt;Gensim&lt;/a&gt;: Topic modeling for humans&lt;/p&gt;
&lt;p&gt;Gensim是一个相当专业的主题模型Python工具包，无论是代码还是文档，我们曾经用《&lt;a href=&quot;http://www.52nlp.cn/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%96%87%E6%A1%A3%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%80&quot;&gt;如何计算两个文档的相似度&lt;/a&gt;》介绍过Gensim的安装和使用过程，这里就不多说了。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://radimrehurek.com/gensim/index.html&quot;&gt;http://radimrehurek.com/gensim/index.html&lt;/a&gt;&lt;br&gt;
github代码页：&lt;a href=&quot;https://github.com/piskvorky/gensim&quot;&gt;https://github.com/piskvorky/gensim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6. &lt;a href=&quot;https://github.com/saffsd/langid.py&quot;&gt;langid.py&lt;/a&gt;: Stand-alone language identification system&lt;/p&gt;
&lt;p&gt;语言检测是一个很有意思的话题，不过相对比较成熟，这方面的解决方案很多，也有很多不错的开源工具包，不过对于Python来说，我使用过langid这个工具包，也非常愿意推荐它。langid目前支持97种语言的检测，提供了很多易用的功能，包括可以启动一个建议的server，通过json调用其API，可定制训练自己的语言检测模型等，可以说是“麻雀虽小，五脏俱全”。&lt;/p&gt;
&lt;p&gt;Github主页：&lt;a href=&quot;https://github.com/saffsd/langid.py&quot;&gt;https://github.com/saffsd/langid.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7. &lt;a href=&quot;https://github.com/fxsjy/jieba&quot;&gt;Jieba&lt;/a&gt;: 结巴中文分词&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;“结巴”中文分词：做最好的Python中文分词组件 “Jieba” (Chinese for “to stutter”) Chinese text segmentation: built to be the best Python Chinese word segmentation module.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;好了，终于可以说一个国内的Python文本处理工具包了：结巴分词，其功能包括支持三种分词模式（精确模式、全模式、搜索引擎模式），支持繁体分词，支持自定义词典等，是目前一个非常不错的Python中文分词解决方案。&lt;/p&gt;
&lt;p&gt;Github主页：&lt;a href=&quot;https://github.com/fxsjy/jieba&quot;&gt;https://github.com/fxsjy/jieba&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8. &lt;a href=&quot;https://github.com/NLeSC/xtas&quot;&gt;xTAS&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;xtas, the eXtensible Text Analysis Suite, a distributed text analysis package based on Celery and Elasticsearch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;感谢微博朋友 &lt;a href=&quot;http://weibo.com/sinorichard&quot;&gt;@大山坡的春&lt;/a&gt; 提供的线索：我们组同事之前发布了xTAS，也是基于python的text mining工具包，欢迎使用，链接：http://t.cn/RPbEZOW。看起来很不错的样子，回头试用一下。&lt;/p&gt;
&lt;p&gt;Github代码页：&lt;a href=&quot;https://github.com/NLeSC/xtas&quot;&gt;https://github.com/NLeSC/xtas&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三、Python科学计算工具包&lt;/p&gt;
&lt;p&gt;说起科学计算，大家首先想起的是Matlab，集数值计算，可视化工具及交互于一身，不过可惜是一个商业产品。开源方面除了&lt;a href=&quot;http://www.gnu.org/software/octave/&quot;&gt;GNU Octave&lt;/a&gt;在尝试做一个类似Matlab的工具包外，Python的这几个工具包集合到一起也可以替代Matlab的相应功能：NumPy+SciPy+Matplotlib+iPython。同时，这几个工具包，特别是NumPy和SciPy，也是很多Python文本处理 &amp;amp; 机器学习 &amp;amp; 数据挖掘工具包的基础，非常重要。最后再推荐一个系列《&lt;a href=&quot;http://sebug.net/paper/books/scipydoc/index.html&quot;&gt;用Python做科学计算&lt;/a&gt;》，将会涉及到NumPy, SciPy, Matplotlib，可以做参考。&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NumPy is the fundamental package for scientific computing with Python. It contains among other things:&lt;br&gt;
1）a powerful N-dimensional array object&lt;br&gt;
2）sophisticated (broadcasting) functions&lt;br&gt;
3）tools for integrating C/C++ and Fortran code&lt;br&gt;
4） useful linear algebra, Fourier transform, and random number capabilities&lt;/p&gt;
&lt;p&gt;Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data. Arbitrary data-types can be defined. This allows NumPy to seamlessly and speedily integrate with a wide variety of databases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NumPy几乎是一个无法回避的科学计算工具包，最常用的也许是它的N维数组对象，其他还包括一些成熟的函数库，用于整合C/C++和Fortran代码的工具包，线性代数、傅里叶变换和随机数生成函数等。NumPy提供了两种基本的对象：ndarray（N-dimensional array object）和 ufunc（universal function object）。ndarray是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.numpy.org/&quot;&gt;http://www.numpy.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt;：Scientific Computing Tools for Python&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SciPy refers to several related but distinct entities:&lt;/p&gt;
&lt;p&gt;1）The SciPy Stack, a collection of open source software for scientific computing in Python, and particularly a specified set of core packages.&lt;br&gt;
2）The community of people who use and develop this stack.&lt;br&gt;
3）Several conferences dedicated to scientific computing in Python – SciPy, EuroSciPy and SciPy.in.&lt;br&gt;
4）The SciPy library, one component of the SciPy stack, providing many numerical routines.
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“SciPy是一个开源的Python算法库和数学工具包，SciPy包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。其功能与软件MATLAB、Scilab和GNU Octave类似。 Numpy和Scipy常常结合着使用，Python大多数机器学习库都依赖于这两个模块。”—-引用自“&lt;a href=&quot;http://qxde01.blog.163.com/blog/static/67335744201368101922991/&quot;&gt;Python机器学习库&lt;/a&gt;”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.scipy.org/&quot;&gt;http://www.scipy.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;http://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;matplotlib is a python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. matplotlib can be used in python scripts, the python and ipython shell (ala MATLAB®* or Mathematica®†), web application servers, and six graphical user interface toolkits.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;matplotlib 是python最著名的绘图库，它提供了一整套和matlab相似的命令API，十分适合交互式地进行制图。而且也可以方便地将它作为绘图控件，嵌入GUI应用程序中。Matplotlib可以配合ipython shell使用，提供不亚于Matlab的绘图体验，总之用过了都说好。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://matplotlib.org/&quot;&gt;http://matplotlib.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;a href=&quot;http://ipython.org/&quot;&gt;iPython&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IPython provides a rich architecture for interactive computing with:&lt;/p&gt;
&lt;p&gt;1）Powerful interactive shells (terminal and Qt-based).&lt;br&gt;
2）A browser-based notebook with support for code, text, mathematical expressions, inline plots and other rich media.&lt;br&gt;
3）Support for interactive data visualization and use of GUI toolkits.&lt;br&gt;
4）Flexible, embeddable interpreters to load into your own projects.&lt;br&gt;
5）Easy to use, high performance tools for parallel computing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“iPython 是一个Python 的交互式Shell，比默认的Python Shell 好用得多，功能也更强大。 她支持语法高亮、自动完成、代码调试、对象自省，支持 Bash Shell 命令，内置了许多很有用的功能和函式等，非常容易使用。 ” 启动iPython的时候用这个命令“ipython –pylab”，默认开启了matploblib的绘图交互，用起来很方便。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://ipython.org/&quot;&gt;http://ipython.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;四、Python 机器学习 &amp;amp; 数据挖掘 工具包&lt;/p&gt;
&lt;p&gt;机器学习和数据挖掘这两个概念不太好区分，这里就放到一起了。这方面的开源Python工具包有很多，这里先从熟悉的讲起，再补充其他来源的资料，也欢迎大家补充。&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://scikit-learn.org/&quot;&gt;scikit-learn&lt;/a&gt;: Machine Learning in Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;scikit-learn (formerly scikits.learn) is an open source machine learning library for the Python programming language. It features various classification, regression and clustering algorithms including support vector machines, logistic regression, naive Bayes, random forests, gradient boosting, k-means and DBSCAN, and is designed to interoperate with the Python numerical and scientific libraries NumPy and SciPy.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;首先推荐大名鼎鼎的scikit-learn，scikit-learn是一个基于NumPy, SciPy, Matplotlib的开源机器学习工具包，主要涵盖分类，回归和聚类算法，例如SVM， 逻辑回归，朴素贝叶斯，随机森林，k-means等算法，代码和文档都非常不错，在许多Python项目中都有应用。例如在我们熟悉的NLTK中，分类器方面就有专门针对scikit-learn的接口，可以调用scikit-learn的分类算法以及训练数据来训练分类器模型。这里推荐一个视频，也是我早期遇到scikit-learn的时候推荐过的：&lt;a href=&quot;http://52opencourse.com/552/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AApython%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7%E5%8C%85scikit-learn%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A7%86%E9%A2%91-tutorial-scikit-learn-machine-learning-in-python&quot;&gt;推荐一个Python机器学习工具包Scikit-learn以及相关视频–Tutorial: scikit-learn – Machine Learning in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://scikit-learn.org/&quot;&gt;http://scikit-learn.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://pandas.pydata.org/&quot;&gt;Pandas&lt;/a&gt;: Python Data Analysis Library&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Pandas is a software library written for the Python programming language for data manipulation and analysis. In particular, it offers data structures and operations for manipulating numerical tables and time series.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;第一次接触Pandas是由于Udacity上的一门数据分析课程“&lt;a href=&quot;http://coursegraph.com/introduction-to-data-science-udacity-ud359-%E5%85%B6%E4%BB%96%E5%A4%A7%E5%AD%A6%E6%88%96%E6%9C%BA%E6%9E%84&quot;&gt;Introduction to Data Science&lt;/a&gt;” 的Project需要用Pandas库，所以学习了一下Pandas。Pandas也是基于NumPy和Matplotlib开发的，主要用于数据分析和数据可视化，它的数据结构DataFrame和R语言里的data.frame很像，特别是对于时间序列数据有自己的一套分析机制，非常不错。这里推荐一本书《&lt;a href=&quot;http://bin.sc/Readings/Programming/Python/Python%20for%20Data%20Analysis/Python_for_Data_Analysis.pdf&quot;&gt;Python for Data Analysis&lt;/a&gt;》，作者是Pandas的主力开发，依次介绍了iPython, NumPy, Pandas里的相关功能，数据可视化，数据清洗和加工，时间数据处理等，案例包括金融股票数据挖掘等，相当不错。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://pandas.pydata.org/&quot;&gt;http://pandas.pydata.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;=====================================================================&lt;br&gt;
分割线，以上工具包基本上都是自己用过的，以下来源于其他同学的线索，特别是《&lt;a href=&quot;http://qxde01.blog.163.com/blog/static/67335744201368101922991/&quot;&gt;Python机器学习库&lt;/a&gt;》，《&lt;a href=&quot;http://52opencourse.com/1125/23%E4%B8%AApython%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8C%85&quot;&gt;23个python的机器学习包&lt;/a&gt;》，做了一点增删修改，欢迎大家补充&lt;br&gt;
=====================================================================&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;http://mlpy.sourceforge.net/&quot;&gt;mlpy – Machine Learning Python&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mlpy is a Python module for Machine Learning built on top of NumPy/SciPy and the GNU Scientific Libraries.&lt;/p&gt;
&lt;p&gt;mlpy provides a wide range of state-of-the-art machine learning methods for supervised and unsupervised problems and it is aimed at finding a reasonable compromise among modularity, maintainability, reproducibility, usability and efficiency. mlpy is multiplatform, it works with Python 2 and 3 and it is Open Source, distributed under the GNU General Public License version 3.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://mlpy.sourceforge.net/&quot;&gt;http://mlpy.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;a href=&quot;http://mdp-toolkit.sourceforge.net/&quot;&gt;MDP&lt;/a&gt;：The Modular toolkit for Data Processing&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Modular toolkit for Data Processing (MDP) is a Python data processing framework.&lt;br&gt;
From the user’s perspective, MDP is a collection of supervised and unsupervised learning algorithms and other data processing units that can be combined into data processing sequences and more complex feed-forward network architectures.&lt;br&gt;
From the scientific developer’s perspective, MDP is a modular framework, which can easily be expanded. The implementation of new algorithms is easy and intuitive. The new implemented units are then automatically integrated with the rest of the library.&lt;br&gt;
The base of available algorithms is steadily increasing and includes signal processing methods (Principal Component Analysis, Independent Component Analysis, Slow Feature Analysis), manifold learning methods ([Hessian] Locally Linear Embedding), several classifiers, probabilistic methods (Factor Analysis, RBM), data pre-processing methods, and many others.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“MDP用于数据处理的模块化工具包，一个Python数据处理框架。 从用户的观点，MDP是能够被整合到数据处理序列和更复杂的前馈网络结构的一批监督学习和非监督学习算法和其他数据处理单元。计算依照速度和内存需求而高效的执行。从科学开发者的观点，MDP是一个模块框架，它能够被容易地扩展。新算法的实现是容易且直观的。新实现的单元然后被自动地与程序库的其余部件进行整合。MDP在神经科学的理论研究背景下被编写，但是它已经被设计为在使用可训练数据处理算法的任何情况中都是有用的。其站在用户一边的简单性，各种不同的随时可用的算法，及应用单元的可重用性，使得它也是一个有用的教学工具。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://mdp-toolkit.sourceforge.net/&quot;&gt;http://mdp-toolkit.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;a href=&quot;http://www.pybrain.org/&quot;&gt;PyBrain&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PyBrain is a modular Machine Learning Library for Python. Its goal is to offer flexible, easy-to-use yet still powerful algorithms for Machine Learning Tasks and a variety of predefined environments to test and compare your algorithms.&lt;/p&gt;
&lt;p&gt;PyBrain is short for Python-Based Reinforcement Learning, Artificial Intelligence and Neural Network Library. In fact, we came up with the name first and later reverse-engineered this quite descriptive “Backronym”.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“PyBrain(Python-Based Reinforcement Learning, Artificial Intelligence and Neural Network)是Python的一个机器学习模块，它的目标是为机器学习任务提供灵活、易应、强大的机器学习算法。（这名字很霸气）&lt;/p&gt;
&lt;p&gt;PyBrain正如其名，包括神经网络、强化学习(及二者结合)、无监督学习、进化算法。因为目前的许多问题需要处理连续态和行为空间，必须使用函数逼近(如神经网络)以应对高维数据。PyBrain以神经网络为核心，所有的训练方法都以神经网络为一个实例。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.pybrain.org/&quot;&gt;http://www.pybrain.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6. &lt;a href=&quot;http://pyml.sourceforge.net/&quot;&gt;PyML&lt;/a&gt; – machine learning in Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;PyML is an interactive object oriented framework for machine learning written in Python. PyML focuses on SVMs and other kernel methods. It is supported on Linux and Mac OS X.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“PyML是一个Python机器学习工具包，为各分类和回归方法提供灵活的架构。它主要提供特征选择、模型选择、组合分类器、分类评估等功能。”&lt;/p&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;http://pyml.sourceforge.net/&quot;&gt;http://pyml.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7. &lt;a href=&quot;https://pypi.python.org/pypi/milk/&quot;&gt;Milk&lt;/a&gt;：Machine learning toolkit in Python.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Its focus is on supervised classification with several classifiers available:&lt;br&gt;
SVMs (based on libsvm), k-NN, random forests, decision trees. It also performs&lt;br&gt;
feature selection. These classifiers can be combined in many ways to form&lt;br&gt;
different classification systems.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“Milk是Python的一个机器学习工具箱，其重点是提供监督分类法与几种有效的分类分析：SVMs(基于libsvm)，K-NN，随机森林经济和决策树。它还可以进行特征选择。这些分类可以在许多方面相结合，形成不同的分类系统。对于无监督学习，它提供K-means和affinity propagation聚类算法。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://luispedro.org/software/milk&quot;&gt;http://luispedro.org/software/milk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;http://luispedro.org/software/milk&lt;/p&gt;
&lt;p&gt;8. &lt;a href=&quot;http://www.pymvpa.org/&quot;&gt;PyMVPA&lt;/a&gt;: MultiVariate Pattern Analysis (MVPA) in Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;PyMVPA is a Python package intended to ease statistical learning analyses of large datasets. It offers an extensible framework with a high-level interface to a broad range of algorithms for classification, regression, feature selection, data import and export. It is designed to integrate well with related software packages, such as scikit-learn, and MDP. While it is not limited to the neuroimaging domain, it is eminently suited for such datasets. PyMVPA is free software and requires nothing but free-software to run.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“PyMVPA(Multivariate Pattern Analysis in Python)是为大数据集提供统计学习分析的Python工具包，它提供了一个灵活可扩展的框架。它提供的功能有分类、回归、特征选择、数据导入导出、可视化等”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.pymvpa.org/&quot;&gt;http://www.pymvpa.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9. &lt;a href=&quot;https://github.com/pydata/pyrallel&quot;&gt;Pyrallel&lt;/a&gt; – Parallel Data Analytics in Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Experimental project to investigate distributed computation patterns for machine learning and other semi-interactive data analytics tasks.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“Pyrallel(Parallel Data Analytics in Python)基于分布式计算模式的机器学习和半交互式的试验项目，可在小型集群上运行”&lt;/p&gt;
&lt;p&gt;Github代码页：&lt;a href=&quot;https://github.com/pydata/pyrallel&quot;&gt;http://github.com/pydata/pyrallel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;10. &lt;a href=&quot;http://montepython.sourceforge.net/&quot;&gt;Monte&lt;/a&gt; – gradient based learning in Python&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
Monte (python) is a Python framework for building gradient based learning machines, like neural networks, conditional random fields, logistic regression, etc. Monte contains modules (that hold parameters, a cost-function and a gradient-function) and trainers (that can adapt a module’s parameters by minimizing its cost-function on training data). &lt;/p&gt;
&lt;p&gt;Modules are usually composed of other modules, which can in turn contain other modules, etc. Gradients of decomposable systems like these can be computed with back-propagation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“Monte (machine learning in pure Python)是一个纯Python机器学习库。它可以迅速构建神经网络、条件随机场、逻辑回归等模型，使用inline-C优化，极易使用和扩展。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://montepython.sourceforge.net&quot;&gt;http://montepython.sourceforge.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;11. &lt;a href=&quot;http://deeplearning.net/software/theano/&quot;&gt;Theano&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently. Theano features:&lt;br&gt;
1）tight integration with NumPy – Use numpy.ndarray in Theano-compiled functions.&lt;br&gt;
2）transparent use of a GPU – Perform data-intensive calculations up to 140x faster than with CPU.(float32 only)&lt;br&gt;
3）efficient symbolic differentiation – Theano does your derivatives for function with one or many inputs.&lt;br&gt;
4）speed and stability optimizations – Get the right answer for log(1+x) even when x is really tiny.&lt;br&gt;
5）dynamic C code generation – Evaluate expressions faster.&lt;br&gt;
6） extensive unit-testing and self-verification – Detect and diagnose many types of mistake.&lt;br&gt;
Theano has been powering large-scale computationally intensive scientific investigations since 2007. But it is also approachable enough to be used in the classroom (IFT6266 at the University of Montreal).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“Theano 是一个 Python 库，用来定义、优化和模拟数学表达式计算，用于高效的解决多维数组的计算问题。Theano的特点：紧密集成Numpy；高效的数据密集型GPU计算；高效的符号微分运算；高速和稳定的优化；动态生成c代码；广泛的单元测试和自我验证。自2007年以来，Theano已被广泛应用于科学运算。theano使得构建深度学习模型更加容易，可以快速实现多种模型。PS：Theano，一位希腊美女，Croton最有权势的Milo的女儿，后来成为了毕达哥拉斯的老婆。”&lt;/p&gt;
&lt;p&gt;12. &lt;a href=&quot;http://deeplearning.net/software/pylearn2/&quot;&gt;Pylearn2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Pylearn2 is a machine learning library. Most of its functionality is built on top of Theano. This means you can write Pylearn2 plugins (new models, algorithms, etc) using mathematical expressions, and theano will optimize and stabilize those expressions for you, and compile them to a backend of your choice (CPU or GPU).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“Pylearn2建立在theano上，部分依赖scikit-learn上，目前Pylearn2正处于开发中，将可以处理向量、图像、视频等数据，提供MLP、RBM、SDA等深度学习模型。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://deeplearning.net/software/pylearn2/&quot;&gt;http://deeplearning.net/software/pylearn2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他的，欢迎大家补充，这里也会持续更新这篇文章。&lt;/p&gt;
&lt;p&gt;注：原创文章，转载请注明出处“&lt;a href=&quot;http://www.52nlp.cn&quot;&gt;我爱自然语言处理&lt;/a&gt;”：&lt;a href=&quot;http://www.52nlp.cn&quot;&gt;www.52nlp.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接地址：&lt;a href=&quot;http://www.52nlp.cn/python-%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98&quot;&gt;http://www.52nlp.cn/python-网页爬虫-文本处理-科学计算-机器学习-数据挖掘&lt;/a&gt;&lt;/p&gt;

											

</description>
        <pubDate>Thu, 24 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-24-python-%25e7%25bd%2591%25e9%25a1%25b5%25e7%2588%25ac%25e8%2599%25ab-%25e6%2596%2587%25e6%259c%25ac%25e5%25a4%2584%25e7%2590%2586-%25e7%25a7%2591%25e5%25ad%25a6%25e8%25ae%25a1%25e7%25ae%2597-%25e6%259c%25ba%25e5%2599%25a8%25e5%25ad%25a6%25e4%25b9%25a0-%25e6%2595%25b0%25e6%258d%25ae%25e6%258c%2596%25e6%258e%2598-060a30129.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-24-python-%25e7%25bd%2591%25e9%25a1%25b5%25e7%2588%25ac%25e8%2599%25ab-%25e6%2596%2587%25e6%259c%25ac%25e5%25a4%2584%25e7%2590%2586-%25e7%25a7%2591%25e5%25ad%25a6%25e8%25ae%25a1%25e7%25ae%2597-%25e6%259c%25ba%25e5%2599%25a8%25e5%25ad%25a6%25e4%25b9%25a0-%25e6%2595%25b0%25e6%258d%25ae%25e6%258c%2596%25e6%258e%2598-060a30129.html</guid>
        
        
      </item>
    
      <item>
        <title>一比特之差：无需利用漏洞的DNS劫持</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p align=&quot;left&quot;&gt;Bitsquatting表示去注册一个域名，它和知名的域名只有一个bit的差别。这个单词源自typosquatting，意为注册一个和知名域名只有一字之差的域名。在解析域名时，bitsquatting可能通过DNS导致计算机上的硬件错误。关于bitsquatting更详细的信息，可以参看我的&lt;a href=&quot;http://media.blackhat.com/bh-us-11/Dinaburg/BH_US_11_Dinaburg_Bitsquatting_WP.pdf&quot;&gt;Blackhat 2011 whitepaper&lt;/a&gt;。YouTube上有人发布了我在DEF CON 19上有关此话题的演讲&lt;a href=&quot;http://www.youtube.com/watch?v=lZ8s1JwtNas&quot;&gt;视频&lt;/a&gt;，当时使用的幻灯片可以在&lt;a href=&quot;http://dinaburg.org/data/DC19_Dinaburg_Presentation.pdf&quot;&gt;这里下载&lt;/a&gt;。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;引言&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;计算机常常由于一个或多比特的内存损坏出现错误，而造成这些错误的原因可能是制造上的缺陷或者宇宙射线、高温之类的环境因素。虽然单个机器中出现这样的错误的可能性是极小的，但是整个互联网上设备的总量却非常庞大：2010年时就有大约50亿个设备连接到互联网。我们可以将这种存在于各个设备上的小概率错误更加形象地描述，那就是买彩票。赢得头奖的概率是极小的，但是只要有足够多的人去买，总有人会成为赢家。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;研究人员之前就在很多&lt;a href=&quot;https://www.cs.princeton.edu/~appel/papers/memerr.pdf&quot;&gt;惊人的地方&lt;/a&gt;利用了比特错误（bit-errors）。现在，在互联网尺度上，我们又有新的办法去利用它。Bitsquatting是其中之一，也就是注册和某个常被访问的域名仅一比特之差的新域名。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;工作原理&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;当比特错误发生时，内存中的数据会被修改。计算机内存的内容可能代表各种意义，有时，它刚好就表示域名。如果程序使用这块内存，就会读取到错误的域名。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下面的图解能够更清楚的说明这个问题，表中是cnn.com的二进制表示方法：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01100011&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101110&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0110111&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0101110&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01100011&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101111&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;n&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;n&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;o&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;m&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p align=&quot;left&quot;&gt;现在假设你使用的计算机含有损坏的内存模块，你打开一个包含超链接到cnn.com的网页，然后你点击了这个链接。会有多少个操作将cnn.com的二进制数据保存到你的内存？写这篇文章时，我想到了下面这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP/IP协议栈由核心态向用户态转化时（根据操作系统的具体实现各有区别）&lt;/li&gt;
&lt;li&gt;在浏览器解析HTML时&lt;/li&gt;
&lt;li&gt;在创建DOM树的内部表示时&lt;/li&gt;
&lt;li&gt;在创建新的HTTP请求时&lt;/li&gt;
&lt;li&gt;在操作系统解析域名时&lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&quot;left&quot;&gt;更进一步，假设其中有一次将域名写入到了损坏的内存模块，它的二进制形式被修改了1bit，现在表示为：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01100011&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0110111&lt;span style=&quot;color: red;&quot;&gt;1&lt;/span&gt;
&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0110111&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0101110&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01100011&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101111&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;o&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;n&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;o&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;m&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p align=&quot;left&quot;&gt; 这样一来，当你点击链接时，浏览器将会跳转到con.com，而不是cnn.com。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;实验&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;这个实验背后的概念很简单：如果比特错误确实改变了设备内存中的域名，那么这些设备会访问到和正确域名一比特之差的bitsquat域名。因此很多频繁解析的域名的bitsquat域名会被全球各地的设备访问到。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;然而这个实验实施起来却没有那么容易，首要的问题是选择合适的域名来进行比特修改。流行的网站和常被解析的域名是不太相同的，很多鲜为人知的域名实际上会被频繁解析。这类域名一般属于内容分发网络或者广告网络，例如fbcdn.net,、2mdn.net和 akamai.com。由于很少有人实际在浏览器中输入这些域名，它们也成为本次实验中最合适的目标。还有个问题就是每次DNS查询必须有两次响应：一次是原本的域名，一次是经过比特修改的域名。因为原始的请求可能会得到正确域名的响应，而丢弃对无效域名的响应。这方面更多的信息，请参考&lt;a href=&quot;http://media.blackhat.com/bh-us-11/Dinaburg/BH_US_11_Dinaburg_Bitsquatting_WP.pdf&quot;&gt;白皮书&lt;/a&gt;或者&lt;a href=&quot;http://dinaburg.org/data/DC19_Dinaburg_Presentation.pdf&quot;&gt;幻灯片&lt;/a&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;为了这次实验我注册了下面这些域名。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注：目前它们全都已经过期，不再属于我了。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;&lt;b&gt;Bitsquat Domain&lt;/b&gt;&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;&lt;b&gt;Original Domain&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;ikamai.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;akamai.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;aeazon.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;amazon.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;a-azon.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;amazon.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;amazgn.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;amazon.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsmft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;micrgsoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;miarosoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;iicrosoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsnft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;mhcrosoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;eicrosoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;mic2osoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;micro3oft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;li6e.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;live.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0mdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2-dn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2edn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2ldn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mfn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mln.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2odn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;6mdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbbdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbgdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;gbcdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fjcdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;dbcdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;roop-servers.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;root-servers.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;doublechick.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;doubleclick.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;do5bleclick.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;doubleclick.net&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p align=&quot;left&quot;&gt;我使用Python脚本应答DNS请求，并且使用Apache记录HTTP请求。令我惊讶的是，有设备连接了。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;实验发现&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;以下结论是基于2010年9月26日至2011年5月5日间的Apache日志得出的。由搜索引擎爬虫和Web漏洞扫描器引起的日志已经被手动过滤了。正因为是手动操作，所以最后统计时可能还有很小一部分漏网之鱼。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现1：比特错误可以被利用在DNS上&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在记录日志期间总共有52317次针bitsquat域名的请求，它们来自与12949个独立IP。除去其中3次产生巨大网络流量的事件，平均每天有59个独立IP对32个bitsquat域名进行了请求。这些请求不是来自于拼写错误或者其他形式的手工输入URL，还有一部分表现出有多个比特错误的特征。以下是一些实际的例子（个人信息已经移除）：&lt;/p&gt;
&lt;div style=&quot;background-color: #eeeeee;&quot;&gt;
&lt;p align=&quot;left&quot;&gt;static.ak.fjcdn.net 109.242.50.xxx “GET /rsrc.php/z67NS/hash/4ys0envq.js HTTP/1.1″ “http://www.facebook.com/profile.php?id=xxxxxxxxxx” “Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; WOW64; Trident/4.0; GTB6.5; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.30729; .NET CLR 3.5.30729; InfoPath.2; Hotbar 11.0.78.0; OfficeLiveConnector.1.5; OfficeLivePatch.1.3; AskTbZTV/5.8.0.12304)”&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;msgr.dlservice.mic2osoft.com 213.178.224.xxx “GET /download/A/6/1/A616CCD4-B0CA-4A3D-B975-3EDB38081B38/ar/wlsetup-cvr.exe HTTP/1.1″ 404 268 “Microsoft BITS/6.6″&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;s0.2ldn.net 66.82.9.xxx “GET /879366/flashwrite_1_2.js HTTP/1.1″ “http://webmail.satx.rr.com/_uac/adpage.html” “Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; HPNTDF; AskTB5.2)”&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;mmv.admob.com 109.175.185.xxx “GET /static/iphone/img/app@2x.png HTTP/1.1″ “Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_1 like Mac OS X; HW iPhone2,1; en_gb) AppleWebKit/525.18.1 (KHTML, like Gecko) (AdMob-iSDK-20101108; iphoneos4.2)”&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现2：并不是所有的比特错误都造成同等程度的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;有些机器相比其他而言，明显控制着更多的网络流量。当一个比特错误发生在普通PC机或者手机上时，它只会影响到一个用户。然而当它发生在代理、DNS服务器或者数据库缓存中时，将会影响到成千上万的用户。在我的实验中，已经观察到了比特错误出现在Web应用、DNS解析服务器和代理服务器中。例如，一个比特错误将fbcnd.net变为fbbdn.net，将使上千个开心农场的玩家请求到我的服务器。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现3：手机和嵌入式设备可能比传统硬件受的影响更大&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我对2011年3月期间访问Wikipedia和bitsquat域名的HTTP User-Agent进行了对比，展示在下面的图例中。其中Other包括了各种手机、游戏机控制台和其他嵌入式设备，它们在对bitsquat域名的访问中，增加的幅度最大。令人好奇的是，来自MacOS针对bitsquat域名的访问相比Wikipedia有显著减少，对此我还没有一个合理的解释。（译注：这里是按两个域名各自的设备分布算的，其中有增多必然有减少，也许分别计算每种设备访问错域名的几率更加合理，即&lt;i&gt;访问错误域名的次数 / 对两种域名的访问总数&lt;/i&gt;。）&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/f435855d0cd7c34aa3ae589293727d00.png&quot; rel=&quot;lightbox[74149]&quot; title=&quot;一比特之差：无需利用漏洞的DNS劫持&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-74152&quot; alt=&quot;bitsquat_1&quot; src=&quot;/images/jobbole.com/d6868d8be74912de5d5ab88747e4aace.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现4：对bitsquat域名的访问流量是日常网络流量的真实写照&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Bitsquat域名的访问者来自于全球各地，其使用的设备也几乎涵盖每种主流的操作系统和嵌入式平台。除使用MacOS的访问者所占的百分比在两种域名间有显著差别之外，使用Windows、Linux、Android和iPhones的百分比基本相同。另外，基于IP地理位置数据库，我们可以观察到来自于美国的访问者在一天内的流量走势。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/ade11df8bbcc2b7bcbd7e3564ed2cdfa.png&quot;&gt;&lt;br&gt;
&lt;/a&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/ade11df8bbcc2b7bcbd7e3564ed2cdfa.png&quot; rel=&quot;lightbox[74149]&quot; title=&quot;一比特之差：无需利用漏洞的DNS劫持&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-74153&quot; alt=&quot;bitsquat_2&quot; src=&quot;/images/jobbole.com/15bbd2df363455797824469e667561cb.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现5：HTTPS/TLS不会有帮助，DNSSEC可能会有一丁点&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;HTTP 1.1在头中包含了一个叫Host的字段，其数值是客户端想要访问的域名。如果Host中包含着bitsquat域名，那么比特错误在域名解析前就发生了。如果Host中是原始域名，那么错误就是发生在域名解析中。我数据中96%的情况是在DNS解析前就出现了比特错误。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/a78196125356295d8d331b1a05dc252a.png&quot; rel=&quot;lightbox[74149]&quot; title=&quot;一比特之差：无需利用漏洞的DNS劫持&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-74154&quot; alt=&quot;bitsquat_3&quot; src=&quot;/images/jobbole.com/cd7c742d1f56b45900a483b0ed4471db.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;像SSL和TLS这种安全传输技术是用于保证两端之间数据的机密性、真实性和完整性，但是比特错误更多发生在数据在某一端还未传输的时候。DNSSEC只能解决那4%发生在域名解析过程中的比特错误。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;数据&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;DNS流量的全部PCAP在此：&lt;a href=&quot;http://dinaburg.org/data/dnslogs.tar.7z&quot;&gt;dnslogs.tar.7z&lt;/a&gt;，56Mb&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;HTTP日志可能包含个人信息，因此不会公开发布。如果你有正当的研究目的需要它们，请&lt;a href=&quot;http://dinaburg.org/about.html&quot;&gt;联系我&lt;/a&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这里有个工具可以快速识别潜在的bitsquat域名：&lt;a href=&quot;http://dinaburg.org/data/bitsquat.py&quot;&gt;bitsquat.py&lt;/a&gt;，&lt;a href=&quot;https://github.com/artemdinaburg/bitsquat-script&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;进一步研究&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;来自Verisign的Duane Wessels也在DNS查询中寻找过网络级别的比特错误，他指出“&lt;b&gt;&lt;a href=&quot;http://www.verisigninc.com/assets/VRSN_Bitsquatting_TR_20120320.pdf&quot;&gt;网络中比特错误相对而言是很少见的，但是有一个可预期的概率&lt;/a&gt;&lt;/b&gt;”。他研究的主要目的，是确定那4%发生在域名解析时的比特错误是否由UDP包在传输后的损坏造成。结论是网络中传输的包不太可能被损坏，用他自己的话说：“我们相信UDP的校验和能够有效防范bitsquat攻击或者其他DNS查询时的错误。无论如何，在进入网络前发生的比特错误不会从中受益，因为在传输前计算的校验和是基于错误的数据得出的。“&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我非常鼓励读者重复我的实验，并且分享你们的结果。如果需要更多信息，请随时&lt;a href=&quot;http://dinaburg.org/about.html&quot;&gt;联系我&lt;/a&gt;。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Thu, 24 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-24-74149-9c77c2cb8.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-24-74149-9c77c2cb8.html</guid>
        
        
      </item>
    
      <item>
        <title>四层和七层负载均衡的区别</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;（一）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;简单理解四层和七层负载均衡:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;① &lt;/strong&gt;所谓四层就是基于IP+端口的负载均衡；七层就是基于URL等应用层信息的负载均衡；同理，还有基于MAC地址的二层负载均衡和基于IP地址的三层负载均衡。 换句换说，二层负载均衡会通过一个虚拟MAC地址接收请求，然后再分配到真实的MAC地址；三层负载均衡会通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址；四层通过虚拟IP+端口接收请求，然后再分配到真实的服务器；七层通过虚拟的URL或主机名接收请求，然后再分配到真实的服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② &lt;/strong&gt;所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。 比如四层的负载均衡，就是通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。七层的负载均衡，就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ &lt;/strong&gt;负载均衡器通常称为四层交换机或七层交换机。四层交换机主要分析IP层及TCP/UDP层，实现四层流量负载均衡。七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息。&lt;/p&gt;
&lt;p&gt;1、负载均衡分为L4 switch（四层交换），即在OSI第4层工作，就是TCP层啦。此种Load Balance不理解应用协议（如HTTP/FTP/MySQL等等）。例子：LVS，F5。&lt;/p&gt;
&lt;p&gt;2、另一种叫做L7 switch（七层交换），OSI的最高层，应用层。此时，该Load Balancer能理解应用协议。例子：  haproxy，MySQL Proxy。&lt;/p&gt;
&lt;p&gt;注意：上面的很多Load Balancer既可以做四层交换，也可以做七层交换。&lt;/p&gt;
&lt;p&gt;（二）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　负载均衡设备也常被称为”四到七层交换机”，那么四层和七层两者到底区别在哪里？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第一，技术原理上的区别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　所谓四层负载均衡&lt;/strong&gt;，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。&lt;/p&gt;
&lt;p&gt;以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/b91593dea3eb4eeaacc72d17c55295c4.png&quot; rel=&quot;lightbox[74131]&quot; title=&quot;四层和七层负载均衡的区别&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-74132&quot; alt=&quot;03114159-1d39f32589b04705b65bf5bda16d2252&quot; src=&quot;/images/jobbole.com/8483cda2a4febf251cbf250fc9ae6c06.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所&lt;/strong&gt;&lt;strong&gt;谓七层负载均衡&lt;/strong&gt;，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。&lt;/p&gt;
&lt;p&gt;以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第二，应用场景的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;七层应用负载的好处，是使得整个网络更”&lt;strong&gt;智能化&lt;/strong&gt;“。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，例如Nginx或者Apache上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。&lt;/p&gt;
&lt;p&gt;另外一个常常被提到功能就&lt;strong&gt;是&lt;/strong&gt;安全性。网络中最常见的SYN Flood攻击，即黑客控制众多源客户端，使用虚假IP地址对同一目标发送SYN攻击，通常这种攻击会大量发送SYN报文，耗尽服务器上的相关资源，以达到Denial of Service(&lt;em&gt;DoS&lt;/em&gt;)的目的。从技术原理上也可以看出，四层模式下这些SYN攻击都会被转发到后端的服务器上；而七层模式下这些SYN攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。另外负载均衡设备可以在七层层面设定多种策略，过滤特定报文，例如SQL Injection等应用层面的特定攻击手段，从应用层面进一步提高系统整体安全。&lt;/p&gt;
&lt;p&gt;现在的7层负载均衡，主要还是着重于&lt;strong&gt;应用&lt;/strong&gt;HTTP协议，所以其应用范围主要是众多的网站或者内部信息平台等基于B/S开发的系统。 4层负载均衡则对应其他TCP应用，例如基于C/S开发的ERP等系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第三，七层应用需要考虑的问题。&lt;a href=&quot;http://hi.baidu.com/aking_roc&quot; target=&quot;_blank&quot;&gt;&lt;br&gt;
&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1：是否真的必要&lt;/strong&gt;，七层应用的确可以提高流量智能化，同时必不可免的带来设备配置复杂，负载均衡压力增高以及故障排查上的复杂性等问题。在设计系统时需要考虑四层七层同时应用的混杂情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2：是否真的可以提高安全性&lt;/strong&gt;。例如SYN Flood攻击，七层模式的确将这些流量从服务器屏蔽，但负载均衡设备本身要有强大的抗DDoS能力，否则即使服务器正常而作为中枢调度的负载均衡设备故障也会导致整个应用的崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3：是否有足够的灵活度&lt;/strong&gt;。七层应用的优势是可以让整个应用的流量智能化，但是负载均衡设备需要提供完善的七层功能，满足客户根据不同情况的基于应用的调度。最简单的一个考核就是能否取代后台Nginx或者Apache等服务器上的调度功能。能够提供一个七层应用开发接口的负载均衡设备，可以让客户根据需求任意设定功能，才真正有可能提供强大的灵活性和智能性。&lt;/p&gt;
&lt;p&gt;（三）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　负载均衡四七层介绍:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡（Load Balance）建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。&lt;/p&gt;
&lt;p&gt;负载均衡有两方面的含义：首先，大量的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间；其次，单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高。&lt;/p&gt;
&lt;p&gt;本文所要介绍的负载均衡技术主要是指在均衡服务器群中所有服务器和应用程序之间流量负载的应用，目前负载均衡技术大多数是用于提高诸如在Web服务器、FTP服务器和其它关键任务服务器上的Internet服务器程序的可用性和可伸缩性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　负载均衡技术分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前有许多不同的负载均衡技术用以满足不同的应用需求，下面从负载均衡所采用的设备对象、应用的网络层次（指OSI参考模型）及应用的地理结构等来分类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　软/硬件负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，如DNS Load Balance，CheckPoint Firewall-1 ConnectControl等，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。&lt;/p&gt;
&lt;p&gt;软件解决方案缺点也较多，因为每台服务器上安装额外的软件运行会消耗系统不定量的资源，越是功能强大的模块，消耗得越多，所以当连接请求特别大的时候，软件本身会成为服务器工作成败的一个关键；软件可扩展性并不是很好，受到操作系统的限制；由于操作系统本身的Bug，往往会引起安全问题。&lt;/p&gt;
&lt;p&gt;硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备我们通常称之为负载均衡器，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。&lt;/p&gt;
&lt;p&gt;负载均衡器有多种多样的形式，除了作为独立意义上的负载均衡器外，有些负载均衡器集成在交换设备中，置于服务器与Internet链接之间，有些则以两块网络适配器将这一功能集成到PC中，一块连接到Internet上，一块连接到后端服务器群的内部网络上。&lt;/p&gt;
&lt;p&gt;一般而言，硬件负载均衡在功能、性能上优于软件方式，不过成本昂贵。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　本地/全局负载均衡&lt;a href=&quot;http://hi.baidu.com/aking_roc&quot; target=&quot;_blank&quot;&gt;&lt;br&gt;
&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡从其应用的地理结构上分为本地负载均衡(Local Load Balance)和全局负载均衡(Global Load Balance，也叫地域负载均衡)，本地负载均衡是指对本地的服务器群做负载均衡，全局负载均衡是指对分别放置在不同的地理位置、有不同网络结构的服务器群间作负载均衡。&lt;/p&gt;
&lt;p&gt;本地负载均衡能有效地解决数据流量过大、网络负荷过重的问题，并且不需花费昂贵开支购置性能卓越的服务器，充分利用现有设备，避免服务器单点故障造成数据流量的损失。其有灵活多样的均衡策略把数据流量合理地分配给服务器群内的服务器共同负担。即使是再给现有服务器扩充升级，也只是简单地增加一个新的服务器到服务群中，而不需改变现有网络结构、停止现有的服务。&lt;/p&gt;
&lt;p&gt;全局负载均衡主要用于在一个多区域拥有自己服务器的站点，为了使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器，从而获得最快的访问速度，也可用于子公司分散站点分布广的大公司通过Intranet（企业内部互联网）来达到资源统一合理分配的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　网络层次上的负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对网络上负载过重的不同瓶颈所在，从网络的不同层次入手，我们可以采用相应的负载均衡技术来解决现有问题。&lt;/p&gt;
&lt;p&gt;随着带宽增加，数据流量不断增大，网络核心部分的数据接口将面临瓶颈问题，原有的单一线路将很难满足需求，而且线路的升级又过于昂贵甚至难以实现，这时就可以考虑采用链路聚合（Trunking）技术。&lt;/p&gt;
&lt;p&gt;链路聚合技术（第二层负载均衡）将多条物理链路当作一条单一的聚合逻辑链路使用，网络数据流量由聚合逻辑链路中所有物理链路共同承担，由此在逻辑上增大了链路&lt;a href=&quot;http://hi.baidu.com/aking_roc&quot; target=&quot;_blank&quot;&gt;的&lt;/a&gt;容量，使其能满足带宽增加的需求。&lt;/p&gt;
&lt;p&gt;现代负载均衡技术通常操作于网络的第四层或第七层。第四层负载均衡将一个Internet上合法注册的IP地址映射为多个内部服务器的IP地址，对每次 TCP连接请求动态使用其中一个内部IP地址，达到负载均衡的目的。在第四层交换机中，此种均衡技术得到广泛的应用，一个目标地址是服务器群VIP（虚拟 IP，Virtual IP address）连接请求的数据包流经交换机，交换机根据源端和目的IP地址、TCP或UDP端口号和一定的负载均衡策略，在服务器IP和VIP间进行映射，选取服务器群中最好的服务器来处理连接请求。&lt;/p&gt;
&lt;p&gt;第七层负载均衡控制应用层服务的内容，提供了一种对访问流量的高层控制方式，适合对HTTP服务器群的应用。第&lt;strong&gt;七层负载均衡技术通过检查流经的HTTP报头，根据报头内的信息来执行负载均衡任务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第七层负载均衡优点表现在如下几个方面：&lt;/p&gt;
&lt;p&gt;通过对HTTP报头的检查，可以检测出HTTP400、500和600系列的错误信息，因而能透明地将连接请求重新定向到另一台服务器，避免应用层故障。&lt;/p&gt;
&lt;p&gt;可根据流经的数据类型（如判断数据包是图像文件、压缩文件或多媒体文件格式等），把数据流量引向相应内容的服务器来处理，增加系统性能。&lt;/p&gt;
&lt;p&gt;能根据连接请求的类型，如是普通文本、图象等静态文档请求，还是asp、cgi等的动态文档请求，把相应的请求引向相应的服务器来处理，提高系统的性能及安全性。&lt;/p&gt;
&lt;p&gt;第七层负载均衡受到其所支持的协议限制（一般只有HTTP），这样就限制了它应用的广泛性，并且检查HTTP报头会占用大量的系统资源，势必会影响到系统的性能，在大量连接请求的情况下，负载均衡设备自身容易成为网络整体性能的瓶颈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实际应用中，我们可能不想仅仅是把客户端的服务请求平均地分配给内部服务器，而不管服务器是否宕机。而是想使Pentium III服务器比Pentium II能接受更多的服务请求，一台处理服务请求较少的服务器能分配到更多的服务请求，出现故障的服务器将不再接受服务请求直至故障恢复等等。&lt;/p&gt;
&lt;p&gt;选择合适的负载均衡策略，使多个设备能很好的共同完成任务，消除或避免现有网络负载分布不均、数据流量拥挤反应时间长的瓶颈。在各负载均衡方式中，针对不同的应用需求，在OSI参考模型的第二、三、四、七层的负载均衡都有相应的负载均衡策略。&lt;/p&gt;
&lt;p&gt;负载均衡策略的优劣及其实现的难易程度有两个关键因素：一、负载均衡算法，二、对网络系统状况的检测方式和能力。&lt;/p&gt;
&lt;p&gt;考虑到服务请求的不同类型、服务器的不同处理能力以及随机选择造成的负载分配不均匀等问题，为了更加合理的把负载分配给内部的多个服务器，就需要应用相应的能够正确反映各个服务器处理能力及网络状态的&lt;strong&gt;负载均衡算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;轮循均衡（Round Robin）：每一次来自网络的请求轮流分配给内部中的服务器，从1至N然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。&lt;/p&gt;
&lt;p&gt;权重轮循均衡（Weighted Round Robin）：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。例如：服务器A的权值被设计成1，B的权值是 3，C的权值是6，则服务器A、B、C将分别接受到10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。&lt;/p&gt;
&lt;p&gt;随机均衡（Random）：把来自网络的请求随机分配给内部中的多个服务器。&lt;/p&gt;
&lt;p&gt;权重随机均衡（Weighted Random）：此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。&lt;/p&gt;
&lt;p&gt;响应速度均衡（Response Time）：负载均衡设备对内部各服务器发出一个探测请求（例如Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。&lt;/p&gt;
&lt;p&gt;最少连接数均衡（Least Connection）：客户端的每一次请求服务在服务器停留的时间可能会有较大的差异，随着工作时间加长，如果采用简单的轮循或随机均衡算法，每一台服务器上的连接进程可能会产生极大的不同，并没有达到真正的负载均衡。最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如FTP。&lt;/p&gt;
&lt;p&gt;处理能力均衡：此种均衡算法将把服务请求分配给内部中处理负荷（根据服务器CPU型号、CPU数量、内存大小及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行状况，所以此种均衡算法相对来说更加精确，尤其适合运用到第七层（应用层）负载均衡的情况下。&lt;/p&gt;
&lt;p&gt;DNS响应均衡（Flash DNS）：在Internet上，无论是HTTP、FTP或是其它的服务请求，客户端一般都是通过域名解析来找到服务器确切的IP地址的。在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在同一时间内把此域名解析成各自相对应服务器的IP地址（即与此负载均衡设备在同一位地理位置的服务器的IP地址）并返回给客户端，则客户端将以最先收到的域名解析IP地址来继续请求服务，而忽略其它的IP地址响应。在种均衡策略适合应用在全局负载均衡的情况下，对本地负载均衡是没有意义的。&lt;/p&gt;
&lt;p&gt;尽管有多种的负载均衡算法可以较好的把数据流量分配给服务器去负载，但如果负载均衡策略没有对网络系统状况的检测方式和能力，一旦在某台服务器或某段负载均衡设备与服务器网络间出现故障的情况下，负载均衡设备依然把一部分数据流量引向那台服务器，这势必造成大量的服务请求被丢失，达不到不间断可用性的要求。所以良好的负载均衡策略应有对网络故障、服务器系统故障、应用服务故障的检&lt;strong&gt;测方式和能力&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Ping侦测：通过ping的方式检测服务器及网络系统状况，此种方式简单快速，但只能大致检测出网络及服务器上的操作系统是否正常，对服务器上的应用服务检测就无能为力了。&lt;/p&gt;
&lt;p&gt;TCP Open侦测：每个服务都会开放某个通过TCP连接，检测服务器上某个TCP端口（如Telnet的23口，HTTP的80口等）是否开放来判断服务是否正常。&lt;/p&gt;
&lt;p&gt;HTTP URL侦测：比如向HTTP服务器发出一个对main.html文件的访问请求，如果收到错误信息，则认为服务器出现故障。&lt;/p&gt;
&lt;p&gt;负载均衡策略的优劣除受上面所讲的两个因素影响外，在有些应用情况下，我们需要将来自同一客户端的所有请求都分配给同一台服务器去负担，例如服务器将客户端注册、购物等服务请求信息保存的本地数据库的情况下，把客户端的子请求分配给同一台服务器来处理就显的至关重要了。有两种方式可以解决此问题，一是根据IP地址把来自同一客户端的多次请求分配给同一台服务器处理，客户端IP地址与服务器的对应信息是保存在负载均衡设备上的；二是在客户端浏览器 cookie内做独一无二的标识来把多次请求分配给同一台服务器处理，适合通过代理服务器上网的客户端。&lt;/p&gt;
&lt;p&gt;还有一种路径外返回模式（Out of Path Return），当客户端连接请求发送给负载均衡设备的时候，中心负载均衡设备将请求引向某个服务器，服务器的回应请求不再返回给中心负载均衡设备，即绕过流量分配器，直接返回给客户端，因此中心负载均衡设备只负责接受并转发请求，其网络负担就减少了很多，并且给客户端提供了更快的响应时间。此种模式一般用于HTTP服务器群，在各服务器上要安装一块虚拟网络适配器，并将其IP地址设为服务器群的VIP，这样才能在服务器直接回应客户端请求时顺利的达成三次握手。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡实施要素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡方案应是在网站建设初期就应考虑的问题，不过有时随着访问流量的爆炸性增长，超出决策者的意料，这也就成为不得不面对的问题。当我们在引入某种负载均衡方案乃至具体实施时，像其他的许多方案一样，首先是确定当前及将来的应用需求，然后在代价与收效之间做出权衡。&lt;/p&gt;
&lt;p&gt;针对当前及将来的应用需求，分析网络瓶颈的不同所在，我们就需要确立是采用哪一类的负载均衡技术，采用什么样的均衡策略，在可用性、兼容性、安全性等等方面要满足多大的需求，如此等等。&lt;/p&gt;
&lt;p&gt;不管负载均衡方案是采用花费较少的软件方式，还是购买代价高昂在性能功能上更强的第四层交换机、负载均衡器等硬件方式来实现，亦或其他种类不同的均衡技术，下面这几项都是我们在引入均衡方案时可能要考虑的问题：&lt;/p&gt;
&lt;p&gt;性能：性能是我们在引入均衡方案时需要重点考虑的问题，但也是一个最难把握的问题。衡量性能时可将每秒钟通过网络的数据包数目做为一个参数，另一个参数是均衡方案中服务器群所能处理的最大并发连接数目，但是，假设一个均衡系统能处理百万计的并发连接数，可是却只能以每秒2个包的速率转发，这显然是没有任何作用的。性能的优劣与负载均衡设备的处理能力、采用的均衡策略息息相关，并且有两点需要注意：一、均衡方案对服务器群整体的性能，这是响应客户端连接请求速度的关键；二、负载均衡设备自身的性能，避免有大量连接请求时自身性能不足而成为服务瓶颈。有时我们也可以考虑采用混合型负载均衡策略来提升服务器群的总体性能，如DNS负载均衡与NAT负载均衡相结合。另外，针对有大量静态文档请求的站点，也可以考虑采用高速缓存技术，相对来说更节省费用，更能提高响应性能；对有大量ssl/xml内容传输的站点，更应考虑采用ssl/xml加速技术。&lt;/p&gt;
&lt;p&gt;可扩展性：IT技术日新月异，一年以前最新的产品，现在或许已是网络中性能最低的产品；业务量的急速上升，一年前的网络，现在需要新一轮的扩展。合适的均衡解决方案应能满足这些需求，能均衡不同操作系统和硬件平台之间的负载，能均衡HTTP、邮件、新闻、代理、数据库、防火墙和 Cache等不同服务器的负载，并且能以对客户端完全透明的方式动态增加或删除某些资源。&lt;/p&gt;
&lt;p&gt;灵活性：均衡解决方案应能灵活地提供不同的应用需求，满足应用需求的不断变化。在不同的服务器群有不同的应用需求时，应有多样的均衡策略提供更广泛的选择。&lt;/p&gt;
&lt;p&gt;可靠性：在对服务质量要求较高的站点，负载均衡解决方案应能为服务器群提供完全的容错性和高可用性。但在负载均衡设备自身出现故障时，应该有良好的冗余解决方案，提高可靠性。使用冗余时，处于同一个冗余单元的多个负载均衡设备必须具有有效的方式以便互相进行监控，保护系统尽可能地避免遭受到重大故障的损失。&lt;/p&gt;
&lt;p&gt;易管理性：不管是通过软件还是硬件方式的均衡解决方案，我们都希望它有灵活、直观和安全的管理方式，这样便于安装、配置、维护和监控，提高工作效率，避免差错。在硬件负载均衡设备上，目前主要有三种管理方式可供选择：一、命令行接口（CLI：Command Line Interface），可通过超级终端连接负载均衡设备串行接口来管理，也能telnet远程登录管理，在初始化配置时，往往要用到前者；二、图形用户接口（GUI：Graphical User Interfaces），有基于普通web页的管理，也有通过Java Applet 进行安全管理，一般都需要管理端安装有某个版本的浏览器；三、SNMP（Simple Network Management Protocol，简单网络管理协议）支持，通过第三方网络管理软件对符合SNMP标准的设备进行管理。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23-74131-098069b71.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23-74131-098069b71.html</guid>
        
        
      </item>
    
      <item>
        <title>关于字符编码，你所需要知道的</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;字符编码的问题看似很小，经常被技术人员忽视，但是很容易导致一些莫名其妙的问题。这里总结了一下字符编码的一些普及性的知识，希望对大家有所帮助。&lt;/p&gt;
&lt;h2&gt;还是得从ASCII码说起&lt;/h2&gt;
&lt;p&gt;说到字符编码，不得不说ASCII码的简史。计算机一开始发明的时候是用来解决数字计算的问题，后来人们发现，计算机还可以做更多的事，例如文本处理。但由于计算机只识“数”，因此人们必须告诉计算机哪个数字来代表哪个特定字符，例如65代表字母‘A’，66代表字母‘B’，以此类推。但是&lt;strong&gt;计算机之间字符-数字的对应关系必须得一致，否则就会造成同一段数字在不同计算机上显示出来的字符不一样&lt;/strong&gt;。因此美国国家标准协会ANSI制定了一个标准，规定了常用字符的集合以及每个字符对应的编号，这就是ASCII字符集（Character Set），也称ASCII码。&lt;/p&gt;
&lt;p&gt;当时的计算机普遍使用8比特字节作为最小的存储和处理单元，加之当时用到的字符也很少，26个大小写英文字母还有数字再加上其他常用符号，也不到100个，因此使用7个比特位就可以高效的存储和处理ASCII码，剩下最高位1比特被用作一些通讯系统的奇偶校验。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;注意，字节代表系统能够处理的最小单位，不一定是8比特。只是现代计算机的事实标准就是用8比特来代表一个字节。在很多技术规格文献中，为了避免产生歧义，更倾向于使用8位组（Octet）而不是字节（Byte）这个术语来强调8个比特的二进制流。下文中为了便于理解，我会延用大家熟悉的“字节”这个概念。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/113c27ca8568e4a3ac626cf9100fb578.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;ASCII字符集由95个可打印字符（0×20-0x7E）和33个控制字符（0×00-0×19，0x7F）组成。可打印字符用于显示在输出设备上，例如荧屏或者打印纸上，控制字符用于向计算机发出一些特殊指令，例如0×07会让计算机发出哔的一声，0×00通常用于指示字符串的结束，0x0D和0x0A用于指示打印机的打印针头退到行首（回车）并移到下一行（换行）。&lt;/p&gt;
&lt;p&gt;那时候的字符编解码系统非常简单，就是简单的查表过程。例如将字符序列编码为二进制流写入存储设备，只需要在ASCII字符集中依次找到字符对应的字节，然后直接将该字节写入存储设备即可。解码二进制流的过程也是类似。&lt;/p&gt;
&lt;h2&gt;OEM字符集的衍生&lt;/h2&gt;
&lt;p&gt;当计算机开始发展起来的时候，人们逐渐发现，ASCII字符集里那可怜的128个字符已经不能再满足他们的需求了。人们就在想，一个字节能够表示的数字（编号）有256个，而ASCII字符只用到了0×00~0x7F，也就是占用了前128个，后面128个数字不用白不用，因此很多人打起了后面这128个数字的主意。可是问题在于，很多人同时有这样的想法，但是大家对于0×80-0xFF这后面的128个数字分别对应什么样的字符，却有各自的想法。这就导致了当时销往世界各地的机器上出现了大量各式各样的OEM字符集。&lt;/p&gt;
&lt;p&gt;下面这张表是IBM-PC机推出的其中一个OEM字符集，字符集的前128个字符和ASCII字符集的基本一致（为什么说基本一致呢，是因为前32个控制字符在某些情况下会被IBM-PC机当作可打印字符解释），后面128个字符空间加入了一些欧洲国家用到的重音字符，以及一些用于画线条画的字符。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d39baa2a063d2459172053cd3871f53c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;事实上，大部分OEM字符集是兼容ASCII字符集的，也就是说，大家对于0×00~0x7F这个范围的解释基本是相同的，而对于后半部分0×80~0xFF的解释却不一定相同。甚至有时候同样的字符在不同OEM字符集中对应的字节也是不同的。&lt;/p&gt;
&lt;p&gt;不同的OEM字符集导致人们无法跨机器交流各种文档。例如职员甲发了一封简历résumés给职员乙，结果职员乙看到的却是r&lt;img alt=&quot;ג&quot; src=&quot;/images/jobbole.com/3471887fbcc718581dd03866ca11d4b7.jpg&quot; width=&quot;5&quot; height=&quot;9&quot; border=&quot;0&quot;&gt;sum&lt;img alt=&quot;ג&quot; src=&quot;/images/jobbole.com/3471887fbcc718581dd03866ca11d4b7.jpg&quot; width=&quot;5&quot; height=&quot;9&quot; border=&quot;0&quot;&gt;s，因为é字符在职员甲机器上的OEM字符集中对应的字节是0×82，而在职员乙的机器上，由于使用的OEM字符集不同，对0×82字节解码后得到的字符却是&lt;img alt=&quot;ג&quot; src=&quot;/images/jobbole.com/3471887fbcc718581dd03866ca11d4b7.jpg&quot; width=&quot;5&quot; height=&quot;9&quot; border=&quot;0&quot;&gt;。&lt;/p&gt;
&lt;h2&gt;多字节字符集（MBCS）和中文字符集&lt;/h2&gt;
&lt;p&gt;上面我们提到的字符集都是基于单字节编码，也就是说，一个字节翻译成一个字符。这对于拉丁语系国家来说可能没有什么问题，因为他们通过扩展第8个比特，就可以得到256个字符了，足够用了。但是对于亚洲国家来说，256个字符是远远不够用的。因此这些国家的人为了用上电脑，又要保持和ASCII字符集的兼容，就发明了多字节编码方式，相应的字符集就称为多字节字符集。例如中国使用的就是双字节字符集编码（DBCS，Double Byte Character Set）。&lt;/p&gt;
&lt;p&gt;对于单字节字符集来说，代码页中只需要有一张码表即可，上面记录着256个数字代表的字符。程序只需要做简单的查表操作就可以完成编解码的过程。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;代码页是字符集编码的具体实现，你可以把他理解为一张“字符-字节”映射表，通过查表实现“字符-字节”的翻译。下面会有更详细的描述。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;而对于多字节字符集，代码页中通常会有很多码表。那么程序怎么知道该使用哪张码表去解码二进制流呢？答案是，&lt;strong&gt;根据第一个字节来选择不同的码表进行解析&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如目前最常用的中文字符集GB2312，涵盖了所有简体字符以及一部分其他字符；GBK（K代表扩展的意思）则在GB2312的基础上加入了对繁体字符等其他非简体字符（GB18030字符集不是双字节字符集，我们在讲Unicode的时候会提到）。这两个字符集的字符都是使用1-2个字节来表示。Windows系统采用936代码页来实现对GBK字符集的编解码。在解析字节流的时候，如果遇到字节的最高位是0的话，那么就使用936代码页中的第1张码表进行解码，这就和单字节字符集的编解码方式一致了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3c5a6e635c7657a78f2660500245dbc8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当字节的高位是1的时候，确切的说，当第一个字节位于0x&lt;code&gt;81&lt;/code&gt;–0x&lt;code&gt;FE之间时，根据第一个字节不同找到代码页中的相应的码表，例如当第一个字节是0x81，那么对应936中的下面这张码表：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c1bd6358303b67c10ec465b39e8eeca3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（关于936代码页中完整的码表信息，参见MSDN：&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc194913%28v=MSDN.10%29.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/cc194913%28v=MSDN.10%29.aspx&lt;/a&gt;.）&lt;/p&gt;
&lt;p&gt;按照936代码页的码表，当程序遇到连续字节流0×81 0×40的时候，就会解码为“丂”字符。&lt;/p&gt;
&lt;h2&gt;ANSI标准、国家标准、ISO标准&lt;/h2&gt;
&lt;p&gt;不同ASCII衍生字符集的出现，让文档交流变得非常困难，因此各种组织都陆续进行了标准化流程。例如美国ANSI组织制定了ANSI标准字符编码（注意，&lt;strong&gt;我们现在通常说到ANSI编码，通常指的是平台的默认编码，例如英文操作系统中是ISO-8859-1，中文系统是GBK&lt;/strong&gt;），ISO组织制定的各种ISO标准字符编码，还有各国也会制定一些国家标准字符集，例如中国的GBK，GB2312和GB18030。&lt;/p&gt;
&lt;p&gt;操作系统在发布的时候，通常会往机器里预装这些标准的字符集还有平台专用的字符集，这样只要你的文档是使用标准字符集编写的，通用性就比较高了。例如你用GB2312字符集编写的文档，在中国大陆内的任何机器上都能正确显示。同时，我们也可以在一台机器上阅读多个国家不同语言的文档了，前提是本机必须安装该文档使用的字符集。&lt;/p&gt;
&lt;h2&gt;Unicode的出现&lt;/h2&gt;
&lt;p&gt;虽然通过使用不同字符集，我们可以在一台机器上查阅不同语言的文档，但是我们仍然无法解决一个问题：&lt;strong&gt;在一份文档中显示所有字符&lt;/strong&gt;。为了解决这个问题，我们需要一个全人类达成共识的巨大的字符集，这就是Unicode字符集。&lt;/p&gt;
&lt;h3&gt;Unicode字符集概述&lt;/h3&gt;
&lt;p&gt;Unicode字符集涵盖了目前人类使用的所有字符，并为每个字符进行统一编号，分配唯一的字符码（Code Point）。Unicode字符集将所有字符按照使用上的频繁度划分为17个层面（Plane），每个层面上有2&lt;sup&gt;16&lt;/sup&gt;=65536个字符码空间。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/63afa920ddf7fb8202d32e33c241a304.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中第0个层面BMP，基本涵盖了当今世界用到的所有字符。其他的层面要么是用来表示一些远古时期的文字，要么是留作扩展。我们平常用到的Unicode字符，一般都是位于BMP层面上的。目前Unicode字符集中尚有大量字符空间未使用。&lt;/p&gt;
&lt;h3&gt;编码系统的变化&lt;/h3&gt;
&lt;p&gt;在Unicode出现之前，所有的字符集都是和具体编码方案绑定在一起的，都是直接将字符和最终字节流绑定死了，例如ASCII编码系统规定使用7比特来编码ASCII字符集；GB2312以及GBK字符集，限定了使用最多2个字节来编码所有字符，并且规定了字节序。这样的编码系统通常用简单的查表，也就是通过代码页就可以直接将字符映射为存储设备上的字节流了。例如下面这个例子：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b8d527f9a38ca589c9d1f0865a6ad409.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种方式的缺点在于，字符和字节流之间耦合得太紧密了，从而限定了字符集的扩展能力。假设以后火星人入住地球了，要往现有字符集中加入火星文就变得很难甚至不可能了，而且很容易破坏现有的编码规则。&lt;/p&gt;
&lt;p&gt;因此Unicode在设计上考虑到了这一点，将字符集和字符编码方案分离开。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b742e06f36eaf51794743b85e7701651.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;虽然每个字符在Unicode字符集中都能找到唯一确定的编号（字符码，又称Unicode码），但是决定最终字节流的却是具体的字符编码&lt;/strong&gt;。例如同样是对Unicode字符“A”进行编码，UTF-8字符编码得到的字节流是0×41，而UTF-16（大端模式）得到的是0×00 0×41。&lt;/p&gt;
&lt;h3&gt;常见的Unicode编码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;UCS-2/UTF-16&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果要我们来实现Unicode字符集中BMP字符的编码方案，我们会怎么实现？由于BMP层面上有2&lt;sup&gt;16&lt;/sup&gt;=65536个字符码，因此我们只需要两个字节就可以完全表示这所有的字符了。&lt;/p&gt;
&lt;p&gt;举个例子，“中”的Unicode字符码是0x4E2D(01001110 00101101)，那么我们可以编码为01001110 00101101（大端）或者00101101 01001110 （小端）。&lt;/p&gt;
&lt;p&gt;UCS-2和UTF-16对于BMP层面的字符均是使用2个字节来表示，并且编码得到的结果完全一致。不同之处在于，&lt;strong&gt;UCS-2最初设计的时候只考虑到BMP字符，因此使用固定2个字节长度，也就是说，他无法表示Unicode其他层面上的字符，而UTF-16为了解除这个限制，支持Unicode全字符集的编解码，采用了变长编码，最少使用2个字节，如果要编码BMP以外的字符，则需要4个字节结对&lt;/strong&gt;，这里就不讨论那么远，有兴趣可以参考维基百科：&lt;a title=&quot;UTF-16/UCS-2&quot; href=&quot;http://en.wikipedia.org/wiki/UTF-16/UCS-2&quot; target=&quot;_blank&quot;&gt;UTF-16/UCS-2&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Windows从NT时代开始就采用了UTF-16编码，很多流行的编程平台，例如.Net，Java，Qt还有Mac下的Cocoa等都是使用UTF-16作为基础的字符编码。例如代码中的字符串，在内存中相应的字节流就是用UTF-16编码过的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTF-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UTF-8应该是目前应用最广泛的一种Unicode编码方案。由于UCS-2/UTF-16对于ASCII字符使用两个字节进行编码，存储和处理效率相对低下，并且由于ASCII字符经过UTF-16编码后得到的两个字节，高字节始终是0×00，很多C语言的函数都将此字节视为字符串末尾从而导致无法正确解析文本。因此一开始推出的时候遭到很多西方国家的抵触，大大影响了Unicode的推行。后来聪明的人们发明了UTF-8编码，解决了这个问题。&lt;/p&gt;
&lt;p&gt;UTF-8编码方案采用1-4个字节来编码字符，方法其实也非常简单。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a3efe42c610a2564c98044a8bfc8ff09.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（上图中的x代表Unicode码的低8位，y代表高8位）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于ASCII字符的编码使用单字节，和ASCII编码一摸一样，这样所有原先使用ASCII编解码的文档就可以直接转到UTF-8编码了。对于其他字符，则使用2-4个字节来表示，其中，首字节前置1的数目代表正确解析所需要的字节数，剩余字节的高2位始终是10。例如首字节是1110yyyy，前置有3个1，说明正确解析总共需要3个字节，需要和后面2个以10开头的字节结合才能正确解析得到字符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;关于UTF-8的更多信息，参考维基百科：&lt;a title=&quot;UTF-8&quot; href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot; target=&quot;_blank&quot;&gt;UTF-8&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GB18030&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何能够将Unicode字符映射为字节流的编码都属于Unicode编码。中国的GB18030编码，覆盖了Unicode所有的字符，因此也算是一种Unicode编码。只不过他的编码方式并不像UTF-8或者UTF-16一样，将Unicode字符的编号通过一定的规则进行转换，而只能通过查表的手段进行编码。&lt;/p&gt;
&lt;p&gt;关于GB18030的更多信息，参考：&lt;a title=&quot;GB18030&quot; href=&quot;http://en.wikipedia.org/wiki/GB18030&quot; target=&quot;_blank&quot;&gt;GB18030&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Unicode相关的常见问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Unicode是两个字节吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储为什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-16和UTF-8。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带签名的UTF-8指的是什么意思？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;带签名指的是字节流以BOM标记开始。很多软件会“智能”的探测当前字节流使用的字符编码，这种探测过程出于效率考虑，通常会提取字节流前面若干个字节，看看是否符合某些常见字符编码的编码规则。由于UTF-8和ASCII编码对于纯英文的编码是一样的，无法区分开来，因此通过在字节流最前面添加BOM标记可以告诉软件，当前使用的是Unicode编码，判别成功率就十分准确了。但是需要注意，不是所有软件或者程序都能正确处理BOM标记，例如PHP就不会检测BOM标记，直接把它当普通字节流解析了。因此如果你的PHP文件是采用带BOM标记的UTF-8进行编码的，那么有可能会出现问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unicode编码和以前的字符集编码有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;早期字符编码、字符集和代码页等概念都是表达同一个意思。例如GB2312字符集、GB2312编码，936代码页，实际上说的是同个东西。但是对于Unicode则不同，Unicode字符集只是定义了字符的集合和唯一编号，Unicode编码，则是对UTF-8、UCS-2/UTF-16等具体编码方案的统称而已，并不是具体的编码方案。所以当需要用到字符编码的时候，你可以写gb2312，codepage936，utf-8，utf-16，但请不要写unicode（看过别人在网页的meta标签里头写charset=unicode，有感而发）。&lt;/p&gt;
&lt;h2&gt;乱码问题&lt;/h2&gt;
&lt;p&gt;乱码指的是程序显示出来的字符文本无法用任何语言去解读。一般情况下会包含大量?或者�。乱码问题是所有计算机用户或多或少会遇到的问题。&lt;strong&gt;造成乱码的原因就是因为使用了错误的字符编码去解码字节流&lt;/strong&gt;，&lt;strong&gt;因此当我们在思考任何跟文本显示有关的问题时，请时刻保持清醒：当前使用的字符编码是什么&lt;/strong&gt;。只有这样，我们才能正确分析和处理乱码问题。&lt;/p&gt;
&lt;p&gt;例如最常见的网页乱码问题。如果你是网站技术人员，遇到这样的问题，需要检查以下原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器返回的响应头Content-Type没有指明字符编码&lt;/li&gt;
&lt;li&gt;网页内是否使用META HTTP-EQUIV标签指定了字符编码&lt;/li&gt;
&lt;li&gt;网页文件本身存储时使用的字符编码和网页声明的字符编码是否一致&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2209b7e687b98f96f1ad15b8bb53cff6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/911fab48d5f8e58eed3c18827af628ce.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意，网页解析的过程如果使用的字符编码不正确，还可能会导致脚本或者样式表出错。具体细节可以参考我以前写过的文章：&lt;a href=&quot;http://www.imkevinyang.com/2009/08/%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E9%9B%86%E5%AF%BC%E8%87%B4%E7%9A%84%E8%84%9A%E6%9C%AC%E9%94%99%E8%AF%AF.html&quot;&gt;文档字符集导致的脚本错误&lt;/a&gt;和&lt;a href=&quot;http://www.imkevinyang.com/2009/11/asp-net%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98.html&quot;&gt;Asp.Net页面的编码问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不久前看到某技术论坛有人反馈，WinForm程序使用Clipboard类的GetData方法去访问剪切板中的HTML内容时会出现乱码的问题，我估计也是由于WinForm在获取HTML文本的时候没有用对正确的字符编码导致的。Windows剪贴板只支持UTF-8编码，也就是说你传入的文本都会被UTF-8编解码。这样一来，只要两个程序都是调用Windows剪切板API编程的话，那么复制粘贴的过程中不会出现乱码。除非一方在获取到剪贴板数据之后使用了错误的字符编码进行解码，才会得到乱码（我做了简单的WinForm剪切板编程实验，发现GetData使用的是系统默认编码，而不是UTF-8编码）。&lt;/p&gt;
&lt;p&gt;关于乱码中出现?或者�，这里需要额外提一下，&lt;strong&gt;当程序使用特定字符编码解析字节流的时候，一旦遇到无法解析的字节流时，就会用?或者�来替代。因此，一旦你最终解析得到的文本包含这样的字符，而你又无法得到原始字节流的时候，说明正确的信息已经彻底丢失了，尝试任何字符编码都无法从这样的字符文本中还原出正确的信息来&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;必要的术语解释&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;字符集（Character Set）&lt;/strong&gt;，字面上的理解就是字符的集合，例如ASCII字符集，定义了128个字符；GB2312定义了7445个字符。而&lt;strong&gt;计算机系统中提到的字符集准确来说，指的是已编号的字符的有序集合（不一定是连续）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符码（Code Point）&lt;/strong&gt;指的就是字符集中每个字符的数字编号。例如ASCII字符集用0-127这连续的128个数字分别表示128个字符；GBK字符集使用区位码的方式为每个字符编号，首先定义一个94X94的矩阵，行称为“区”，列称为“位”，然后将所有国标汉字放入矩阵当中，这样每个汉字就可以用唯一的“区位”码来标识了。例如“中”字被放到54区第48位，因此字符码就是5448。而Unicode中将字符集按照一定的类别划分到0~16这17个层面（Planes）中，每个层面中拥有2&lt;sup&gt;16&lt;/sup&gt;=65536个字符码，因此Unicode总共拥有的字符码，也即是Unicode的字符空间总共有17*65536=1114112。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/46c43be8707d3543d63f0331008c36a6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码&lt;/strong&gt;的过程是将字符转换成字节流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解码&lt;/strong&gt;的过程是将字节流解析为字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符编码（Character Encoding）&lt;/strong&gt;是将字符集中的字符码映射为字节流的一种具体实现方案。例如ASCII字符编码规定使用单字节中低位的7个比特去编码所有的字符。例如‘A’的编号是65，用单字节表示就是0×41，因此写入存储设备的时候就是b’01000001’。GBK编码则是将区位码（GBK的字符码）中的区码和位码的分别加上0xA0（160）的偏移（之所以要加上这样的偏移，主要是为了和ASCII码兼容），例如刚刚提到的“中”字，区位码是5448，十六进制是0×3630，区码和位码分别加上0xA0的偏移之后就得到0xD6D0，这就是“中”字的GBK编码结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码页（Code Page）&lt;/strong&gt;一种字符编码具体形式。早期字符相对少，因此通常会使用类似表格的形式将字符直接映射为字节流，然后通过查表的方式来实现字符的编解码。现代操作系统沿用了这种方式。例如Windows使用936代码页、Mac系统使用EUC-CN代码页实现GBK字符集的编码，名字虽然不一样，但对于同一汉字的编码肯定是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大小端&lt;/strong&gt;的说法源自《格列佛游记》。我们知道，鸡蛋通常一端大一端小，小人国的人们对于剥蛋壳时应从哪一端开始剥起有着不一样的看法。同样，计算机界对于传输多字节字（由多个字节来共同表示一个数据类型）时，是先传高位字节（大端）还是先传低位字节（小端）也有着不一样的看法，这就是计算机里头大小端模式的由来了。无论是写文件还是网络传输，实际上都是往流设备进行写操作的过程，而且这个写操作是从流的低地址向高地址开始写（这很符合人的习惯），对于多字节字来说，如果先写入高位字节，则称作大端模式。反之则称作小端模式。也就是说，大端模式下，字节序和流设备的地址顺序是相反的，而小端模式则是相同的。一般网络协议都采用大端模式进行传输。&lt;/p&gt;
&lt;p&gt;——&lt;a title=&quot;关于字符编码，你所需要知道的&quot; href=&quot;http://www.imkevinyang.com/2010/06/%e5%85%b3%e4%ba%8e%e5%ad%97%e7%ac%a6%e7%bc%96%e7%a0%81%ef%bc%8c%e4%bd%a0%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84.html&quot;&gt;&lt;em&gt;&lt;strong&gt;Kevin Yang&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a title=&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&quot; href=&quot;http://www.joelonsoftware.com/printerFriendly/articles/Unicode.html&quot; target=&quot;_blank&quot;&gt;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://developers.sun.com/dev/gadc/technicalpublications/articles/gb18030.html&quot;&gt;http://developers.sun.com/dev/gadc/technicalpublications/articles/gb18030.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Universal_Character_Set&quot;&gt;http://en.wikipedia.org/wiki/Universal_Character_Set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Code_page&quot;&gt;http://en.wikipedia.org/wiki/Code_page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23-74109-23c6c0d86.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23-74109-23c6c0d86.html</guid>
        
        
      </item>
    
      <item>
        <title>Stream 的 Perl 后端实现关键技术介绍 (Mojolicous)</title>
        <description>

							&lt;p&gt;上一个文章&lt;a href=&quot;http://%20http://www.php-oa.com/2014/07/23/%E5%85%A8%E5%B9%B3%E5%8F%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%B8%8A%E4%BC%A0%E6%8A%80%E6%9C%AF.html&quot;&gt;全平台大文件断点续传上传技术&lt;/a&gt;中的核心技术除了浏览器, 就是服务器端的实现了. 我在这边了简单高效, 是使用的 Mojolicious 来实现的.&lt;br&gt;
 Mojolcious 有着很好的事件支持, 所以就算本身只启动一个进程的时候, 都可以接收无数用户的同时上传.&lt;br&gt;
下面我来讲一下这个技术中实现的重点.&lt;br&gt;
我们知道 POST 上传, 是分很多种不同的情况, 在 Stream 的项目中,  HTML5 的实现, 是使用的 POST body 的方式实现的.有关 post 上关方式的介绍, 请看: &lt;a href=&quot;http://www.php-oa.com/2014/07/15/http-post-mojolicious.html&quot;&gt;HTTP 的 POST 参数提交&lt;/a&gt;.&lt;br&gt;
在上面文章的例子中, 取 body 都是从使用 req-&amp;gt;body 的方式来取, 这也就意味着, 如果上传 1G ,我们会一次给一 G 的内容都放入内存. 在 Mojolicious 中有一个叫 Mojo::Upload 的模块, 也是处理上传的, 但是它只能处理以  application/x-www-form-urlencoded 和  application/x-www-form-urlencoded 的上传. 这个处理得非常有技巧, 整个文件上传了多少, 就会给多少内容存到文件本身, 这样就不会有过大的内存占用. 并且都是事件回调, 所以可以很好的处理多用户.&lt;/p&gt;
&lt;p&gt;但这个模块并不能处理 post 一个超大 body 就是文件本身的情况. 直接取 body 又大占内存, 所以在这, 我是使用的 Mojolicous 本身提供的 hook 点, 在用户提交创建完连接后, 然后请求的 header 解析完的时候, 来做了一个事件注册.&lt;br&gt;
整个核心的代码简写是:&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
hook after_build_tx =&amp;gt; sub {
    my $tx = shift;
    my $app = shift;
    weaken $tx;

    $tx-&amp;gt;req-&amp;gt;content-&amp;gt;on(body =&amp;gt; sub {
        my $single  = shift;

        return unless $tx-&amp;gt;req-&amp;gt;url-&amp;gt;path-&amp;gt;contains(&#39;/upload&#39;);
        my $file = Mojo::Asset::File-&amp;gt;new(path =&amp;gt; $tx-&amp;gt;req-&amp;gt;param(&#39;path&#39;), cleanup =&amp;gt; 0);

        $single-&amp;gt;unsubscribe(&#39;read&#39;)-&amp;gt;on(read =&amp;gt; sub {
            my ($single, $bytes) = @_;
            $file-&amp;gt;add_chunk($bytes);
        });
    });
};

&lt;/pre&gt;
&lt;p&gt;
这个 body 的事件是创建完连接, 并在 header 解析完, 但 body 并没有开始取的时候注册, 所以这个地方, 只针对我们上传的目录来进行实时写入的事件回调注册就行.&lt;/p&gt;
&lt;p&gt;这时我们进入 body , 然后对 body 读取的事件中的可读的时候, 进行注册, 使用 Mojo::Asset::File 来对一个文件不断的追加, 直到整个文件写入完整后.&lt;/p&gt;
&lt;p&gt;注意, Mojo::Asset::File 这个模块是在 Mojolicous 5.16 以后才支持对已存在的文件进行追加写入( 还是我好不容易向作者提交的补丁 ).&lt;/p&gt;

			&lt;!--[syntaxhighlighter]--&gt;
			&lt;!--代码高亮，请勿编辑--&gt;
			&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shCore.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shBrushPerl.js&quot;&gt;&lt;/script&gt;

			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shCoreDefault.css&quot;&gt;
			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shThemeDefault.css&quot;&gt;
			&lt;script type=&quot;text/javascript&quot;&gt;
			SyntaxHighlighter.defaults[&#39;class-name&#39;]	= &#39;.syntaxhighlighter {     background-color: 999999 }&#39;;
			SyntaxHighlighter.defaults[&#39;smart-tabs&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;tab-size&#39;]		= 4;
			SyntaxHighlighter.defaults[&#39;gutter&#39;]		= true;
			SyntaxHighlighter.defaults[&#39;quick-code&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;collapse&#39;] 		= false;
			SyntaxHighlighter.defaults[&#39;auto-links&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;toolbar&#39;]		= true;
			SyntaxHighlighter.all();
			&lt;/script&gt;
			&lt;!--[/syntaxhighlighter]--&gt;						

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23-5642.html-a2578a751.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23-5642.html-a2578a751.html</guid>
        
        
      </item>
    
      <item>
        <title>Access Control</title>
        <description>
&lt;p&gt;In Xcode 6 beta 4, Swift adds support for access control. This gives you complete control over what part of the code is accessible within a single file, available across your project, or made public as API for anyone that imports your framework. The three access levels included in this release are:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;
&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; entities are available only from within the source file where they are defined.&lt;/li&gt; &lt;li&gt;
&lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt; entities are available to the entire module that includes the definition (e.g. an app or framework target).&lt;/li&gt; &lt;li&gt;
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; entities are intended for use as API, and can be accessed by any file that imports the module, e.g. as a framework used in several of your projects.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;By default, most entities have &lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt; access. This allows application developers to largely ignore access control, and most Swift code already written will continue to work without change. Your framework code does need to be updated to define &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; API, giving you total control of the exposed interface your framework provides.&lt;/p&gt; &lt;p&gt;The &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; access level is the most restrictive, and makes it easy to hide implementation details from other source files. By properly structuring your code, you can safely use features like extensions and top-level functions without exposing that code to the rest of your project.&lt;/p&gt; &lt;p&gt;Developers building frameworks to be used across their projects need to mark their API as &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;. While distribution and use of 3rd-party binary frameworks is not recommended (as mentioned in a previous blog post), Swift supports construction and distribution of frameworks in source form.&lt;/p&gt; &lt;p&gt;In addition to allowing access specification for an entire declaration, Swift allows the &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; of a property to be more accessible than its &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;. Here is an example class that is part of a framework:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;public class&lt;/span&gt; ListItem {

	&lt;span class=&quot;comment&quot;&gt;// Public properties.&lt;/span&gt;
	&lt;span class=&quot;key&quot;&gt;public var&lt;/span&gt; text: &lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;
	&lt;span class=&quot;key&quot;&gt;public var&lt;/span&gt; isComplete: &lt;span class=&quot;title&quot;&gt;Bool&lt;/span&gt;

	&lt;span class=&quot;comment&quot;&gt;// Readable throughout the module, but only writeable from within this file.&lt;/span&gt;
	&lt;span class=&quot;key&quot;&gt;private(set) var&lt;/span&gt; UUID: &lt;span class=&quot;title&quot;&gt;NSUUID&lt;/span&gt;

	&lt;span class=&quot;key&quot;&gt;public init&lt;/span&gt;(text: &lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;, completed: &lt;span class=&quot;title&quot;&gt;Bool&lt;/span&gt;, UUID: &lt;span class=&quot;title&quot;&gt;NSUUID&lt;/span&gt;) {
		&lt;span class=&quot;key&quot;&gt;self&lt;/span&gt;.text = text
		&lt;span class=&quot;key&quot;&gt;self&lt;/span&gt;.isComplete = completed
		&lt;span class=&quot;key&quot;&gt;self&lt;/span&gt;.UUID = UUID
	}

	&lt;span class=&quot;comment&quot;&gt;// Usable within the framework target, but not by other targets.&lt;/span&gt;
	&lt;span class=&quot;key&quot;&gt;func&lt;/span&gt; refreshIdentity() {
		&lt;span class=&quot;key&quot;&gt;self&lt;/span&gt;.UUID = NSUUID()
	}

	&lt;span class=&quot;key&quot;&gt;public override func&lt;/span&gt; isEqual(object: &lt;span class=&quot;title&quot;&gt;AnyObject&lt;/span&gt;?) -&amp;gt; &lt;span class=&quot;title&quot;&gt;Bool&lt;/span&gt; {
		&lt;span class=&quot;key&quot;&gt;if let&lt;/span&gt; item = object &lt;span class=&quot;key&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;title&quot;&gt;ListItem&lt;/span&gt; {
			&lt;span class=&quot;key&quot;&gt;return self&lt;/span&gt;.UUID == item.UUID
		}
		&lt;span class=&quot;key&quot;&gt;return false&lt;/span&gt;
	}
}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;When mixing Objective-C and Swift, because the generated header for a framework is part of the framework’s public Objective-C interface, only declarations marked &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; appear in the generated header for a Swift framework. For applications, the generated header contains both &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; and &lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt; declarations.&lt;/p&gt; &lt;p&gt; For more information, &lt;a href=&quot;http://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/&quot;&gt;The Swift Programming Language&lt;/a&gt; and &lt;a href=&quot;http://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/&quot;&gt;Using Swift with Cocoa and Objective-C&lt;/a&gt; books have been updated to cover access control. &lt;a href=&quot;https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_6_beta_4_o2p8fz/xcode_6_beta_4_release_notes.pdf&quot;&gt;Read the complete Xcode 6 beta 4 release notes here&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23--id=5-bae94eb73.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23--id=5-bae94eb73.html</guid>
        
        
      </item>
    
      <item>
        <title>全平台大文件断点续传上传技术 ( 开源项目 Stream )</title>
        <description>

							&lt;p&gt;近来看了一下大文件断点续传的开源项目, 发现了 &lt;a href=&quot;http://www.twinkling.cn/&quot;&gt;Stream &lt;/a&gt;这个好项目, 非常非常感谢作者. 然后我花了点时间, 简单的使用 Perl 来实现了一下相关的接口. 这个是非常好的用来解决不同浏览器上传文件的方案.&lt;/p&gt;
&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;mainContentOfPage&quot;&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#stream-%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D&quot; name=&quot;user-content-stream-%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D&quot;&gt;&lt;/a&gt;Stream 上传插件介绍&lt;/h1&gt;
&lt;p&gt;
	Stream 这个项目主要是为了解决大文件上传, 本程序只是它的一个 Perl 后端的实现. 项目网站是: &lt;a href=&quot;http://www.twinkling.cn&quot;&gt;http://www.twinkling.cn&lt;/a&gt; 原始地址是: &lt;a href=&quot;http://git.oschina.net/jiangdx/stream/wikis/home&quot;&gt;http://git.oschina.net/jiangdx/stream/wikis/home&lt;/a&gt;. 因为它对 HTML5 和 Flash 都支持, 所以很合适做全功能的上传平台. 在这, 感谢作者为我们大家提供这么好的开源项目.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;支持HTML5、Flash两种方式（跨域）上传
支持多文件一起上传
HTML5方式支持断点续传，拖拽等新特性
兼容性好IE7+, FF3.6+, Chrome*，Safari4+，遨游等主流浏览器
选择文件的按钮完全可以自定义
进度条、速度、剩余时间等附属信息
基本的自定义属性及函数，如文件多选、上传成功的响应函数等
示例代码java实现（StreamServlet, FormDataServlet{commons-fileupload的stream api}, TokenServlet）

注：Chrome没测试最低版本，不想支持IE6
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#stream-%E7%9A%84-perl-%E5%90%8E%E7%AB%AF&quot; name=&quot;user-content-stream-%E7%9A%84-perl-%E5%90%8E%E7%AB%AF&quot;&gt;&lt;/a&gt;Stream 的 Perl 后端&lt;/h1&gt;
&lt;p&gt;
	本后端是使用 Perl 中常用的框架 Mojolicious 实现. 本程序做为后端接收上传过来的大文件的时候, 完全使用的是异步流式处理, 所以就算是单进程, 也可以处理多个上传的请求. 并且不会有多少内存的占用. 因为使用 Mojolicious 实现, 所以需要安装这个框架和一些相关的模块. Perl 中模块的安装需要使用 cpanm 所以先要下载 cpanm .&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ wget  http://xrl.us/cpanm  --no-check-certificate -O /sbin/cpanm
$ chmod +x  /sbin/cpanm 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	然后开始安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cpanm Mojolicious EV Digest::MD5 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#%E5%AE%89%E8%A3%85&quot; name=&quot;user-content-%E5%AE%89%E8%A3%85&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;
&lt;p&gt;
	这个 Perl 的后端的 stream 的实现文件都在项目 &lt;a href=&quot;https://github.com/iakuf/mojolicious-stream-upload&quot;&gt;https://github.com/iakuf/mojolicious-stream-upload&lt;/a&gt; 中. 大家需要使用到其中二个文件 stream.pl 和 StreamUpload.conf 所以可以使用任何方法下载这个项目中的文件. 其中 stream.pl 是执行文件, StreamUpload.conf 是配置文件.&lt;/p&gt;
&lt;p&gt;
	stream.pl 可以放在任何路径, StreamUpload.conf 请放到 &#39;/etc&#39; 的目录下.&lt;/p&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#%E9%85%8D%E7%BD%AE&quot; name=&quot;user-content-%E9%85%8D%E7%BD%AE&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;
&lt;p&gt;
	整个配置文件如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    hypnotoad =&amp;gt; {
        listen =&amp;gt; [&#39;http://*:3008&#39;],
            user   =&amp;gt; &#39;newupload&#39;,
            group  =&amp;gt; &#39;newupload&#39;,
    },
    UploadServer   =&amp;gt; &#39;http://xxx.xxxx.com&#39;,
    CrossOrigins   =&amp;gt; &#39;http://xxx.xxxx.com&#39;,
    FileRepository =&amp;gt; &#39;/tmp/&#39;,
    debug          =&amp;gt; 1,
    log            =&amp;gt; &#39;/var/log/upload.log&#39;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	指定用户和组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user   =&amp;gt; &#39;newupload&#39;
group  =&amp;gt; &#39;newupload&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	哪些域名的文件, 是可以接收并存储的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CrossOrigins   =&amp;gt; &#39;http://xxx.xxx.com&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	文件存储的目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FileRepository =&amp;gt; &#39;/tmp/&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	修改服务器启动的端口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;listen =&amp;gt; [&#39;http://*:3008&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#%E5%90%AF%E5%8A%A8&quot; name=&quot;user-content-%E5%90%AF%E5%8A%A8&quot;&gt;&lt;/a&gt;启动&lt;/h1&gt;
&lt;p&gt;
	hyphotoad 是一个常用的 Perl 后端的 Web 异步服务器, 为 Mojolicious 的原生配置. 多进程, 为 Unix 优化过. 所以使用它来启动,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ hypnotoad stream.pl 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	现在就可以直接打开这个服务器来进行测试了&lt;/p&gt;
&lt;/article&gt;
						

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23-%25e5%2585%25a8%25e5%25b9%25b3%25e5%258f%25b0%25e5%25a4%25a7%25e6%2596%2587%25e4%25bb%25b6%25e6%2596%25ad%25e7%2582%25b9%25e7%25bb%25ad%25e4%25bc%25a0%25e4%25b8%258a%25e4%25bc%25a0%25e6%258a%2580%25e6%259c%25af.html-a531e7bfe.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23-%25e5%2585%25a8%25e5%25b9%25b3%25e5%258f%25b0%25e5%25a4%25a7%25e6%2596%2587%25e4%25bb%25b6%25e6%2596%25ad%25e7%2582%25b9%25e7%25bb%25ad%25e4%25bc%25a0%25e4%25b8%258a%25e4%25bc%25a0%25e6%258a%2580%25e6%259c%25af.html-a531e7bfe.html</guid>
        
        
      </item>
    
      <item>
        <title>教你用NeoBundle管理Vim插件</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shougo/neobundle.vim&quot;&gt;NeoBundle&lt;/a&gt; 是一个 &lt;a href=&quot;http://olex.openlogic.com/packages/vim&quot;&gt;Vim&lt;/a&gt; 的插件管理器，以 &lt;a href=&quot;https://github.com/gmarik/Vundle.vim&quot;&gt;Vundle&lt;/a&gt; 为基础（Vundle 是一个基于 &lt;a href=&quot;https://github.com/tpope/vim-pathogen&quot;&gt;Pathogen&lt;/a&gt; 的 Vim 插件管理器）。在之前的文章中，我&lt;a href=&quot;http://www.openlogic.com/wazi/bid/262302/Three-tools-for-managing-Vim-plugins&quot;&gt;非常不推荐使用 Neobundle&lt;/a&gt;，原因是它当时还处于高速开发阶段（LCTT：意味着不稳定、变数大），并且当时它的英文文档很少。现在，已经过了一年多了，这两个问题都早已不再是问题。&lt;/p&gt;
&lt;p&gt;我们为什么要使用插件管理器？Vim 支持大量插件，但是由于它没有严格定义框架，插件的文件可以胡乱分布在不同目录下，导致用户管理起来会很困难（LCTT：当然，前提是你有很多插件，还有点小小的强迫症，觉得理一理这些插件心里会舒服点）。而一款插件管理器能让管理变得简单许多。Pathogen, Vundle 和 NeoBundle 的工作就是为不同插件建立一个目录，然后将这些目录扔到 ~/.vim/bundle 目录下。这个文件整理方法可以让你方便彻底地删除插件，使用 ‘rm -rf &amp;lt;插件目录&amp;gt;’ 或直接在文件管理器里面把插件所在的目录删除就可以了，绝对绿色环保无残留。同时，这种方法还能最大程度避免插件与插件之间的不兼容性。&lt;/p&gt;
&lt;p&gt;eoBundle 是一个基于 Vundle 的项目，如同 Vundle，它们都可以安装和升级插件。然而 NeoBundle 的说明文件上明确指出：“NeoBundle 不是一个稳定的插件管理器，如果你想要一个稳定的，请选择 Vundle”。最新的 release-note 上也有警告“可能会造成兼容性问题”——这是一个开发者写的注解，说明这个管理器还不能让人放心使用。&lt;/p&gt;
&lt;p&gt;所以，我们为什么要使用 NeoBundle？它都不能保证稳定运行！好吧，它还是有可取之处的。Vundle 只支持 &lt;a href=&quot;http://olex.openlogic.com/packages/git&quot;&gt;Git&lt;/a&gt; 这种版本控制系统，而 NeoBundle 可以支持 &lt;a href=&quot;http://olex.openlogic.com/packages/subversion&quot;&gt;Subversion&lt;/a&gt; 和 &lt;a href=&quot;http://olex.openlogic.com/packages/mercurial&quot;&gt;Mercurial&lt;/a&gt;。另一个原因是如果你不想插件升级时破坏你的 Vim 生态环境，你可以锁住 NeoBundle，让它只使用某个插件的固定版本。&lt;/p&gt;
&lt;p&gt;另外，NeoBundle 创建者，Shougo Matsuishita（LCTT：名字看着像日本人），正在将它的命令接口添加到其他插件项目，以便减少他们的命令使用量。现在 NeoBundle 支持3种插件：&lt;a href=&quot;https://github.com/Shougo/unite.vim&quot;&gt;unite.vim&lt;/a&gt;，Vim 使用的文件和缓存管理器；&lt;a href=&quot;https://github.com/Shougo/vimshell.vim/blob/master/doc/vimshell.txt&quot;&gt;vimshell.vim&lt;/a&gt;，Vim 使用的脚本程序；&lt;a href=&quot;https://github.com/Shougo/vimproc.vim/blob/master/doc/vimproc.txt&quot;&gt;vimproc.vim&lt;/a&gt;，运行于 vimshell.vim 中，用于对异步事件的支持。上面说的都是特殊案例，缺少英文文档，所以用户希望有人能完善它们。在正式使用它们之前，我们需要把注意力先集中在一些基本操作上。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;安装并初始化 NeoBundle&lt;/h3&gt;
&lt;p&gt;NeoBundle 支持 Vim 7.2.051 或更高版本，需要 git 和 &lt;a href=&quot;http://olex.openlogic.com/packages/curl&quot;&gt;cURL&lt;/a&gt;（用于下载文件）。你可以手动下载 NeoBundle，也可以使用 cURL 下载它在 GitHub 上的库。在你的 home 目录下使用如下命令，可以将 NeoBundle 插件下载到 .vim/bundle/neobundle.vim 目录里，然后 NeoBundle 就能管理它自己了。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;curl https://raw.githubusercontent.com/Shougo/neobundle.vim/master/bin/install.sh | sh&lt;/pre&gt;
&lt;p&gt;你还需要修改 .vimrc 文件。NeoBundle 的 GitHub 主页提供一个 .vimrc 范本，但是直接使用这个范本，NeoBundle 需要你安装5个可能不需要插件。如果不需要它们，你可以使用下面的最小配置：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;if has(&#39;vim_starting&#39;)
set nocompatible    
set runtimepath+=~/.vim/bundle/neobundle.vim/
call neobundle#begin(expand(&#39;~/.vim/bundle/&#39;))
NeoBundleFetch &#39;Shougo/neobundle.vim&#39;
call neobundle#end()
filetype plugin indent on&lt;/pre&gt;
&lt;p&gt;上述配置的作用是：启动 NeoBundle 并且像其他插件一样升级自己。NeoBundle 默认从 GitHub 下载并升级，如果你正好在使用 GitHub，你只需要为这个插件指定维护者的用户名和路径。在上面的配置中，NeoBundleFetch 只需要指定为“Shougo/neobundle.vim”，而不是完整的 GitHub 路径。如果你想使用其他网站，比如是 Subversion 或 Mecurial 的网站，你就需要添加完整的 URL。&lt;/p&gt;
&lt;p&gt;如果你想安装其他插件，你可以使用下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;curl -k https://github.com/[项目维护者]/[插件路径] &amp;gt; ~/.vim/bundle/[插件路径]&lt;/pre&gt;
&lt;p&gt;举个例子：你想安装 &lt;a href=&quot;https://github.com/tpope/vim-abolish&quot;&gt;vim-abolish&lt;/a&gt;，一个超级 NB 的文本搜索和替换插件，就使用下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;curl -k https://github.com/tpope/vim-abolish &amp;gt; ~/.vim/bundle/abolish&lt;/pre&gt;
&lt;p&gt;如果要让它自动升级，在 NeoBundleFetch 那行下面添加一行：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;NeoBundle &#39;tpope/vim-abolish&#39;&lt;/pre&gt;
&lt;p&gt;再介绍一个小技巧：你可以为插件指定一个分支或版本号。什么意思？NeoBundle 只会使用这个插件的某个分支或版本，而忽略其版本更新。如果你使用的某个插件处于高速开发过程，你就可以使用这个技巧，避免用到有 bug 的插件版本。举个例子：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;NeoBundle &#39;Shougo/vimshell&#39;, { &#39;rev&#39; : &#39;3787e5&#39; }&lt;/pre&gt;
&lt;p&gt;还有一个技巧：在 .vimtc 文件内添加一行关于“NeoBundleCheck”的属性。NeoBundle 会根据配置检查没安装的插件，并提示你安装它们。你也可以使用命令“:NeoBundleInstall”（LCTT：这是要在 Vim 编辑器的命令模式下输入）来安装或升级插件。&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;NeoBundle 用法&lt;/h3&gt;
&lt;p&gt;很多 NeoBundle 命令用起来和 Vundle 类似，但命令的名字不一样。下面是 NeoBundle 命令的用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;:NeoBundleUpdate：安装或升级插件，如果你手动把一个插件的目录删除了，这个命令会重新安装这个插件。在这个命令后面加上插件名称，就只升级一个插件；不加参数，会将所有己安装但没被记录在案的插件给记录下来。:NeoBundleInstall 命令效果相同。&lt;/li&gt;
&lt;li&gt;:NeoBundle {REPOSITORY URI} [[REVISION}] [,OPTIONS}]]：将一个插件锁定到固定版本，防止胡乱升级。&lt;/li&gt;
&lt;li&gt;:NeoBundleList：列出所有未初始化的插件。&lt;/li&gt;
&lt;li&gt;:NeoBundleClean：进入交互界面，删除插件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些命令在配合 unite.vim （LCTT：就是上面举过的32个例子之一）使用时，效果会稍微有些出入。你可以使用“:help neobundle”命令了解更多信息。&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;是否使用 NeoBundle，自己决定&lt;/h3&gt;
&lt;p&gt;NeoBundle 是强大的工具，正处于高速开发状态。任何处于这种状态的项目，都会被帖上“有前途”和“不稳定”两个标签，看你自己怎么选。如果你想要最新的稳定版本的插件，NeoBundle 能够把 Vundle 和 Pathogen 甩出几条街。&lt;/p&gt;
&lt;p&gt;然而在线帮助文档已经给出警告，它不是个稳定的产品，不及时更新版本可能造成一些插件运行出错。最后，你需要在 .vimrc 文件为你的 Neoundle 和其他插件指定一个稳定的版本。记住这警告，然后你可以在使用这些尖端技术产品时游刃有余。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Tue, 22 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-22-74055-d95c87eea.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-22-74055-d95c87eea.html</guid>
        
        
      </item>
    
      <item>
        <title>一站式学习Wireshark（八）：应用Wireshark过滤条件抓取特定数据流</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;应用抓包过滤，选择Capture | Options，扩展窗口查看到&lt;strong&gt;Capture Filter&lt;/strong&gt;栏。双击选定的接口，如下图所示，弹出&lt;strong&gt;Edit Interface Settints&lt;/strong&gt;窗口。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7ffcc37d1b7296aa062e068b9c3a28bb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图显示了&lt;strong&gt;Edit Interface Settings&lt;/strong&gt;窗口，这里可以设置抓包过滤条件。如果你确知抓包过滤条件的语法，直接在Capture Filter区域输入。在输入错误时，Wireshark通过红色背景区域表明无法处理过滤条件。最有可能的情况是，过滤条件中含有输入错误，或是使用了display filter的语法。&lt;/p&gt;
&lt;p&gt;点击&lt;strong&gt;Capture Filter&lt;/strong&gt;按钮查看并选择已保存的抓包过滤条件。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e9792c6412bc2a86af25ffcb1d7a5cb5.jpg&quot;&gt;&lt;/p&gt;
&lt;div&gt;
&lt;h1&gt;更多信息&lt;/h1&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;抓取指定&lt;/strong&gt;&lt;strong&gt;IP地址的数据流:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的抓包环境下有很多主机正在通讯，可以考虑使用所观察主机的IP地址来进行过滤。以下为IP地址抓包过滤示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;host 10.3.1.1：抓取发到/来自10.3.1.1的数据流&lt;/li&gt;
&lt;li&gt;host 2406:da00:ff00::6b16:f02d：抓取发到/来自IPv6地址2406:da00:ff00::6b16:f02d的数据流&lt;/li&gt;
&lt;li&gt;not host 10.3.1.1：抓取除了发到/来自10.3.1.1以外的所有数据流&lt;/li&gt;
&lt;li&gt;src host 10.3.1.1：抓取来自10.3.1.1的数据流&lt;/li&gt;
&lt;li&gt;dst host 10.3.1.1：抓取发到10.3.1.1的数据流&lt;/li&gt;
&lt;li&gt;host 10.3.1.1 or 10.3.1.2：抓取发到/来自10.3.1.1，以及与之通讯的所有数据流，与10.3.1.2，以及与之通讯的所有数据流&lt;/li&gt;
&lt;li&gt;host &lt;a href=&quot;http://www.espn.com/&quot; target=&quot;_blank&quot;&gt;www.espn.com&lt;/a&gt;：抓取发到/来自所有解析为&lt;a href=&quot;http://www.espn.xn--comip-k81m/&quot; target=&quot;_blank&quot;&gt;www.espn.com的IP&lt;/a&gt;地址的数据流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;抓取指定&lt;/strong&gt;&lt;strong&gt;IP地址范围的数据流:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你需要抓取来自/发到一组地址的数据流，可以采用CIDR(无类别域间路由，Classless Interdomain Routing)格式或使用mask参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;net 10.3.0.0/16：抓取网络10.3.0.0上发到/来自所有主机的数据流(16表示长度)&lt;/li&gt;
&lt;li&gt;net 10.3.0.0 mask 255.255.0.0：与之前的过滤结果相同&lt;/li&gt;
&lt;li&gt;ip6 net 2406:da00:ff00::/64：抓取网络2406:da00:ff00:0000(IPv6)上发到/来自所有主机的数据流&lt;/li&gt;
&lt;li&gt;not dst net 10.3.0.0/16：抓取除了发到以10.3开头的IP地址以外的所有数据流&lt;/li&gt;
&lt;li&gt;not src net 10.3.0.0/16：抓取除了来自以10.3开头的IP地址以外的所有数据流&lt;/li&gt;
&lt;li&gt;ip proto &amp;lt;protocol code&amp;gt;：抓取ip协议字段等于&amp;lt;protocol code&amp;gt;值的报文。如TCP(code 6), UDP(code 17), ICMP(code 1)。&lt;/li&gt;
&lt;li&gt;ip[2:2]==&amp;lt;number&amp;gt;：ip报文大小&lt;/li&gt;
&lt;li&gt;ip[8]==&amp;lt;number&amp;gt;：TTL(Time to Live)值&lt;/li&gt;
&lt;li&gt;ip[9]==&amp;lt;number&amp;gt;：协议值&lt;/li&gt;
&lt;li&gt;icmp[icmptype]==&amp;lt;identifier&amp;gt;: 抓取 ICMP代码等于identifier的ICMP报文, 如icmp-echo 以及 icmp-request。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方括号中第一个数字表示从协议头开始的偏移量，第二个数字表示需要观察多少位。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6e18d07030a1bb14e1c6e6ff26fb78de.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抓取发到广播或多播地址的数据流&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只需侦听广播或多播数据流，就可以掌握网络上主机的许多信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ip broadcast：抓取广播报文&lt;/li&gt;
&lt;li&gt;ip multicast：抓取多播报文&lt;/li&gt;
&lt;li&gt;dst host ff02::1：抓取到IPv6多播地址所有主机的数据流&lt;/li&gt;
&lt;li&gt;dst host ff02::2：抓取到IPv6多播地址所有路由器的数据流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小贴士：&lt;/p&gt;
&lt;p&gt;Wireshark包含了一些默认的抓包过滤条件。点击主工具栏的&lt;strong&gt;Edit Capture Filters&lt;/strong&gt;，跳转到已保存抓包过滤列表。你会发现一些常见抓包过滤的示例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抓取基于&lt;/strong&gt;&lt;strong&gt;MAC地址的数据流:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你需要抓取发到/来自某一主机的IPv4或IPv6数据流，可创建基于主机MAC地址的抓包过滤条件。&lt;/p&gt;
&lt;p&gt;应用MAC地址时，需确保与目标主机处于同一网段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ether host 00:08:15:00:08:15：抓取发到/来自00:08:15:00:08:15的数据流&lt;/li&gt;
&lt;li&gt;ether src 02:0A:42:23:41:AC：抓取来自02:0A:42:23:41:AC的数据流&lt;/li&gt;
&lt;li&gt;ether dst 02:0A:42:23:41:AC：抓取发到02:0A:42:23:41:AC的数据流&lt;/li&gt;
&lt;li&gt;not ether host 00:08:15:00:08:15：抓取除了发到/来自00:08:15:00:08:15以外的所有数据流&lt;/li&gt;
&lt;li&gt;ether broadcast或ether dst ff:ff:ff:ff:ff:ff：抓取广播报文&lt;/li&gt;
&lt;li&gt;ether multicast：多播报文&lt;/li&gt;
&lt;li&gt;抓取指定以太网类型的报文：ether proto 0800&lt;/li&gt;
&lt;li&gt;抓取指定VLAN：vlan &amp;lt;vlan number&amp;gt;&lt;/li&gt;
&lt;li&gt;抓取指定几个VLAN：vlan &amp;lt;vlan number&amp;gt; and vlan &amp;lt;vlan number&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;抓取基于指定应用的数据流&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可能需要查看基于一个或几个应用的数据流。抓包过滤器语法无法识别应用名，因此需要根据端口号来定义应用。通过目标应用的TCP或UDP端口号，将不相关的报文过滤掉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;port 53：抓取发到/来自端口53的UDP/TCP数据流（典型是DNS数据流）&lt;/li&gt;
&lt;li&gt;not port 53：抓取除了发到/来自端口53以外的UDP/TCP数据流&lt;/li&gt;
&lt;li&gt;port 80：抓取发到/来自端口80的UDP/TCP数据流（典型是HTTP数据流）&lt;/li&gt;
&lt;li&gt;udp port 67：抓取发到/来自端口67的UDP数据流（典型是DHCP据流）&lt;/li&gt;
&lt;li&gt;tcp port 21：抓取发到/来自端口21的TCP数据流（典型是FTP命令通道）&lt;/li&gt;
&lt;li&gt;portrange 1-80：抓取发到/来自端口1-80的所有UDP/TCP数据流&lt;/li&gt;
&lt;li&gt;tcp portrange 1-80：抓取发到/来自端口1-80的所有TCP数据流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;抓取结合端口的数据流&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你需要抓取多个不连续端口号的数据流，将它们通过逻辑符号连接起来，如下图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;port 20 or port 21：抓取发到/来自端口20或21的UDP/TCP数据流（典型是FTP数据和命令端口）&lt;/li&gt;
&lt;li&gt;host 10.3.1.1 and port 80：抓取发到/来自10.3.1.1端口80的数据流&lt;/li&gt;
&lt;li&gt;host 10.3.1.1 and not port 80：抓取发到/来自10.3.1.1除了端口80以外的数据流&lt;/li&gt;
&lt;li&gt;udp src port 68 and udp dst port 67：抓取从端口68到端口67的所有UDP数据流（典型是从DHCP客户端到DHCP服务器）&lt;/li&gt;
&lt;li&gt;udp src port 67 and udp dst port 68：抓取从端口67到端口68的所有UDP数据流（典型是从DHCP服务器到DHCP客户端）&lt;/li&gt;
&lt;li&gt;抓取TCP连接的开始（SYN）和结束（FIN）报文，配置tcp[tcpflags] &amp;amp; (tcp-syn|tcp-fin)!=0&lt;/li&gt;
&lt;li&gt;抓取所有RST(Reset)标志位为1的TCP报文，配置tcp[tcpflags] &amp;amp; (tcp-rst)!=0&lt;/li&gt;
&lt;li&gt;less &amp;lt;length&amp;gt;：抓取小于等于某一长度的报文，等同于len &amp;lt;=&amp;lt;length&amp;gt;&lt;/li&gt;
&lt;li&gt;greater &amp;lt;length&amp;gt;：抓取大于等于某一长度的报文，等同于len &amp;gt;=&amp;lt;length&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SYN: 简历连接的信号&lt;/p&gt;
&lt;p&gt;FIN: 关闭连接的信号&lt;/p&gt;
&lt;p&gt;ACK: 确认接收数据的信号&lt;/p&gt;
&lt;p&gt;RST: 立即关闭连接的信号&lt;/p&gt;
&lt;p&gt;PSH: 推信号，尽快将数据转由应用处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×00 = 0: No flags set (null scan)&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×01 = 1: FIN set and ACK not set&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×03 = 3: SYN set and FIN set&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×05 = 5: RST set and FIN set&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×06 = 6: SYN set and RST set&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×08 = 8: PSH set and ACK not set&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tcp[13]是从协议头开始的偏移量，0,1,3,5,6,8是标识位&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/589b72d6f6daa6d9de863f779bac8c7c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尽量避免使用抓包过滤。即便多看几个报文，也比漏看一个报文要好。&lt;/strong&gt;当你抓取了大量报文的时候，用显示过滤（过滤选项也更多）来重点查看某一数据流。&lt;/p&gt;
&lt;p&gt;小贴士：&lt;/p&gt;
&lt;p&gt;如果你需要查看TCP帧中的某一ASCII字符串，用Wireshark String-Matching Capture Filter Generator(&lt;a href=&quot;http://www.wireshark.org/tools/string-cf.html&quot; target=&quot;_blank&quot;&gt;http://www.wireshark.org/tools/string-cf.html&lt;/a&gt;)。例如，想要抓取HTTP GET报文，输入GET并将TCP偏移量设置为0。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Tue, 22 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-22-74018-e2c2860b8.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-22-74018-e2c2860b8.html</guid>
        
        
      </item>
    
      <item>
        <title>Feature Flag 功能发布控制</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;产品在新功能发布前，可能会采取小流量测试的方式，或者在确定方案前使用A/B测试来衡量。一般开发人员会跟运维同学合作，通过一些现有平台切换机器或者流量来实现。本文介绍了另外一种简便的方式，并解释了其在持续集成上的应用，同时提供了现有的开发框架供快速使用。&lt;/p&gt;
&lt;h2&gt;Feature Flag VS Feature Branches&lt;/h2&gt;
&lt;p&gt;Feature Flag(又名 Feature Toggle、Flip等)是一种允许控制线上功能开启或者关闭的方式，通常会采取配置文件的方式来控制。提到Feature Flag一般都会跟Feature Branches进行比较。这两个有什么关联与差别呢？可以通过一个简单的示例来比较：&lt;/p&gt;
&lt;p&gt;假设产品需要添加一个功能，如果你在主干上进行开发，那么通常的做法是在前端开发人员在界面上添加功能，然后可能会有其他同学来完成后端服务、安全保障，最后测试及Bug修复并发布上线。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/3f023edafa76373e737f3cda38decf85.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73931&quot; alt=&quot;new-feature&quot; src=&quot;/images/jobbole.com/0ceec95bf020414d8fd832e7b7e08a76.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;上图中有个明显的问题是&lt;strong&gt;主干分支上在功能测试完毕之前是不能进行发布&lt;/strong&gt;的，因为功能已经在提供在界面中，必须完备之后才能发布给用户使用。&lt;/p&gt;
&lt;p&gt;当然解决方法也很简单，例如我们常见的是会使用功能分支(Feature Branches)来解决。在主干上拉取一个分支，然后在分支上开完测试完之后在合并到主干上，这样就不会影响主干的持续发布了。如果有另外的新的功能那么同样拉取新的分支来解决。如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/b139771f4bd796365f7d28ed3593d19c.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73933&quot; alt=&quot;new-feature2&quot; src=&quot;/images/jobbole.com/b4e810b6466d9ac806b26bbd5a79ad40.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;但这样同样存在问题，如果一个功能比较复杂，开发的周期较长，而在此期间主干上已经多次修改代码，那么等分支上开发完之后合并到主干将是一个比较麻烦的工作。你必须去处理各种冲突，与其他开发人员沟通修改点。这是很多人不愿意做的。&lt;/p&gt;
&lt;p&gt;于是有人提供了新的方案来解决这个问题。例如将开发工作拆分成多个小块，在各个分支上开发测试完成后及时合并到主干中，并且可以先隐藏界面功能，直到所有的功能开发完成之后才展现。这样每次合并的难度就小多了；或者每次将主干上的修改都及时同步到分支上，这样分支上开发完成之后合并到主干上就简单多了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/5876f970ca04ac464c0e4664f69a9a51.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73934&quot; alt=&quot;new-feature3&quot; src=&quot;/images/jobbole.com/cd969a53adefb39cbb953d2828ec2028.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;但如果&lt;strong&gt;发布时出现bug&lt;/strong&gt;怎么办？可能常见的是进行回滚重新上线。有什么方式既能避免分支合并的麻烦、保持主干快速迭代随时发布，又能更好的控制新功能的发布、方便的进行小流量或快速回滚操作呢？答案就是Feature Flag。&lt;/p&gt;
&lt;p&gt;Feature Flag允许关闭未完成的功能，你可以在主干上进行迭代开发，新功能即便未开发完成也不会影响发布，因为它对用户是&lt;code&gt;关闭&lt;/code&gt;的。当功能开发完成之后，修改配置便可以让功能发布。这种操作甚至可以在线上进行，例如代码已经发布但功能不可见，你可以修改配置让功能对&lt;strong&gt;特定的用户&lt;/strong&gt;(线上测试、小流量或者全量发布等)可见。如果发现新功能存在问题，那么可以通过配置文件来迅速回滚，而必须重新分支上线。Feature Flag原理示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/990e4ee6ca912e39bafcd11f05375d5f.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73936&quot; alt=&quot;featureToggle&quot; src=&quot;/images/jobbole.com/6312cf3bb128a0d3eb8de77d6c9798fe.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;各自的优缺点&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;选择合适的方案，而不拘泥于方式本身&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;并没有万能的方案，两种方式都有各自的优缺点。&lt;/p&gt;
&lt;h3&gt;Feature Branches&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同时开发多个功能分支不会影响主干和线上代码&lt;/li&gt;
&lt;li&gt;在分支上开发新功能时不用担心对其他在开发的功能的影响&lt;/li&gt;
&lt;li&gt;现有很多持续集成系统支持分支的构建、测试、部署等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;也很明显，&lt;a href=&quot;http://martinfowler.com/bliki/FeatureBranch.html&quot; target=&quot;_blank&quot;&gt;Martin Fowler&lt;/a&gt;的文章中已经做了全面的阐述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分支分出去时间越长往往代码合并难度越大&lt;/li&gt;
&lt;li&gt;在一个分支中修改了函数名字可能会引入大量编译错误。这点被称为语义冲突（semantic conflict）&lt;/li&gt;
&lt;li&gt;为了减少语义冲突，会尽量少做重构。而重构是持续改进代码质量的手段。如果在开发的过程中持续不断的存在功能分支，就会阻碍代码质量的改进。&lt;/li&gt;
&lt;li&gt;一旦代码库中存在了分支，也就不再是真正的持续集成了。当然你可以给每个分支建立一个对应的CI，但它只能测试当前分支的正确性。如果在一个分支中修改了函数功能，但是在另一个分支还是按照原来的假设在使用，在合并的时候会引入bug，需要大量的时间来修复这些bug。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Feature Toggle&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免了分支合并代码冲突的问题，因为是基于主干的开发&lt;/li&gt;
&lt;li&gt;每次提交都在主干，迭代速度明显有优势&lt;/li&gt;
&lt;li&gt;新功能的整个过程都持续集成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未完成的功能可能会部署到线上，如果配置有误可能将未完成的功能开启。当然可以将界面层最后开发避免过早暴露。&lt;/li&gt;
&lt;li&gt;主干上担心提交代码影响其他功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以根据需要选择合适的方案。Feature Flag在避免分支合并加快迭代上有优势，另外Feature Flag除了主干开发上的支持，还有什么实用功能呢？下面来介绍。&lt;/p&gt;
&lt;h2&gt;Feature Flag种类与应用&lt;/h2&gt;
&lt;p&gt;一般Feature Flag可以分为两类，见下所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发布开关&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在发布代码时关掉未完成的功能&lt;/li&gt;
&lt;li&gt;生存期短&lt;/li&gt;
&lt;li&gt;功能稳定就马上删除&lt;/li&gt;
&lt;li&gt;在整个开发过程中有预定义的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;业务开关&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现A/B测试&lt;/li&gt;
&lt;li&gt;针对特定人群发布功能尽早获得反馈&lt;/li&gt;
&lt;li&gt;针对特定条件开启或者关闭功能。例如可以设置在指定时间点开启，这样新功能将按照设定自动上线下线，无需手动上线，适合专题等情况&lt;/li&gt;
&lt;li&gt;能线上开启或者关闭,实现快速回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发布开关主要是为了隐藏未开发完成的功能，而业务开关则可以帮助我们快速满足某些需求。例如A/B测试，Feature Flag可以轻松控制展现哪个功能，提升A/B测试的可维护性。我们也可以通过配置里面的逻辑让新功能针对小部分人群甚至是特定地域的人群发布，尽早获取功能的反馈。甚至是可以在线上开启调试，只让新功能对调试人员可见。而这些都只需要配置文件和简单的标记来实现。&lt;/p&gt;
&lt;h2&gt;谁在用Feature Flag&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;功能看起来很酷，但是不是新东西？有谁在用呢，我可不不愿意承担风险&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;事实上Feature Flag已经在国外互联网公司中获得广泛的使用。例如FaceBook、Google等公司使用基于主干的开发模式来持续集成开发，Feature Flag是其中一个基础技术。下面这幅图展现了FaceBook开发模式转变历程,可以看到几年前facebook就开始使用Feature Toggle，使用了Feature Flag关闭主干上未开发完成的功能来保证快速迭代和高频率的发布。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/546b1655ef24c07a846869272a16ae15.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73938&quot; alt=&quot;facebook&quot; src=&quot;/images/jobbole.com/90222994abf75057531d3a23ffcb6e14.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;国外主干开发中推荐这样一种方式：trunk作为开发主线，所有开发人员完成开发后向及时向主干提交代码，开发人员不允许在主干上拉取分支。在发布的时候由系统拉取分支发布，主干上的bug修复及时同步到发布分支。开发人员可以本地使用git等工具进行版本管理。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/d2c55b38c1f915bba4d4b1af268aa552.jpg&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73939&quot; alt=&quot;tbd&quot; src=&quot;/images/jobbole.com/595bdd6f052b91c2161119c4bff5c5f4.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;虽然基于主干的开发模式已经成为国外的主流，但分支开发并不是不该使用。使用分支不推荐的是让新功能代码在分支上长时间堆积，分支应当是生存周期短的。&lt;/p&gt;
&lt;p&gt;实际应用中我们可以根据业务场景来选择是否用功能分支还是Feature Flag，并且这两者可以相互结合。例如在文章前面提到的示例中，可以使用分支来开发细分的子功能保持分支及时合并，同时使用Feature Flag来控制功能的发布，提升工作效率。&lt;/p&gt;
&lt;h2&gt;最佳实践&lt;/h2&gt;
&lt;p&gt;除了主干开发，什么情况下选择使用Feature Flag呢？下面是使用Feature Flag的一些典型场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 UI 中隐藏或禁用新功能&lt;/li&gt;
&lt;li&gt;在应用程序中隐藏或禁用新组件&lt;/li&gt;
&lt;li&gt;对接口进行版本控制&lt;/li&gt;
&lt;li&gt;扩展接口&lt;/li&gt;
&lt;li&gt;支持组件的多个版本&lt;/li&gt;
&lt;li&gt;将新功能添加到现有应用程序&lt;/li&gt;
&lt;li&gt;增强现有应用程序中的现有功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，由于Feature Flag本身是对业务功能的控制，所以不适于功能大范围的改动等情况。另外使用过程中需要注意一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只在需要的地方创建开关。美酒虽豪，不可贪杯。滥用任何技术都会出现问题。&lt;/li&gt;
&lt;li&gt;控制开关的数量。同上，开关应按需使用并及时清除。&lt;/li&gt;
&lt;li&gt;开关之间代码保持独立。如果代码存在依赖就没法删除，最终维护性反而变差&lt;/li&gt;
&lt;li&gt;清除发布开关和废弃代码。发布开关应当在功能稳定后删除，旧代码也是。&lt;/li&gt;
&lt;li&gt;界面层最后暴露。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;如何实现&lt;/h2&gt;
&lt;p&gt;实现这套东西复杂吗？下面以php和smarty模板为例来介绍。&lt;/p&gt;
&lt;p&gt;首先需要一套控制代码逻辑的工具，虽然开源的框架有在后端代码层的支持，但推荐在模板层使用Feature Flag，因为模板直接跟功能挂钩，维护起来更加直观方便。&lt;/p&gt;
&lt;p&gt;例如我们会提供一个smarty插件，让你控制相应的展现:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/4f8e3c1849fd0fcf7be5f15a50f4deba.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73940&quot; alt=&quot;feature-smarty&quot; src=&quot;/images/jobbole.com/9fb17b4ac0813c18537c4c413574ebbc.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;这个代码的意思是如果common模块的featureA命中，则展现下面代码，否则展现另外一套代码，展现代码由于与功能相关，所以就相当于控制了展现哪个功能。当然你也可以不用&lt;code&gt;featureelse&lt;/code&gt;只控制功能的开启或者关闭。&lt;/p&gt;
&lt;p&gt;另外我们需要一个配置文件，对应featureA的配置，如下所示：&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: false&quot;&gt;{
      &quot;features&quot; : {
          &quot;featureA&quot; : {
              &quot;type&quot; : &quot;switch&quot;,
              &quot;value&quot; : &quot;on&quot;,
              &quot;desc&quot; : &quot;test switch feature work or not&quot;
          }
      }
 }&lt;/pre&gt;
&lt;p&gt;featureA配置的value是&lt;code&gt;on&lt;/code&gt;，开关类型是&lt;code&gt;switch&lt;/code&gt;。也就是说这个功能是开启的。与switch类似的可以实现多个feature类型，例如抽样控制、日期控制、地域控制等，代码逻辑只需要根据value的设定判断是true还是false。例如抽样类型，value设置0.5，那么对应的类型逻辑只需要判断随机数是否在0-0.5范围内而已。&lt;/p&gt;
&lt;p&gt;部署中我们只需要修改featureA的配置就可以控制功能的发布，是不是so easy!&lt;/p&gt;
&lt;h2&gt;开发框架&lt;/h2&gt;
&lt;p&gt;有哪些相应的开源框架呢？几乎各种语言都有相应的实现。例如FEX &lt;a href=&quot;http://fis.baidu.com/&quot; target=&quot;_blank&quot;&gt;FIS&lt;/a&gt;小组提供了基于php和node.js的框架。此外还有多种语言的开源实现：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语言&lt;/th&gt;
&lt;th&gt;Feature Flag框架&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;php&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;基于smarty的&lt;a href=&quot;https://github.com/wangcheng714/feature-flag&quot; target=&quot;_blank&quot;&gt;Feature Flag框架&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;NodeJs&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;基于Node前后端解决方案Yogurt的&lt;a href=&quot;https://github.com/fex-team/yog-feature&quot; target=&quot;_blank&quot;&gt;Feature Flag框架&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.togglz.org/&quot; target=&quot;_blank&quot;&gt;Togglz&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.NET&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/jason-roberts/FeatureToggle&quot; target=&quot;_blank&quot;&gt;FeatureToggle&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ruby&lt;/td&gt;
&lt;td&gt;
&lt;a href=&quot;https://github.com/FetLife/rollout&quot; target=&quot;_blank&quot;&gt;Rollout&lt;/a&gt;、&lt;a href=&quot;https://github.com/jamesgolick/degrade&quot; target=&quot;_blank&quot;&gt;Degrade&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;
&lt;a href=&quot;https://github.com/disqus/gargoyle&quot; target=&quot;_blank&quot;&gt;Gargoyle&lt;/a&gt;、&lt;a href=&quot;https://github.com/disqus/nexus&quot; target=&quot;_blank&quot;&gt;Nexus admin&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Groovy&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/ryannorris/grails-feature-toggle&quot; target=&quot;_blank&quot;&gt;GrailsFeatureToggle&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Feature Flag与Feature Branches各有优势，结合使用能发挥更大作用&lt;/li&gt;
&lt;li&gt;结合业务场景选择合适方案&lt;/li&gt;
&lt;li&gt;Feature Flag能支持主干开发，并在控制功能发布上有独特优势&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/magazine/dn683796.aspx&quot; target=&quot;_blank&quot;&gt;采用功能切换进行软件开发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations&quot; target=&quot;_blank&quot;&gt;使用功能开关更好地实现持续部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://martinfowler.com/bliki/FeatureToggle.html&quot; target=&quot;_blank&quot;&gt;FeatureToggle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/HendrikEbbers/feature-driven-development-35863636?qid=2a29fcc2-9c8c-404f-ae41-d4dc7494d278&amp;amp;v=qf1&amp;amp;b=&amp;amp;from_search=5&quot; target=&quot;_blank&quot;&gt;Feature driven development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.pluralsight.com/favor-feature-toggles-over-feature-branches&quot; target=&quot;_blank&quot;&gt;Favor Feature Toggles over Feature Branches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://paulhammant.com/2013/04/05/what-is-trunk-based-development/&quot; target=&quot;_blank&quot;&gt;What is Trunk Based Development?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://abhishek-tiwari.com/post/decoupling-deployment-and-release-feature-toggles&quot; target=&quot;_blank&quot;&gt;Decoupling Deployment and Release- Feature Toggles&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Mon, 21 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-21-73930-06f292316.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-21-73930-06f292316.html</guid>
        
        
      </item>
    
      <item>
        <title>推荐！国外程序员整理的机器学习资源大全</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;本文汇编了一些机器学习领域的框架、库以及软件（按编程语言排序）。&lt;/p&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#c&quot; name=&quot;user-content-c&quot;&gt;&lt;/a&gt;C++&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#compute-vision&quot; name=&quot;user-content-compute-vision&quot;&gt;&lt;/a&gt;计算机视觉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/liuliu/ccv&quot;&gt;CCV&lt;/a&gt; —基于C语言/提供缓存/核心的机器视觉库，新颖的机器视觉库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://opencv.org/&quot;&gt;OpenCV&lt;/a&gt;—它提供C++, C, Python, Java 以及 MATLAB接口，并支持Windows, Linux, Android and Mac OS操作系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning&quot; name=&quot;user-content-general-purpose-machine-learning&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mlpack.org/&quot;&gt;MLPack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dlib.net/ml.html&quot;&gt;DLib&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://code.google.com/p/encog-cpp/&quot;&gt;ecogg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://image.diku.dk/shark/sphinx_pages/build/html/index.html&quot;&gt;shark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#closure&quot; name=&quot;user-content-closure&quot;&gt;&lt;/a&gt;Closure&lt;/h2&gt;
&lt;h4&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.clojure-toolbox.com/&quot;&gt;Closure Toolbox&lt;/a&gt;—Clojure语言库与工具的分类目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#go&quot; name=&quot;user-content-go&quot;&gt;&lt;/a&gt;Go&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing&quot; name=&quot;user-content-natural-language-processing&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/reiver/go-porterstemmer&quot;&gt;go-porterstemmer&lt;/a&gt;—一个Porter词干提取算法的原生Go语言净室实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/Rookii/paicehusk&quot;&gt;paicehusk&lt;/a&gt;—Paice/Husk词干提取算法的Go语言实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://bitbucket.org/tebeka/snowball&quot;&gt;snowball&lt;/a&gt;—Go语言版的Snowball词干提取器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 16px; font-style: normal; font-weight: bold;&quot;&gt;通用机器学习&lt;/span&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-2&quot; name=&quot;user-content-general-purpose-machine-learning-2&quot;&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/sjwhitworth/golearn&quot;&gt;Go Learn&lt;/a&gt;— Go语言机器学习库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/daviddengcn/go-pr&quot;&gt;go-pr&lt;/a&gt; —Go语言机器学习包.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/jbrukh/bayesian&quot;&gt;bayesian&lt;/a&gt;—Go语言朴素贝叶斯分类库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/thoj/go-galib&quot;&gt;go-galib&lt;/a&gt;—Go语言遗传算法库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization&quot; name=&quot;user-content-data-analysis--data-visualization&quot;&gt;&lt;/a&gt;&lt;br&gt;
数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/StepLg/go-graph&quot;&gt;go-graph&lt;/a&gt;—Go语言图形库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.svgopen.org/2011/papers/34-SVGo_a_Go_Library_for_SVG_generation/&quot;&gt;SVGo&lt;/a&gt;—Go语言的SVG生成库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#java&quot; name=&quot;user-content-java&quot;&gt;&lt;/a&gt;Java&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-1&quot; name=&quot;user-content-natural-language-processing-1&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/corenlp.shtml&quot;&gt;CoreNLP&lt;/a&gt;—斯坦福大学的CoreNLP提供一系列的自然语言处理工具，输入原始英语文本，可以给出单词的基本形式（下面Stanford开头的几个工具都包含其中）。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/lex-parser.shtml&quot;&gt;Stanford Parser&lt;/a&gt;—一个自然语言解析器。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/tagger.shtml&quot;&gt;Stanford POS Tagger&lt;/a&gt; —一个词性分类器。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/CRF-NER.shtml&quot;&gt;Stanford Name Entity Recognizer&lt;/a&gt;—Java实现的名称识别器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/segmenter.shtml&quot;&gt;Stanford Word Segmenter&lt;/a&gt;—分词器，很多NLP工作中都要用到的标准预处理步骤。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/tregex.shtml&quot;&gt;Tregex, Tsurgeon and Semgrex&lt;/a&gt; —用来在树状数据结构中进行模式匹配，基于树关系以及节点匹配的正则表达式（名字是“tree regular expressions”的缩写）。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/phrasal/&quot;&gt;Stanford Phrasal:&lt;/a&gt;最新的基于统计短语的机器翻译系统，&lt;a href=&quot;http://nlp.stanford.edu/software/phrasal/&quot;&gt; &lt;/a&gt;java编写&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/tokensregex.shtml&quot;&gt;Stanford Tokens Regex&lt;/a&gt;—用以定义文本模式的框架。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/sutime.shtml&quot;&gt;Stanford Temporal Tagger&lt;/a&gt;—SUTime是一个识别并标准化时间表达式的库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/patternslearning.shtml&quot;&gt;Stanford SPIED&lt;/a&gt;—在种子集上使用模式，以迭代方式从无标签文本中学习字符实体&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/tmt/tmt-0.4/&quot;&gt;Stanford Topic Modeling Toolbox&lt;/a&gt; —为社会科学家及其他希望分析数据集的人员提供的主题建模工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/twitter-text-java&quot;&gt;Twitter Text Java&lt;/a&gt;—Java实现的推特文本处理库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://mallet.cs.umass.edu/&quot;&gt;MALLET&lt;/a&gt; -—基于Java的统计自然语言处理、文档分类、聚类、主题建模、信息提取以及其他机器学习文本应用包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://opennlp.apache.org/&quot;&gt;OpenNLP&lt;/a&gt;—处理自然语言文本的机器学习工具包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://alias-i.com/lingpipe/index.html&quot;&gt;LingPipe&lt;/a&gt; —使用计算机语言学处理文本的工具包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-3&quot; name=&quot;user-content-general-purpose-machine-learning-3&quot;&gt;&lt;/a&gt;&lt;br&gt;
通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://spark.apache.org/docs/latest/mllib-guide.html&quot;&gt;MLlib in Apache Spark&lt;/a&gt;—Spark中的分布式机器学习程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/apache/mahout&quot;&gt;Mahout&lt;/a&gt; —分布式的机器学习库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/classifier.shtml&quot;&gt;Stanford Classifier&lt;/a&gt; —斯坦福大学的分类器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.cs.waikato.ac.nz/ml/weka/&quot;&gt;Weka&lt;/a&gt;—Weka是数据挖掘方面的机器学习算法集。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/cloudera/oryx&quot;&gt;ORYX&lt;/a&gt;—提供一个简单的大规模实时机器学习/预测分析基础架构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-1&quot; name=&quot;user-content-data-analysis--data-visualization-1&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/apache/hadoop-mapreduce&quot;&gt;Hadoop&lt;/a&gt;—大数据分析平台&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/apache/spark&quot;&gt;Spark&lt;/a&gt;—快速通用的大规模数据处理引擎。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/cloudera/impala&quot;&gt;Impala&lt;/a&gt; —为Hadoop实现实时查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#javascript&quot; name=&quot;user-content-javascript&quot;&gt;&lt;/a&gt;Javascript&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-2&quot; name=&quot;user-content-natural-language-processing-2&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/twitter-text-js&quot;&gt;Twitter-text-js&lt;/a&gt; —JavaScript实现的推特文本处理库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nicktesla/nlpjs&quot;&gt;NLP.js&lt;/a&gt; —javascript及coffeescript编写的NLP工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/NaturalNode/natural&quot;&gt;natural&lt;/a&gt;—Node下的通用NLP工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/loadfive/Knwl.js&quot;&gt;Knwl.js&lt;/a&gt;—JS编写的自然语言处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-2&quot; name=&quot;user-content-data-analysis--data-visualization-2&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://d3js.org/&quot;&gt;D3.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.highcharts.com/&quot;&gt;High Charts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nvd3.org/&quot;&gt;NVD3.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dc-js.github.io/dc.js/&quot;&gt;dc.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.chartjs.org/&quot;&gt;chartjs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dimplejs.org/&quot;&gt;dimple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amcharts.com/&quot;&gt;amCharts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-4&quot; name=&quot;user-content-general-purpose-machine-learning-4&quot;&gt;&lt;/a&gt;&lt;br&gt;
通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://cs.stanford.edu/people/karpathy/convnetjs/&quot;&gt;Convnet.js&lt;/a&gt;—训练深度学习模型的JavaScript库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tixz/clustering.js&quot;&gt;Clustering.js&lt;/a&gt;—用JavaScript实现的聚类算法，供Node.js及浏览器使用。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/serendipious/nodejs-decision-tree-id3&quot;&gt;Decision Trees&lt;/a&gt;—Node.js实现的决策树，使用ID3算法。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/rlidwka/node-fann&quot;&gt;Node-fann&lt;/a&gt; —Node.js下的快速人工神经网络库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tixz/kmeans.js&quot;&gt;Kmeans.js&lt;/a&gt;—k-means算法的简单Javascript实现，供Node.js及浏览器使用。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/primaryobjects/lda&quot;&gt;LDA.js&lt;/a&gt; —供Node.js用的LDA主题建模工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/yandongliu/learningjs&quot;&gt;Learning.js&lt;/a&gt;—逻辑回归/c4.5决策树的JavaScript实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://joonku.com/project/machine_learning&quot;&gt;Machine Learning&lt;/a&gt;—Node.js的机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nicolaspanel/node-svm&quot;&gt;Node-SVM&lt;/a&gt;—Node.js的支持向量机&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/harthur/brain&quot;&gt;Brain&lt;/a&gt; —JavaScript实现的神经网络&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/omphalos/bayesian-bandit.js&quot;&gt;Bayesian-Bandit&lt;/a&gt; —贝叶斯强盗算法的实现，供Node.js及浏览器使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#julia&quot; name=&quot;user-content-julia&quot;&gt;&lt;/a&gt;Julia&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-5&quot; name=&quot;user-content-general-purpose-machine-learning-5&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/PGM.jl&quot;&gt;PGM&lt;/a&gt;—Julia实现的概率图模型框架。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/trthatcher/DA.jl&quot;&gt;DA&lt;/a&gt;—Julia实现的正则化判别分析包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/lindahua/Regression.jl&quot;&gt;Regression&lt;/a&gt;—回归分析算法包（如线性回归和逻辑回归）。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/dcjones/Loess.jl&quot;&gt;Local Regression&lt;/a&gt; —局部回归，非常平滑！&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nutsiepully/NaiveBayes.jl&quot;&gt;Naive Bayes&lt;/a&gt; —朴素贝叶斯的简单Julia实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/dmbates/MixedModels.jl&quot;&gt;Mixed Models&lt;/a&gt; —（统计）混合效应模型的Julia包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fredo-dedup/SimpleMCMC.jl&quot;&gt;Simple MCMC&lt;/a&gt; —Julia实现的基本mcmc采样器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/Distance.jl&quot;&gt;Distance&lt;/a&gt;—Julia实现的距离评估模块&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/bensadeghi/DecisionTree.jl&quot;&gt;Decision Tree&lt;/a&gt; —决策树分类器及回归分析器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/compressed/neural.jl&quot;&gt;Neural&lt;/a&gt; —Julia实现的神经网络&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/doobwa/MCMC.jl&quot;&gt;MCMC&lt;/a&gt; —Julia下的MCMC工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLM&lt;/a&gt; —Julia写的广义线性模型包&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lendle/OnlineLearning.jl&quot;&gt;Online Learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/simonster/GLMNet.jl&quot;&gt;GLMNet&lt;/a&gt; —GMLNet的Julia包装版，适合套索/弹性网模型。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/Clustering.jl&quot;&gt;Clustering&lt;/a&gt;—数据聚类的基本函数：k-means, dp-means等。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/SVM.jl&quot;&gt;SVM&lt;/a&gt;—Julia下的支持向量机。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/KernelDensity.jl&quot;&gt;Kernal Density&lt;/a&gt;—Julia下的核密度估计器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/DimensionalityReduction.jl&quot;&gt;Dimensionality Reduction&lt;/a&gt;—降维算法&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/NMF.jl&quot;&gt;NMF&lt;/a&gt; —Julia下的非负矩阵分解包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/EricChiang/ANN.jl&quot;&gt;ANN&lt;/a&gt;—Julia实现的神经网络&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-3&quot; name=&quot;user-content-natural-language-processing-3&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/slycoder/TopicModels.jl&quot;&gt;Topic Models&lt;/a&gt; —Julia下的主题建模&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/johnmyleswhite/TextAnalysis.jl&quot;&gt;Text Analysis&lt;/a&gt;—Julia下的文本分析包&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-3&quot; name=&quot;user-content-data-analysis--data-visualization-3&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/IainNZ/GraphLayout.jl&quot;&gt;Graph Layout&lt;/a&gt; —纯Julia实现的图布局算法。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/DataFramesMeta.jl&quot;&gt;Data Frames Meta&lt;/a&gt; —DataFrames的元编程工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nfoti/JuliaData&quot;&gt;Julia Data&lt;/a&gt;—处理表格数据的Julia库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/WizardMac/DataRead.jl&quot;&gt;Data Read&lt;/a&gt;—从Stata、SAS、SPSS读取文件&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/HypothesisTests.jl&quot;&gt;Hypothesis Tests&lt;/a&gt;—Julia中的假设检验包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/dcjones/Gadfly.jl&quot;&gt;Gladfly&lt;/a&gt; —Julia编写的灵巧的统计绘图系统。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/johnmyleswhite/stats.jl&quot;&gt;Stats&lt;/a&gt;—Julia编写的统计测试函数包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/johnmyleswhite/RDatasets.jl&quot;&gt;RDataSets&lt;/a&gt; —读取R语言中众多可用的数据集的Julia函数包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/DataFrames.jl&quot;&gt;DataFrames&lt;/a&gt; —处理表格数据的Julia库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;Distributions&lt;/a&gt;—概率分布及相关函数的Julia包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/DataArrays.jl&quot;&gt;Data Arrays&lt;/a&gt; —元素值可以为空的数据结构。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/TimeSeries.jl&quot;&gt;Time Series&lt;/a&gt;—Julia的时间序列数据工具包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/Sampling.jl&quot;&gt;Sampling&lt;/a&gt;—Julia的基本采样算法包&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#misc-stuff--presentations&quot; name=&quot;user-content-misc-stuff--presentations&quot;&gt;&lt;/a&gt;杂项/演示文稿&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaDSP/DSP&quot;&gt;DSP&lt;/a&gt; —数字信号处理&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaCon/presentations&quot;&gt;JuliaCon Presentations&lt;/a&gt;—Julia大会上的演示文稿&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/davidavdav/SignalProcessing&quot;&gt;SignalProcessing&lt;/a&gt;—Julia的信号处理工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/timholy/Images.jl&quot;&gt;Images&lt;/a&gt;—Julia的图片库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#matlab&quot; name=&quot;user-content-matlab&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;Lua&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#general-purpose-machine-learning-7&quot; name=&quot;user-content-general-purpose-machine-learning-7&quot;&gt;&lt;/a&gt;&lt;br&gt;
通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://torch.ch/&quot;&gt;Torch7&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://jucor.github.io/torch-cephes&quot;&gt;cephes&lt;/a&gt; —Cephes数学函数库，包装成Torch可用形式。提供并包装了超过180个特殊的数学函数，由Stephen L. Moshier开发，是SciPy的核心，应用于很多场合。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/graph&quot;&gt;graph&lt;/a&gt; —供Torch使用的图形包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://jucor.github.io/torch-randomkit/&quot;&gt;randomkit&lt;/a&gt;—从Numpy提取的随机数生成包，包装成Torch可用形式。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://soumith.ch/torch-signal/signal/&quot;&gt;signal&lt;/a&gt; —Torch-7可用的信号处理工具包，可进行FFT, DCT, Hilbert, cepstrums, stft等变换。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/nn&quot;&gt;nn&lt;/a&gt; —Torch可用的神经网络包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/nngraph&quot;&gt;nngraph&lt;/a&gt; —为nn库提供图形计算能力。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/lua---nnx&quot;&gt;nnx&lt;/a&gt;—一个不稳定实验性的包，扩展Torch内置的nn库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/optim&quot;&gt;optim&lt;/a&gt;—Torch可用的优化算法库，包括 SGD, Adagrad, 共轭梯度算法, LBFGS, RProp等算法。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/koraykv/unsup&quot;&gt;unsup&lt;/a&gt;—Torch下的非监督学习包。提供的模块与nn(LinearPsd, ConvPsd, AutoEncoder, …)及独立算法 (k-means, PCA)等兼容。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/manifold&quot;&gt;manifold&lt;/a&gt;—操作流形的包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/koraykv/torch-svm&quot;&gt;svm&lt;/a&gt;—Torch的支持向量机库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/lbfgs&quot;&gt;lbfgs&lt;/a&gt;—将liblbfgs包装为FFI接口。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/vowpal_wabbit&quot;&gt;vowpalwabbit&lt;/a&gt; —老版的vowpalwabbit对torch的接口。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/lua---opengm&quot;&gt;OpenGM&lt;/a&gt;—OpenGM是C++编写的图形建模及推断库，该binding可以用Lua以简单的方式描述图形，然后用OpenGM优化。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/MichaelMathieu/lua---spaghetti&quot;&gt;sphagetti&lt;/a&gt; —MichaelMathieu为torch7编写的稀疏线性模块。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ocallaco/LuaSHkit&quot;&gt;LuaSHKit&lt;/a&gt; —将局部敏感哈希库SHKit包装成lua可用形式。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/rlowrance/kernel-smoothers&quot;&gt;kernel smoothing&lt;/a&gt; —KNN、核权平均以及局部线性回归平滑器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/cutorch&quot;&gt;cutorch&lt;/a&gt;—torch的CUDA后端实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/cunn&quot;&gt;cunn&lt;/a&gt; —torch的CUDA神经网络实现。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/lua---imgraph&quot;&gt;imgraph&lt;/a&gt;—torch的图像/图形库，提供从图像创建图形、分割、建立树、又转化回图像的例程&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/videograph&quot;&gt;videograph&lt;/a&gt;—torch的视频/图形库，提供从视频创建图形、分割、建立树、又转化回视频的例程&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/marcoscoffier/torch-saliency&quot;&gt;saliency&lt;/a&gt; —积分图像的代码和工具，用来从快速积分直方图中寻找兴趣点。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/marcoscoffier/lua---stitch&quot;&gt;stitch&lt;/a&gt; —使用hugin拼合图像并将其生成视频序列。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/marcoscoffier/lua---sfm&quot;&gt;sfm&lt;/a&gt;—运动场景束调整/结构包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/koraykv/fex&quot;&gt;fex&lt;/a&gt; —torch的特征提取包，提供SIFT和dSIFT模块。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/sermanet/OverFeat&quot;&gt;OverFeat&lt;/a&gt;—当前最高水准的通用密度特征提取器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://numlua.luaforge.net/&quot;&gt;Numeric Lua&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://labix.org/lunatic-python&quot;&gt;Lunatic Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.scilua.org/&quot;&gt;SciLua&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bitbucket.org/lucashnegri/lna&quot;&gt;Lua – Numerical Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zrake.webfactional.com/projects/lunum&quot;&gt;Lunum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#demos-and-scripts&quot; name=&quot;user-content-demos-and-scripts&quot;&gt;&lt;/a&gt;演示及脚本&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/e-lab/torch7-demos&quot;&gt;Core torch7 demos repository&lt;/a&gt;.核心torch7演示程序库
&lt;ul&gt;
&lt;li&gt;线性回归、逻辑回归&lt;/li&gt;
&lt;li&gt;人脸检测（训练和检测是独立的演示）&lt;/li&gt;
&lt;li&gt;基于mst的断词器&lt;/li&gt;
&lt;li&gt;train-a-digit-classifier&lt;/li&gt;
&lt;li&gt;train-autoencoder&lt;/li&gt;
&lt;li&gt;optical flow demo&lt;/li&gt;
&lt;li&gt;train-on-housenumbers&lt;/li&gt;
&lt;li&gt;train-on-cifar&lt;/li&gt;
&lt;li&gt;tracking with deep nets&lt;/li&gt;
&lt;li&gt;kinect demo&lt;/li&gt;
&lt;li&gt;滤波可视化&lt;/li&gt;
&lt;li&gt;saliency-networks&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/soumith/galaxyzoo&quot;&gt;Training a Convnet for the Galaxy-Zoo Kaggle challenge(CUDA demo)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mbhenaff/MusicTagging&quot;&gt;Music Tagging&lt;/a&gt;—torch7下的音乐标签脚本&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/rosejn/torch-datasets&quot;&gt;torch-datasets&lt;/a&gt; 读取几个流行的数据集的脚本，包括：
&lt;ul&gt;
&lt;li&gt;BSR 500&lt;/li&gt;
&lt;li&gt;CIFAR-10&lt;/li&gt;
&lt;li&gt;COIL&lt;/li&gt;
&lt;li&gt;Street View House Numbers&lt;/li&gt;
&lt;li&gt;MNIST&lt;/li&gt;
&lt;li&gt;NORB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fidlej/aledataset&quot;&gt;Atari2600&lt;/a&gt; —在Arcade Learning Environment模拟器中用静态帧生成数据集的脚本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Matlab&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#computer-vision&quot; name=&quot;user-content-computer-vision&quot;&gt;&lt;/a&gt;计算机视觉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.ifp.illinois.edu/~minhdo/software/contourlet_toolbox.tar&quot;&gt;Contourlets&lt;/a&gt; —实现轮廓波变换及其使用函数的MATLAB源代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.shearlab.org/index_software.html&quot;&gt;Shearlets&lt;/a&gt;—剪切波变换的MATLAB源码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.curvelet.org/software.html&quot;&gt;Curvelets&lt;/a&gt;—Curvelet变换的MATLAB源码（Curvelet变换是对小波变换向更高维的推广，用来在不同尺度角度表示图像。）&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.cmap.polytechnique.fr/~peyre/download/&quot;&gt;Bandlets&lt;/a&gt;—Bandlets变换的MATLAB源码&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-4&quot; name=&quot;user-content-natural-language-processing-4&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://amplab.cs.berkeley.edu/2012/05/05/an-nlp-library-for-matlab/&quot;&gt;NLP&lt;/a&gt; —一个Matlab的NLP库&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-6&quot; name=&quot;user-content-general-purpose-machine-learning-6&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.cs.toronto.edu/~hinton/MatlabForSciencePaper.html&quot;&gt;Training a deep autoencoder or a classifier on MNIST digits&lt;/a&gt;—在MNIST字符数据集上训练一个深度的autoencoder或分类器[深度学习]。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://homepage.tudelft.nl/19j49/t-SNE.html&quot;&gt;t-Distributed Stochastic Neighbor Embedding&lt;/a&gt; —获奖的降维技术，特别适合于高维数据集的可视化&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://people.kyb.tuebingen.mpg.de/spider/&quot;&gt;Spider&lt;/a&gt;—Matlab机器学习的完整面向对象环境。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.csie.ntu.edu.tw/~cjlin/libsvm/#matlab&quot;&gt;LibSVM&lt;/a&gt; —支持向量机程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.csie.ntu.edu.tw/~cjlin/liblinear/#download&quot;&gt;LibLinear&lt;/a&gt; —大型线性分类程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/josephmisiti/machine-learning-module&quot;&gt;Machine Learning Module&lt;/a&gt; —M. A .Girolami教授的机器学习课程，包括PDF，讲义及代码。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://caffe.berkeleyvision.org/&quot;&gt;Caffe&lt;/a&gt;—考虑了代码清洁、可读性及速度的深度学习框架&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/newfolder/PRT&quot;&gt;Pattern Recognition Toolbox&lt;/a&gt; —Matlab中的模式识别工具包，完全面向对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 16px; font-style: normal; font-weight: bold;&quot;&gt;数据分析/数据可视化&lt;/span&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-4&quot; name=&quot;user-content-data-analysis--data-visualization-4&quot;&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://www.cs.purdue.edu/homes/dgleich/packages/matlab_bgl/&quot;&gt;matlab_gbl&lt;/a&gt;—处理图像的Matlab包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.mathworks.com/matlabcentral/fileexchange/24134-gaimc---graph-algorithms-in-matlab-code&quot;&gt;gamic&lt;/a&gt;—图像算法纯Matlab高效实现，对MatlabBGL的mex函数是个补充。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#python&quot; name=&quot;user-content-python&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;.NET&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#computer-vision-3&quot; name=&quot;user-content-computer-vision-3&quot;&gt;&lt;/a&gt;计算机视觉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://code.google.com/p/opencvdotnet/&quot;&gt;OpenCVDotNet&lt;/a&gt; —包装器，使.NET程序能使用OpenCV代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.emgu.com/wiki/index.php/Main_Page&quot;&gt;Emgu CV&lt;/a&gt;—跨平台的包装器，能在Windows, Linus, Mac OS X, iOS, 和Android上编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#natural-language-processing-6&quot; name=&quot;user-content-natural-language-processing-6&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/sergey-tihon/Stanford.NLP.NET/&quot;&gt;Stanford.NLP for .NET&lt;/a&gt; —斯坦福大学NLP包在.NET上的完全移植，还可作为NuGet包进行预编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#general-purpose-machine-learning-9&quot; name=&quot;user-content-general-purpose-machine-learning-9&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nuget.org/packages/Accord.MachineLearning/&quot;&gt;Accord.MachineLearning&lt;/a&gt; —支持向量机、决策树、朴素贝叶斯模型、K-means、高斯混合模型和机器学习应用的通用算法，例如：随机抽样一致性算法、交叉验证、网格搜索。这个包是Accord.NET框架的一部分。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fsprojects/Vulpes&quot;&gt;Vulpes&lt;/a&gt;—F#语言实现的Deep belief和深度学习包，它在Alea.cuBase下利用CUDA GPU来执行。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nuget.org/packages/encog-dotnet-core/&quot;&gt;Encog&lt;/a&gt; —先进的神经网络和机器学习框架，包括用来创建多种网络的类，也支持神经网络需要的数据规则化及处理的类。它的训练采用多线程弹性传播。它也能使用GPU加快处理时间。提供了图形化界面来帮助建模和训练神经网络。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://bragisoft.com/&quot;&gt;Neural Network Designer&lt;/a&gt; —这是一个数据库管理系统和神经网络设计器。设计器用WPF开发，也是一个UI，你可以设计你的神经网络、查询网络、创建并配置聊天机器人，它能问问题，并从你的反馈中学习。这些机器人甚至可以从网络搜集信息用来输出，或是用来学习。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#data-analysis--data-visualization-6&quot; name=&quot;user-content-data-analysis--data-visualization-6&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nuget.org/packages/numl/&quot;&gt;numl&lt;/a&gt; —numl这个机器学习库，目标就是简化预测和聚类的标准建模技术。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nuget.org/packages/MathNet.Numerics/&quot;&gt;Math.NET Numerics&lt;/a&gt;—Math.NET项目的数值计算基础，着眼提供科学、工程以及日常数值计算的方法和算法。支持 Windows, Linux 和 Mac上的 .Net 4.0, .Net 3.5 和 Mono ，Silverlight 5, WindowsPhone/SL 8, WindowsPhone 8.1 以及装有 PCL Portable Profiles 47 及 344的Windows 8， 装有 Xamarin的Android/iOS 。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://research.microsoft.com/en-us/projects/sho/&quot;&gt;Sho&lt;/a&gt; —Sho是数据分析和科学计算的交互式环境，可以让你将脚本（IronPython语言）和编译的代码（.NET）无缝连接，以快速灵活的建立原型。这个环境包括强大高效的库，如线性代数、数据可视化，可供任何.NET语言使用，还为快速开发提供了功能丰富的交互式shell。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Python&lt;/h2&gt;
&lt;h4&gt;计算机视觉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://simplecv.org/&quot;&gt;SimpleCV&lt;/a&gt;—开源的计算机视觉框架，可以访问如OpenCV等高性能计算机视觉库。使用Python编写，可以在Mac、Windows以及Ubuntu上运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-5&quot; name=&quot;user-content-natural-language-processing-5&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nltk.org/&quot;&gt;NLTK&lt;/a&gt; —一个领先的平台，用来编写处理人类语言数据的Python程序&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.clips.ua.ac.be/pattern&quot;&gt;Pattern&lt;/a&gt;—Python可用的web挖掘模块，包括自然语言处理、机器学习等工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://textblob.readthedocs.org/&quot;&gt;TextBlob&lt;/a&gt;—为普通自然语言处理任务提供一致的API，以NLTK和Pattern为基础，并和两者都能很好兼容。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fxsjy/jieba#jieba-1&quot;&gt;jieba&lt;/a&gt;—中文断词工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/isnowfy/snownlp&quot;&gt;SnowNLP&lt;/a&gt; —中文文本处理库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/victorlin/loso&quot;&gt;loso&lt;/a&gt;—另一个中文断词库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/duanhongyi/genius&quot;&gt;genius&lt;/a&gt; —基于条件随机域的中文断词库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/pprett/nut&quot;&gt;nut&lt;/a&gt; —自然语言理解工具包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-7&quot; name=&quot;user-content-general-purpose-machine-learning-7&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers&quot;&gt;Bayesian Methods for Hackers&lt;/a&gt; —Python语言概率规划的电子书&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://spark.apache.org/docs/latest/mllib-guide.html&quot;&gt;MLlib in Apache Spark&lt;/a&gt;—Spark下的分布式机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://scikit-learn.org/&quot;&gt;scikit-learn&lt;/a&gt;—基于SciPy的机器学习模块&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://graphlab.com/products/create/docs/&quot;&gt;graphlab-create&lt;/a&gt; —包含多种机器学习模块的库（回归，聚类，推荐系统，图分析等），基于可以磁盘存储的DataFrame。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://bigml.com/&quot;&gt;BigML&lt;/a&gt;—连接外部服务器的库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clips/pattern&quot;&gt;pattern&lt;/a&gt;—Python的web挖掘模块&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/numenta/nupic&quot;&gt;NuPIC&lt;/a&gt;—Numenta公司的智能计算平台。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/lisa-lab/pylearn2&quot;&gt;Pylearn2&lt;/a&gt;—基于Theano的机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/hannes-brt/hebel&quot;&gt;hebel&lt;/a&gt; —Python编写的使用GPU加速的深度学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/piskvorky/gensim&quot;&gt;gensim&lt;/a&gt;—主题建模工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/pybrain/pybrain&quot;&gt;PyBrain&lt;/a&gt;—另一个机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/muricoca/crab&quot;&gt;Crab&lt;/a&gt; —可扩展的、快速推荐引擎。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ocelma/python-recsys&quot;&gt;python-recsys&lt;/a&gt; —Python实现的推荐系统。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/AllenDowney/ThinkBayes&quot;&gt;thinking bayes&lt;/a&gt;—关于贝叶斯分析的书籍&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/echen/restricted-boltzmann-machines&quot;&gt;Restricted Boltzmann Machines&lt;/a&gt; —Python实现的受限波尔兹曼机。[深度学习]。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/pprett/bolt&quot;&gt;Bolt&lt;/a&gt; —在线学习工具箱。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/patvarilly/CoverTree&quot;&gt;CoverTree&lt;/a&gt; —cover tree的Python实现，scipy.spatial.kdtree便捷的替代。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nilearn/nilearn&quot;&gt;nilearn&lt;/a&gt;—Python实现的神经影像学机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/shogun-toolbox/shogun&quot;&gt;Shogun&lt;/a&gt;—机器学习工具箱。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/perone/Pyevolve&quot;&gt;Pyevolve&lt;/a&gt; —遗传算法框架。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://caffe.berkeleyvision.org/&quot;&gt;Caffe&lt;/a&gt; —考虑了代码清洁、可读性及速度的深度学习框架&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/breze-no-salt/breze&quot;&gt;breze&lt;/a&gt;—深度及递归神经网络的程序库，基于Theano。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-5&quot; name=&quot;user-content-data-analysis--data-visualization-5&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt; —基于Python的数学、科学、工程开源软件生态系统。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt;—Python科学计算基础包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://numba.pydata.org/&quot;&gt;Numba&lt;/a&gt; —Python的低级虚拟机JIT编译器，Cython and NumPy的开发者编写，供科学计算使用&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://networkx.github.io/&quot;&gt;NetworkX&lt;/a&gt; —为复杂网络使用的高效软件。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://pandas.pydata.org/&quot;&gt;Pandas&lt;/a&gt;—这个库提供了高性能、易用的数据结构及数据分析工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/avelino/mining&quot;&gt;Open Mining&lt;/a&gt;—Python中的商业智能工具（Pandas web接口）。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/pymc-devs/pymc&quot;&gt;PyMC&lt;/a&gt; —MCMC采样工具包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/quantopian/zipline&quot;&gt;zipline&lt;/a&gt;—Python的算法交易库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://pydy.org/&quot;&gt;PyDy&lt;/a&gt;—全名Python Dynamics，协助基于NumPy, SciPy, IPython以及 matplotlib的动态建模工作流。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/sympy/sympy&quot;&gt;SymPy&lt;/a&gt; —符号数学Python库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/statsmodels/statsmodels&quot;&gt;statsmodels&lt;/a&gt;—Python的统计建模及计量经济学库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.astropy.org/&quot;&gt;astropy&lt;/a&gt; —Python天文学程序库，社区协作编写&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; —Python的2D绘图库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ContinuumIO/bokeh&quot;&gt;bokeh&lt;/a&gt;—Python的交互式Web绘图库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://plot.ly/python&quot;&gt;plotly&lt;/a&gt; —Python and matplotlib的协作web绘图库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/wrobstory/vincent&quot;&gt;vincent&lt;/a&gt;—将Python数据结构转换为Vega可视化语法。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mikedewar/d3py&quot;&gt;d3py&lt;/a&gt;—Python的绘图库，基于D3.js。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/yhat/ggplot&quot;&gt;ggplot&lt;/a&gt; —和R语言里的ggplot2提供同样的API。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/kartograph/kartograph.py&quot;&gt;Kartograph.py&lt;/a&gt;—Python中渲染SVG图的库，效果漂亮。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://pygal.org/&quot;&gt;pygal&lt;/a&gt;—Python下的SVG图表生成器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/twitter/pycascading&quot;&gt;pycascading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;杂项脚本/iPython笔记/代码库&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#misc-scripts--ipython-notebooks--codebases&quot; name=&quot;user-content-misc-scripts--ipython-notebooks--codebases&quot;&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rasbt/pattern_classification&quot;&gt;pattern_classification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Wavelets/ThinkStats2&quot;&gt;thinking stats 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hyperopt/hyperopt-sklearn&quot;&gt;hyperopt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/numenta/nupic&quot;&gt;numpic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ged-lab/2012-paper-diginorm&quot;&gt;2012-paper-diginorm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ogrisel/notebooks&quot;&gt;ipython-notebooks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CamDavidsonPilon/decision-weights&quot;&gt;decision-weights&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/Wavelets/sarah-palin-lda&quot;&gt;Sarah Palin LDA&lt;/a&gt; —Sarah Palin关于主题建模的电邮。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/Wavelets/diffusion-segmentation&quot;&gt;Diffusion Segmentation&lt;/a&gt; —基于扩散方法的图像分割算法集合。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/Wavelets/scipy-tutorials&quot;&gt;Scipy Tutorials&lt;/a&gt; —SciPy教程，已过时，请查看scipy-lecture-notes&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/marcelcaraciolo/crab&quot;&gt;Crab&lt;/a&gt;—Python的推荐引擎库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/maxsklar/BayesPy&quot;&gt;BayesPy&lt;/a&gt;—Python中的贝叶斯推断工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/GaelVaroquaux/scikit-learn-tutorial&quot;&gt;scikit-learn tutorials&lt;/a&gt;—scikit-learn学习笔记系列&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/madhusudancs/sentiment-analyzer&quot;&gt;sentiment-analyzer&lt;/a&gt; —推特情绪分析器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fabianp/group_lasso&quot;&gt;group-lasso&lt;/a&gt;—坐标下降算法实验，应用于（稀疏）群套索模型。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mne-tools/mne-python-notebooks&quot;&gt;mne-python-notebooks&lt;/a&gt;—使用 mne-python进行EEG/MEG数据处理的IPython笔记&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/jvns/pandas-cookbook&quot;&gt;pandas cookbook&lt;/a&gt;—使用Python pandas库的方法书。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/BRML/climin&quot;&gt;climin&lt;/a&gt;—机器学习的优化程序库，用Python实现了梯度下降、LBFGS、rmsprop、adadelta 等算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#kaggle-competition-source-code&quot; name=&quot;user-content-kaggle-competition-source-code&quot;&gt;&lt;/a&gt;Kaggle竞赛源代码&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/hammer/wikichallenge&quot;&gt;wiki challange&lt;/a&gt; —Kaggle上一个维基预测挑战赛 Dell Zhang解法的实现。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/amueller/kaggle_insults&quot;&gt;kaggle insults&lt;/a&gt;—Kaggle上”从社交媒体评论中检测辱骂“竞赛提交的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/MLWave/kaggle_acquire-valued-shoppers-challenge&quot;&gt;kaggle_acquire-valued-shoppers-challenge&lt;/a&gt;—Kaggle预测回头客挑战赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-cifar&quot;&gt;kaggle-cifar&lt;/a&gt; —Kaggle上CIFAR-10 竞赛的代码，使用cuda-convnet&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-blackbox&quot;&gt;kaggle-blackbox&lt;/a&gt; —Kaggle上blackbox赛代码，关于深度学习。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-accelerometer&quot;&gt;kaggle-accelerometer&lt;/a&gt; —Kaggle上加速度计数据识别用户竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-advertised-salaries&quot;&gt;kaggle-advertised-salaries&lt;/a&gt; —Kaggle上用广告预测工资竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-amazon&quot;&gt;kaggle amazon&lt;/a&gt; —Kaggle上给定员工角色预测其访问需求竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-bestbuy_big&quot;&gt;kaggle-bestbuy_big&lt;/a&gt;—Kaggle上根据bestbuy用户查询预测点击商品竞赛的代码（大数据版）&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-bestbuy_small&quot;&gt;kaggle-bestbuy_small&lt;/a&gt;—Kaggle上根据bestbuy用户查询预测点击商品竞赛的代码（小数据版）&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/kastnerkyle/kaggle-dogs-vs-cats&quot;&gt;Kaggle Dogs vs. Cats&lt;/a&gt; —Kaggle上从图片中识别猫和狗竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/benanne/kaggle-galaxies&quot;&gt;Kaggle Galaxy Challenge&lt;/a&gt; —Kaggle上遥远星系形态分类竞赛的优胜代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-gender&quot;&gt;Kaggle Gender&lt;/a&gt; —Kaggle竞赛：从笔迹区分性别&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-merck&quot;&gt;Kaggle Merck&lt;/a&gt;—Kaggle上预测药物分子活性竞赛的代码（默克制药赞助）&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-stackoverflow&quot;&gt;Kaggle Stackoverflow&lt;/a&gt;—Kaggle上 预测Stack Overflow网站问题是否会被关闭竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/wine-quality&quot;&gt;wine-quality&lt;/a&gt; —预测红酒质量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#ruby&quot; name=&quot;user-content-ruby&quot;&gt;&lt;/a&gt;Ruby&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-6&quot; name=&quot;user-content-natural-language-processing-6&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/louismullie/treat&quot;&gt;Treat&lt;/a&gt;—文本检索与注释工具包，Ruby上我见过的最全面的工具包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.deveiate.org/projects/Linguistics/&quot;&gt;Ruby Linguistics&lt;/a&gt;—这个框架可以用任何语言为Ruby对象构建语言学工具。包括一个语言无关的通用前端，一个将语言代码映射到语言名的模块，和一个含有很有英文语言工具的模块。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/aurelian/ruby-stemmer&quot;&gt;Stemmer&lt;/a&gt;—使得Ruby可用 libstemmer_c中的接口。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.deveiate.org/projects/Ruby-WordNet/&quot;&gt;Ruby Wordnet&lt;/a&gt; —WordNet的Ruby接口库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://sourceforge.net/projects/raspell/&quot;&gt;Raspel&lt;/a&gt; —aspell绑定到Ruby的接口&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ealdent/uea-stemmer&quot;&gt;UEA Stemmer&lt;/a&gt;—UEALite Stemmer的Ruby移植版，供搜索和检索用的保守的词干分析器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/twitter-text-rb&quot;&gt;Twitter-text-rb&lt;/a&gt;—该程序库可以将推特中的用户名、列表和话题标签自动连接并提取出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-8&quot; name=&quot;user-content-general-purpose-machine-learning-8&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tsycho/ruby-machine-learning&quot;&gt;Ruby Machine Learning&lt;/a&gt; —Ruby实现的一些机器学习算法。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mizoR/machine-learning-ruby&quot;&gt;Machine Learning Ruby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/vasinov/jruby_mahout&quot;&gt;jRuby Mahout&lt;/a&gt; —精华！在JRuby世界中释放了Apache Mahout的威力。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/cardmagic/classifier&quot;&gt;CardMagic-Classifier&lt;/a&gt;—可用贝叶斯及其他分类法的通用分类器模块。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mnielsen/neural-networks-and-deep-learning&quot;&gt;Neural Networks and Deep Learning&lt;/a&gt;—《神经网络和深度学习》一书的示例代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数据分析/数据可视化&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-6&quot; name=&quot;user-content-data-analysis--data-visualization-6&quot;&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/alexgutteridge/rsruby&quot;&gt;rsruby&lt;/a&gt; - Ruby – R bridge&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/chrislo/data_visualisation_ruby&quot;&gt;data-visualization-ruby&lt;/a&gt;—关于数据可视化的Ruby Manor演示的源代码和支持内容&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://www.ruby-toolbox.com/projects/ruby-plot&quot;&gt;ruby-plot&lt;/a&gt; —将gnuplot包装为Ruby形式，特别适合将ROC曲线转化为svg文件。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zuhao/plotrb&quot;&gt;plot-rb&lt;/a&gt;—基于Vega和D3的ruby绘图库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.rubyinside.com/scruffy-a-beautiful-graphing-toolkit-for-ruby-194.html&quot;&gt;scruffy&lt;/a&gt; —Ruby下出色的图形工具包&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sciruby.com/&quot;&gt;SciRuby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/glean/glean&quot;&gt;Glean&lt;/a&gt;—数据管理工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/bioruby/bioruby&quot;&gt;Bioruby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/nkallen/arel&quot;&gt;Arel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#misc&quot; name=&quot;user-content-misc&quot;&gt;&lt;/a&gt;Misc&lt;br&gt;
杂项&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/infochimps-labs/big_data_for_chimps&quot;&gt;Big Data For Chimps&lt;/a&gt;—大数据处理严肃而有趣的指南书&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#r&quot; name=&quot;user-content-r&quot;&gt;&lt;/a&gt;R&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-9&quot; name=&quot;user-content-general-purpose-machine-learning-9&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jbrownlee/CleverAlgorithmsMachineLearning&quot;&gt;Clever Algorithms For Machine Learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/johnmyleswhite/ML_for_Hackers&quot;&gt;Machine Learning For Hackers&lt;br&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://cran.r-project.org/web/views/MachineLearning.html&quot;&gt;Machine Learning Task View on CRAN&lt;/a&gt;—R语言机器学习包列表，按算法类型分组。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://caret.r-forge.r-project.org/&quot;&gt;caret&lt;/a&gt;—R语言150个机器学习算法的统一接口&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ecpolley/SuperLearner&quot;&gt;SuperLearner&lt;/a&gt; and &lt;a href=&quot;http://cran.r-project.org/web/packages/subsemble/index.html&quot;&gt;subsemble&lt;/a&gt;—该包集合了多种机器学习算法&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www-bcf.usc.edu/~gareth/ISL/&quot;&gt;Introduction to Statistical Learning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-7&quot; name=&quot;user-content-data-analysis--data-visualization-7&quot;&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;h4&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://health.adelaide.edu.au/psychology/ccs/teaching/lsr/&quot;&gt;Learning Statistics Using R&lt;br&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://ggplot2.org/&quot;&gt;ggplot2&lt;/a&gt;—基于图形语法的数据可视化包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#scala&quot; name=&quot;user-content-scala&quot;&gt;&lt;/a&gt;Scala&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-7&quot; name=&quot;user-content-natural-language-processing-7&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.scalanlp.org/&quot;&gt;ScalaNLP&lt;/a&gt;—机器学习和数值计算库的套装&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/scalanlp/breeze&quot;&gt;Breeze&lt;/a&gt; —Scala用的数值处理库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/scalanlp/chalk&quot;&gt;Chalk&lt;/a&gt;—自然语言处理库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/factorie/factorie&quot;&gt;FACTORIE&lt;/a&gt;—可部署的概率建模工具包，用Scala实现的软件库。为用户提供简洁的语言来创建关系因素图，评估参数并进行推断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-8&quot; name=&quot;user-content-data-analysis--data-visualization-8&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://spark.apache.org/docs/latest/mllib-guide.html&quot;&gt;MLlib in Apache Spark&lt;/a&gt;—Spark下的分布式机器学习库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/scalding&quot;&gt;Scalding&lt;/a&gt; —CAscading的Scala接口&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/summingbird&quot;&gt;Summing Bird&lt;/a&gt;—用Scalding 和 Storm进行Streaming MapReduce&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/algebird&quot;&gt;Algebird&lt;/a&gt; —Scala的抽象代数工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/xerial/xerial&quot;&gt;xerial&lt;/a&gt; —Scala的数据管理工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/avibryant/simmer&quot;&gt;simmer&lt;/a&gt; —化简你的数据，进行代数聚合的unix过滤器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/PredictionIO/PredictionIO&quot;&gt;PredictionIO&lt;/a&gt; —供软件开发者和数据工程师用的机器学习服务器。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/BIDData/BIDMat&quot;&gt;BIDMat&lt;/a&gt;—支持大规模探索性数据分析的CPU和GPU加速矩阵库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-10&quot; name=&quot;user-content-general-purpose-machine-learning-10&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/etsy/Conjecture&quot;&gt;Conjecture&lt;/a&gt;—Scalding下可扩展的机器学习框架&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/avibryant/brushfire&quot;&gt;brushfire&lt;/a&gt;—scalding下的决策树工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tresata/ganitha&quot;&gt;ganitha&lt;/a&gt; —基于scalding的机器学习程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/bigdatagenomics/adam&quot;&gt;adam&lt;/a&gt;—使用Apache Avro, Apache Spark 和 Parquet的基因组处理引擎，有专用的文件格式，Apache 2软件许可。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/bioscala/bioscala&quot;&gt;bioscala&lt;/a&gt; —Scala语言可用的生物信息学程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/BIDData/BIDMach&quot;&gt;BIDMach&lt;/a&gt;—机器学习CPU和GPU加速库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#credits&quot; name=&quot;user-content-credits&quot;&gt;&lt;/a&gt;&lt;/h2&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Mon, 21 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-21-73806-f8e20413f.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-21-73806-f8e20413f.html</guid>
        
        
      </item>
    
      <item>
        <title>技术的进化</title>
        <description>&lt;p&gt;前几日，吴军博士在微博上转发了王石为其新书《文明之光》写的序言。在序言里，王石提到了达尔文进化论在社会与技术的适应性问题。王石在他短短几句话里并未充分说明了他的观点，只是举了英文键盘的例子说明了&lt;strong&gt;存活下来的不一定更“好”，仅仅是更“适”而已&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我在微博上留下了一条评论：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;生物突变过程，并不一定是适合文明尤其是技术的进化的，好比如从帆船不可能突变到轮船，喷气机也不是内燃机或其它任何先前技术的变种，技术的进化更多是组合进化不太具有偶然性，而不是生物的单物种偶然性突变。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;用达尔文的理论去解释不同领域的演进,是许多人的偏好，尤其是国人。但是，无论觉得达尔文理论能如何为你切身地解答从哪而来的问题，将它放置于任何领域成为“大一统”的进化观点，我想是不合适的，至少将其置于技术的领域，是不完整的。尽管吴军博士回复说，《文明之光》一书并没有太谈进化论，我还是想把我的观点讲清楚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一.不完整的进化论理解&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;达尔文的生物进化理论需要从两个方面来理解：&lt;strong&gt;变异与选择&lt;/strong&gt;。由于某些历史与政治的原因，进化论被引进进入中国时，就被严复梁启超他们“阉割”了，只片面的强调了“选择”一含义，这也就是大多数人固有的“物竞天择，适者生存”的观点，而对其“变异”层面的含义却知之甚少。由于“进化就是选择”这一狭隘观点的影响，导致达尔文的理论被”泛滥“地解释所有的领域的发展，因为单从“选择”层面来看，其确实是适合其它领域的。当然，用来解释社会发展领域的发展，也是当初严复和梁启超他们原本目的。&lt;/p&gt;

&lt;p&gt;如果说“进化就是选择”，那前面王石先生举的英文键盘一例来说进化，也是合理的（其实这也就是常说的”路径依赖“）。但是这样的观点如果奉成为“理论”，肯定是不完整的。选择论回答不了被选择的“物件”从何而来的疑问。而完整的达尔文理论认为&lt;strong&gt;变异为选择提供了资源&lt;/strong&gt;。如果说”选择“解答了发展的问题，那”变异“则解答了起源的问题。在生物的进化上，这里的变异指的就是基因突变，并且是单个物种内的自身基因变化。&lt;/p&gt;

&lt;p&gt;正是这种关乎基因突变的观点，将达尔文理论套到技术领域，是根本站不住脚的。比如雷达诞生于半导体，你可以对20世纪30年代的半导体线圈进行任何你喜欢的改变，但是你永远不可能得到雷达，制造雷达需要一个和半导体完全不同的理念。我前文微博里提到的帆船到轮船，喷气机到内燃机的也同样如此，无论你对帆船如何改造，没有革命性发动机出现，你不可能得到轮船，而发动机的出现，跟”船“这个”物种“不存在任何关系。而从喷气机到内燃机，也不是一脉的向前突变得到的，而是依赖完全不同的物理理论的出现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二.技术进化的特点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;那么技术领域的究竟如何向前进化的呢？技术作家布莱恩.阿瑟在其《技术的本质》一书里给出了一个初步的答案。布莱恩.阿瑟认为技术的进化具有以下两大特点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组合进化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;技术总是由一些基本的功能模块组合而成的&lt;/strong&gt;。技术的组合进化，是技术演变的最本质特征，也是其不同与生物进化的根本区别。&lt;/p&gt;

&lt;p&gt;在人类发展最初的石器时代，石制工具就被打磨成两类，锋利的和有孔的，这两类又与木制的手柄组合成复合工具，锋利的成了矛，有孔的成了锤头。回到现代，你打开一台老式的台式电脑，你会发现里面的零部件，如CPU，硬盘，内存条等。同时拆开一台现代的智能手机，也会发生同样的部件。同样，蒸汽机的出现，其与原来的帆船技术的组合，从而使得轮船得以出现服务于人类。&lt;strong&gt;技术在某种程度上一定是来自此前已有技术的新的组合&lt;/strong&gt;，这是新技术出现的根本特征，也解答了进化论中关于”变异“那一部分问题。而这个组合进化产生变异的特征在生物体上是看不到的，生物的变异是指单个生物体的基因突变，而不同物种相互组合杂交而进化，几乎没出现过。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;具有层级递归性模块化演进&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;技术是组合进化的，但是其不是单纯的一层组合，也就是说不是将具有匹配的概念或原理的目的单层次的聚集起来，即可得到新的技术。其组合具有层次结构。可以将技术分解成主集成，次级集成，次次级集成等，直至分解为最基本的部分。如果说整体的技术是树干的话，那次级集成是枝条，最基本的零件就是更小的分支了。以一本纸质书为例，其主集成是纸张和印刷的组合，而纸张和印刷两者可以继续拆分，如印刷可以拆分为油墨技术，电子技术等等。&lt;strong&gt;技术呈现出这种递归性的结构，技术总是包含着技术，直到最基础的水平&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果只是将技术的单元进行层次化的组合，那将是一个无比复杂的工程。比如一个手表有1000个零件，一个钟表匠一个零件一个零件地安装，安装过程中，如果他的工作被打断了，他就必须从头开始。但是，如果将10个模块组装起来，每个模块又由10个子模块组装起来，每个子模块由10个零件组合起来，当他暂停或被打断工作时，他只是损失了一小部分工作。这种零件集成可以更好地预防不可预知的变动，且更易修复。同时，除了解决复杂性的带来的低效问题，模块化更为重要的一点是允许技术的组成部分分别演进，从而又再推动整体技术的前进。好比如发动机的这一模块的进步，可以推动汽车，轮船这些整体技术的进步一样。&lt;/p&gt;

&lt;p&gt;当然，将技术分割为功能模块是需要付出一些代价的，比如需要耗费时间和精力定义模块之间的标准等。所以，&lt;strong&gt;只有模块能被反复使用，且反复使用的次数足够时，才值得付出代价将技术进行分割&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三.技术进化的启示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面关于技术进化的特点的讨论，不只是让我们认识了技术进化的与生物进化的区别，更是能更好的指导我们构建更有生命力能向前进化的技术产品。回到我们熟悉的软件系统领域，我们见过太多技术产品被很快淘汰，也见过很多技术产品永远处于不断推倒后重构的死胡同里。从进化的角度看，这样的技术产品根本不存在进化的可能。这其中根本原因，我想更多是其没有满足我们前文说到的可进化技术的一些基本特点。一个没有组合特点的系统，其必然扩展性差，必然面临无法向前进一步进化的可能。而没有定义层次和规则，那也就没有模块化的概念，系统无法进行单个模块的垂直演进，没有模块级别的重用， 当碰到任何不可预知的变动，必然是全部推倒重新再来。这样的系统产品，当然也就不存在生命力可言。&lt;/p&gt;

&lt;p&gt;对此审视我们用过的系统产品，那些经久不衰的，如Unix/Linux，必然是遵循这技术进化的根本特征的。而对于当今互联网产品而言，生命力确实是一个奢侈的词，这应该不仅仅是生态环境的选择问题,而需要系统产品生产者更多的反思！&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;如果您觉得这篇文字有意思，欢迎转发！欢迎更多的朋友们关注我的微信公众号：&lt;strong&gt;JustinNotes&lt;/strong&gt;&lt;/p&gt;

&lt;hr&gt;
</description>
        <pubDate>Sun, 20 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-20-ji-zhu-de-jin-hua-9c5e0c611.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-20-ji-zhu-de-jin-hua-9c5e0c611.html</guid>
        
        
      </item>
    
      <item>
        <title>Chef入门（一）</title>
        <description>

	
	

	&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/a21eddb15b6ddbe9e395938fd299dee1.jpg&quot; title=&quot;Chef&quot; alt=&quot;Chef&quot;&gt;&lt;/p&gt;

&lt;h1&gt;Chef是什么&lt;/h1&gt;

&lt;p&gt;官方的介绍是这样的：&lt;code&gt;Automation for Web-Scale IT.Chef delivers fast, scalable, flexible IT automation.&lt;/code&gt;简单来说Chef就是IT自动化工具，它把服务器的环境（软件、依赖库、网络等）进行抽象，以特有的配置语法（Ruby语言）对其进行管理，可以自动的进行服务器环境的初始化工作。Chef也是实践&lt;a href=&quot;http://www.infoq.com/cn/articles/devops-not-legend/&quot;&gt;DevOps&lt;/a&gt;和&lt;a href=&quot;http://martinfowler.com/articles/continuousIntegration.html&quot;&gt;Continuous Integration&lt;/a&gt;的重要工具，同类的工具还有&lt;a href=&quot;http://puppetlabs.com/&quot;&gt;puppet&lt;/a&gt;。&lt;/p&gt;

&lt;h1&gt;为什么需要Chef&lt;/h1&gt;

&lt;p&gt;Web开发者肯定对以下的情景熟悉：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新开发的功能在开发环境运行得很好，可是一部署到生产环境就出错了，登录到服务器上一看，我靠，少个lib没装 = =&lt;/li&gt;
&lt;li&gt;很多人入职一家新公司首先做的事情就是配环境，这个工作比较浪费时间，经常是缺这个库缺那个库，还有很多未知的坑，即使有完整的文档，手动的安装也是比较反人类的。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;以上的问题总结为一句话就是环境管理的混乱，或者说根本没有环境管理。环境管理可能是个不那么太引起开发者重视的一项事情，许多人对环境的要求只是能够跑起来，不管通过什么自虐的方式配置起来都没有问题，如果生产环境发生了变更，而开发环境没有及时变更，那么只能骂娘。其实环境管理和代码的版本控制是一样的重要，你能想象没有版本控制的开发方式吗？有人会说：我照着文档手动配置环境也很快，也不会出错啊。如果这样那么你可以关闭当前网页了。&lt;/p&gt;

&lt;p&gt;Chef基本上做两件事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境管理&lt;/li&gt;
&lt;li&gt;以自动化的方式进行服务器环境初始化或变更工作&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Chef环境&lt;/h1&gt;

&lt;p&gt;Chef环境由三个部分组成：Chef server，Workstation, Node（此Node非Node.js）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Chef server是Chef环境的中枢，其中存储了基础设施环境的信息。你可以使用&lt;a href=&quot;http://www.getchef.com/chef/install/&quot;&gt;开源Chef server&lt;/a&gt;，也可以使用Chef官方提供的商业服务：&lt;a href=&quot;http://www.getchef.com/contact/on-premises/&quot;&gt;Enterprise Chef&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Workstation是你的工作台，一般情况下就是你的开发机器。你会在Workstation中创建cookbook，并且上传到Chef server，以及其他与Chef相关的工作。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个Node就是你基础设施环境中的一台服务器，也就是你用Chef来管理的机器。一个Node可以是一台物理机器，一个虚拟机，也可以是cloud环境中的一个instance，甚至是你网络环境中的一个交换机或路由器。如果你想要在Node上部署环境，那么Node会与Chef server进行交互获取信息，并在Node上执行环境初始化操作。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;三者之间的关系是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/e12c12b86ad41150d7fb7b05974ec5bf.jpg&quot; title=&quot;chef-overview&quot; alt=&quot;chef-overview&quot;&gt;&lt;/p&gt;

&lt;h1&gt;获取Chef Server&lt;/h1&gt;

&lt;p&gt;为了节省时间和资源，本文使用Enterprise Chef作为自己的Chef Server，先&lt;a href=&quot;https://manage.opscode.com&quot;&gt;注册&lt;/a&gt;账号，然后登录并添加自己的ORGANIZATION，这里就不详细说明了，请自行摸索。&lt;/p&gt;

&lt;h1&gt;安装Workstation&lt;/h1&gt;

&lt;h2&gt;Omnibus installer&lt;/h2&gt;

&lt;p&gt;我们首先安装&lt;a href=&quot;http://docs.opscode.com/install_omnibus.html&quot;&gt;omnibus installer&lt;/a&gt;，Mac或Ubuntu用户执行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L https://www.opscode.com/chef/install.sh | sudo bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上命令会在机器上安装&lt;code&gt;chef-client&lt;/code&gt;，&lt;code&gt;Ruby语言&lt;/code&gt;，&lt;code&gt;Knife&lt;/code&gt;等一系列工具，安装结束后输入以下命令来确认安装没有问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chef-client -v
Chef: 11.12.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chef-client安装完成之后，会在&lt;code&gt;/opt&lt;/code&gt;生成如下的目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/opt
   /chef
      /bin
      /embedded
         /bin
         /include
         /lib
         /share
         /ssl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：如果我们使用的是自行安装的开源Chef server，那么需要安装git，git安装方法这里不再叙述。&lt;/p&gt;

&lt;p&gt;以上完成之后，我们需要获取chef-repo，如果使用的是Enterprise Chef，那么你需要下载&lt;a href=&quot;https://manage.opscode.com/starter-kit&quot;&gt;Starter Kit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/9d43ca46dcedf9b0160ed7b18026fae5.jpg&quot; title=&quot;chef-starter-kit&quot; alt=&quot;chef-starter-kit&quot;&gt;&lt;/p&gt;

&lt;p&gt;之后拷贝到home目录下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp chef-repo ~/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;获取配置文件&lt;/h2&gt;

&lt;p&gt;为了能够与Chef server通讯，我们需要&lt;a href=&quot;https://manage.opscode.com&quot;&gt;登录&lt;/a&gt;到Enterprise Chef上获取三个配置文件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;knife.rb&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/193f51d5d4d4caeeeb5c9aade1765432.jpg&quot; title=&quot;chef-get-knife.rb&quot; alt=&quot;chef-get-knife.rb&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ORGANIZATION-validator.pem（注：ORGANIZATION为你自己组织的名字）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/c01a4cf5bcdbaafb14553183b4c0f9b2.jpg&quot; title=&quot;chef-get-validator.pem&quot; alt=&quot;chef-get-validator.pem&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;USER.pem（注：USER为你的用户名）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/68e34d68915b1691b2bfaeee9de968c7.jpg&quot; title=&quot;chef-get-USER.pem&quot; alt=&quot;chef-get-USER.pem&quot;&gt;&lt;/p&gt;

&lt;p&gt;获取到以上三个文件之后，我们需要把它们拷贝到&lt;code&gt;~/chef-repo/.chef&lt;/code&gt;目录下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp /path/to/knife.rb /path/to/ORGANIZATION-validator.pem /path/to/USERNAME.pem ~/chef-repo/.chef
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;把Ruby添加到$PATH&lt;/h2&gt;

&lt;p&gt;由于Chef中的工具都是基于Ruby语言的，所以chef-client中包含了一个稳定版本的Ruby解释器，你需要把它添加到$PATH中，以便通过命令行可以执行Ruby脚本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;export PATH=&quot;/opt/chef/embedded/bin:$PATH&quot;&#39; &amp;gt;&amp;gt; ~/.bash_profile &amp;amp;&amp;amp; source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;验证chef-client&lt;/h2&gt;

&lt;p&gt;如果通过Knife可以和Chef server通信，那么代表Workstation安装成功，接下来需要验证。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进入&lt;code&gt;chef-repo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; $ cd ~/chef-repo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行以下命令&lt;/p&gt;

&lt;p&gt; $ knife client list&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;如果执行成功会返回一个可以访问Chef server的client列表。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;workstation
registered_node
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;安装Node&lt;/h1&gt;

&lt;p&gt;一个Node可以是任何可以连接上网络的电脑，你必须是它的管理员，并且拥有sudo或者root权限。官方推荐CentOS 6+，Windows Server 2008+，或者Ubuntu 12.04+。你还需要拥有它的SSH账号、密码以及端口。&lt;/p&gt;

&lt;p&gt;虽然你可以自己折腾物理机器，不过如果只是想看看Chef有什么功能的话，Chef官方提供了一些配置好的虚拟机，君请自取：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://opscode-cheflab.herokuapp.com/labs/learnchef/ubuntu/attend&quot;&gt;Ubuntu Training Lab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://opscode-cheflab.herokuapp.com/labs/learnchef/centos/attend&quot;&gt;CentOS Training Lab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://opscode-cheflab.herokuapp.com/labs/learnchef/windows/attend&quot;&gt;Windows Training Lab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如果你想在自己的本地折腾，那么Chef官方也提供了&lt;a href=&quot;http://www.vagrantup.com/&quot;&gt;Vagrant&lt;/a&gt;方案：在你之前下载的&lt;code&gt;Starter Kit&lt;/code&gt;中已经包含了&lt;code&gt;Vagrantfile&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ll ~/chef-repo
-rw-r--r--  1 weizhifeng  staff       2405 Jul 18 06:26 README.md
-rw-r--r--  1 weizhifeng  staff       3747 Jul 18 16:24 Vagrantfile
drwxr-xr-x  4 weizhifeng  staff        136 Jul 18 06:26 cookbooks
drwxr-xr-x  3 weizhifeng  staff        102 Jul 18 06:26 roles
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以直接执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant up
Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider...
==&amp;gt; default: Clearing any previously set forwarded ports...
==&amp;gt; default: Fixed port collision for 22 =&amp;gt; 2222. Now on port 2200.
==&amp;gt; default: Clearing any previously set network interfaces...
==&amp;gt; default: Preparing network interfaces based on configuration...
    default: Adapter 1: nat
==&amp;gt; default: Forwarding ports...
    default: 8080 =&amp;gt; 9090 (adapter 1)
    default: 22 =&amp;gt; 2200 (adapter 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来启动VM。&lt;/p&gt;

&lt;p&gt;接下来我们需要执行&lt;code&gt;knife bootstrap&lt;/code&gt;命令，这个命令会在VM上安装chef-client，并且chef-client会与Chef server进行交互。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ knife bootstrap localhost --sudo -x vagrant -P vagrant --ssh-port 2222 -N node1   
Connecting to localhost
localhost Starting first Chef Client run...
....
....
localhost Starting Chef Client, version 11.12.8
localhost resolving cookbooks for run list: []
localhost Synchronizing Cookbooks:
localhost Compiling Cookbooks...
localhost [2014-07-19T13:50:55+00:00] WARN: Node node1 has an empty run list.
localhost Converging 0 resources
localhost 
localhost Running handlers:
localhost Running handlers complete
localhost 
localhost Chef Client finished, 0/0 resources updated in 76.501062463 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：如果你运行了N个Vagrant VM，那么&lt;code&gt;--ssh-port 2222&lt;/code&gt;可能不正确，你可以在&lt;code&gt;vagrant up&lt;/code&gt;输出的日志中找到正确的网络转发端口。&lt;/p&gt;

&lt;p&gt;为了确认Node是否已经bootstrap成功，访问&lt;a href=&quot;http://manage.opscode.com/organizations&quot;&gt;manage.opscode.com/organizations&lt;/a&gt;，在Nodes标签上你应该可以看到刚才bootstrap的node名称。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/bd078a428c2ecc13b11602729b0c40d6.jpg&quot; title=&quot;chef-nodes&quot; alt=&quot;chef-nodes&quot;&gt;&lt;/p&gt;

&lt;p&gt;恭喜，你现在拥有了一个Chef环境，下一篇文章我们开始介绍Chef怎么使用。&lt;/p&gt;

&lt;h1&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.opscode.com/install_workstation.html&quot;&gt;http://docs.opscode.com/install_workstation.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.opscode.com/knife.html&quot;&gt;http://docs.opscode.com/knife.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.getchef.com/legacy/get-started/&quot;&gt;http://learn.getchef.com/legacy/get-started/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.vagrantup.com/v2/getting-started/up.html&quot;&gt;http://docs.vagrantup.com/v2/getting-started/up.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


	(完)

	&lt;div class=&quot;post-info&quot;&gt;
		19 Jul 2014  
	
		
	
		
	&lt;/div&gt;
	
	&lt;!-- disqus start --&gt;
	
	
	&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;http://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;
&lt;/noscript&gt;
	
	&lt;!-- disqus end --&gt;

	&lt;!-- related start --&gt;
	
	&lt;!-- related end --&gt;

</description>
        <pubDate>Sat, 19 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-19-learn-chef-01.html-2708b97ab.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-19-learn-chef-01.html-2708b97ab.html</guid>
        
        
      </item>
    
      <item>
        <title>击败二分检索算法——插值检索、快速检索</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;二分检索是查找有序数组最简单然而最有效的算法之一。现在的问题是，更复杂的算法能不能做的更好？我们先看一下其他方法。&lt;/p&gt;
&lt;p&gt;有些情况下，散列整个数据集是不可行的，或者要求既查找位置，又查找数据本身。这个时候，用哈希表就不能实现O(1)的运行时间了。但对有序数组， 采用分治法通常可以实现O(log(n))的最坏运行时间。&lt;/p&gt;
&lt;p&gt;在下结论前，有一点值得注意，那就是可以从很多方面“击败”一个算法：所需的空间，所需的运行时间，对底层数据结构的访问需求。接下来我们做一个运行时对比实验，实验中创建多个不同的随机数组，其元素个数均在10,000到81,920,000之间，元素均为4字节整型数据。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二分检索&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/28c8edde3d61a0411511d3b1866f06364.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73518&quot; alt=&quot;1&quot; src=&quot;/images/jobbole.com/3926f1cd5450556aeb560d367b40808e.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot; align=&quot;center&quot;&gt;二分检索算法的每一步，搜索空间总会减半，因此保证了运行时间。在数组中查找一个特定元素，可以保证在 O(log(n))时间内完成，而且如果找的正好是中间元素就更快了。也就是说，要从81,920,000个元素的数组中找某个元素的位置，只需要27个甚至更少的迭代。&lt;/p&gt;
&lt;p&gt;由于二分检索的随机跳跃性，该算法并非缓存友好的，因此只要搜索空间小于特定值（64或者更少），一些微调的二分检索算法就会切换回线性检索继续查找。然而，这个最终的空间值是极其架构相关的，因此大部分框架都没有做这个优化。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速检索；最后回归到二分检索的快速检索&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/665f644e43731ff9db3d341da5c827e14.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73519&quot; alt=&quot;2&quot; src=&quot;/images/jobbole.com/55b8b2b1d8240367a4a8d1ebb6fec3b1.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果由于某些原因，数组长度未知，快速检索可以识别初始的搜索域。这个算法从第一个元素开始，一直加倍搜索域的上界，直到这个上界已经大于待查关键字。之后，根据实现不同，或者采用标准的二分检索查找，或者开始另一轮的快速检索。前者可以保证O(log(n)) 的运行时间，后者则更接近O(n)的运行时间。&lt;/p&gt;
&lt;p&gt;如果我们要找的元素比较接近数组的开头，快速检索就非常有效。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽样检索&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/38026ed22fc1a91d92b5d2ef93540f204.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73520&quot; alt=&quot;3&quot; src=&quot;/images/jobbole.com/8fe61d7b867c882f73dcc417d21cf0c2.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;抽样检索有点类似二分检索，不过在确定主要搜索区域之前，它会先从数组中拿几个样例。最后，如果范围足够小，就采用标准的二分检索确定待查元素的准确位置。这个理论很有趣，不过在实践中执行效果并不好。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插值检索；最后回归到顺序查找的插值检索&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/011ecee7d295c066ae68d4396215c3d03.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73521&quot; alt=&quot;4&quot; src=&quot;/images/jobbole.com/1834e255a86da238292eb405ad63b4e4.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在被测的算法中，插值检索可以说是“最聪明”的一个算法。它类似于人类使用电话簿的方法，它试图通过假设元素在数组中均匀分布，来猜测元素的位置。&lt;/p&gt;
&lt;p&gt;首先，它抽样选择出搜索空间的开头和结尾，然后猜测元素的位置。算法一直重复这个步骤，直到找到元素。如果猜测是准确的，比较的次数大概是O(log(log(n))，运行时间大概是O(log(n))；但如果猜测的不对，运行时间就会是O(n)了。&lt;/p&gt;
&lt;p&gt;插值检索的一个改进版本是，只要可推测我们猜测的元素位置是接近最终位置的，就开始执行顺序查找。相比二分检索，插值检索的每次迭代计算代价都很高，因此在最后一步采用顺序查找，无需猜测元素位置的复杂计算，很容易就可以从很小的区域（大概10个元素）中找到最终的元素位置。&lt;/p&gt;
&lt;p&gt;围绕插值检索的一大疑问就是，O(log(log(n))的比较次数可能产生O(log(log(n))的运行时间。这并非个案，因为存储访问时间和计算下一次猜测的CPU时间相比，这两者之间要有所权衡。如果数据量很大，而且存储访问时间也很显著，比如在一个实际的硬盘上，插值检索轻松击败二分检索。然而，实验表明，如果访问时间很短，比如说RAM，插值检索可能不会产生任何好处。&lt;/p&gt;
&lt;p&gt;&lt;b&gt; &lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;试验结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;试验中的源代码都是用Java写的；每个实验在相同的数组上运行10次；数组是随机产生的整型数组，存储在内存中。&lt;/p&gt;
&lt;p&gt;在插值检索中，首先会采用抽样检索，从检索空间拿20个样例，以确定接下来的搜索域。如果假定的域只有10个或更少的元素，就开始采用线性检索。另外，如果这个搜索域元素个数小于2000，就回退到标准的二分检索了。&lt;/p&gt;
&lt;p&gt;作为参考，java默认的Arrays.binarySearch算法也被加入实验，以同自定义的算法对比运行时间。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/e4da3b7fbbce2345d7772b0674a318d5.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-73522&quot; alt=&quot;5&quot; src=&quot;/images/jobbole.com/c302133d6c5ba5d207301064dba6000e.jpg&quot;&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;Average search time / element, given the array size&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/1679091c5a880faf6fb5e6087eb1b2dc.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-73523&quot; alt=&quot;6&quot; src=&quot;/images/jobbole.com/30896ce76290686b4428b60a44ba2562.jpg&quot;&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;Average comparisons / search, given the array size&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;尽管我们对插值检索期望很高，它的实际运行时间并未击败java默认的二分检索算法。如果存储访问时间长，结合采用某些类型的哈希树和B+树可能是一个更好的选择。但值得注意的是，对均匀分布的数组，组合使用插值检索和顺序检索在比较次数上总能胜过二分检索。不过平台的二分检索已经很高效，所以很多情况下，可能不需要用更复杂的算法来代替它。&lt;/p&gt;
&lt;p&gt;原始数据 – 每个检索的平均运行时间&lt;/p&gt;
&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Size&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Arrays.&lt;br&gt;
&lt;/b&gt;&lt;b&gt;binarySearch&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Interpolation&lt;br&gt;
&lt;/b&gt;&lt;b&gt;+Seq&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Interpolation&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Sampling&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Binary&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Gallop&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Gallop&lt;br&gt;
&lt;/b&gt;&lt;b&gt;+Binary&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,000&lt;/td&gt;
&lt;td&gt;1.50E-04 ms&lt;/td&gt;
&lt;td&gt;1.60E-04 ms&lt;/td&gt;
&lt;td&gt;2.50E-04 ms&lt;/td&gt;
&lt;td&gt;3.20E-04 ms&lt;/td&gt;
&lt;td&gt;5.00E-05 ms&lt;/td&gt;
&lt;td&gt;1.50E-04 ms&lt;/td&gt;
&lt;td&gt;1.00E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20,000&lt;/td&gt;
&lt;td&gt;5.00E-05 ms&lt;/td&gt;
&lt;td&gt;5.50E-05 ms&lt;/td&gt;
&lt;td&gt;1.05E-04 ms&lt;/td&gt;
&lt;td&gt;2.35E-04 ms&lt;/td&gt;
&lt;td&gt;7.00E-05 ms&lt;/td&gt;
&lt;td&gt;1.15E-04 ms&lt;/td&gt;
&lt;td&gt;6.50E-05 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40,000&lt;/td&gt;
&lt;td&gt;4.75E-05 ms&lt;/td&gt;
&lt;td&gt;5.00E-05 ms&lt;/td&gt;
&lt;td&gt;9.00E-05 ms&lt;/td&gt;
&lt;td&gt;1.30E-04 ms&lt;/td&gt;
&lt;td&gt;5.25E-05 ms&lt;/td&gt;
&lt;td&gt;1.33E-04 ms&lt;/td&gt;
&lt;td&gt;8.75E-05 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80,000&lt;/td&gt;
&lt;td&gt;4.88E-05 ms&lt;/td&gt;
&lt;td&gt;5.88E-05 ms&lt;/td&gt;
&lt;td&gt;9.88E-05 ms&lt;/td&gt;
&lt;td&gt;1.95E-04 ms&lt;/td&gt;
&lt;td&gt;6.38E-05 ms&lt;/td&gt;
&lt;td&gt;1.53E-04 ms&lt;/td&gt;
&lt;td&gt;9.00E-05 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;160,000&lt;/td&gt;
&lt;td&gt;5.25E-05 ms&lt;/td&gt;
&lt;td&gt;5.94E-05 ms&lt;/td&gt;
&lt;td&gt;1.01E-04 ms&lt;/td&gt;
&lt;td&gt;2.53E-04 ms&lt;/td&gt;
&lt;td&gt;6.56E-05 ms&lt;/td&gt;
&lt;td&gt;1.81E-04 ms&lt;/td&gt;
&lt;td&gt;9.38E-05 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;320,000&lt;/td&gt;
&lt;td&gt;5.16E-05 ms&lt;/td&gt;
&lt;td&gt;6.13E-05 ms&lt;/td&gt;
&lt;td&gt;1.22E-04 ms&lt;/td&gt;
&lt;td&gt;2.19E-04 ms&lt;/td&gt;
&lt;td&gt;6.31E-05 ms&lt;/td&gt;
&lt;td&gt;2.45E-04 ms&lt;/td&gt;
&lt;td&gt;1.04E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;640,000&lt;/td&gt;
&lt;td&gt;5.30E-05 ms&lt;/td&gt;
&lt;td&gt;6.06E-05 ms&lt;/td&gt;
&lt;td&gt;9.61E-05 ms&lt;/td&gt;
&lt;td&gt;2.12E-04 ms&lt;/td&gt;
&lt;td&gt;7.27E-05 ms&lt;/td&gt;
&lt;td&gt;2.31E-04 ms&lt;/td&gt;
&lt;td&gt;1.16E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1,280,000&lt;/td&gt;
&lt;td&gt;5.39E-05 ms&lt;/td&gt;
&lt;td&gt;6.06E-05 ms&lt;/td&gt;
&lt;td&gt;9.72E-05 ms&lt;/td&gt;
&lt;td&gt;2.59E-04 ms&lt;/td&gt;
&lt;td&gt;7.52E-05 ms&lt;/td&gt;
&lt;td&gt;2.72E-04 ms&lt;/td&gt;
&lt;td&gt;1.18E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2,560,000&lt;/td&gt;
&lt;td&gt;5.53E-05 ms&lt;/td&gt;
&lt;td&gt;6.40E-05 ms&lt;/td&gt;
&lt;td&gt;1.11E-04 ms&lt;/td&gt;
&lt;td&gt;2.57E-04 ms&lt;/td&gt;
&lt;td&gt;7.37E-05 ms&lt;/td&gt;
&lt;td&gt;2.75E-04 ms&lt;/td&gt;
&lt;td&gt;1.05E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5,120,000&lt;/td&gt;
&lt;td&gt;5.53E-05 ms&lt;/td&gt;
&lt;td&gt;6.30E-05 ms&lt;/td&gt;
&lt;td&gt;1.26E-04 ms&lt;/td&gt;
&lt;td&gt;2.69E-04 ms&lt;/td&gt;
&lt;td&gt;7.66E-05 ms&lt;/td&gt;
&lt;td&gt;3.32E-04 ms&lt;/td&gt;
&lt;td&gt;1.18E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,240,000&lt;/td&gt;
&lt;td&gt;5.66E-05 ms&lt;/td&gt;
&lt;td&gt;6.59E-05 ms&lt;/td&gt;
&lt;td&gt;1.22E-04 ms&lt;/td&gt;
&lt;td&gt;2.92E-04 ms&lt;/td&gt;
&lt;td&gt;8.07E-05 ms&lt;/td&gt;
&lt;td&gt;4.27E-04 ms&lt;/td&gt;
&lt;td&gt;1.42E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20,480,000&lt;/td&gt;
&lt;td&gt;5.95E-05 ms&lt;/td&gt;
&lt;td&gt;6.54E-05 ms&lt;/td&gt;
&lt;td&gt;1.18E-04 ms&lt;/td&gt;
&lt;td&gt;3.50E-04 ms&lt;/td&gt;
&lt;td&gt;8.31E-05 ms&lt;/td&gt;
&lt;td&gt;4.88E-04 ms&lt;/td&gt;
&lt;td&gt;1.49E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40,960,000&lt;/td&gt;
&lt;td&gt;5.87E-05 ms&lt;/td&gt;
&lt;td&gt;6.58E-05 ms&lt;/td&gt;
&lt;td&gt;1.15E-04 ms&lt;/td&gt;
&lt;td&gt;3.76E-04 ms&lt;/td&gt;
&lt;td&gt;8.59E-05 ms&lt;/td&gt;
&lt;td&gt;5.72E-04 ms&lt;/td&gt;
&lt;td&gt;1.75E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;81,920,000&lt;/td&gt;
&lt;td&gt;6.75E-05 ms&lt;/td&gt;
&lt;td&gt;6.83E-05 ms&lt;/td&gt;
&lt;td&gt;1.04E-04 ms&lt;/td&gt;
&lt;td&gt;3.86E-04 ms&lt;/td&gt;
&lt;td&gt;8.66E-05 ms&lt;/td&gt;
&lt;td&gt;6.89E-04 ms&lt;/td&gt;
&lt;td&gt;2.15E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;原始数据 – 每个检索的平均比较次数&lt;/p&gt;
&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Size&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Arrays.&lt;br&gt;
&lt;/b&gt;&lt;b&gt;binarySearch&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Interpolation&lt;br&gt;
&lt;/b&gt;&lt;b&gt;+Seq&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Interpolation&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Sampling&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Binary&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Gallop&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Gallop&lt;br&gt;
&lt;/b&gt;&lt;b&gt;+Binary&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;10.6&lt;/td&gt;
&lt;td&gt;17.6&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;12.2&lt;/td&gt;
&lt;td&gt;58.2&lt;/td&gt;
&lt;td&gt;13.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;11.3&lt;/td&gt;
&lt;td&gt;20.7&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;13.2&lt;/td&gt;
&lt;td&gt;66.3&lt;/td&gt;
&lt;td&gt;14.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;11.0&lt;/td&gt;
&lt;td&gt;16.9&lt;/td&gt;
&lt;td&gt;20.9&lt;/td&gt;
&lt;td&gt;14.2&lt;/td&gt;
&lt;td&gt;74.9&lt;/td&gt;
&lt;td&gt;15.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.1&lt;/td&gt;
&lt;td&gt;19.9&lt;/td&gt;
&lt;td&gt;38.0&lt;/td&gt;
&lt;td&gt;15.2&lt;/td&gt;
&lt;td&gt;84.0&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;160,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;11.7&lt;/td&gt;
&lt;td&gt;18.3&lt;/td&gt;
&lt;td&gt;38.0&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;td&gt;93.6&lt;/td&gt;
&lt;td&gt;17.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;320,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.4&lt;/td&gt;
&lt;td&gt;25.3&lt;/td&gt;
&lt;td&gt;38.2&lt;/td&gt;
&lt;td&gt;17.2&lt;/td&gt;
&lt;td&gt;103.8&lt;/td&gt;
&lt;td&gt;18.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;640,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.4&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;41.6&lt;/td&gt;
&lt;td&gt;18.2&lt;/td&gt;
&lt;td&gt;114.4&lt;/td&gt;
&lt;td&gt;19.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1,280,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.5&lt;/td&gt;
&lt;td&gt;20.2&lt;/td&gt;
&lt;td&gt;57.0&lt;/td&gt;
&lt;td&gt;19.2&lt;/td&gt;
&lt;td&gt;125.5&lt;/td&gt;
&lt;td&gt;20.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2,560,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.8&lt;/td&gt;
&lt;td&gt;22.7&lt;/td&gt;
&lt;td&gt;57.0&lt;/td&gt;
&lt;td&gt;20.2&lt;/td&gt;
&lt;td&gt;137.1&lt;/td&gt;
&lt;td&gt;21.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5,120,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.7&lt;/td&gt;
&lt;td&gt;26.5&lt;/td&gt;
&lt;td&gt;57.5&lt;/td&gt;
&lt;td&gt;21.2&lt;/td&gt;
&lt;td&gt;149.2&lt;/td&gt;
&lt;td&gt;22.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,240,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;13.2&lt;/td&gt;
&lt;td&gt;25.2&lt;/td&gt;
&lt;td&gt;62.1&lt;/td&gt;
&lt;td&gt;22.2&lt;/td&gt;
&lt;td&gt;161.8&lt;/td&gt;
&lt;td&gt;23.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20,480,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;13.4&lt;/td&gt;
&lt;td&gt;23.4&lt;/td&gt;
&lt;td&gt;76.0&lt;/td&gt;
&lt;td&gt;23.2&lt;/td&gt;
&lt;td&gt;175.0&lt;/td&gt;
&lt;td&gt;24.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40,960,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;13.4&lt;/td&gt;
&lt;td&gt;21.9&lt;/td&gt;
&lt;td&gt;76.1&lt;/td&gt;
&lt;td&gt;24.2&lt;/td&gt;
&lt;td&gt;188.6&lt;/td&gt;
&lt;td&gt;25.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;81,920,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;19.7&lt;/td&gt;
&lt;td&gt;77.0&lt;/td&gt;
&lt;td&gt;25.2&lt;/td&gt;
&lt;td&gt;202.7&lt;/td&gt;
&lt;td&gt;26.2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;源代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/adam-ho/misc/tree/master/searchPerformance/src/main/java/com/search&quot;&gt;点此获取检索算法的完整源代码&lt;/a&gt;。注意，代码不是产品级别的；比如，在某些例子里，可能有过多或过少的范围检查。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Sat, 19 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-19-73517-816d30f94.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-19-73517-816d30f94.html</guid>
        
        
      </item>
    
      <item>
        <title>Building assert() in Swift, Part 1: Lazy Evaluation</title>
        <description>
assert()

</description>
        <pubDate>Fri, 18 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-18--id=4-6372976f7.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-18--id=4-6372976f7.html</guid>
        
        
      </item>
    
      <item>
        <title>React 的 diff 算法</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;a href=&quot;http://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;React&lt;/a&gt; 是 Facebook 开发的构建用户界面的类库。它从设计之初就将性能作为重点。这篇文章将展示 diff 算法和渲染过程怎样工作，你可以借鉴优化自己的应用。&lt;/p&gt;
&lt;h2&gt;Diff 算法&lt;/h2&gt;
&lt;p&gt;在深入实现的细节之前，需要了解一下 React 怎样工作的。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;var MyComponent = React.createClass({
  render: function() {
    if (this.props.first) {
      return &amp;lt;div className=&quot;first&quot;&amp;gt;&amp;lt;span&amp;gt;A Span&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;;
    } else {
      return &amp;lt;div className=&quot;second&quot;&amp;gt;&amp;lt;p&amp;gt;A Paragraph&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;;
    }
  }
});&lt;/pre&gt;
&lt;p&gt;任何时间，你描述的是你的 UI 看起来是什么样子。需要特别注意，render 执行的结果得到的不是真正的 DOM 节点。结果仅仅是轻量级的 JavaScript 对象，我们称之为 virtual DOM。&lt;/p&gt;
&lt;p&gt;React 要从这个表现形式当中尝试找到前一个渲染结果到后一个的最小步数。比如，当我们挂载了 &lt;code&gt;&amp;lt;MyComponent first={true} /&amp;gt;&lt;/code&gt;，然后用 &lt;code&gt;&amp;lt;MyComponent first={false} /&amp;gt;&lt;/code&gt; 替换，然后又取消挂载，这样一个过程的 DOM 的指令是这样的:&lt;/p&gt;
&lt;p&gt;从没有到第一步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建节点:
&lt;pre class=&quot;brush: html; gutter: true&quot;&gt;&amp;lt;div className=&quot;first&quot;&amp;gt;&amp;lt;span&amp;gt;A Span&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一步到第二步替换属性:?&lt;code&gt;className=&quot;first&quot; 到 className=&quot;second&quot;&lt;/code&gt;&lt;br&gt;
提盒节点:?&lt;code&gt;&amp;lt;span&amp;gt;A Span&amp;lt;/span&amp;gt;&lt;/code&gt;?到?&lt;code&gt;&amp;lt;p&amp;gt;A Paragraph&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二步到没有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除节点:
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;&amp;lt;div className=&quot;second&quot;&amp;gt;&amp;lt;p&amp;gt;A Paragraph&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;按照层级&lt;/h4&gt;
&lt;p&gt;找到两课任意的树之间最小的修改是一个复杂度为 &lt;code&gt;O(n^3)&lt;/code&gt; 的问题。你可以想象，我们的例子里这不是容易处理的。React 用了一种简单但是强大的技巧，达到了接近 &lt;code&gt;O(n)&lt;/code&gt; 的复杂度。&lt;/p&gt;
&lt;p&gt;React 仅仅是尝试把树按照层级分解。 这彻底简化了复杂度，而且也不会失去很多，因为 Web 应用很少有 component 移动到树的另一个层级去。它们大部分只是在相邻的子节点之间移动。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/5353c5a8ae864b68bae903cb71e106ce.png&quot; rel=&quot;lightbox[73701]&quot; title=&quot;React 的 diff 算法&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73702&quot; alt=&quot;d1&quot; src=&quot;/images/jobbole.com/abe2c8e0d29baf5fc2084d7620a783a8.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;列表&lt;/h4&gt;
&lt;p&gt;假设我们有个 component，一个循环渲染了 5 个 component，随后又在列表中间插入一个新的 component。只知道这些信息，要弄清两个 component 的列表怎么对应很难。&lt;/p&gt;
&lt;p&gt;默认情况下，React 会将前一个列表第一个 component 和后一个第一个关联起来，后面也是。你可以写一个 &lt;code&gt;key&lt;/code&gt; 属性帮助 React 来处理它们之间的对应关系。世纪钟，在子元素中找到唯一的 key 通常很容易。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/18be24308734e65e462e74629de57c95.png&quot; rel=&quot;lightbox[73701]&quot; title=&quot;React 的 diff 算法&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73703&quot; alt=&quot;d2&quot; src=&quot;/images/jobbole.com/0b8617082291c2866018664f1cf02e23.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Components&lt;/h4&gt;
&lt;p&gt;React app 通常由用户定义的 component 组合而成，通常结果是一个主要是很多 &lt;code&gt;div&lt;/code&gt; 组成的树。这个信息也被 React 的 diff 算法考虑进去，React 只会匹配相同 class 的 component。&lt;/p&gt;
&lt;p&gt;比如，如果有个 &lt;code&gt;&amp;lt;Header&amp;gt;&lt;/code&gt; 被 &lt;code&gt;&amp;lt;ExampleBlock&amp;gt;&lt;/code&gt; 替换掉了，React 会删除掉 header 再创建一个 example block。我们不需要化宝贵的时间去匹配两个不大可能又相似之处的 component。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/8016bb213a31681fefb1236e8d74f18b.png&quot; rel=&quot;lightbox[73701]&quot; title=&quot;React 的 diff 算法&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73704&quot; alt=&quot;d3&quot; src=&quot;/images/jobbole.com/6b5f8bea5a0ee0d68e5670754810a11e.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;事件代理&lt;/h2&gt;
&lt;p&gt;往 DOM 节点上绑事件慢得人心碎啊，而且很费内存。&lt;/p&gt;
&lt;p&gt;作为替代，React 部署了流行的技术，叫做”事件代理”。React 走得更远，重新实现了一遍符合 W3C 规范的事件系统。意味着 IE8 事件处理的 bug 成为过去了，所有时间名称跨浏览器保持一致。&lt;/p&gt;
&lt;p&gt;这里解释一下怎么实现的。 事件 listener 被绑定到整个文档的根节点上。当事件被触发，浏览器会给出一个出发的目标的 DOM 节点。为了在 DOM 的层级传播事件，React 不会迭代 virtual DOM 的层级。而是，我们依靠每个 React component 各自独立的 id 来编码这个层级。&lt;/p&gt;
&lt;p&gt;我们能通过简单的字符串操作来获取所有父级 component 的父级内容。把事件 listener 存储在 hash map 当中，我们发现性能比放到 virtual DOM 还要好。这个例子展示了，当一个事件广播到整个 virtual DOM 时发生什么。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;// dispatchEvent(&#39;click&#39;，&#39;a.b.c&#39;，event)
clickCaptureListeners[&#39;a&#39;](event);
clickCaptureListeners[&#39;a.b&#39;](event);
clickCaptureListeners[&#39;a.b.c&#39;](event);
clickBubbleListeners[&#39;a.b.c&#39;](event);
clickBubbleListeners[&#39;a.b&#39;](event);
clickBubbleListeners[&#39;a&#39;](event);&lt;/pre&gt;
&lt;p&gt;浏览器为每个事件和每个 listener 创建一个新的事件对象。这个事件对象的属性很不错，你能获取到事件的引用，甚至修改掉。然而这也意味着高额的内存分配。&lt;/p&gt;
&lt;p&gt;React 在启动时就为那些对象分配了一个内存池。任何时候需要用到事件对象，就可以从这个内存池进行复用。这一点非常显著地减轻了垃圾回收的负担。&lt;/p&gt;
&lt;h2&gt;渲染&lt;/h2&gt;
&lt;h4&gt;批量化&lt;/h4&gt;
&lt;p&gt;你调用 component 的 &lt;code&gt;setState&lt;/code&gt; 方法的时候，React 将其标记为 dirty。到每一个事件循环结束，React 检查所有标记 dirty 的 component 重新绘制。&lt;/p&gt;
&lt;p&gt;这里的”批量化”是说，在一个事件循环当中，DOM 只会被更新一次。这个特性是构建高效的 app 的关键，而且用通常的 JavaScript 代码难以实现。而在 React 应用里，你默认就实现了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/7b7d59d08b4480b47a5b480a91f3f199.png&quot; rel=&quot;lightbox[73701]&quot; title=&quot;React 的 diff 算法&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73705&quot; alt=&quot;d4&quot; src=&quot;/images/jobbole.com/f62a4c9f0c9c2808037d1dfadc28dbe6.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h4&gt;子树渲染&lt;/h4&gt;
&lt;p&gt;调用 &lt;code&gt;setState&lt;/code&gt; 方法时，component 重新构建包括了子节点的 virtual DOM。如果你在根节点调用 &lt;code&gt;setState&lt;/code&gt;，整个 React 的应用都会被重新渲染。所有的 component，即便没有更新，都会调用他们的 &lt;code&gt;render&lt;/code&gt; 方法。这个听起来可怕，性能像是很低，但实际上我们不会触碰真实的 DOM，运行起来没问题。&lt;/p&gt;
&lt;p&gt;首先，我们讨论的是展示用户界面. 因为屏幕空间有限，通常你需要一次渲染成败上千条指令。JavaScript 对于能处理的整个界面，在业务逻辑上已经足够快了。&lt;/p&gt;
&lt;p&gt;另一点，在写 React 代码时，每当又数据更新，你不是都调用根节点的 &lt;code&gt;setState&lt;/code&gt;。你会在需要接收对应更新的 component 上调用，或者在上面的几个 component。你很少要一直到根节点上. 就是说更新只出现在用户产生交互的局部.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/0c946ae9ee9fffc1a8d180d618568698.png&quot; rel=&quot;lightbox[73701]&quot; title=&quot;React 的 diff 算法&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73706&quot; alt=&quot;d5&quot; src=&quot;/images/jobbole.com/c4de89fa3336f20696c0e31bae8d59f0.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h4&gt;选择性子树渲染&lt;/h4&gt;
&lt;p&gt;最后，你还有可能截断一些子树的重新渲染。如果你在 component 上实现以下方法的话：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;boolean shouldComponentUpdate(object nextProps， object nextState)&lt;/pre&gt;
&lt;p&gt;根据 component 的前一个和下一个 &lt;code&gt;props/state&lt;/code&gt;，你可以告诉 React 这个 component 没有更新，也不需要重新绘制。实现得好的话，可以带来巨大的性能提升。&lt;/p&gt;
&lt;p&gt;要用这个方法，你要能够对 JavaScript Object 进行比对。这件有很多细节的因素，比如对比应该是深度的还是浅层的，如果要深的，我们是用不可变数据结构，还是进行深度拷贝。&lt;/p&gt;
&lt;p&gt;而且你要注意，真个函数每次都会被调用，所以你要确保运行起来花的事件更少，比 React 的技巧，还有比渲染 component 需要的时间，即便重新绘制并不是必要的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/78334626370247b9ea8ed249b37a7196.png&quot; rel=&quot;lightbox[73701]&quot; title=&quot;React 的 diff 算法&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73707&quot; alt=&quot;d6&quot; src=&quot;/images/jobbole.com/cd4c0dbd39755d85f843c53ed45572e7.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;帮助 React 变快的技术并不新颖。 长久以来，我们到知道触碰 DOM 是费时的，你应该合并处理读和写的操作，事件代理会更快。&lt;/p&gt;
&lt;p&gt;人们还是会经常讨论他们，因为在实际当中用 JavaScript 进行实现很是挺难的。React 突出的一个原因是这些优化默认就启动了。这就让你避免掉不小心把 app 写得很慢。&lt;/p&gt;
&lt;p&gt;React 消耗性能的模型很简单，很好理解: 每次调用 &lt;code&gt;setState&lt;/code&gt; 会重新计算整个子树。如果你想要提高性能，尽量少调用 &lt;code&gt;setState&lt;/code&gt;，还有用 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 减少大的子树的重新计算。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Thu, 17 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-17-73701-418acf0a6.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-17-73701-418acf0a6.html</guid>
        
        
      </item>
    
      <item>
        <title>BASH的保护性编程技巧</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;div&gt;
&lt;p&gt;这是我写BASH程序的招式。这里本没有什么新的内容，但是从我的经验来看，人们爱滥用BASH。他们忽略了计算机科学，而从他们的程序中创造的是“&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_ball_of_mud&quot;&gt;大泥球&lt;/a&gt;”（译注：指架构不清晰的软件系统）。&lt;/p&gt;
&lt;div&gt;在此我告诉你方法，以保护你的程序免于障碍，并保持代码的整洁。&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;不可改变的全局变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;尽量少用全局变量&lt;/li&gt;
&lt;li&gt;以大写命名&lt;/li&gt;
&lt;li&gt;只读声明&lt;/li&gt;
&lt;li&gt;用全局变量来代替隐晦的$0，$1等&lt;/li&gt;
&lt;li&gt;
&lt;div&gt;在我的程序中常使用的全局变量：&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;readonly PROGNAME=$(basename $0)
readonly PROGDIR=$(readlink -m $(dirname $0))
readonly ARGS=&quot;$@&quot;&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;一切皆是局部的&lt;/h2&gt;
&lt;p&gt;所有变量都应为局部的。&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;change_owner_of_file() {
    local filename=$1
    local user=$2
    local group=$3

    chown $user:$group $filename
}&lt;/pre&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;change_owner_of_files() {
    local user=$1; shift
    local group=$1; shift
    local files=$@
    local i

    for i in $files
    do
        chown $user:$group $i
    done
}&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;自注释（self documenting）的参数&lt;/li&gt;
&lt;li&gt;通常作为循环用的变量i，把它声明为局部变量是很重要的。&lt;/li&gt;
&lt;li&gt;局部变量不作用于全局域。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;kfir@goofy ~ $ local a
bash: local: can only be used in a function&lt;/pre&gt;
&lt;figure&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;/figure&gt;
&lt;div&gt;
&lt;h2&gt;main()&lt;/h2&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;有助于保持所有变量的局部性&lt;/li&gt;
&lt;li&gt;直观的函数式编程&lt;/li&gt;
&lt;li&gt;
&lt;div&gt;代码中唯一的全局命令是：main&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;main() {
    local files=&quot;/tmp/a /tmp/b&quot;
    local i

    for i in $files
    do
        change_owner_of_file kfir users $i
    done
}
main&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;一切皆是函数&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;唯一全局性运行的代码是：&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;- 不可变的全局变量声明&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;- main()函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持代码整洁&lt;/li&gt;
&lt;li&gt;过程变得清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;main() {
    local files=$(ls /tmp | grep pid | grep -v daemon)
}&lt;/pre&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files() {
    local dir=$1

    ls $dir \
        | grep pid \
        | grep -v daemon
}

main() {
    local files=$(temporary_files /tmp)
}&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;div&gt;第二个例子好得多。查找文件是temporary_files()的问题而非main()的。这段代码用temporary_files()的单元测试也是可测试的。&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;如果你一定要尝试第一个例子，你会得到查找临时文件以和main算法的大杂烩。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;test_temporary_files() {
    local dir=/tmp

    touch $dir/a-pid1232.tmp
    touch $dir/a-pid1232-daemon.tmp

    returns &quot;$dir/a-pid1232.tmp&quot; temporary_files $dir

    touch $dir/b-pid1534.tmp

    returns &quot;$dir/a-pid1232.tmp $dir/b-pid1534.tmp&quot; temporary_files $dir
}&lt;/pre&gt;
&lt;div&gt;如你所见，这个测试不关心main()。&lt;/div&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;调试函数&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;带-x标志运行程序：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;bash -x my_prog.sh&lt;/pre&gt;
&lt;div&gt;只调试一小段代码，使用set-x和set+x，会只对被set -x和set +x包含的当前代码打印调试信息。&lt;/div&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files() {
    local dir=$1

    set -x
    ls $dir \
        | grep pid \
        | grep -v daemon
    set +x
}&lt;/pre&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;打印函数名和它的参数：&lt;/div&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files() {
    echo $FUNCNAME $@
    local dir=$1

    ls $dir \
        | grep pid \
        | grep -v daemon
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;调用函数：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files /tmp&lt;/pre&gt;
&lt;p&gt;会打印到标准输出：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files /tmp&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;div&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;代码的清晰度&lt;/h2&gt;
&lt;/div&gt;
&lt;p&gt;这段代码做了什么？&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;main() {
    local dir=/tmp

    [[ -z $dir ]] \
        &amp;amp;&amp;amp; do_something...

    [[ -n $dir ]] \
        &amp;amp;&amp;amp; do_something...

    [[ -f $dir ]] \
        &amp;amp;&amp;amp; do_something...

    [[ -d $dir ]] \
        &amp;amp;&amp;amp; do_something...
}
main&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;p&gt;让你的代码说话：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;is_empty() {
    local var=$1

    [[ -z $var ]]
}

is_not_empty() {
    local var=$1

    [[ -n $var ]]
}

is_file() {
    local file=$1

    [[ -f $file ]]
}

is_dir() {
    local dir=$1

    [[ -d $dir ]]
}

main() {
    local dir=/tmp

    is_empty $dir \
        &amp;amp;&amp;amp; do_something...

    is_not_empty $dir \
        &amp;amp;&amp;amp; do_something...

    is_file $dir \
        &amp;amp;&amp;amp; do_something...

    is_dir $dir \
        &amp;amp;&amp;amp; do_something...
}
main&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;每一行只做一件事&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;div&gt;用反斜杠\来作分隔符。例如：&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files() {
    local dir=$1

    ls $dir | grep pid | grep -v daemon
}&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;p&gt;可以写得简洁得多：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files() {
    local dir=$1

    ls $dir \
        | grep pid \
        | grep -v daemon
}&lt;/pre&gt;
&lt;div&gt;
&lt;ul&gt;
&lt;li&gt;符号在缩进行的开始&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;符号在行末的坏例子：（译注：原文在此例中用了temporary_files()代码段，疑似是贴错了。结合上下文，应为print_dir_if_not_empty()）&lt;/p&gt;
&lt;/div&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;print_dir_if_not_empty() {
    local dir=$1

    is_empty $dir &amp;amp;&amp;amp; \
        echo &quot;dir is empty&quot; || \
        echo &quot;dir=$dir&quot;
}&lt;/pre&gt;
&lt;p&gt;好的例子：我们可以清晰看到行和连接符号之间的联系。&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;print_dir_if_not_empty() {
    local dir=$1

    is_empty $dir \
        &amp;amp;&amp;amp; echo &quot;dir is empty&quot; \
        || echo &quot;dir=$dir&quot;
}&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;打印用法&lt;/h2&gt;
&lt;p&gt;不要这样做：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;echo &quot;this prog does:...&quot;
echo &quot;flags:&quot;
echo &quot;-h print help&quot;&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;p&gt;它应该是个函数：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;usage() {
    echo &quot;this prog does:...&quot;
    echo &quot;flags:&quot;
    echo &quot;-h print help&quot;
}&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;p&gt;echo在每一行重复。因此我们得到了这个文档：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;usage() {
    cat &amp;lt;&amp;lt;- EOF
    usage: $PROGNAME options

    Program deletes files from filesystems to release space. 
    It gets config file that define fileystem paths to work on, and whitelist rules to 
    keep certain files.

    OPTIONS:
       -c --config              configuration file containing the rules. use --help-config to see the syntax.
       -n --pretend             do not really delete, just how what you are going to do.
       -t --test                run unit test to check the program
       -v --verbose             Verbose. You can specify more then one -v to have more verbose
       -x --debug               debug
       -h --help                show this help
          --help-config         configuration help

    Examples:
       Run all tests:
       $PROGNAME --test all

       Run specific test:
       $PROGNAME --test test_string.sh

       Run:
       $PROGNAME --config /path/to/config/$PROGNAME.conf

       Just show what you are going to do:
       $PROGNAME -vn -c /path/to/config/$PROGNAME.conf
    EOF
}&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;p&gt;注意在每一行的行首应该有一个真正的制表符‘\t’。&lt;/p&gt;
&lt;p&gt;在vim里，如果你的tab是4个空格，你可以用这个替换命令：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;:s/^    /\t/&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;命令行参数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这里是一个例子，完成了上面usage函数的用法。我从&lt;a title=&quot;bash shell script to use getopts with gnu style long positional parameters&quot; href=&quot;http://kirk.webfinish.com/2009/10/bash-shell-script-to-use-getopts-with-gnu-style-long-positional-parameters/&quot;&gt;Kirk’s blog post – bash shell script to use getopts with gnu style long positional parameters&lt;/a&gt;得到这段代码&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;cmdline() {
    # got this idea from here:
    # http://kirk.webfinish.com/2009/10/bash-shell-script-to-use-getopts-with-gnu-style-long-positional-parameters/
    local arg=
    for arg
    do
        local delim=&quot;&quot;
        case &quot;$arg&quot; in
            #translate --gnu-long-options to -g (short options)
            --config)         args=&quot;${args}-c &quot;;;
            --pretend)        args=&quot;${args}-n &quot;;;
            --test)           args=&quot;${args}-t &quot;;;
            --help-config)    usage_config &amp;amp;amp;&amp;amp;amp; exit 0;;
            --help)           args=&quot;${args}-h &quot;;;
            --verbose)        args=&quot;${args}-v &quot;;;
            --debug)          args=&quot;${args}-x &quot;;;
            #pass through anything else
            *) [[ &quot;${arg:0:1}&quot; == &quot;-&quot; ]] || delim=&quot;\&quot;&quot;
                args=&quot;${args}${delim}${arg}${delim} &quot;;;
        esac
    done

    #Reset the positional parameters to the short options
    eval set -- $args

    while getopts &quot;nvhxt:c:&quot; OPTION
    do
         case $OPTION in
         v)
             readonly VERBOSE=1
             ;;
         h)
             usage
             exit 0
             ;;
         x)
             readonly DEBUG=&#39;-x&#39;
             set -x
             ;;
         t)
             RUN_TESTS=$OPTARG
             verbose VINFO &quot;Running tests&quot;
             ;;
         c)
             readonly CONFIG_FILE=$OPTARG
             ;;
         n)
             readonly PRETEND=1
             ;;
        esac
    done

    if [[ $recursive_testing || -z $RUN_TESTS ]]; then
        [[ ! -f $CONFIG_FILE ]] \
            &amp;amp;amp;&amp;amp;amp; eexit &quot;You must provide --config file&quot;
    fi
    return 0
}&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;p&gt;你像这样，使用我们在头上定义的不可变的ARGS变量：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;main() {
    cmdline $ARGS
}
main&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;单元测试&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在更高级的语言中很重要。&lt;/li&gt;
&lt;li&gt;
&lt;div&gt;使用shunit2做单元测试&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;test_config_line_paths() {
    local s=&#39;partition cpm-all, 80-90,&#39;

    returns &quot;/a&quot; &quot;config_line_paths &#39;$s /a, &#39;&quot;
    returns &quot;/a /b/c&quot; &quot;config_line_paths &#39;$s /a:/b/c, &#39;&quot;
    returns &quot;/a /b /c&quot; &quot;config_line_paths &#39;$s   /a  :    /b : /c, &#39;&quot;
}

config_line_paths() {
    local partition_line=&quot;$@&quot;

    echo $partition_line \
        | csv_column 3 \
        | delete_spaces \
        | column 1 \
        | colons_to_spaces
}

source /usr/bin/shunit2&lt;/pre&gt;
&lt;p&gt;这里是另一个使用df命令的例子：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;DF=df

mock_df_with_eols() {
    cat &amp;amp;lt;&amp;amp;lt;- EOF
    Filesystem           1K-blocks      Used Available Use% Mounted on
    /very/long/device/path
                         124628916  23063572 100299192  19% /
    EOF
}

test_disk_size() {
    returns 1000 &quot;disk_size /dev/sda1&quot;

    DF=mock_df_with_eols
    returns 124628916 &quot;disk_size /very/long/device/path&quot;
}

df_column() {
    local disk_device=$1
    local column=$2

    $DF $disk_device \
        | grep -v &#39;Use%&#39; \
        | tr &#39;\n&#39; &#39; &#39; \
        | awk &quot;{print \$$column}&quot;
}

disk_size() {
    local disk_device=$1

    df_column $disk_device 2
}&lt;/pre&gt;
&lt;p&gt;这里我有个例外，为了测试，我在全局域中声明了DF为非只读。这是因为shunit2不允许改变全局域函数。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Thu, 17 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-17-73257-503521781.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-17-73257-503521781.html</guid>
        
        
      </item>
    
      <item>
        <title>HTTP 的 POST 参数提交和上传的不同与 Mojolicious 的实现.</title>
        <description>

							&lt;p&gt;对于 HTTP 协议, 我们在使用 POST 上传的时候, 其实是有好几种不同的处理方式的, 所以对于客户端和服务器端, 也分别都有不同的处理. 正常普通的网页在提交参数上传到服务器的时候, 主要会根据内容的不同来使用不同的处理. 所体现在不同的地方在 Content-Type 的类型.&lt;br&gt;
比如我们常常用 Mojolicious 处理这类接收到的参数和内容的时候, 会让很多人晕掉, 所以我在这, 基于协议的头, 来给大家介绍一下在参数和上传的时候有什么不同.&lt;br&gt;
客户端, 比如浏览器网页中的 form 的表格的参数的不同, 客户端比如 Linux 命令行的 curl 的参数的不同和程序接口提交参数的不同, HTTP 协议在上传的时候, 大约会有三种不同, 这些体现在 Content-Type 的三种类型:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
		application/x-www-form-urlencoded&lt;/li&gt;
&lt;li&gt;
		multipart/form-data&lt;/li&gt;
&lt;li&gt;
		post 的 body 的内容&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们来详细介绍&lt;/p&gt;
&lt;h3&gt;
	1. application/x-www-form-urlencoded 默认&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;浏览器:&lt;/strong&gt;  在 HTML 中 form 有个参数是 enctype 属性用于指定编码方式, 常用有前面讲的两种: application/x-www-form-urlencoded 和 multipart/form-data. 但默认的时候, 我们并不指定. 不指定的时候, 默认是 &quot;application/x-www-form-urlencoded&quot; , 所以其实, 我们平时都是使用的这种格式来提交数据. 因为是默认就不写出来了. 注意, 这个会对空格和特别的符号进行 url 的 encode.&lt;br&gt;
 &lt;br&gt;
&lt;strong&gt;程序:&lt;/strong&gt; 我们现在以 Mojo::UserAgent 这个模块为例子, 我们提交一个参数 args 值为 test.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
$ua-&amp;gt;post(&#39;http://www.php-oa.com/a/b&#39; =&amp;gt; form =&amp;gt; { args =&amp;gt; &#39;test&#39;});

&lt;/pre&gt;
&lt;p&gt;命令:&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
$curl -svo /dev/null -d &quot;args=test&quot; http://www.php-oa.com/a/b
&lt;/pre&gt;
&lt;p&gt;
&lt;strong&gt;HTTP 协议状态&lt;/strong&gt;&lt;br&gt;
这个时候所发送的 HTTP 的头和内容分别如下. body 中会存着参数, 会有一个特别的 Header.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
-- Blocking request (http://www.php-oa.com/a/b)
-- Connect (http:www.php-oa.com:80)
-- Client &amp;gt;&amp;gt;&amp;gt; Server (http://www.php-oa.com/a/b)
POST /a/b HTTP/1.1
User-Agent: Mojolicious (Perl)
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip
Content-Length: 9
Host: www.php-oa.com

args=test
&lt;/pre&gt;
&lt;p&gt;
&lt;strong&gt;服务端接收方式&lt;/strong&gt;&lt;br&gt;
这个时候, 服务器会根据因为是 POST 的方法, 并且头部的 Content-Type: application/x-www-form-urlencoded 会去解析 body 的参数. 这样在 Mojolicious 服务器&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
post &#39;/a/b&#39; =&amp;gt; sub {
  my $self = shift;
  my $foo  = $self-&amp;gt;param(&#39;args&#39;);
  $self-&amp;gt;render(text =&amp;gt; &quot;Hello from $foo.&quot;);
}

&lt;/pre&gt;
&lt;h3 style=&quot;padding:0px; margin:0px; font-family:微软雅黑,Verdana,sans-serif,宋体; line-height:24px; text-align:left&quot;&gt;
	 &lt;/h3&gt;
&lt;h3&gt;
	2. multipart/form-data 大文件, 媒体文件&lt;/h3&gt;
&lt;p&gt;对于比较大的, 有一些二进制数据和象视频文件之类大文件, 建议使用这种方式上传.&lt;br&gt;
&lt;strong&gt;浏览器:&lt;/strong&gt;&lt;br&gt;
普通的 HTTP 的写法如果要使用 enctype 的话, 只要象下面一样就行.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
&amp;lt;form action=&quot;/path/to/login&quot; enctype=&quot;multipart/form-data&quot;&amp;gt;
  &amp;lt;input disabled=&quot;disabled&quot; name=&quot;first_name&quot; type=&quot;text&quot; /&amp;gt;
  &amp;lt;input value=&quot;Ok&quot; type=&quot;submit&quot; /&amp;gt;
&amp;lt;/form&amp;gt;

&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端:&lt;/strong&gt;&lt;br&gt;
在 Mojo::UserAgent 考虑得非常周全, 当你提交的内容中包含二进制文件之类时, 就会自动帮你转换成 &quot;multipart/form-data&quot; 格式提交. 这个格式会生成一个随机字符来分割不同参数. 区分是否使用这种格式主要是, 当你提交的参数中, 又是一个引用, 并且引中可以使用 content 来指定内容或者 file 来指定路径.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
$ua-&amp;gt;post(&#39;http://www.php-oa.com/a/b&#39; =&amp;gt; form =&amp;gt; { args =&amp;gt; &#39;test&#39;, args_file =&amp;gt; { file =&amp;gt; &#39;/root/.bash_history&#39; } });

# or
$ua-&amp;gt;post(&#39;http://www.php-oa.com/a/b&#39; =&amp;gt; form =&amp;gt; { args =&amp;gt; &#39;test&#39;, args_file =&amp;gt; { content =&amp;gt; &#39;test&#39; } });


&lt;/pre&gt;
&lt;p&gt;
&lt;strong&gt;HTTP 协议状态&lt;/strong&gt;&lt;br&gt;
这个地方我们可以见到 Content-Type: multipart/form-data 的请求头, 告诉文件和参数是这种格式上传过来的.并且 boundary 用于指定一个参数之间的分割符.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
-- Blocking request (http://www.php-oa.com/a/b)
-- Connect (http:www.php-oa.com:80)
-- Client &amp;gt;&amp;gt;&amp;gt; Server (http://www.php-oa.com/a/b)
POST /a/b HTTP/1.1
User-Agent: Mojolicious (Perl)
Content-Type: multipart/form-data; boundary=WRoHX
Connection: keep-alive
Accept-Encoding: gzip
Content-Length: 14428
Host: www.php-oa.com

--WRoHX
Content-Disposition: form-data; name=&quot;args&quot;
test
--WRoHX
Content-Disposition: form-data; name=&quot;args_file&quot;; filename=&quot;.bash_history&quot;
........文件本身




&lt;/pre&gt;
&lt;p&gt;
&lt;strong&gt;服务器接收方式&lt;/strong&gt;&lt;br&gt;
在后端的服务器接收的时候 Mojolicious 想得非常周到. 对于这种格式能自动解析, 并且全程异步.不会多占内存. 这个会自动给大的文件使用一个叫 Mojo::Upload 的对象来处理, 我们可以通过 $self-&amp;gt;req-&amp;gt;upload(&#39;args_file&#39;); 这个方法取得这个内容的对象, 这个内容的对象是Mojo::Asset::File 这个对象, 存文件和取大文件之类可以直接调用.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
post &#39;/a/b&#39; =&amp;gt; sub {
  my $self = shift;
  my $upload = $self-&amp;gt;req-&amp;gt;upload(&#39;args_file&#39;);
  my $foo  = $self-&amp;gt;param(&#39;args&#39;);
  $self-&amp;gt;render(text =&amp;gt; &quot;Hello from $foo.&quot;);
}


&lt;/pre&gt;
&lt;h3&gt;
	&lt;br&gt;
	3. POST 的 body 的内容&lt;/h3&gt;
&lt;p&gt;最后一种, 是有时我们做大文件上传, 和提交内容之类.这个时候, 整个 body 都是文件本体. 参数象 get 一样通过 url 传过去.&lt;br&gt;
这个就不用抓头了, 没任何转换, 直接整个 body 是个大文件.&lt;br&gt;
&lt;strong&gt;客户端提交:&lt;/strong&gt;&lt;br&gt;
我们来看看客户端在这个时候怎么上传送. 同样,  我们使用 Mojo::UserAgent 为例子.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
my $ua = Mojo::UserAgent-&amp;gt;new;
$ua-&amp;gt;transactor-&amp;gt;add_generator(stream =&amp;gt; sub {
    my ($transactor, $tx, $path) = @_; 
    $tx-&amp;gt;req-&amp;gt;content-&amp;gt;asset(Mojo::Asset::File-&amp;gt;new(path =&amp;gt; $path));
});
$ua-&amp;gt;post(&#39;http://www.php-oa.com/a/b&#39; =&amp;gt; stream =&amp;gt; &#39;/root/.bash_history&#39; );

&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;服务器接收&lt;/strong&gt;&lt;br&gt;
这个时候, 在服务器端怎么接收啦?&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
post &#39;/a/b&#39; =&amp;gt; sub {
  my $self = shift;
  my $body = $self-&amp;gt;req-&amp;gt;body;
  my $foo  = $self-&amp;gt;param(&#39;args&#39;);
  $self-&amp;gt;render(text =&amp;gt; &quot;Hello from $foo.&quot;);
}

&lt;/pre&gt;
&lt;p&gt;这个, 我们直接取请求的 body 就可以了, 但这有个小问题, 这是这个文件上传完, 这个 body 会存着所有的文件, 比如这个上传的文件有 1G , 这个 1G 就都会占着内存. 这个情况, Mojolicious 并没有实现事件来根据块取文件. 晚点, 我有个有于大文件上传的文章, 会分享我在 Mojolicious 中实现异步以块方式存储文件. 这样用户上传多少, 我存多少, 并不会占用更多的内存.&lt;/p&gt;
&lt;p&gt;好了整个三种方式都介绍完了, 大家一定注意区分哦 .&lt;/p&gt;

			&lt;!--[syntaxhighlighter]--&gt;
			&lt;!--代码高亮，请勿编辑--&gt;
			&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shCore.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shBrushPerl.js&quot;&gt;&lt;/script&gt;

			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shCoreDefault.css&quot;&gt;
			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shThemeDefault.css&quot;&gt;
			&lt;script type=&quot;text/javascript&quot;&gt;
			SyntaxHighlighter.defaults[&#39;class-name&#39;]	= &#39;.syntaxhighlighter {     background-color: 999999 }&#39;;
			SyntaxHighlighter.defaults[&#39;smart-tabs&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;tab-size&#39;]		= 4;
			SyntaxHighlighter.defaults[&#39;gutter&#39;]		= true;
			SyntaxHighlighter.defaults[&#39;quick-code&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;collapse&#39;] 		= false;
			SyntaxHighlighter.defaults[&#39;auto-links&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;toolbar&#39;]		= true;
			SyntaxHighlighter.all();
			&lt;/script&gt;
			&lt;!--[/syntaxhighlighter]--&gt;						

</description>
        <pubDate>Tue, 15 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-15-http-post-mojolicious.html-e69430dd0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-15-http-post-mojolicious.html-e69430dd0.html</guid>
        
        
      </item>
    
      <item>
        <title>自动补完不算什么，一键直达目录才是终极神器！</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在命令行中切换目录是最常用的操作，不过很少有比一遍又一遍重复“cd ls cd ls cd ls ……”更令人沮丧的事情了。如果你不是百分百确定你想要进入的下一个目录的名字，那么你不得不使用ls来确认，然后使用cd来进入你想要进的那一个。所幸的是，现在大量的终端和shell语言提供了强大的自动补全功能来处理该问题。但是，你仍然需要一直疯狂地敲击TAB键来干这事。如果你和我一样懒惰，你一定会对autojump感到惊喜。&lt;/p&gt;
&lt;p&gt;autojump是一个命令行工具，它允许你可以直接跳转到你喜爱的目录，而不用管你现在身在何处。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;在Linux上安装autojump&lt;/h3&gt;
&lt;p&gt;在Ubuntu或Debian上安装autojump：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo apt-get install autojump&lt;/pre&gt;
&lt;p&gt;要在CentOS或Fedora上安装autojump，请使用yum命令。在CentOS上，你需要先&lt;a href=&quot;http://xmodulo.com/2013/03/how-to-set-up-epel-repository-on-centos.html&quot;&gt;启用EPEL仓库&lt;/a&gt;才行。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo yum install autojump&lt;/pre&gt;
&lt;p&gt;在Archlinux上安装autojump：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo pacman -S autojump&lt;/pre&gt;
&lt;p&gt;如果你找不到适合你的版本的包，你可以从&lt;a href=&quot;https://github.com/joelthelion/autojump&quot;&gt;GitHub&lt;/a&gt;上下载源码包来编译。&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;autojump的基本用法&lt;/h3&gt;
&lt;p&gt;autojump的工作方式很简单：它会在你每次启动命令时记录你当前位置，并把它添加进它自身的数据库中。这样，某些目录比其它一些目录添加的次数多，这些目录一般就代表你最重要的目录，而它们的“权重”也会增大。&lt;/p&gt;
&lt;p&gt;现在不管你在哪个目录，你都可以使用下面的语法来直接跳转到这些目录：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;autojump [目录的名字或名字的一部分]&lt;/pre&gt;
&lt;p&gt;注意，你不需要输入完整的名称，因为autojump会检索它的数据库，并返回最可能的结果。&lt;/p&gt;
&lt;p&gt;例如，假定我们正在下面的目录结构中工作。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/5ac2b235e8f05cf2e114fb3dfe2969d5.jpg&quot; rel=&quot;lightbox[73611]&quot; title=&quot;自动补完不算什么，一键直达目录才是终极神器！&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73608&quot; alt=&quot;rger140043jbr5bwr2n1znj87c&quot; src=&quot;/images/jobbole.com/27ecc25eed09c8f3d23f5ec33fcad643.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么下面的命令将直接让你跳到/root/home/doc下，不管你当前位置在哪里。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump do&lt;/pre&gt;
&lt;p&gt;如果你也很讨厌打字，那么我推荐你为autojump起个别名，或者使用默认的别名。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ j [目录的名字或名字的一部分]&lt;/pre&gt;
&lt;p&gt;另外一个引人注目的功能是，autojump支持zsh和自动补完。如果你不确认哪里是不是你要跳转的地方，敲击TAB键就会列出完整路径。&lt;/p&gt;
&lt;p&gt;还是同样的例子，输入：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump d&lt;/pre&gt;
&lt;p&gt;然后敲击tab键，将会返回/root/home/doc或者/root/home/ddl。&lt;/p&gt;
&lt;p&gt;最后，对于高级用户，你可以访问目录数据库，并修改它的内容。可以使用下面的命令来手动添加一个目录：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump -a [目录]&lt;/pre&gt;
&lt;p&gt;如果你突然想要把当前目录变成你的最爱和使用最频繁的文件夹，你可以在该目录通过命令的参数 i 来手工增加它的权重&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump -i [权重]&lt;/pre&gt;
&lt;p&gt;这将使得该目录更可能被选择跳转。相反的例子是在该目录使用参数 d 来减少权重：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump -d [权重]&lt;/pre&gt;
&lt;p&gt;要跟踪所有这些改变，输入：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump -s&lt;/pre&gt;
&lt;p&gt;这会显示数据库中的统计数据。而以下：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump --purge&lt;/pre&gt;
&lt;p&gt;命令将会把不再存在的目录从数据库中移除。&lt;/p&gt;
&lt;p&gt;简言之，autojump将会受到所有命令行高级用户的欢迎。不管你是在ssh进一台服务器，还是仅仅想要追随复古潮流，敲更少的键来减少导航时间总是件好事。如果你真的热衷于此类工具，你也肯定也想看看&lt;a href=&quot;https://github.com/clvv/fasd&quot;&gt;Fasd&lt;/a&gt;，它应该会给你一个惊喜——我们下次再介绍它。&lt;/p&gt;
&lt;p&gt;你觉得autojump怎么样？你会经常用它么？发表一下你的评论吧。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Tue, 15 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-15-73611-c58e1239a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-15-73611-c58e1239a.html</guid>
        
        
      </item>
    
      <item>
        <title>在线扑克如何作弊：一次软件安全研究</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?--&gt;&lt;/p&gt;
&lt;p&gt;扑克是一种风靡世界的纸牌游戏，我们不仅可以在家中的餐桌上、赌场上、或者桥牌室中玩扑克，现在还可以在网上玩。我们研究可靠软件技术的一些人也玩扑克。因为我们现在都会花大量的时间在网上，所以将打扑克和可靠软件技术研究结合在一起只是时间问题。我们将在线扑克游戏和软件安全结合起来研究后，发现一个巨大的安全漏洞，这就是本篇文章所要讲的。&lt;/p&gt;
&lt;p&gt;人们可以在PlanetPoker这样的互联网桥牌室与其他人打德州扑克，这些游戏是实时的，而且用真钱。由于我们的主要工作是为公司提供安全、可靠且健壮的软件，所以我们很好奇在线游戏背后的软件是什么样的。它如何运行？是否公平？我们查看了PlanetPoker网站上的FAQ页面，这个页面包含它们的洗牌算法（为展现游戏公平性而公开洗牌算法，这还是很令人惊讶的），这些足以开始我们的分析了。当我们看到洗牌算法时，就开始怀疑这其中可能有问题。一个小小的调查研究证明这种直觉是正确的。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;游戏&lt;/h2&gt;
&lt;p&gt;在德州扑克中，每个玩家发两张牌（称作底牌）。最初的发牌后是一轮下注。第一轮下注结束后，接下来所有的发牌都是牌面朝上，所有玩家都可以看到的。庄家在牌桌上发三张牌面朝上的牌（称为翻牌），然后就是第二轮下注。德州扑克一般是定额下注，就是说每个玩家在每一轮下注都是定额。比如，在3美元到6美元的游戏中，前两轮是3美元赌注，而第三轮和第四轮是6美元赌注。第二轮下注后，庄家在牌桌上再发一张牌面朝上的牌（称为转牌），然后就是第三轮下注。最后，庄家在牌桌上再发最后一张牌面朝上的牌（称为河牌），然后就是最后一轮下注。剩余的每个玩家使用自己手中的两张底牌和牌桌上的五张公共牌，从这七张牌中选五张，凑成最大的组合。玩家凑成的成手牌的好坏由标准扑克成手牌顺序决定。&lt;/p&gt;
&lt;p&gt;德州扑克是一种快节奏的，令人兴奋的游戏。这个游戏很重要的一个组成是虚张声势，并且玩家要对其他玩家持有的牌做快速判断，这些判断决定谁是最终的胜者。有趣的是，德州扑克还是每年在拉斯维加斯举办的世界扑克系列赛中的其中一项。&lt;/p&gt;
&lt;p&gt;既然现在每个人和他们的狗都是在线的，而且几乎所有类型的业务都被呈现在互联网上，那么在线赌场和桥牌室的出现就再自然不过了。虽然说要进赌场的话，去印第安保留区和河船就很容易做到，但是更方便的参与游戏仍是现在的真实需求。如果能在自己家舒舒服服的上网娱乐（更别说可以穿着自己的睡衣），不用忍受二手烟，以及那些令人讨厌的玩家，这绝对是很吸引人的。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;安全风险无处不在&lt;/h2&gt;
&lt;p&gt;所有的便利都伴随着一定的代价。很不幸，玩在线扑克存在真正的风险。赌场本身可能就是一个骗局，其存在只是为了从玩家手上拿钱，它根本没有打算回报玩家任何胜局。运行在线赌场的服务器也可能被恶意攻击者破解，以获得信用卡号码，或者尝试在游戏中利用一些优势。因为大多数赌场不对玩家的客户端程序和托管纸牌游戏的服务器之间的网络流量进行认证和加密，可想而知，一个恶意玩家就可能检查这些网络流量（采用经典的中间人攻击），以确定对手牌。这些风险都是网络安全专家非常熟悉的。&lt;/p&gt;
&lt;p&gt;串通也是一个扑克所独有的问题（不同于其他游戏，如21点或掷骰子）。因为扑克玩家互相对抗，他们的对手并不是赌场本身。当一个桌子上的两个或多个玩家互相串通时，他们作为一个团队一起玩，往往会使用相同的资金。互相串通的玩家知道他们团队成员手上的牌（通常是通过细微的信号），而且他们为使团队获得最大的利益而下注，不管是团队中的谁赢都行。串通在现实的桥牌室中是一个问题，但对在线扑克来说，这个问题更严重。在线玩家可以使用即时通讯工具、电话会议聊天工具等，这使得串通问题成为一个严重的风险。如果一个在线游戏的所有玩家都一起合作，来欺骗那些不质疑网络安全的，容易受骗的玩家怎么办？你怎么保证你永远不会成为这些攻击的受害者呢？&lt;/p&gt;
&lt;p&gt;最后也很重要的一个风险（特别是对本文而言），就是在线扑克软件本身可能存在缺陷。软件问题是引起安全风险的一种臭名昭著的形式，而且它常常被过分相信防火墙和加密技术的公司所忽略。软件应用程序会给一个系统带来非常多的安全漏洞，我们每天都会花大量的时间来找出并解决这些软件安全问题，所以我们注意到在线扑克也是迟早的事。本文的其余部分就专门来讨论我们在一个流行的在线扑克游戏中发现的软件安全问题。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;软件安全风险&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;洗虚拟牌&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们关注的第一个软件缺陷涉及洗虚拟牌。公平洗牌意味着什么呢？本质上来说，它意味着牌的所有可能组合出现的概率相等，我们称对这52张牌的每个排序为一次洗牌。&lt;/p&gt;
&lt;p&gt;对真实的一副牌，有52!（约2^226）种不重复的洗牌。计算机洗一副虚拟牌时，它从这些可能的组合中选一种。现在有很多洗牌算法，一些算法优于其它，一些则是完全错误的。&lt;/p&gt;
&lt;p&gt;ASF软件公司开发的算法被大部分在线扑克游戏所使用。我们发现他们的洗牌算法有很多缺陷，根据这些发现，我们联系了ASF公司，他们更改了他们的算法，但是我们还没有看他们的新算法。从安全角度确保一切都完全正确并不容易啊（本文的其余部分将会介绍）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图表一：有缺陷的ASF洗牌算法&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: pascal; gutter: true&quot;&gt;procedure TDeck.Shuffle;
var
    ctr: Byte;
    tmp: Byte;

    random_number: Byte;
begin
    { Fill the deck with unique cards }
    for ctr := 1 to 52 do
        Card[ctr] := ctr;

    { Generate a new seed based on the system clock }
    randomize;

    { Randomly rearrange each card }
    for ctr := 1 to 52 do begin
        random_number := random(51)+1;
        tmp := card[random_number];
        card[random_number] := card[ctr];
        card[ctr] := tmp;
    end;

    CurrentCard := 1;
    JustShuffled := True;
end;&lt;/pre&gt;
&lt;p&gt;上面是ASF软件公司发布的洗牌算法，以使人们相信他们的计算机生成的洗牌是完全公平的。不过讽刺的是，这一举措对我们来说是完全相反的效果。&lt;/p&gt;
&lt;p&gt;算法开始时先初始化一个数组，其值按顺序依次为1到52，代表52张可能的牌。然后程序用系统时间作种子，调用Randomize()初始化一个伪随机数发生器。实际的洗牌是通过依次将数组中的每个位置与一个随机选择的位置交换。这个随机选择的位置是通过调用伪随机数发生器选择的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题一：大小差一（Off-By-One）错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;精明的程序员就会发现，该算法包含一个大小差一（off-by-one）错误。该算法遍历初始的那副牌，将其每张牌与其它任意牌交换。然而和大多数Pascal函数不同，Random(n)函数实际上返回一个0到n-1的数字，而不是1到n。算法利用接下来的一小段代码来选择与当前牌交换的牌：这个公式设置一个值在1到51之间的随机数。总之，该算法从不选择最后一张牌与当前牌交换。当ctr最终指向最后一张牌，也就是第52张牌时，这张牌可以与任何其它牌交换，除了它自身。也就是说，这个洗牌算法从不允许第52张牌在洗牌结束后依然在第52个位置。这很明显违反了公平原则，不过很容易修复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题二：设计不良的洗牌分布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进一步考察该洗牌算法后，我们发现，即使不考虑大小差一（off-by-one）问题，该算法返回的洗牌结果也不是均匀分布的。该洗牌的核心基本算法如图2所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;洗牌&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进一步考察算法后发现，即使不考虑大小差一（off-by-one）错误，该算法返回的洗牌结果也不是均匀分布的。也就是说，一些洗牌结果出现的概率比其它洗牌结果出现的概率大。如果一个玩家知道这个漏洞，就可以在一个牌桌上坐很久，从而利用这种不均匀分布的优势。&lt;/p&gt;
&lt;p&gt;我们用一个小例子来说明这种问题，这里我们采用上述洗牌算法来洗牌，这副牌只有三张（n=3）。&lt;/p&gt;
&lt;p&gt;图2：不要这样洗牌&lt;/p&gt;
&lt;pre class=&quot;brush: pascal; gutter: true&quot;&gt;for (i is 1 to 3)
    Swap i with random position between i and 3&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0e8cca2e064262251dfcba44f3ba596a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;图2描述了我们所采用的洗牌算法，并且描绘了采用该算法生成所有可能的洗牌结果的树。如果随机数源设计良好的话，那么这棵树中所有叶子出现的概率相等。&lt;/p&gt;
&lt;p&gt;即使只考虑这个小例子，我们就可以发现，该算法的洗牌结果不是等概率的。231、213、132比312、321、123出现的更频繁。如果你要对第一张牌下注，并且你知道上述这些洗牌结果的出现概率，你就会知道牌2比其它牌出现的概率大。而当一副牌的牌数增加时，这种概率不等现象会愈发被放大。当用上述算法洗52张牌时（n=52），洗牌的这种不均匀分布会造成某些手牌出现概率偏大，从而改变赔率。一些经验丰富的玩家，他们专门研究赔率，然后就可以利用这种倾斜的手牌概率来赢得赌博。&lt;/p&gt;
&lt;p&gt;图3：可以这样洗牌&lt;/p&gt;
&lt;pre class=&quot;brush: pascal; gutter: true&quot;&gt;for (i is 1 to 3)
    Swap i with random position between i and 3&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7a61e6133f5fc4f336f88bb6e3ed472d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3提供了一个更好的洗牌算法。它与上述算法的关键区别在于，遍历一副牌时，每张牌可能的交换位置减少了。同样，我们用三张牌的洗牌树来解释这个算法。和ASF提供的算法不同，该新算法将每张牌i与[i，n]中的某张牌交换，而不是[1，n]中的某张牌交换，从而将叶子数从3^3=27减少到了3!=6.这很重要，因为n!个不同的叶子意味着，所有可能的洗牌结果，新洗牌算法都会洗出一次，而且仅仅一次，从而每种洗牌结果出现的概率相等，这才是公平！&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;在确定性机器上生成随机数&lt;/h3&gt;
&lt;p&gt;我们讨论的第一组软件缺陷仅仅改变某些牌出现的概率，一些聪明的赌徒可以利用这种概率倾斜为自己创造优势，但是这种缺陷并不会完全破环这个系统。相比之下，这部分我们将要讨论的第三种缺陷，绝对是可以让在线扑克玩家完全妥协的“好东西”了。首先我们简短介绍伪随机数生成器，为下文奠定基础。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;伪随机数生成器原理&lt;/h3&gt;
&lt;p&gt;假设我们要生成1到52之间的一个随机数，每个数字等概率出现。理想情况下，我们生成0到1之间的一个值，然后将这个值乘以52，其中每个值等概率出现，且不受前值影响。注意0到1之间有无穷多个数，但是计算机不提供无限精度。&lt;/p&gt;
&lt;p&gt;为使计算机做到上述算法所描述的，伪随机数生成器通常产生一个从0到N之间的整数，然后用那个整数除以N，这样返回结果就总是0到1之间的数了。之后我们调用生成器时，它将第一次调用产生的整数结果传递给一个函数，这个函数生成一个0到N之间的新整数，然后返回新整数除以N的结果。这意味着，任何伪随机数生成器返回的唯一值的数目被限定为0到N之间整数的个数。而在大多数常见的随机数生成器中，N是2^32（约40亿），也就是32位数的最大值。换句话说，这种生成器最多能产生40亿个可能的值。扳起手指数一数也知道，40亿不算多。&lt;/p&gt;
&lt;p&gt;开始要给伪随机数生成器提供一个种子，作为初始的整数，将其传递给那个函数。种子是生成随机数字序列的开端。要注意，伪随机数生成器的输出是完全可预测的，它返回的每个值都完全由其先前返回的值决定（最终，由种子决定，即种子是一切的开始）。如果我们知道用于计算任意一个值的那个整数，那么生成器后续给出的所有值都是可知的。&lt;/p&gt;
&lt;p&gt;图4是宝蓝（Borland）编译器提供的伪随机数生成器，它就是一个很好的例子。如果我们知道RandSeed的当前值为12345，那么它产生的下一个整数是1655067934，然后其返回值将是20.由于计算机是完全确定性的机器，所以事情总是如此。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图4：宝蓝的Random()函数实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: pascal; gutter: true&quot;&gt;long long RandSeed = #### ;

unsigned long Random(long max)
{
     long long x ;
     double i ;
     unsigned long final ;
     x = 0xffffffff;
     x += 1 ;

     RandSeed *= ((long long)134775813);
     RandSeed += 1 ;
     RandSeed = RandSeed % x ;
     i = ((double)RandSeed) / (double)0xffffffff ;
     final = (long) (max * i) ;

     return (unsigned long)final;
}&lt;/pre&gt;
&lt;p&gt;历史经验表明，随机数生成器的种子通常是基于系统时钟产生，也就是用系统时间的某些方面作为种子。这意味着，如果你知道生成器是基于哪个时间做种子，你就知道生成器将会生成的所有数值（包括数字出现的顺序）。这一切的结果是，伪随机数完全可预知。毋庸置疑，这一事实对洗牌算法影响深远。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;在玩扑克时，随机数生成器是如何被错误使用的&lt;/h3&gt;
&lt;p&gt;ASF软件使用的洗牌算法总是开始于一副有序的牌，然后生成一个随机数序列，用于重排那副牌。回想一下，一副真正的扑克牌有52!（约2^226）种各不相同的洗牌结果，而一个32位随机数生成器的种子必须是一个32位数，也就是只有40多亿个可能的种子。而每次洗牌前，都会对牌以及生成器种子初始化，所以该算法只能产生40多亿个可能的洗牌结果，而40多亿要远远小于52!.&lt;/p&gt;
&lt;p&gt;更糟的是，图一所示的算法采用Pascal函数Randomize()为随机数生成器选择种子。Randomize()函数基于午夜开始的毫秒数选择种子，一天只有86,400,000毫秒。因为这些数字被用作生成器的种子，从而可能的洗牌结果缩减为86,400,000个。八千六百万要远远小于40亿，但这还不是最糟的。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;破坏系统&lt;/h3&gt;
&lt;p&gt;了解系统时钟种子后，我们有一个想法，可以把洗牌结果数目减少的更多。通过将我们的程序与生成伪随机数的服务器系统时钟同步，我们可以将可能的组合数降至200,000之后，这个系统就是我们的了，因为搜索这么小的洗牌结果集完全不在话下，在PC上就可以实时完成。&lt;/p&gt;
&lt;p&gt;RST攻击本身要求这副牌中的5张牌已知，基于这5张已知牌，我们的程序搜索那几十万个洗牌结果集，然后推导出完美匹配的一个。在德州扑克这个案例中，我们的程序将作弊玩家的两张底牌以及前三张翻牌（公共牌）作为输入。这五张牌在第一轮下注后就全部已知了，有这些信息就足以让我们在比赛中实时确定准确的洗牌结果。图5是我们为攻击粗粗设计的GUI。左上角的“Site Parameters“框用于同步时钟，右上角的”Game Parameters“用于输入5张牌，并初始化搜索。图5是所有的牌都被程序确定后的一张截图。我们现在知道谁拿了什么牌，以及剩余的翻牌值，还有谁会提前赢。&lt;/p&gt;
&lt;p&gt;图5：攻击的图形用户界面GUI&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/91be54747f410cb6ea96db240de16647.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;一旦知道5张牌，我们的程序就开始不断的生成洗牌，直到那个洗牌中包含这5张牌，并且顺序也一样。由于Randomize()函数基于服务器的系统时间，因此在合理精度内猜对开始的种子并不难（猜得越接近，需要搜索的洗牌结果数就越少）。然而最棒的是这个，一旦找到一个正确的种子，就有可能在几秒钟内将我们的攻击程序与服务器同步。这种事后同步允许我们的程序不到1秒就确定随机数生成器使用的种子，以及接下来游戏将要使用的所有的洗牌。&lt;/p&gt;
&lt;p&gt;除了技术细节，我们的攻击也被很多新闻媒体所报道，这种媒体覆盖也体现了这个发现人性的一面。登陆我们的&lt;a href=&quot;http://www.cigital.com/&quot; target=&quot;_blank&quot;&gt;网站&lt;/a&gt;&lt;a href=&quot;http://www.cigital.com/&quot;&gt;Web site&lt;/a&gt; ，可以看到我们最初的发布稿 &lt;a href=&quot;http://www.cigital.com/news/index.php?pg=art&amp;amp;artid=20&quot;&gt;original press release&lt;/a&gt;，CNN视频剪辑，还有纽约时报的一个故事。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;洗虚拟牌的正确做法&lt;/h3&gt;
&lt;p&gt;正如我们所见，洗虚拟牌乍看容易，其实不然。要写洗牌算法，最好的方法是，基于扎实的数学基础开发一种可以安全地产生良好的洗牌的技术。此外，我们认为发布一个好算法，并允许被大家审查，是一个很不错的想法（这与开源狂热者的观点不谋而合），关键是不能置安全性于模糊状态。像ASF一样发布一个差算法并不好，但不发布这样的差算法也不好！&lt;/p&gt;
&lt;p&gt;密码学基于坚实的数学基础开发健壮的算法，用于保护个人、政府和商业机密，而不是基于模糊的理论。洗牌也一样，我们可以将加密密钥的长度与随机种子的规模做类比，其中，加密密钥的长度直接关系到很多加密算法的强度。&lt;/p&gt;
&lt;p&gt;开发一个洗牌算法相当简单。首先要清楚，算法不需要能产生52!种洗牌结果，因为玩牌时只会用到很少部分的洗牌结果。然而算法产生的洗牌结果必须是均匀分布的，这非常重要。良好的分布确保在一次洗牌中，每张牌在每个位置出现的概率基本相等。这个分布性要求相对容易实现和验证。下面的伪代码描述了一个简单的洗牌算法，如果配上合适的随机数生成器，该算法产生的洗牌结果是均匀分布的。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;START WITH FRESH DECK
GET RANDOM SEED
FOR CT = 1, WHILE CT &amp;lt;= 52, DO
X = RANDOM NUMBER BETWEEN CT AND 52 INCLUSIVE
SWAP DECK[CT] WITH DECK[X]&lt;/pre&gt;
&lt;p&gt;这个算法成功的关键在于随机数生成器（RNG）的选择。RNG直接影响上述算法能否成功的产生均匀分布的洗牌，以及这些洗牌能否用于安全的在线牌类游戏。首先，RNG本身必须产生均匀分布的随机数。一些伪随机数生成器（PRNG）已经被证明具有此数学属性，比如基于Lehmer算法的伪随机数生成器。这些好的PRNG足以用于生成洗牌时的“随机“数。&lt;/p&gt;
&lt;p&gt;正如我们所见，初始种子的选择是成功与否的关键。所有的事情最终都归结于种子。因此，玩家在玩由PRNG生成的洗牌时，无法确定生成该副洗牌所使用的种子，这一点至关重要。&lt;/p&gt;
&lt;p&gt;要确定生成特定洗牌所使用的种子，一种蛮力做法是，系统地遍历所有可能的种子，生成相应的洗牌序列，并将其与待寻找的洗牌序列对比。为避免这种攻击，可用的种子数一定要多，使得在特定时间限制内，执行穷举搜索不可行。但是要注意，找到一个匹配的洗牌平均只需搜索一半的种子空间。而对于在线扑克，特定时间限制应该是一场游戏的时长，这个时长通常以分钟计。&lt;/p&gt;
&lt;p&gt;根据我们的经验，运行在奔腾400计算机上的简单程序，可以每分钟检查大约200万个种子。按照这个速度，这个机器对32位种子空间（约2^32个可能的种子）的穷举搜索需一天多一点。尽管这个时长必然超过我们规定的那个时间限制，但是如果利用计算机网络执行分布式搜索，那么在我们的时间限制内完成搜索是完全可能的。&lt;/p&gt;
&lt;p&gt;我们讲蛮力攻击主要是想强调加密密钥长度与洗牌使用的种子之间的相似性。暴力破解密码攻击要尝试每个可能的密钥，以破解加密信息。同样，蛮力攻击洗牌算法也要检查所有可能的种子。有关加密密钥的长度，目前已有一个重大的研究发现。总体而言，该研究是这样的：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;3&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Algorithm&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Weak Key&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Typical Key&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Strong Key&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DES&lt;/td&gt;
&lt;td&gt;40 or 56&lt;/td&gt;
&lt;td&gt;56&lt;/td&gt;
&lt;td&gt;Triple-DES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RC4&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RSA&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;768 or 1024&lt;/td&gt;
&lt;td&gt;2048&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ECC&lt;/td&gt;
&lt;td&gt;125&lt;/td&gt;
&lt;td&gt;170&lt;/td&gt;
&lt;td&gt;230&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;人们以前认为实时破解56位的数据加密算法（DES）不可行，但事实并非如此。1997年1月，一个保密的DES密钥在96天内被找到。之后，又做到41天内破解，然后是56小时，然后是1999年1月，在22小时15分钟内破解。对短的密钥长度或者小的种子集来说，这种破解能力的飞跃发展当然不是好兆头。&lt;/p&gt;
&lt;p&gt;人们甚至还发明了专门的机器，用于破解加密算法。1998年，电子前沿基金会EFF就制造了一个专用机，用于破解DES信息。制造这个机器的目的在于强调DES是多么不堪一击（DES是一种流行的、政府认可的算法，要深入了解DES攻击，请点击 &lt;a href=&quot;http://www.eff.org/descracker/&quot;&gt;http://www.eff.org/descracker/&lt;/a&gt; ）。DES之所以易于被破解，与其密钥长度直接相关。由此可见，制造专用于破解RNG种子的机器也并非不可能啊。&lt;/p&gt;
&lt;p&gt;我们认为32位的种子空间不足以对抗猛烈的蛮力攻击，但是64位的种子空间应该足以抵抗几乎所有的蛮力攻击。因为现在很多计算机都支持64位整数，所以使用64位的种子就很有必要了，而且一个64位数应该足以避免洗牌时遭受蛮力攻击。&lt;/p&gt;
&lt;p&gt;单单用64位还不行。我们决不能断定攻击者肯定无法预测或估计PRNG使用的种子。如果他们有方法预测种子，那么上述蛮力攻击的计算压力就变得无关紧要了，因为相比而言，此时破坏整个系统还要容易的多。我们利用的漏洞，不仅仅是ASF的缺陷算法采用很小的32位的PRNG，还有该方法的种子依赖于一天之中的时间。我们已经证明，这种算法基本无随机性可言。&lt;/p&gt;
&lt;p&gt;总结分析一下，整个系统的安全依赖于选择一个不可预测的随机种子，要实现这样的选择，最好是采用基于硬件的技术。基于硬件的方法从物理环境直接拿到不可预测的随机数据。由于在线扑克等涉及真钱交易的游戏，都对安全性要求至高，所以有必要进行一些投资，以确保随机数生成器正确完成。&lt;/p&gt;
&lt;p&gt;总而言之，开发一个好的洗牌算法，并且采用经过验证的硬件设备为64位伪随机数生成器准备种子，有这两点，足以使洗牌实现公平性以及安全性。实现一个公平的系统并非很难，在线扑克玩家有权提出这样的要求。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Tue, 15 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-15-70736-aa634f1ba.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-15-70736-aa634f1ba.html</guid>
        
        
      </item>
    
      <item>
        <title>Swift Language Changes in Xcode 6 beta 3</title>
        <description>
 &lt;p&gt;The Swift programming language continues to advance with each new Xcode 6 beta, including new features, syntax enhancements, and behavioral refinements. Xcode 6 beta 3 incorporates some important changes, a few of which we’d like to highlight:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Array has been completely redesigned to have full value semantics to match the behavior of Dictionary and String. Now a &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; array is completely immutable, and a &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; array is completely mutable.&lt;/li&gt;
&lt;li&gt;Syntax “sugar” for Array and Dictionary has changed. Arrays are declared using &lt;span class=&quot;keyword&quot;&gt;[Int]&lt;/span&gt; as short hand for &lt;span class=&quot;keyword&quot;&gt;Array&amp;lt;Int&amp;gt;&lt;/span&gt;, instead of &lt;span class=&quot;keyword&quot;&gt;Int[]&lt;/span&gt;. Similarly, Dictionary uses &lt;span class=&quot;keyword&quot;&gt;[Key: Value]&lt;/span&gt; for &lt;span class=&quot;keyword&quot;&gt;Dictionary&amp;lt;Key, Value&amp;gt;&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The half-open range operator has been changed from &lt;span class=&quot;keyword&quot;&gt;..&lt;/span&gt; to &lt;span class=&quot;keyword&quot;&gt;..&amp;lt;&lt;/span&gt; to make it more clear alongside the &lt;span class=&quot;keyword&quot;&gt;...&lt;/span&gt; operator for closed ranges.&lt;/li&gt;
&lt;/ul&gt; &lt;p&gt;Xcode 6 beta is free to Registered Apple Developers and can be downloaded on the &lt;a href=&quot;https://developer.apple.com/xcode/downloads/&quot;&gt;Xcode downloads page&lt;/a&gt;. Read all about these and other changes in the complete &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/releasenotes/DeveloperTools/RN-Xcode/&quot;&gt;release notes for Xcode 6 beta 3.&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 15 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-15--id=3-f752832d5.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-15--id=3-f752832d5.html</guid>
        
        
      </item>
    
      <item>
        <title>一站式学习Wireshark（七）：Statistics统计工具功能详解与应用</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;Wireshark一个强大的功能在于它的统计工具。使用Wireshark的时候，我们有各种类型的工具可供选择，从简单的如显示终端节点和会话到复杂的如Flow和IO图表。本文将介绍基本网络统计工具。包括：捕捉文件摘要（Summary）,捕捉包的层次结构（Protocol Hirarchy）, 会话（Conversations）, 终端节点（Endpoints）, HTTP。&lt;/p&gt;
&lt;div&gt;
&lt;h1&gt;更多信息&lt;/h1&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从statistics菜单，选择&lt;strong&gt;Summary&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/aadb32a48278da7e97e35d6c53a43480.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如下图的截屏所示，你会看到：&lt;/p&gt;
&lt;p&gt;File：&lt;/p&gt;
&lt;p&gt;捕捉文件的一般信息，如文件名和路径，长度，等等&lt;/p&gt;
&lt;p&gt;Time：&lt;/p&gt;
&lt;p&gt;第一个包和最后一个包的时间戳，以及抓包过程持续时间&lt;/p&gt;
&lt;p&gt;Capture：&lt;/p&gt;
&lt;p&gt;显示文件捕捉于哪一个接口，以及评论窗口&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c678f0c4d509a5f83ae60d02d43414ae.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在窗口的较低部分是&lt;strong&gt;Display&lt;/strong&gt;窗口，展示抓包文件统计信息的摘要，包括：&lt;/p&gt;
&lt;p&gt;捕捉报文的总数与百分比&lt;/p&gt;
&lt;p&gt;显示报文的数量（加上过滤条件之后）&lt;/p&gt;
&lt;p&gt;标记报文的数量&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4dfb098373d67e9751ae9cf32197dfa3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一菜单简单收集所有抓包数据，在定义了过滤条件的时候，将呈现过滤后的数据。当想要知道每秒的平均报文数或是字节数时，可以使用此工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Protocol Hierarchy:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一部分阐述如何确知网络运行数据。从statistics菜单，选择&lt;strong&gt;Protocol Hierarchy&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/26960ecb8b7d009daac3dcec26b023c2.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个窗口现实的是捕捉文件包含的所有协议的树状分支。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fd250c8be18a6b290bd5ed06915efa9c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;Protocol Hierarchy窗口有如下字段：&lt;/p&gt;
&lt;p&gt;Protocol：&lt;/p&gt;
&lt;p&gt;协议名称&lt;/p&gt;
&lt;p&gt;% Packets：&lt;/p&gt;
&lt;p&gt;含有该协议的包数目在捕捉文件所有包所占的比例&lt;/p&gt;
&lt;p&gt;Packets：&lt;/p&gt;
&lt;p&gt;含有该协议的包的数目&lt;/p&gt;
&lt;p&gt;Bytes：&lt;/p&gt;
&lt;p&gt;含有该协议的字节数&lt;/p&gt;
&lt;p&gt;Mbit/s：&lt;/p&gt;
&lt;p&gt;抓包时间内的协议带宽&lt;/p&gt;
&lt;p&gt;End Packets：&lt;/p&gt;
&lt;p&gt;该协议中的包的数目（作为文件中的最高协议层）&lt;/p&gt;
&lt;p&gt;End Bytes：&lt;/p&gt;
&lt;p&gt;该协议中的字节数（作为文件中的最高协议层）&lt;/p&gt;
&lt;p&gt;End Mbit/s：&lt;/p&gt;
&lt;p&gt;抓包时间内的协议带宽（作为文件中的最高协议层）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小贴士：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包通常会包含许多协议，有很多协议会在每个包中被统计。End Packets，End Bytes，End Mbit/s列是该层在抓包中作为最后一层协议的统计数据（也就是说，协议处于报文的顶层，并且没有更高层信息了）。例如，没有载荷的TCP报文（例如，SYN报文），这一类没有负载任何上层信息的报文。这就是为什么在Ethernet层，IPv4层和UDP层报文计数为0，因为没有接收到以这些协议作为最后一层的帧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值得注意的两点是：&lt;/p&gt;
&lt;p&gt;百分比永远指的是相同协议层级。例如，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用要点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. Percentage永远参照的是相同协议层。例如，上例中81.03%是IPv4报文，8.85%是IPv6报文，10.12%是ARP报文。第二层之上的各协议所占百分比总和是100%。&lt;/p&gt;
&lt;p&gt;2. 另一方面，TCP占总数据的75.70%，在TCP协议之内，只有12.74%的报文是HTTP，除此之外没有其他统计。这是由于Wireshark只统计有HTTP头的报文。它不统计如确认报文或数据报文这样没有HTTP头的报文。&lt;/p&gt;
&lt;p&gt;3. 为了使Wireshark同时统计数据报文，例如，TCP报文内部的HTTP报文，关闭&lt;strong&gt;Allow sub-dissector&lt;/strong&gt;选项，对TCP数据流重新统计。可在&lt;strong&gt;Preferences&lt;/strong&gt;菜单或&lt;strong&gt;Packet Details&lt;/strong&gt;面板中右键&lt;strong&gt;TCP&lt;/strong&gt;来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conversations：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 在Statistics菜单中，选择&lt;strong&gt;Coversations&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bd6f1f07d4649683896fbad45cda9d06.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2. 会看到以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/eabdf42a7432afe6ac200cdadcaa9d67.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 可以选择第2层以太网统计数据，第3层IP统计数据，或第4层TCP或UDP统计数据。&lt;/p&gt;
&lt;p&gt;4. 可以选择以下统计工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;On layer 2(Ethernet)&lt;/strong&gt;：查找并过滤广播风暴或&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;On layer 3 or 4(TCP/IP)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;通过互联网路由器端口并行连接，查看谁在向ISP传输数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;小贴士：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你看到互联网上某一IP地址通过端口80（HTTP）向外传输大量数据流，你就需要将该地址复制入浏览器并且查看你的用户与哪一个网站通讯最多。&lt;/p&gt;
&lt;p&gt;如果没有得到结果，只需到标准DNS查询站点（Google一下DNS lookup）查看哪一种流量占用了你的网线。&lt;/p&gt;
&lt;p&gt;5. 也可以通过选择位于窗口左下方的&lt;strong&gt;Limit to display filter&lt;/strong&gt;复选框&lt;strong&gt;，&lt;/strong&gt;将会话统计信息进行显示过滤。这样，仅呈现所有通过显示过滤条件的统计数据。&lt;/p&gt;
&lt;p&gt;6.要查看IP地址对应名称，可以选择&lt;strong&gt;Name resolution&lt;/strong&gt;复选框。要查看IP名称解析，进入&lt;strong&gt;View | Name Resolution | Enable for Network layer&lt;/strong&gt;进行激活。&lt;/p&gt;
&lt;p&gt;7. 对于TCP或UDP，可以在Packet list中对指定报文进行标记，之后从菜单中选择&lt;strong&gt;Follow TCP Stream&lt;/strong&gt;或&lt;strong&gt;Follow UDP Stream&lt;/strong&gt;。从而定义一个显示过滤条件，仅显示指定数据流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用要点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络会话是两个指定终端之间的数据流。例如，IP会话是两个IP地址之间的所有数据流，TCP会话包含了所有TCP连接。&lt;/p&gt;
&lt;p&gt;通过&lt;strong&gt;Conversations&lt;/strong&gt;列表，能看出很多网络问题。&lt;/p&gt;
&lt;p&gt;以太网会话统计&lt;/p&gt;
&lt;p&gt;在Ethernet conversations statistics中，查找以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大量的广播风暴：可以看见较轻微的广播风暴；而对于每秒数千甚至数万个报文的严重广播风暴，Wireshark会停止显示数据并且屏幕冻结。只有断开Wireshark连接时才能看见。&lt;/li&gt;
&lt;li&gt;如果你看到来自某一MAC地址的大量数据，查看会话第一部分的vendor ID，会给你一些导致问题的线索。即使MAC地址的第一部分标识了vendor，但它并不一定就标识了PC本身。这是由于MAC地址属于PC上安装的以太网芯片厂商，而并不一定属于PC制造商。如果无法识别数据流来源地址，可以ping嫌疑地址并通过ARP获取它的MAC地址，在交换机中查找该地址，如果有操作系统的话直接用find命令来定位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IP会话统计&lt;/p&gt;
&lt;p&gt;在IP conversations statistics中，查找以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看收发大量数据流的IP地址。如果是你知道的服务器（你记得服务器的地址或地址范围），那问题就解决了；但也有可能只是某台设备正在扫描网络，或仅是一台产生过多数据的PC。&lt;/li&gt;
&lt;li&gt;查看扫描模式（scan pattern）。这可能是一次正常的扫描，如SNMP软件发送ping报文以查找网络，但通常扫描都不是好事情。&lt;/li&gt;
&lt;li&gt;一次典型的扫描模式如下图所示：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/439a1e3c42fba8cead8cff27c35e8332.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;本例中的扫描模式，一个IP地址，192.168.110.58，发送ICMP报文至192.170.3.44, 192.170.3.45, 192.170.3.46, 192.170.3.47,等等（上图仅显示扫描的很小一部分）。这种情况下我们有一个蠕虫病毒感染了网络上的所有PC，在它感染PC的时候，它就开始产生ICMP请求并将它们发送至网络。这些窄带连接（例如：WAN连接）可以很容易地被封锁。&lt;/p&gt;
&lt;p&gt;TCP/UDP会话统计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看带有太多TCP连接的设备。每一个PC合理的连接数是10到20个，上百个则是不正常的。&lt;/li&gt;
&lt;li&gt;尝试查找无法辨识的端口号。它可能是正常的，但也可能是有问题的。下图显示了一次典型的TCP扫描：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8d10d243fac731a5e7c7ac80acd4afe7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Endpoints:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;/strong&gt;从statistics菜单，选择&lt;strong&gt;Endpoints&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bff9e2e66d4e9efc5c49c806b8a8c662.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2. 出现以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4437c52b23b33f5460bf08b943bd670f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 此窗口中，能够看到第2,3,4层的endpoints，也就是以太网，IP, TCP或UDP。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用要点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一工具列出了Wireshark发现的所有endpoints上的统计信息。可以是以下任意一种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;少量以太网endpoints（MAC地址）与大量IP终端节点（IP地址）：可能的情况例如，一个路由器从很多远端设备收发报文，我们会看见路由器的MAC地址及很多IP地址经由此处。&lt;/li&gt;
&lt;li&gt;少量IP终端节点与大量TCP终端节点：可能的情况是每一台主机有很多个TCP连接。可能是有很多连接的服务器的一个正常操作，也可能是一种网络攻击（如SYN攻击）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是一个网络中心的抓包示例，一个内部网络有四个HP服务器和一个Cisco路由器，MAC地址的第一部分已经解析了厂商名称：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7db911d4df184d7b5745f86a38a7d015.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当我们查看IPv4:191下的endpoints，我们看到有很多来自192.168.10.0, 192.168.30.0，以及其他网络地址。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0755e4198d74eede37aca5c606afa55c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;/strong&gt;从statistics菜单，选择&lt;strong&gt;HTTP&lt;/strong&gt;，将会出现以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c938a97e3fc13e2119b2099a725c27bd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在HTTP子菜单中，可以看到以下信息：&lt;/p&gt;
&lt;p&gt;Packet Counter：&lt;/p&gt;
&lt;p&gt;每一个网站的报文数量。帮助识别有多少响应和请求。&lt;/p&gt;
&lt;p&gt;Requests：&lt;/p&gt;
&lt;p&gt;各网站的请求分布。&lt;/p&gt;
&lt;p&gt;Load Distribution：&lt;/p&gt;
&lt;p&gt;各网站的负载分布。&lt;/p&gt;
&lt;p&gt;按照以下操作步骤查看&lt;strong&gt;Packet Counter&lt;/strong&gt;统计信息：&lt;/p&gt;
&lt;p&gt;1. 进入&lt;strong&gt;Statistics | HTTP | Packet Counter。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2. 显示以下过滤窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0509837aa0e3547e4538b4046a3e0034.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 此窗口中，可设置过滤条件以查看符合过滤条件的统计信息。如果想要查看整个抓包文件的统计信息，留白不填。这就会显示IP层之上的统计信息，也就是所有HTTP报文。&lt;/p&gt;
&lt;p&gt;4. 点击&lt;strong&gt;Create Stat&lt;/strong&gt;按钮，会看到以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5aeba4c17e55cb23ba068c63f270f1d4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果要查看某一特定节点的HTTP统计信息，可以通过display filter的方式配置过滤条件。&lt;/p&gt;
&lt;p&gt;按照以下操作步骤查看&lt;strong&gt;HTTP Requests&lt;/strong&gt;统计信息：&lt;/p&gt;
&lt;p&gt;1. 进入&lt;strong&gt;Statistics | HTTP | Requests，&lt;/strong&gt;出现以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a189bfc000984c307f1eea30076c527a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2. 选择所需过滤条件。对于所有数据，留白。&lt;/p&gt;
&lt;p&gt;3. 点击&lt;strong&gt;Create Stat&lt;/strong&gt;按钮，会出现以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6778934bcfad139526d4b8dcd6601407.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;4. 要获得指定HTTP主机的统计信息，设置过滤条件http.host contains &amp;lt;host_name&amp;gt; 或 http.host==&amp;lt;host_name&amp;gt;。&lt;/p&gt;
&lt;p&gt;5. 例如，通过设置过滤条件http.host contains ndi-com.com，可以获得站点 &lt;a href=&quot;http://www.ndi-com.com/&quot; target=&quot;_blank&quot;&gt;www.ndi-com.com&lt;/a&gt;的统计信息，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2cab759a25ea0f261482513445623b3a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;6. 结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a42f66b3c4f3c6768bc996d087c25336.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;按照以下操作步骤查看&lt;strong&gt;Load Distribution&lt;/strong&gt;统计信息：&lt;/p&gt;
&lt;p&gt;1. 进入&lt;strong&gt;Statistics | HTTP | Load Distribution。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt; &lt;/strong&gt;出现以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/af5c7db6a5230248f9ae47d703bc5e82.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 选择所需过滤条件。对于所有数据，留白。&lt;/p&gt;
&lt;p&gt;4. 点击&lt;strong&gt;Create Stat&lt;/strong&gt;按钮，会出现以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/59a9cbd87223e3b2eba5722beeef8fb7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用要点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们打开一个网页，通常会向若干个URL发送请求。本例中，我们打开的其中一个网页是&lt;a href=&quot;http://www.cnn.xn--com%2Cedition-lx0r784c19zieax92bm2p.cnn.com/&quot; target=&quot;_blank&quot;&gt;www.cnn.com，并将我们导向edition.cnn.com&lt;/a&gt;。我们发送了若干个请求：到root URL，到breaking_news URL，以及主页上两个其他位置。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Mon, 14 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-14-73482-53135089a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-14-73482-53135089a.html</guid>
        
        
      </item>
    
      <item>
        <title>一站式学习Wireshark（六）：狙击网络高延时点</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在某些情况下，丢包可能并不是造成延时的原因。你可能会发现尽管两台主机之间通讯速度很慢，但这种慢速并没有伴随着TCP重传或是重复ACK的征兆。在这种情况下，需要使用另一种方式来定位高延时点。&lt;/p&gt;
&lt;p&gt;查找高延时点最有效的方法之一是检查最初的握手信号以及跟随其后的几个报文。例如，一个简单的客户端与网络服务器的连接，客户端尝试通过浏览器访问网络服务器的站点。我们只关心这一通信序列的前六个报文，包括TCP握手过程，首次HTTP GET请求，对此GET请求的确认，以及从服务器发至客户端的第一个数据报文。&lt;/p&gt;
&lt;div&gt;
&lt;h1&gt;更多信息&lt;/h1&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;正常通讯&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在讨论高延时状况之前，找一个正常的通讯作为参照。在第二节已经介绍过TCP握手过程以及HTTP通讯，这里不再赘述。在下面这张图里，我们关心的部分只有Time列：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/13fdeb837a35b3a269e49af2a916b108.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一通讯序列是非常快速的，整个过程耗时不到0.1秒。&lt;/p&gt;
&lt;p&gt;接下来几个抓包文件包含同样的traffic模式，但是在报文时序上有所不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;慢速通讯——线路延时：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们看看下面这个报文。注意到所有报文都是相同的，除了报文2和5的时间延时较长：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/78fe15de3cab8c56b8c4df57ebd79bb0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;逐一分析这六个报文，立刻就会看到第一次延时。客户端（172.16.16.128）发送首次SYN报文以开始TCP握手，在服务器（74.125.95.104）返回SYN/ACK之前，有0.87秒的延时。这是线路延时的第一个信号，这是由客户端和服务器之间的设备引起的。&lt;/p&gt;
&lt;p&gt;我们判断这是线路延时的依据是所传送的报文类型特征。当服务器接收到一个SYN报文，只需花费很少的处理过程就可发送回复，因为这一工作负载并不包含任何传输层之上的处理。即使服务器工作负载非常繁重，它通常也会快速地以SYN/ACK来回复SYN报文。这就排除了服务器是高延时的潜在原因。&lt;/p&gt;
&lt;p&gt;客户端也被排除的原因在于，它除了接收SYN/ACK报文之外，没有进行任何处理。&lt;/p&gt;
&lt;p&gt;这一抓包的前两个报文帮我们排除了客户端和服务器，并指出了潜在原因。&lt;/p&gt;
&lt;p&gt;继续分析，我们发现结束三步握手信号的ACK报文快速出现，客户端发送的HTTP GET请求也是如此。产生这两个报文的所有处理在本地客户端接收到SYN/ACK之后进行，因此在客户端没有繁重的负载需要处理的情况下，这两个报文预计会很快传送。&lt;/p&gt;
&lt;p&gt;到了报文5，我们看到另一个延时高得离谱的报文。出现在最初的HTTP GET请求发送过后，从服务器返回的ACK报文花费了1.15秒才收到。接收到HTTP GET请求之后，服务器在开始发送数据之前首先发送了一个TCP ACK，同样只需占用服务器很少的处理。这是另一个线路延时的信号。&lt;/p&gt;
&lt;p&gt;不管何时你经历着线路延时，你几乎总是会看到：在最初的握手信号期间的SYN/ACK报文，以及整个通讯过程的ACK报文中，存在着高延时。即使这一信息并没有告诉你网络上延时的确切原因，至少让你明白客户端和服务器都不是延时点所在，因此延时发生在两者之间的设备。这时，你应当开始检查受影响主机之间的各种防火墙，路由器，以及代理，以定位罪魁祸首。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;慢速通讯——客户端延时：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下一个延时场景的抓包如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4a76e09686f9b7c44d7994979711de41.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一抓包开始时很正常，TCP握手非常迅速，没有任何延时的迹象。正常状态持续至第四个报文：握手信号结束之后接收到一个HTTP GET请求。这个报文距离前一个接收到的报文有1.34秒的延时。&lt;/p&gt;
&lt;p&gt;要确认网络的延时点，需要检查第3和第4个报文之间发生了什么。报文3是客户端发送到服务器的TCP握手信号中的最后一个ACK，报文4是从客户端发送至服务器的GET请求。这两个报文的共同之处在于都是由客户端发送，并且独立于服务器。由于所有这些操作都集中在客户端上，GET请求应当在发送了ACK之后快速传送。&lt;/p&gt;
&lt;p&gt;不幸的是对于终端用户，从ACK到GET的传送并没有快速发生。GET报文的创建与传输取决于应用层的处理，这一过程中的延时意味着客户端无法及时的执行这一功能。这表示客户端最终为通讯中的高延时负责。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;慢速通讯——服务器延时：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后一个延时场景的抓包如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/625f40df7012781b93dcc32afe2605d0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这一抓包中，两个主机之间的TCP握手过程完成得干脆利落，因此开始时并无问题。接下来几个报文也很顺利，首个GET请求及回复ACK报文也在快速交付。直到最后一个报文，我们看到了高延时的信号。&lt;/p&gt;
&lt;p&gt;第六个报文是服务器响应客户端GET请求的第一个HTTP数据报文，但是在服务器发送GET请求的TCP ACK 0.98秒之后才到达。报文5和6的传送过程与我们在前一个场景所见ACK和GTE请求的传送类似。但是，在这一情况下，服务器是我们关注的焦点。&lt;/p&gt;
&lt;p&gt;报文5是服务器对从客户端接收GET请求的回应。只要该报文被发送，服务器就应当立即发送数据。这一读取，封装，传送的过程是由HTTP协议完成的，由于这是应用层协议，需要服务器参与处理过程。这一报文的延迟接收表明服务器无法在合理的时间内处理数据，最终指向服务器是延时点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延时定位思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过六个报文，我们能够定位服务器与客户端之间的网络高延时点。这些场景可能看起来有点复杂，但是下图能使你的定位延时过程变得简单快捷。这一原则几乎能应用于任何基于TCP的通讯。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e8395bfb6d7188aa8b202cd7cf8c87b3.jpg&quot;&gt;&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Mon, 14 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-14-73477-5f4626e65.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-14-73477-5f4626e65.html</guid>
        
        
      </item>
    
      <item>
        <title>lvs FullNAT顿卡问题原因追查</title>
        <description>                &lt;h2&gt;问题描述：&lt;/h2&gt;
&lt;p&gt;在FullNAT在使用过程中，在开启SYNProxy的情况下，采用CURL去连接某个URL，会有偶尔卡顿一下，命令如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for i in `seq 1 10000`;do curl -o &#39;/dev/null&#39; -w &quot;%{time_total}:%{time_connect}:%{time_appconnect}:%{time_starttransfer}\n&quot;  http://192.168.1.100 &amp;gt;&amp;gt; fullnat.txt ; done&lt;br&gt;
100   582  100   582    0     0  54356      0 --:--:-- --:--:-- --:--:-- 58200&lt;br&gt;
% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&lt;br&gt;
                                   Dload  Upload   Total   Spent    Left  Speed&lt;br&gt;
100   582  100   582    0     0  54586      0 --:--:-- --:--:-- --:--:-- 58200&lt;br&gt;
% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&lt;br&gt;
                                   Dload  Upload   Total   Spent    Left  Speed&lt;/code&gt;&lt;br&gt;
以上命令偶尔会出现6s左右的超时等待。这个事情很神奇，为什么是6s呢，不是其他数字呢，如果是丢包的话，时间为什么这么固定呢，猜测这可能跟程序的实现有关系？&lt;/p&gt;
&lt;h2&gt;抓包复现：&lt;/h2&gt;
&lt;p&gt;我们在FullNAT机器和RealServer机器同时抓包。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://noops.me/wp-content/uploads/2014/07/fullnat-packet.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
第一张图是在fullnat机器上抓的，是从client到fullnat的包，第二张图在real server上抓的，是从fullnat到real server的包，从图中可以看出，从xx.xx.116.25到xx.xx.48.24，xx.xx.116.25是client，xx.xx.48.24为fullnat的vip,从第一张图中看出，完成了三次握手以后，client就开始请求数据包，但是请求数据包一直没有回应，在超时以后一直进行重发。难道是请求数据包时丢了？我们从real server上的抓包情况可以得到结果。client从03秒(抓包机器时间设置相差3分钟，单秒数是对的)开始发送数据包，但是real server从09秒时才开始3次握手建立连接。建立连接以后，并且将重发的包又转发了一遍。那么，我们从二张图中得出，导致延迟的原因是fullnat和real server建立连接的过程中，第一个syn包丢了或者没有送出来，才导致了这6秒的延时，那么为什么是6s呢，这得从fullnat代码中查看，经过代码搜索，终于找到了蛛丝马迹。&lt;br&gt;
在ip_vs_proto_tcp.c文件中：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1158 int sysctl_ip_vs_tcp_timeouts[IP_VS_TCP_S_LAST + 1] = {&lt;br&gt;
1159     [IP_VS_TCP_S_NONE] = 2 * HZ,&lt;br&gt;
1160     [IP_VS_TCP_S_ESTABLISHED] = 90 * HZ,&lt;br&gt;
1161     [IP_VS_TCP_S_SYN_SENT] = 3 * HZ,&lt;br&gt;
1162     [IP_VS_TCP_S_SYN_RECV] = 30 * HZ,&lt;br&gt;
1163     [IP_VS_TCP_S_FIN_WAIT] = 3 * HZ,&lt;br&gt;
1164     [IP_VS_TCP_S_TIME_WAIT] = 3 * HZ,&lt;br&gt;
1165     [IP_VS_TCP_S_CLOSE] = 3 * HZ,&lt;br&gt;
1166     [IP_VS_TCP_S_CLOSE_WAIT] = 3 * HZ,&lt;br&gt;
1167     [IP_VS_TCP_S_LAST_ACK] = 3 * HZ,&lt;br&gt;
1168     [IP_VS_TCP_S_LISTEN] = 2 * 60 * HZ,&lt;br&gt;
1169     [IP_VS_TCP_S_SYNACK] = 30 * HZ,&lt;br&gt;
1170     [IP_VS_TCP_S_LAST] = 2 * HZ,&lt;br&gt;
1171 };&lt;/code&gt;&lt;br&gt;
1161行中的IP_VS_TCP_S_SYN_SENT代表了当fullnat和real server 的第一syn包发送失败以后超时重传的时间,如果synproxy在第二个三次握手时，第一个syn包发送失败或者被丢弃，重发的时间间隔为3s，这就解释了为什么是超时6s,估计是fullnat发送了3次syn包，但是前两次都丢弃了，或者fullnat前两个根本没有发包。从抓包的结果来看，fullnat确实没有发送前2个包，我们进一步在fullnat中打日志查看。在ip_vs_conn.c文件中，对超时的连接有处理：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;881 static void ip_vs_conn_expire(unsigned long data)&lt;br&gt;
 ...&lt;br&gt;
 901     /*&lt;br&gt;
 902      * Retransmit syn packet to rs.&lt;br&gt;
 903      * We just check syn_skb is not NULL, as syn_skb&lt;br&gt;
 904      * is stored only if syn-proxy is enabled.&lt;br&gt;
 905      */&lt;br&gt;
 906     spin_lock(&amp;amp;cp-&amp;gt;lock);&lt;br&gt;
 907     if (cp-&amp;gt;syn_skb != NULL &amp;amp;&amp;amp; atomic_read(&amp;amp;cp-&amp;gt;syn_retry_max) &amp;gt; 0) {&lt;br&gt;
 908         atomic_dec(&amp;amp;cp-&amp;gt;syn_retry_max);&lt;br&gt;
 909         if (cp-&amp;gt;packet_xmit) {&lt;br&gt;
 910             tmp_skb = skb_copy(cp-&amp;gt;syn_skb, GFP_ATOMIC);&lt;br&gt;
 911             cp-&amp;gt;packet_xmit(tmp_skb, cp, pp);&lt;br&gt;
 912         }&lt;br&gt;
 913         /* statistics */&lt;br&gt;
 914         IP_VS_INC_ESTATS(ip_vs_esmib, SYNPROXY_RS_ERROR);&lt;br&gt;
 915         spin_unlock(&amp;amp;cp-&amp;gt;lock);&lt;br&gt;
 916         goto expire_later;&lt;br&gt;
 917     }&lt;br&gt;
 918     spin_unlock(&amp;amp;cp-&amp;gt;lock);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上的代码意思就是说，如果重发的次数没有超过最大重发次数（默认是3次），就进行重发。对packet_xmit函数进行了跟踪，发送在超时的时候，packet_xmit函数确实进行了调用，而且调用了成功了，但是抓包却没有抓到。因此估计是在fullnat下面的某个环节，内核把数据包给丢了，具体是在哪里丢的，由于涉及内核东西较多，我暂时还没有追踪。&lt;/p&gt;
&lt;h2&gt;改进方法&lt;/h2&gt;
&lt;p&gt;由于synproxy的第二个三次握手时，没有采用tcp的重传机制，而是采用了简单的3s重传机制，当有丢包时，会出现3s,6s，9s等不等的延迟。消除此现象的方式大概有几种：&lt;br&gt;
1，关掉synproxy，通过测试发现，关掉synproxy的情况会出现某些请求的等待，但出现的概率降低，同时等待的时间大都小于3s&lt;br&gt;
2，改造synproxy的重复机制，使其和tcp的重传机制一样，这也是小米目前采用的方式，修改如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;882 static void ip_vs_conn_expire(unsigned long data)&lt;br&gt;
 883 {&lt;br&gt;
 884     struct ip_vs_conn *cp = (struct ip_vs_conn *)data;&lt;br&gt;
 885     struct sk_buff *tmp_skb = NULL;&lt;br&gt;
 886     struct ip_vs_protocol *pp = ip_vs_proto_get(cp-&amp;gt;protocol);&lt;br&gt;
 887     /* fix synproxy timeout add by panxiaodong@xiaomi.com */&lt;br&gt;
 888     int retry_idx = 0;&lt;br&gt;
 ...&lt;br&gt;
 904     /*&lt;br&gt;
 905      * Retransmit syn packet to rs.&lt;br&gt;
 906      * We just check syn_skb is not NULL, as syn_skb&lt;br&gt;
 907      * is stored only if syn-proxy is enabled.&lt;br&gt;
 908      */&lt;br&gt;
 909     spin_lock(&amp;amp;cp-&amp;gt;lock);&lt;br&gt;
 910     if (cp-&amp;gt;syn_skb != NULL &amp;amp;&amp;amp; atomic_read(&amp;amp;cp-&amp;gt;syn_retry_max) &amp;gt; 0) {&lt;br&gt;
 911         atomic_dec(&amp;amp;cp-&amp;gt;syn_retry_max);&lt;br&gt;
 912         /* fix synproxy timeout add by panxiaodong@xiaomi.com */&lt;br&gt;
 913         retry_idx = sysctl_ip_vs_synproxy_syn_retry - atomic_read(&amp;amp;cp-&amp;gt;syn_retry_max);&lt;br&gt;
 914         cp-&amp;gt;timeout *= (1&amp;lt;&amp;lt;retry_idx);&lt;br&gt;
 915&lt;br&gt;
 916         if (cp-&amp;gt;packet_xmit) {&lt;br&gt;
 917             tmp_skb = skb_copy(cp-&amp;gt;syn_skb, GFP_ATOMIC);&lt;br&gt;
 918             cp-&amp;gt;packet_xmit(tmp_skb, cp, pp);&lt;br&gt;
 919         }&lt;/code&gt;&lt;br&gt;
 从测试效果来看，也能降低延迟等待，但是并不能消除此问题。&lt;br&gt;
 3，修改packet_xmit函数，从追踪的过程中，发现packet_xmit函数已经调用成功，但是包并没有真正发出，估计是内种某个过程丢了，packet_xmit发送宏如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;243 #define IP_VS_XMIT(pf, skb, rt)             \&lt;br&gt;
 244 do {                            \&lt;br&gt;
 245     (skb)-&amp;gt;ipvs_property = 1;           \&lt;br&gt;
 246     skb_forward_csum(skb);              \&lt;br&gt;
 247     NF_HOOK(pf, NF_INET_LOCAL_OUT, (skb), NULL, \&lt;br&gt;
 248         (rt)-&amp;gt;u.dst.dev, dst_output);       \&lt;br&gt;
 249 } while (0)&lt;/code&gt;&lt;br&gt;
 具体为什么会丢包，就不得知了，可以将NF_HOOK接口替换成更底层的发送接口，使用dev_queue_xmit函数可能能解决次问题，synproxy中就使用了此函数，但是我还没有去验证。&lt;/p&gt;
&lt;h2&gt;总结：&lt;/h2&gt;
&lt;p&gt;在fullnat使用过程中，出现顿卡的问题比较影响使用，采用方法二能够降低顿卡现象，但是没有完全解决。或许替换NF_HOOK能完全解决此问题，这个需要与 fullnat的作者[吴佳明等]沟通。测试过程中发现pps越高，顿卡现象越严重，在pps没有超过100w时，基本不会出现顿卡现象。后续会把fullnat在各种环境中的表现，总结一下，再分享出来。&lt;/p&gt;
            
</description>
        <pubDate>Mon, 14 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-14--p=1505-20610a66c.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-14--p=1505-20610a66c.html</guid>
        
        
      </item>
    
      <item>
        <title>Compatibility</title>
        <description>
&lt;p&gt;One of the most common questions we heard at WWDC was, “What is the compatibility story for Swift?”. This seems like a great first topic.&lt;/p&gt; &lt;h3&gt;App Compatibility&lt;/h3&gt; &lt;p&gt;Simply put, if you write a Swift app today and submit it to the App Store this Fall when iOS 8 and OS X Yosemite are released, you can trust that your app will work well into the future. In fact, you can target back to OS X Mavericks or &lt;span class=&quot;nowrap&quot;&gt;iOS 7&lt;/span&gt; with that same app. This is possible because Xcode embeds a small Swift runtime library within your app’s bundle. Because the library is embedded, your app uses a consistent version of Swift that runs on past, present, and future OS releases.&lt;/p&gt; &lt;h3&gt;Binary Compatibility and Frameworks&lt;/h3&gt; &lt;p&gt;While your app’s runtime compatibility is ensured, the Swift language itself will continue to evolve, and the binary interface will also change. To be safe, all components of your app should be built with the same version of Xcode and the Swift compiler to ensure that they work together.&lt;/p&gt; &lt;p&gt;This means that frameworks need to be managed carefully. For instance, if your project uses frameworks to share code with an embedded extension, you will want to build the frameworks, app, and extensions together. It would be dangerous to rely upon binary frameworks that use Swift — especially from third parties. As Swift changes, those frameworks will be incompatible with the rest of your app. When the binary interface stabilizes in a year or two, the Swift runtime will become part of the host OS and this limitation will no longer exist.&lt;/p&gt; &lt;h3&gt;Source Compatibility&lt;/h3&gt; &lt;p&gt;Swift is ready to use today, in brand new apps or alongside your proven Objective-C code. We have big plans for the Swift language, including improvements to syntax, and powerful new features. And as Swift evolves, we will provide tools in Xcode to help you migrate your source code forward.&lt;/p&gt; &lt;p&gt;We can’t wait to see what you build!&lt;/p&gt;

</description>
        <pubDate>Fri, 11 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-11--id=2-00b0ddf6a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-11--id=2-00b0ddf6a.html</guid>
        
        
      </item>
    
      <item>
        <title>DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在上一篇文章《&lt;a href=&quot;http://www.cnblogs.com/SwordTao/p/3767340.html&quot;&gt;DDoS攻防战 （二） ：CC攻击工具实现与防御理论&lt;/a&gt;》中,笔者阐述了一个防御状态机，它可用来抵御来自应用层的DDoS攻击，但是该状态机依赖一个能应对大量条目快速增删的ip黑白名单防火墙，我们目前并没有发现很好的开源实现以供我们使用。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·实现方案选择：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;硬件实现或者软件实现？&lt;/p&gt;
&lt;p&gt;在面对诸如大量畸形包这样的攻击时，硬件实现将会是非常好的选择，这是因为在进行此类型的封包过滤时，系统需要记忆的状态很少（对于FPGA、ASIC诸多硬件实现方案来讲，记忆元件的成本决不可忽视，寄存器与静态RAM都非常昂贵，所以当需要记忆的信息很少时，纯硬件方案的速度优势使得其完胜软件方案）。&lt;/p&gt;
&lt;p&gt;但是，当状态机需要处理庞大的记忆信息时，我们就需要选择廉价的存储器——动态随机存储器（如SDRAM中的DDR3）来作为系统状态机的存储介质，以降低系统的成本和复杂度。这时，软件实现更胜一筹。尽管纯硬件实现的速度会比软件的方式高出很多，但我们也从第一篇文章《&lt;a href=&quot;http://www.cnblogs.com/SwordTao/p/3766151.html&quot;&gt;DDoS攻防战 （一） ： 概述&lt;/a&gt;》中lvs性能的测试结果中看到，软件实现的、作为服务器前端均衡调度器的lvs，性能理想并且能胜任实际生产环境中的、庞大的用户请求处理，可见，如果设计合理，软件实现的性能无需过多担忧。&lt;/p&gt;
&lt;p&gt;最终，我们决定采用软件的方法来实现所需的ip黑白名单模块。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·最终系统鸟瞰：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者花费大约二十天的时间，使用C语言实现了这一模块，其中，内核空间的核心代码约2300行，用户空间管理工具的代码总行数约为700行。下为系统的鸟瞰：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/219e6104bd9573cda6d5eb910c9aaa61.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72936&quot; alt=&quot;041927426214190&quot; src=&quot;/images/jobbole.com/d915a7fa71ecd91a5cebf8da673480c5.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt; ·用户空间管理工具fripadm，通过ioctl与工作于内核态的frdev模块进行通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  ·frdev维护两个double_hash_table的实例，并提供了一个挂在NF_INET_PRE_ROUTING的钩子函数，其通过操作这两个double_hash_table的实例以分别实现ip黑名单、白名单的功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  ·frdev通过内核中设备驱动的ioctl机制，向用户空间提供这两个double_hash_table实例的操作函数，而我们的用户空间管理工具fripadm正是基于此而实现的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是内核态的主要数据结构与其对应的操作函数：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/69d337ddf8c78477c9a0ef2631d4abe5.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72937&quot; alt=&quot;041909364491925&quot; src=&quot;/images/jobbole.com/e3211d3f289593cc143e4b3b0f9d5c27.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;struct fr_ip_hash_array的功能：
  精确ip查询；
  模糊ip查询；
  自定义hash表的长度；
  自定义hash function，其输入散列随机数为rnd；
  维护精确ip的哈希表；
  维护模糊ip的链表；
  维护精确ip与模糊ip的诸统计信息；

ip字符描述语法：
  /* ips_syntax : RE 
  digit  =: [0-9]
  num    =: (digit){1,3}
  atom   =: num | (num&#39;-&#39;num) | &#39;*&#39;
  ip     =: atom &#39;.&#39; atom &#39;.&#39; atom &#39;.&#39; atom 
  ips    =: (ip &#39; &#39;)+
  */
  // ret 0 success,otherwise syntax error
  // &quot;1-220.*.100.33 1-220.*.100.33 1-220.*.100.33&quot;

struct fr_ip_hash_array的方法：
  fr_ip_hash_array_malloc / fr_ip_hash_array_destroy
  fr_ip_hash_array_insert_ip  ：增加一条精确ip记录
  fr_ip_hash_array_insert_blurip_ptr  ：增加一条模糊ip记录（以指针引用的方式）
  fr_ip_hash_array_delete_ip
  fr_ip_hash_array_delete_blurip_ptr
  fr_ip_hash_array_delete_ip_randomly  ：随机地删除指定数量的精确ip
  fr_ip_hash_array_insert_ip_bystrings  ：通过字符串的表述方式，向fr_ip_hash_array增加精确ip或者模糊ip
  fr_ip_hash_array_delete_ip_bystrings
  fr_ip_hash_array_find_bool  ：查找给定的ip是否在已存储的模糊ip范围之内或者精确ip的哈希表之中
  fr_ip_hash_array_find_ip_bool  ：查找给定的ip是否在精确ip的哈希表之中
  fr_ip_hash_array_find_ip_bystrings_bool&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;·为什么使用双哈希表缓冲？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请考虑如下场景：&lt;/p&gt;
&lt;p&gt;情况1：来自应用层的DDoS攻击常常是瞬间涌入大量非法ip请求，例如数万个非法ip，所以，对于防火墙黑白名单功能的要求至少有如下：能在很短的时间内更新大量数据项，且不能造成系统服务停顿。&lt;/p&gt;
&lt;p&gt;分析：如果只使用一个全局的哈希表，当在短时间内进行大量的数据项增删时，例如，成千上万个，此时，即使采用多把读写锁分割哈希表的策略，对共享资源的竞争也依然将严重影响系统响应速度，严重时系统可能会停顿或者更糟，对于生产环境中的高负载服务器，这是无法容忍的。&lt;/p&gt;
&lt;p&gt;解决：以空间换时间&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/aa638936ce768f48f83884904359bbbd.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72938&quot; alt=&quot;041910359024155&quot; src=&quot;/images/jobbole.com/f79cd374f6285d556d21facd945d2de2.jpg&quot;&gt;&lt;/a&gt;\&lt;/p&gt;
&lt;p&gt;采用双哈希表缓冲的策略，将系统共享资源的竞争热点压缩至两个hash表指针主备切换的极短时间内，此方法能显著降低系统在大量数据项更新时共享资源的竞争。&lt;/p&gt;
&lt;p&gt;系统查询将会直接访问master指向的fr_ip_hash_array，而用户的更新操作将直接针对mirror所指向的另一个fr_ip_hash_array实例，直到switch_mirror_update操作的执行，master将被瞬间“更新”。这是其主要的工作特点。&lt;/p&gt;
&lt;p&gt;对于SMP与多队列网卡的系统，可采用如下策略：多数cpu核心专门负责处理内核的softirq任务，剩下的少数cpu负责进行双哈希表的更新、切换与重建等操作。这样可提高系统对攻击的快速防御响应。&lt;/p&gt;
&lt;p&gt;但此方案将使得系统需要维护两个互为镜像的哈希表，这将加重系统内存的读写负担。&lt;/p&gt;
&lt;p&gt;具体实现细节如下：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;struct fr_ip_double_hash的成员：
  struct fr_ip_hash_array * master_ptr;
  rwlock_t master_lock;  
  struct fr_ip_hash_array * mirror_ptr;
  rwlock_t mirror_lock;

struct fr_ip_double_hash的方法：
  fr_ip_double_hash_malloc / fr_ip_double_hash_destroy
  fr_ip_double_hash_mirror_insert_ip ：只针对mirror的insert ip操作
  fr_ip_double_hash_mirror_insert_blurip_ptr
  fr_ip_double_hash_mirror_insert_bystrings
  fr_ip_double_hash_mirror_delete_ip
  fr_ip_double_hash_mirror_delete_blurip_ptr
  fr_ip_double_hash_mirror_delete_bystrings
  fr_ip_double_hash_mirror_delete_ip_randomly
  fr_ip_double_hash_mirror_delete_all ：删除mirror中所有的ip记录，即所有的精确ip和模糊ip记录
  fr_ip_double_hash_switch_mirror_update ：将mirror与master互换，并更新master至mirror（此时的mirror即为之前的master）
  fr_ip_double_hash_rebuild ：将双哈希表重建，可指定新的hash function、rnd以及hash表的长度，这将解决hash表查询效率低下的问题，以防御外界针对hash表的攻击。当然，在重建之后，原有的诸多ip条目不会丢失。
  fr_ip_double_hash_find_bool
  fr_ip_double_hash_find_bystrings_bool&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;挂到协议栈上的钩子函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在模块初始化函数fr_ip_dev_init的最后，即当两个双哈希表实例（分别用作黑名单与白名单）初始化成功、fedev设备注册成功之后，其将会执行nf_register_hook，将指定的钩子函数fr_nf_hook_sample挂到NF_INET_PRE_ROUTING之上。&lt;/p&gt;
&lt;p&gt;fr_nf_hook_sample的主要处理代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;if(fr_ip_double_hash_find_bool(double_hash_white_ptr,sip)) 
　　  return NF_ACCEPT;
   else if(fr_ip_double_hash_find_bool(double_hash_ptr,sip)) 
　　  return NF_DROP;
   else  
　　  return NF_ACCEPT;&lt;/pre&gt;
&lt;p&gt;其中，double_hash_white_ptr指向白名单fr_ip_double_hash实例，double_hash_ptr则指向黑名单fr_ip_double_hash实例，由于支持模糊ip匹配，故，上述代码使得对源ip过滤的“通”、“堵”策略皆可使用。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内核空间frdev的ioctl处理函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前，ioctl支持来自用户空间的如下操作：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;//黑名单操作
/* in-black ip */
#define FR_IP_IOCTL_TYPE_FIND    1
#define FR_IP_IOCTL_TYPE_FIND_BYSTRINGS        2    // *   输入ip字符查找
#define FR_IP_IOCTL_TYPE_MIRROR_INSERT_IP    3    
#define FR_IP_IOCTL_TYPE_MIRROR_INSERT_BYSTRINGS    4    // * 
#define FR_IP_IOCTL_TYPE_MIRROR_DELETE_IP    5        // *  
#define FR_IP_IOCTL_TYPE_MIRROR_DELETE_IP_RANDOMLY        6 //*  
#define FR_IP_IOCTL_TYPE_MIRROR_DELETE_BYSTRINGS    7    // * 
#define FR_IP_IOCTL_TYPE_MIRROR_DELETE_ALL        8    //*  
#define FR_IP_IOCTL_TYPE_SWITCH_MIRROR_UPDATE    9    // *  
#define FR_IP_IOCTL_TYPE_REBUILD    10    // *    
#define FR_IP_IOCTL_TYPE_COPY_HASH_STRUCT     11    // *
#define FR_IP_IOCTL_TYPE_DUMP    12    //*    输出双哈希表的分布情况与统计信息
#define FR_IP_IOCTL_TYPE_MIRROR_INSERT_IP_BINS    13    //*   一次增加大量精确ip，以二进制的方式输入
#define FR_IP_IOCTL_TYPE_MIRROR_DELETE_IP_BINS    14    //*  

//白名单操作
/* in-white ip */
#define FR_IP_IOCTL_TYPE_WHITE_FIND    101
#define FR_IP_IOCTL_TYPE_WHITE_FIND_BYSTRINGS        102  // * 
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_INSERT_IP        103
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_INSERT_BYSTRINGS    104  // * 
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_DELETE_IP        105
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_DELETE_IP_RANDOMLY        106  // * 
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_DELETE_BYSTRINGS    107    // * 
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_DELETE_ALL        108    //*  
#define FR_IP_IOCTL_TYPE_WHITE_SWITCH_MIRROR_UPDATE    109    // *  
#define FR_IP_IOCTL_TYPE_WHITE_REBUILD    110    // *    
#define FR_IP_IOCTL_TYPE_WHITE_COPY_HASH_STRUCT     111    // *
#define FR_IP_IOCTL_TYPE_WHITE_DUMP    112    //*  
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_INSERT_IP_BINS    113    //*  
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_DELETE_IP_BINS    114    //*&lt;/pre&gt;
&lt;p&gt;上述各功能的具体实现请阅读frdev源码中的fr_ip_dev_ioctl_routine函数。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户空间管理工具：fripadm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一步，实现fripadm_black_in_exe与fripadm_white_in_exe，是分别管理黑白名单的工具，不过，较为简陋，第二步，使用shell脚本对其进行二次封装得到fripadm_black_in.sh与fripadm_white_in.sh这两个较用户友好的工具。&lt;/p&gt;
&lt;p&gt;fripadm为用户空间的C语言开发者们提供了如下API：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;//针对ip黑名单的操作
double_hash_find_bystrings(int fd,char * str, unsigned int size) //其中fd为frdev的fd——文件描述符
double_hash_mirror_insert_bystrings(int fd,char * str, unsigned int size)
double_hash_mirror_insert_bins(int fd,char * str, unsigned int size)
double_hash_mirror_delete_bystrings(int fd,char * str, unsigned int size)
double_hash_mirror_delete_bins(int fd,char * str, unsigned int size)
double_hash_mirror_delete_ip_randomly(int fd,unsigned int size)
double_hash_mirror_delete_all(int fd)
double_hash_switch_mirror_update(int fd)
double_hash_rebuild(int fd,unsigned int modular, unsigned int rnd)
double_hash_dump(int fd)
//针对ip白名单的操作
double_hash_white_find_bystrings(int fd,char * str, unsigned int size) //其中fd为frdev的fd——文件描述符
double_hash_white_mirror_insert_bystrings(int fd,char * str, unsigned int size)
double_hash_white_mirror_insert_bins(int fd,char * str, unsigned int size)
double_hash_white_mirror_delete_bystrings(int fd,char * str, unsigned int size)
double_hash_white_mirror_delete_bins(int fd,char * str, unsigned int size)
double_hash_white_mirror_delete_ip_randomly(int fd,unsigned int size)
double_hash_white_mirror_delete_all(int fd)
double_hash_white_switch_mirror_update(int fd)
double_hash_white_rebuild(int fd,unsigned int modular, unsigned int rnd)
double_hash_white_dump(int fd)&lt;/pre&gt;
&lt;p&gt;fripadm_black_in_exe、fripadm_white_in_exe、fripadm_black_in.sh与 fripadm_white_in.sh的具体实现请参看frdev源码。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最终系统测试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/bafa2a3553cf40af65c32be09b6c8040.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72941&quot; alt=&quot;041917316374465&quot; src=&quot;/images/jobbole.com/52518f6f7cce3e0a2992190919f677ee.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;按照README所述的过程，编译、安装完毕frdev设备后，便可进行如下测试：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/40040dcaf4798222c23a7968d024dc7c.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72942&quot; alt=&quot;041937462625839&quot; src=&quot;/images/jobbole.com/36e7cb5791c8b6c9f82f89ceb2208ce5.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/00279c2d6d4bcc2583f4241519db59b6.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72943&quot; alt=&quot;041938024021637&quot; src=&quot;/images/jobbole.com/7bf0bc150b5c97bdf03e17393db621c2.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原本被black所DROP的数据包，在更新了white的ip条目后，被white所ACCEPT，上图红线标出了数据包被截断的icmp_seq的区间。  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于frdev的陈述到此为止。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最近笔者在阅读《白帽子讲Web安全》这本书时，发现了雅虎公司用于防护应用层DDoS攻击的系统Yahoo Detecting System Abuse，yahoo为此系统申请了专利保护。下面是关于这个系统的描述： &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; （Patent N0.: US 7,533,414 B1 &lt;/strong&gt;&lt;strong&gt;资料来源 &lt;a href=&quot;http://patentimages.storage.googleapis.com/pdfs/US7533414.pdf&quot;&gt;http://patentimages.storage.googleapis.com/pdfs/US7533414.pdf&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;  A system continually monitors service requests and detects service abuses.&lt;/p&gt;
&lt;p&gt;First, a screening list is created to identify potential abuse events. A screening list includes event IDs and associated count values. A pointer cyclically selects entries in the table,advancing as events are received.&lt;/p&gt;
&lt;p&gt;An incoming event ID is compared with the event IDs in the table. If the incoming event ID matches an event ID in the Screening list,the associated count is incremented. Otherwise, the count of a selected table entry is decremented. If the count value of the selected entry falls to Zero, it is replaced With the incoming event.&lt;/p&gt;
&lt;p&gt;Event IDs can be based on properties of service users,such as user identifications, or of service request contents,such as a search term or message content. The screening list is analyzed to determine whether actual abuse is occurring.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大概思路如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/372862ce489bd277c6d3da768af24458.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72944&quot; alt=&quot;041922262301198&quot; src=&quot;/images/jobbole.com/9e54da35f3d34a2aa8783d1477be9ad1.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此系统通过维护一个筛选表来得到用户的请求频率，以判断其是否存在service abuse，然采取相关措施，例如BLOCK。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  这种防御思想，与我们之前所提出的防御状态机有着异曲同工之妙。笔者认为这是必然的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前面的文章已经提过，DDoS攻击存在的主要原因之一是网络服务的开放性，我们不可能从下层来解决这样的问题（因为服务的可用性是第一要求），只能从上层分析解决.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  而应用层已经处于协议栈的最高层，所以，要防御应用层DDoS攻击，只能从应用层以上来寻找解法，故，在这种情况下，除了借助数据统计分析，难道还会有更好的方法么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实现frdev的过程中，借助互联网解决了很多问题，所以，&lt;strong&gt;如果您需要frdev的源码，请在下方留下邮箱 :)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果有小伙伴想要一起来增强&lt;/strong&gt;&lt;strong&gt;frdev的功能，热烈欢迎 :)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通讯邮箱：&lt;a href=&quot;mailto:yunthanatos@163.com&quot;&gt;yunthanatos@163.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Thu, 10 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-10-72935-d195773f0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-10-72935-d195773f0.html</guid>
        
        
      </item>
    
  </channel>
</rss>
