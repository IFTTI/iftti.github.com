<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IT技术干货</title>
    <description>[IT技术干货iftti.com] @KernelHacks</description>
    <link>http://iftti.com/</link>
    <atom:link href="http://iftti.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 28 Aug 2014 17:00:24 +0800</pubDate>
    <lastBuildDate>Thu, 28 Aug 2014 17:00:24 +0800</lastBuildDate>
    <generator>Jekyll v2.2.0</generator>
    
      <item>
        <title>Optionals Case Study: valuesForKeys</title>
        <description>

						
						

						&lt;p&gt;This post explores how optionals help preserve strong type safety within Swift. We’re going to create a Swift version of an Objective-C API. Swift doesn’t really need this API, but it makes for a fun example.&lt;/p&gt;
&lt;p&gt;In Objective-C, &lt;span class=&quot;keyword&quot;&gt;NSDictionary&lt;/span&gt; has a method &lt;span class=&quot;keyword&quot;&gt;-objectsForKeys:notFoundMarker:&lt;/span&gt; that takes an &lt;span class=&quot;keyword&quot;&gt;NSArray&lt;/span&gt; of keys, and returns an &lt;span class=&quot;keyword&quot;&gt;NSArray&lt;/span&gt; of corresponding values. From the documentation: “the &lt;em&gt;N&lt;/em&gt;-th object in the returned array corresponds to the &lt;em&gt;N&lt;/em&gt;-th key in [the input parameter] keys.” What if the third key isn’t actually in the dictionary? That’s where the &lt;span class=&quot;keyword&quot;&gt;notFoundMarker&lt;/span&gt; parameter comes in. The third element in the array will be this marker object rather than a value from the dictionary. The Foundation framework even provides a class for this case if you don’t have another to use: &lt;span class=&quot;keyword&quot;&gt;NSNull&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;In Swift, the &lt;span class=&quot;keyword&quot;&gt;Dictionary&lt;/span&gt; class doesn’t have an &lt;span class=&quot;keyword&quot;&gt;objectsForKeys&lt;/span&gt; equivalent. For this exercise, we’re going to add one — as &lt;span class=&quot;keyword&quot;&gt;valuesForKeys&lt;/span&gt; in keeping with the common use of ‘value’ in Swift — using an extension:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Dictionary&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;func&lt;/span&gt; valuesForKeys(keys: [&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;], notFoundMarker: &lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;) -&amp;gt; [&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;] {
		&lt;span class=&quot;comment&quot;&gt;// To be implemented&lt;/span&gt;
	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is where our new implementation in Swift will differ from Objective-C. In Swift, the stronger typing restricts the resulting array to contain only a single type of element — we can’t put &lt;span class=&quot;keyword&quot;&gt;NSNull&lt;/span&gt; in an array of strings. However, Swift gives an even better option: we can return an &lt;em&gt;array of optionals&lt;/em&gt;. All our values get wrapped in optionals, and instead of &lt;span class=&quot;keyword&quot;&gt;NSNull&lt;/span&gt;, we just use &lt;span class=&quot;keyword&quot;&gt;nil&lt;/span&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Dictionary&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;func&lt;/span&gt; valuesForKeys(keys: [&lt;span class=&quot;title&quot;&gt;Key&lt;/span&gt;]) -&amp;gt; [&lt;span class=&quot;title&quot;&gt;Value&lt;/span&gt;?] {
		&lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; result = [Value?]()
		result.reserve(keys.count)
		&lt;span class=&quot;key&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;key&quot;&gt;in&lt;/span&gt; keys {
			result.&lt;span class=&quot;method&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;method&quot;&gt;self&lt;/span&gt;[key])
		}
		&lt;span class=&quot;key&quot;&gt;return&lt;/span&gt; result
	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NOTE: Some of you may have guessed why a Swift &lt;span class=&quot;keyword&quot;&gt;Dictionary&lt;/span&gt; doesn’t need this API, and already imagined something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Dictionary&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;func&lt;/span&gt; valuesForKeys(keys: [&lt;span class=&quot;title&quot;&gt;Key&lt;/span&gt;]) -&amp;gt; [&lt;span class=&quot;title&quot;&gt;Value&lt;/span&gt;?] {
		&lt;span class=&quot;key&quot;&gt;return&lt;/span&gt; keys.&lt;span class=&quot;method&quot;&gt;map&lt;/span&gt; { &lt;span class=&quot;method&quot;&gt;self&lt;/span&gt;[$0] }
	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This has the exact same effect as the imperative version above, but all of the boilerplate has been wrapped up in the call to &lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;. This is great example why Swift types often have a small API surface area, because it’s so easy to just call &lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt; directly.&lt;/p&gt;
&lt;p&gt;Now we can try out some examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;let&lt;/span&gt; dict = [&lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Amir&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Bertha&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Ching&quot;&lt;/span&gt;]

&lt;span class=&quot;pointer&quot;&gt;dict&lt;/span&gt;.&lt;span class=&quot;enum&quot;&gt;valuesForKeys&lt;/span&gt;([&lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt;])
&lt;span class=&quot;comment&quot;&gt;// [Optional(&quot;Amir&quot;), Optional(&quot;Ching&quot;)]&lt;/span&gt;

&lt;span class=&quot;pointer&quot;&gt;dict&lt;/span&gt;.&lt;span class=&quot;enum&quot;&gt;valuesForKeys&lt;/span&gt;([&lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;D&quot;&lt;/span&gt;])
&lt;span class=&quot;comment&quot;&gt;// [Optional(&quot;Bertha&quot;), nil]&lt;/span&gt;

&lt;span class=&quot;pointer&quot;&gt;dict&lt;/span&gt;.&lt;span class=&quot;enum&quot;&gt;valuesForKeys&lt;/span&gt;([])
&lt;span class=&quot;comment&quot;&gt;// []&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Nested Optionals&lt;/h3&gt;
&lt;p&gt;Now, what if we asked for the &lt;span class=&quot;keyword&quot;&gt;last&lt;/span&gt; element of each result?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;pointer&quot;&gt;dict&lt;/span&gt;.&lt;span class=&quot;enum&quot;&gt;valuesForKeys&lt;/span&gt;([&lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt;]).&lt;span class=&quot;title&quot;&gt;last&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// Optional(Optional(&quot;Ching&quot;))&lt;/span&gt;

&lt;span class=&quot;pointer&quot;&gt;dict&lt;/span&gt;.&lt;span class=&quot;enum&quot;&gt;valuesForKeys&lt;/span&gt;([&lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;D&quot;&lt;/span&gt;]).&lt;span class=&quot;title&quot;&gt;last&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// Optional(nil)&lt;/span&gt;

&lt;span class=&quot;pointer&quot;&gt;dict&lt;/span&gt;.&lt;span class=&quot;enum&quot;&gt;valuesForKeys&lt;/span&gt;([]).&lt;span class=&quot;title&quot;&gt;last&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s strange — we have two levels of &lt;span class=&quot;keyword&quot;&gt;Optional&lt;/span&gt; in the first case, and &lt;span class=&quot;keyword&quot;&gt;Optional(nil)&lt;/span&gt; in the second case. What’s going on?&lt;/p&gt;
&lt;p&gt;Remember the declaration of the &lt;span class=&quot;keyword&quot;&gt;last&lt;/span&gt; property:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; last: &lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;? { get }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This says that the &lt;span class=&quot;keyword&quot;&gt;last&lt;/span&gt; property’s type is an &lt;span class=&quot;keyword&quot;&gt;Optional&lt;/span&gt; version of the array’s element type. In &lt;em&gt;this&lt;/em&gt; case, the element type is also optional (&lt;span class=&quot;keyword&quot;&gt;String?&lt;/span&gt;). So we end up with &lt;span class=&quot;keyword&quot;&gt;String??&lt;/span&gt;, a doubly-nested optional type.&lt;/p&gt;
&lt;p&gt;So what does &lt;span class=&quot;keyword&quot;&gt;Optional(nil)&lt;/span&gt; mean?&lt;/p&gt;
&lt;p&gt;Recall that in Objective-C we were going to use &lt;span class=&quot;keyword&quot;&gt;NSNull&lt;/span&gt; as a placeholder. The Objective-C version of these three calls looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&lt;span class=&quot;pointer&quot;&gt;dict&lt;/span&gt; valuesForKeys:@[@&lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;, @&lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt;] notFoundMarker:[NSNull null]].lastObject
&lt;span class=&quot;comment&quot;&gt;// @&quot;Ching&quot;&lt;/span&gt;

[&lt;span class=&quot;pointer&quot;&gt;dict&lt;/span&gt; valuesForKeys:@[@&lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;, @&lt;span class=&quot;string&quot;&gt;&quot;D&quot;&lt;/span&gt;] notFoundMarker:[NSNull null]].lastObject
&lt;span class=&quot;comment&quot;&gt;// NSNull&lt;/span&gt;

[&lt;span class=&quot;pointer&quot;&gt;dict&lt;/span&gt; valuesForKeys:@[] notFoundMarker:[NSNull null]].lastObject
&lt;span class=&quot;comment&quot;&gt;// nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In both the Swift and Objective-C cases, a return value of &lt;span class=&quot;keyword&quot;&gt;nil&lt;/span&gt; means “the array is empty, therefore there’s no last element.” The return value of &lt;span class=&quot;keyword&quot;&gt;Optional(nil)&lt;/span&gt; (or in Objective-C &lt;span class=&quot;keyword&quot;&gt;NSNull&lt;/span&gt;) means “the last element of this array exists, but it represents an absence.” Objective-C has to rely on a placeholder object to do this, but Swift can represent it in the type system.&lt;/p&gt;
&lt;h3&gt;Providing a Default&lt;/h3&gt;
&lt;p&gt;To wrap up, what if you &lt;em&gt;did&lt;/em&gt; want to provide a default value for anything that wasn’t in the dictionary? Well, that’s easy enough.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Dictionary&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;func&lt;/span&gt; valuesForKeys(keys: [&lt;span class=&quot;title&quot;&gt;Key&lt;/span&gt;], notFoundMarker: &lt;span class=&quot;title&quot;&gt;Value&lt;/span&gt;) -&amp;gt; [&lt;span class=&quot;title&quot;&gt;Value&lt;/span&gt;] {
		&lt;span class=&quot;key&quot;&gt;return self&lt;/span&gt;.&lt;span class=&quot;enum&quot;&gt;valuesForKeys&lt;/span&gt;(keys).&lt;span class=&quot;method&quot;&gt;map&lt;/span&gt; { $0 &lt;span class=&quot;method&quot;&gt;??&lt;/span&gt; notFoundMarker }
	}
}


&lt;span class=&quot;pointer&quot;&gt;dict&lt;/span&gt;.&lt;span class=&quot;enum&quot;&gt;valuesForKeys&lt;/span&gt;([&lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;D&quot;&lt;/span&gt;], notFoundMarker: &lt;span class=&quot;string&quot;&gt;&quot;Anonymous&quot;&lt;/span&gt;)
&lt;span class=&quot;comment&quot;&gt;// [&quot;Bertha&quot;, &quot;Anonymous&quot;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While Objective-C has to rely on a placeholder object to do this, Swift can represent it in the type system, and provides rich syntactic support for handling optional results.&lt;/p&gt;

						
												
											

</description>
        <pubDate>Wed, 27 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-27--id=12-253f68f80.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-27--id=12-253f68f80.html</guid>
        
        
        <category>apple_swift</category>
        
      </item>
    
      <item>
        <title>实现键值对存储（一）：什么是键值对存储，为什么要实现它</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在本文中，我将会以键值对是什么的一个简短描述开始。然后我将解释本项目之后的一些理由，最后我将说明我打算实现的键值对存储的主要目标。这里是本文中将会包含内容的列表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;键值对存储的概述&lt;/li&gt;
&lt;li&gt;键值对存储 vs 关系型数据库&lt;/li&gt;
&lt;li&gt;为什么要实现键值对存储&lt;/li&gt;
&lt;li&gt;计划&lt;/li&gt;
&lt;li&gt;引用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h1 align=&quot;left&quot;&gt;1. 键值对存储的概述&lt;b&gt;&lt;/b&gt;
&lt;/h1&gt;
&lt;p&gt;基于很多文章已经有了很多详细的介绍，本节只是对于键值对存储的一个简短介绍。我已经选择了几篇放在本文底部的引用一节中。&lt;/p&gt;
&lt;p&gt;键值对存储是数据库最简单的组织形式。基本上所有的编程语言都带有应用在内存中的键值对存储。C++STL的映射容器（map container）和Java的HashMap以及Python的字典类型都是键值对存储。键值对存储通常都有如下接口：&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Get( key ):&lt;/b&gt; 获取之前存储于某标示符“key”之下的一些数据，或者“key”下没有数据时报错。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Set( key, value ):&lt;/b&gt; 将“value”存储到存储空间中某标示符“key”下，使得我们可以通过调用相同的“key”来访问它。如果“key”下已经有了一些数据，旧的数据将被替换。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Delete( key ):&lt;/b&gt;  删除存储在“key”下的数据。&lt;/p&gt;
&lt;p&gt;大部分低层实现都是使用哈希表或者某种自平衡树（例如B-树或者红黑树）。有时候数据太大而不装不进内存，或者必须维持数据谨防系统因为未知原因而崩溃。在这些情况下，就必须使用到文件系统。&lt;/p&gt;
&lt;p&gt;键值对存储是NoSQL运动的一部分，NoSQL将所有不使用基于关系型数据库概念的数据库系统组合在一起。&lt;a href=&quot;http://en.wikipedia.org/wiki/NoSQL&quot;&gt;维基百科上的NoSQL词条&lt;/a&gt;很好的总结了这些数据库的特征。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不使用SQL查询语言&lt;/li&gt;
&lt;li&gt;可不全面支持&lt;a href=&quot;http://en.wikipedia.org/wiki/ACID&quot;&gt;ACID&lt;/a&gt;（原子性、一致性、隔离性、持久性）。&lt;/li&gt;
&lt;li&gt;可提供分布式、容错强的结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h1&gt;2. 键值对存储和关系型数据库&lt;/h1&gt;
&lt;p&gt;不像关系型数据库，键值对存储不需要了解值中的数据，也没有像MySQL或者PostgreSQL中那样的任何结构。这同时表示像SQL那样用WHERE语句或者通过任何形式的过滤来请求数据中的一部分是无法做到的。如果你不知道去哪找，你必须遍历所有的键，获取它们对应的值，应用某种你需要的过滤，然后保留你想要的东西。这将会需要大量的运算，也即表示只有当键已知的时候才能体现出最佳性能，否则键值对存储将无法胜任（注意：一些键值对存储能够存储结构化的数据并有字段索引）。&lt;/p&gt;
&lt;p&gt;因此，即使键值对存储在访问速度上经常比关系型数据库系统性能要好数个数量级，但对键已知的需求也限制着其应用。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h1 align=&quot;left&quot;&gt;3. 为什么要实现键值对存储&lt;b&gt;&lt;/b&gt;
&lt;/h1&gt;
&lt;p&gt;我开始这个项目主要是作为充电的一种方式，学习和补充一些核心后端基本原理知识。读书和维基上的文章很无聊并且没有练习，因此我认为着手开始做并且实际写一写代码会更好。我要找的是一个可以让我复习如下内容的项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++编程语言&lt;/li&gt;
&lt;li&gt;面向对象设计&lt;/li&gt;
&lt;li&gt;算法和数据结构&lt;/li&gt;
&lt;li&gt;内存管理&lt;/li&gt;
&lt;li&gt;多进程或或多线程的并发管理&lt;/li&gt;
&lt;li&gt;服务器/客户端模式的网络&lt;/li&gt;
&lt;li&gt;磁盘访问的I/O问题和文件系统的使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个使用文件系统作为永久存储，且提供网络接口的键值对存储将会包含上面列出的全部范围的内容。这个项目刚好能够处理后端工程的各个领域。但是让我们面对现实。市面上已经有了大量的键值对存储，其中一些是由很聪明的人实现的，并且已经在大公司的生产环境使用了。这包括Redis, MongoDB, memcached, BerkeleyDB, Kyoto Cabinet 和LevelDB。&lt;/p&gt;
&lt;p&gt;除此之外，近期出现了关于键值对存储的潮流。好像每人都有一个并且想给大家看自己的键值对存储系统有多么出色和快速。这个问题在&lt;a href=&quot;http://randomfoo.net/2009/04/20/some-notes-on-distributed-key-stores&quot;&gt;Leonard Lin博客中关于键值对存储的文章&lt;/a&gt;中描述了。这些项目中大多数在那时还不成熟且不能应用于生产环境，但人们仍然想展示出来。在博客文章或会议幻灯片中经常可以看到对一些晦涩键值对存储系统性能的比较。这些图表基本上毫无意义，并且只是在自己的硬件上用自己的数据和应用进行的孤立测试，可以告诉你哪一种键值对存储最适用于解决你的问题。这里是性能所依赖的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件&lt;/li&gt;
&lt;li&gt;使用的文件系统&lt;/li&gt;
&lt;li&gt;实际应用和具体哪些键会被访问（&lt;a href=&quot;http://en.wikipedia.org/wiki/Locality_of_reference&quot;&gt;引用的局部性&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;数据集，特别是键和值的长度，以及使用哈希表的时候键碰撞的可能性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，编写一个键值对存储系统并有一定的影响力是比较难的，因为其很有可能因为其它已存在的更好的键值对存储系统的存在而被忽视，或者被简单的淹没在半生不熟的业余项目中而没人关心。&lt;/p&gt;
&lt;p&gt;为了差异性，这个项目不能像其他人做的那样为了速度，而必须瞄准于填补现有解决方案间的空隙。这里是我发现的能够让键值对项目脱颖而出的几个方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适应于某种特定数据类型（例如：图片，地理数据等）&lt;/li&gt;
&lt;li&gt;适应于某种特定操作（例如读取性能特别好或者写入性能特别好等）&lt;/li&gt;
&lt;li&gt;适应于某种特定问题 （例如：自动参数调节，很多键值对存储都有很多选项，而找到一个最好的参数设置有时候很棘手）&lt;/li&gt;
&lt;li&gt;提供更多数据访问选项。以LevelDB为例，数据可以向前或者向后访问，有迭代器，是按照键排序的。并不是所有的键值对存储都能做到这样。&lt;/li&gt;
&lt;li&gt;使自己的实现更平易近人：现在，很少有键值对存储系统有完全的代码。如果你需要快速搭建一个项目，而你必须为其自定义一个键值对存储。即便不是一个广为人知的项目，有代码的解决方案看起来确实平易近人并且会作为选项之一。实际上理解代码并相信这个解决方案会弥补这些不足。&lt;/li&gt;
&lt;li&gt; 明确应用。这儿有一个实际问题的例子：很多网络爬虫框架（网络蜘蛛）有一个粗劣的接口来管理他们需要爬的URL，这经常使得客户使用键值对存储来实现逻辑。所有的网络爬虫框架都能因一个统一的URL优化的键值对存储而受益。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h1&gt;4. 计划&lt;/h1&gt;
&lt;p&gt;项目的目标是用易于理解的C++代码开发一个轻量级键值对存储。事实上，我打算在本项目中遵从&lt;a href=&quot;http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml&quot;&gt;Google C++ 代码风格导引&lt;/a&gt;。我将会使用哈希表作为底层数据结构，数据将会存储在硬盘上，同时将会实现一个网络接口。我不会项目进度而匆忙完成，而是要在设计和实现时简洁和清晰。我同样会尽我能力最小化硬盘上数据库文件的空间占用。&lt;/p&gt;
&lt;p&gt;我不想重新发明轮子，所以我会从查看别的C或者C++的键值对存储项目开始，然后从中选取比较出色的。我会逐渐学习他们的结构和代码，从中获取启示。后端工程是我的核心技能之一，我已经有了这个项目所需的大部分知识，但我知道我还要学很多新东西，这使其对我来说更加有意思。我同样乐于记录下其中的全部东西。以前我很喜欢逛核心技术博客，例如&lt;a href=&quot;http://www.alexonlinux.com/&quot; target=&quot;_blank&quot;&gt;Alexander Sandler&lt;/a&gt;和&lt;a href=&quot;http://duartes.org/gustavo/blog/best-of&quot; target=&quot;_blank&quot;&gt;Gustavo Duarte&lt;/a&gt;，我也想贡献出一些有用的，尽可能好的东西。&lt;/p&gt;
&lt;p&gt;我的研究结果和键值对存储的一些工作将在这个文章系列中记录。不要试图用文章的日期来推测键值对存储实现的时间：文章可能和实际研究或者做的事之间有相当大的延迟。&lt;/p&gt;
&lt;p&gt;在第二部分，我将搜索顶级的键值对存储项目并解释为什么我选择了其中的部分作为参考，而不选另一些。其他的文章你可以参考本系列的&lt;a href=&quot;http://codecapsule.com/2012/11/07/ikvs-implementing-a-key-value-store-table-of-contents/&quot;&gt;目录&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;你可以在下边的“引用”一节中找到一些文章和书籍章节来学习更多关于键值对存储的知识。在阅读第二节之前，我强烈建议至少读一下&lt;a href=&quot;http://www.aosabook.org/en/nosql.html&quot; target=&quot;_blank&quot;&gt;The NoSQL Ecosystem&lt;/a&gt;和 &lt;a href=&quot;http://blog.marc-seeger.de/2009/09/21/key-value-stores-a-practical-overview/&quot; target=&quot;_blank&quot;&gt;Key Value Stores: A Practical Overview&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h1 align=&quot;left&quot;&gt;5. 参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.aosabook.org/en/nosql.html&quot; target=&quot;_blank&quot;&gt;The NoSQL Ecosystem&lt;/a&gt;, from the book “Architecture of Open Source Applications, Volume 1″&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://horicky.blogspot.com.es/2009/11/nosql-patterns.html&quot; target=&quot;_blank&quot;&gt;NoSQL Patterns&lt;/a&gt;, by Ricky Ho&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nosql-database.org/&quot; target=&quot;_blank&quot;&gt;NoSQL Databases&lt;/a&gt;, referencing all the NoSQL databases that matter at the moment&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://highlyscalable.wordpress.com/2012/03/01/nosql-data-modeling-techniques/&quot; target=&quot;_blank&quot;&gt;NoSQL Data Modeling Techniques&lt;/a&gt;, by Ilya Katsov&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.networkworld.com/cgi-bin/mailto/x.cgi?pagetosend=/news/tech/2012/102212-nosql-263595.html&quot; target=&quot;_blank&quot;&gt;NoSQL databases benchmark: Cassandra, HBase, MongoDB, Riak&lt;/a&gt;, and the discussion on &lt;a href=&quot;http://news.ycombinator.com/item?id=4733212&quot; target=&quot;_blank&quot;&gt;Hacker News&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/NoSQL&quot; target=&quot;_blank&quot;&gt;Wikipedia article on NoSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/ACID&quot; target=&quot;_blank&quot;&gt;Wikipedia article on the ACID paradigm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://blog.marc-seeger.de/2009/09/21/key-value-stores-a-practical-overview/&quot; target=&quot;_blank&quot;&gt;Key Value Stores: A Practical Overview&lt;/a&gt;, by Marc Seeger&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://randomfoo.net/2009/04/20/some-notes-on-distributed-key-stores&quot; target=&quot;_blank&quot;&gt;Some Notes on Distributed Key Stores&lt;/a&gt;, by Leonard Lin&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Tue, 26 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-26-75844-f42bbf63c.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-26-75844-f42bbf63c.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>实现一个键值对存储：目录</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;2014年7月8日更新：这个系列的文章仍在继续，我正在实现这个键值对存储并将在其差不多完成的时候写一篇文章。这些文章每一篇都花了我很长时间来写。为了在完成的时候获得更新通知，你可以在博客右上角订阅。&lt;/p&gt;
&lt;p&gt;这篇文章是我今天开始的系列文章“实现一个键值对存储”（IKVS）的主条目。本文旨在以内容列表的形式总结系列中所有文章，可能在晚些时候有一些关于项目的笔记。&lt;/p&gt;
&lt;p&gt;本文的内容可能随时间变化直到系列完成。特别是在目录里，各个部分的标题还没有写而顺序也有可能改变。随着内容逐渐完成，一些部分也有可能被移除或者有新的部分被添加进来。&lt;/p&gt;
&lt;p&gt;项目中的更多信息可以在 “第一部分：什么是键值对存储，为什么要实现它”的1.3节中找到。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://codecapsule.com/2012/11/07/ikvs-part-1-what-are-key-value-stores-and-why-implement-one/&quot; target=&quot;_blank&quot;&gt;1 – &lt;/a&gt;&lt;a href=&quot;http://blog.jobbole.com/75844/&quot; target=&quot;_blank&quot;&gt;什么是键值对存储，为什么要实现它？&lt;/a&gt; （已翻成中文）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.1 – 键值对存储综述&lt;/li&gt;
&lt;li&gt;1.2 –键值对存储 vs 关系型数据库&lt;/li&gt;
&lt;li&gt;1.3 – 为什么要实现键值对存储&lt;/li&gt;
&lt;li&gt;1.4 – 计划&lt;/li&gt;
&lt;li&gt;1.5 – 引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span style=&quot;text-decoration: underline;&quot;&gt;&lt;a href=&quot;http://codecapsule.com/2012/12/03/implementing-a-key-value-store-part-2-using-existing-key-value-stores-as-models/&quot;&gt;2 – 使用已存在的键值对存储作为模型&lt;/a&gt;&lt;/span&gt;&lt;span style=&quot;text-decoration: underline;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.1 – 不要重复发明轮子&lt;/li&gt;
&lt;li&gt;2.2 – 候选模型和选择标准&lt;/li&gt;
&lt;li&gt;2.3 – 所选的键值对存储的概览&lt;/li&gt;
&lt;li&gt;2.4 – 引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/&quot;&gt;3 – Kyoto Cabinet和LevelDB结构的比较分析&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3.1 – 结构分析的意图和方法&lt;/li&gt;
&lt;li&gt;3.2 – 键值对存储组件的概览&lt;/li&gt;
&lt;li&gt;3.3 – Kyoto Cabinet和LevelDB的结构与概念分析&lt;/li&gt;
&lt;li&gt;3.4 – 代码审查&lt;/li&gt;
&lt;li&gt;3.5 – 引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://codecapsule.com/2013/04/03/implementing-a-key-value-store-part-4-api-design/&quot;&gt;4 – API设计&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4.1 – API设计的基本原则&lt;/li&gt;
&lt;li&gt;4.2 – 定义FelixDB公共API的功能。&lt;/li&gt;
&lt;li&gt;4.3 – 比较已存在数据库的API功能&lt;/li&gt;
&lt;li&gt;4.4 – Conclusion 结论&lt;/li&gt;
&lt;li&gt;4.5 – References 引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://codecapsule.com/2013/05/13/implementing-a-key-value-store-part-5-hash-table-implementations/&quot;&gt;5 – 哈希表实现&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5.1 – Hash tables 哈希表&lt;/li&gt;
&lt;li&gt;5.2 – Implementations 实现&lt;/li&gt;
&lt;li&gt;5.3 – Conclusion 结论&lt;/li&gt;
&lt;li&gt;5.4 – References 引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6 – 实现存储在文件系统中的高存储效率的哈希表&lt;/p&gt;
&lt;p&gt;7 – 存储管理&lt;/p&gt;
&lt;p&gt;8 – 网络&lt;/p&gt;
&lt;p&gt;9 – 接口：REST, memcached等&lt;/p&gt;
&lt;p&gt;10 – 更进一步&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Tue, 26 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-26-75842-066a29463.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-26-75842-066a29463.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>55分钟学会正则表达式</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;伯乐在线补充：推荐几个正则表达式编辑器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Debuggex ：&lt;a href=&quot;https://www.debuggex.com/&quot; target=&quot;_blank&quot;&gt;https://www.debuggex.com/&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;PyRegex：&lt;a href=&quot;http://www.pyregex.com/&quot; target=&quot;_blank&quot;&gt;http://www.pyregex.com/&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;Regexper：&lt;a href=&quot;http://www.regexper.com/&quot; target=&quot;_blank&quot;&gt;http://www.regexper.com/&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正则表达式是一种查找以及字符串替换操作。正则表达式在文本编辑器中广泛使用，比如正则表达式被用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;检查文本中是否含有指定的特征词&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;找出文中匹配特征词的位置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;从文本中提取信息，比如：字符串的子串&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;修改文本&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;与文本编辑器相似，几乎所有的高级编程语言都支持正则表达式。在这样的语境下，“文本”也就是一个字符串，可以执行的操作都是类似的。一些编程语言（比如Perl，JavaScript）会检查正则表达式的语法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;正则表达式是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;正则表达式只是一个字符串。没有长度限制，但是，这样的正则表达式长度往往较短。如下所示是一些正则表达式的例子：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;I had a \S+ day today&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;[A-Za-z0-9\-_]{3,16}&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;\d\d\d\d-\d\d-\d\d&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;v(\d+)(\.\d+)*&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;TotalMessages=&quot;(.*?)&quot;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;&amp;lt;[^&amp;lt;&amp;gt;]&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;这些字符串实际上都是微型计算机程序。正则表达式的语法，实际上是一种轻量级、简洁、适用于特定领域的编程语言。记住这一点，那么你就很容易理解下面的事情：&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;每一个正则表达式，都可以分解为一个指令序列，比如“先找到这样的字符，再找到那样的字符，再从中找到一个字符。。。”&lt;br&gt;
&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;每一个正则表达式都有输入（文本）和输出（匹配规则的输出，有时是修改后的文本）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;正则表达式有可能出现语法错误——不是所有的字符串都是正则表达式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;正则表达式语法很有个性，也可以说很恐怖&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;有时可以通过编译，使得正则表达式执行更快&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;在实现中，正则表达式还有其他的特点。本文将重点讨论正则表达式的核心语法，在几乎所有的正则表达式中都可以见到这些规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;特别提示：正则表达式与文件通配语法无关，比如 *.xml&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;正则表达式的基础语法&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;
&lt;span style=&quot;font-family: Simsun;&quot;&gt;字符&lt;/span&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt; &lt;/span&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;正则表达式中包含了一系列的字符，这些字符只能匹配它们本身。有一些被称为“元字符”的特殊字符，可以匹配一些特殊规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;如下所示的例子中，我用红色标出了元字符。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;I had a &lt;span style=&quot;color: #ff0000;&quot;&gt;\S+&lt;/span&gt; day today&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;code&gt;[A-Za-z0-9\-_]{3,16}&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;\d\d\d\d&lt;/span&gt;-&lt;span style=&quot;color: #ff0000;&quot;&gt;\d\d&lt;/span&gt;-&lt;span style=&quot;color: #ff0000;&quot;&gt;\d\d&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;v&lt;span style=&quot;color: #ff0000;&quot;&gt;(\d+)(\.\d+)*&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;TotalMessages=&quot;&lt;span style=&quot;color: #ff0000;&quot;&gt;(.*?)&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;&amp;lt;&lt;span style=&quot;color: #ff0000;&quot;&gt;[^&amp;lt;&amp;gt;]*&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt; &lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;大部分的字符，包括所有的字母和数字字符，是普通字符。也就意味着，它们只能匹配它们自己，如下所示的正则表达式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cat&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;意味着，只能匹配一个字符串，以“c”开头，然后是字符“a”，紧跟着是字符“t”的字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;到目前为止，正则表达式的功能类似于&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;常规的Find功能&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;Java中的 &lt;code&gt;String.indexOf()&lt;/code&gt; 函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;PHP中的 &lt;code&gt;strpos()&lt;/code&gt;函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;等等&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;注意：不做特殊说明，正则表达式中是区分大小写的。但是，几乎所有正则表达式的实现，都会提供一个Flag用来控制是否区分大小写。&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;div&gt;
&lt;h3&gt;&lt;span style=&quot;font-family: Simsun;&quot;&gt;点“.”&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;我们第一个要讲解的元字符是“.”。这个符号意味着可以匹配任意一个字符。如下所示的正则表达式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;c.t&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;意味着匹配“以c开头,之后是任意一个字符，紧跟着是字母t”的字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;在一段文本中，这样的正则表达式可以用来找出&lt;/span&gt;&lt;span style=&quot;color: #262626; font-family: Simsun; font-size: medium;&quot;&gt;&lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;cot&lt;/code&gt;, &lt;code&gt;czt这样的字符串，甚至可以找出c.t这样的组合，但是不能找到ct或者是coot这样的字符串。&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;使用反斜杠“\”可以忽略元字符，使得元字符的功能与普通字符一样。所以，正则表达式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;c\.t&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;表示“找到字母c,然后是一个句号（“.”），紧跟着字母t”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;反斜杠本身也是一个元字符，这意味着反斜杠本身也可以通过相似的方法变回到普通字符的用途。因此，正则表达式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;c\\t&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;表示匹配“以字符c开头,然后是一个反斜杠，紧跟着是字母t”的字符串。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Simsun; font-size: medium;&quot;&gt;注意！在正则表达式的实现中，.是不能用于匹配换行符的。”换行符“的表示方法在不同实现中也不同。实际编程时，请参考相关文档。在本文中，我认为.是可以匹配任意字符的。实现环境通常会提供一个Flag标志位，来控制这一点。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;字符类&lt;/h2&gt;
&lt;p&gt;字符类是一组在方括号内的字符，表示可以匹配其中的任何一个字符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正则表达式c[aeiou]t，表示可以匹配的字符串是”以c开头，接着是aeiou中的任何一个字符，最后以t结尾”。在文本的实际应用中，这样的正则表达式可以匹配：cat,cet,cit,cot,cut五种字符串。&lt;/li&gt;
&lt;li&gt;正则表达式[0123456789]表示匹配任意一个整数。&lt;/li&gt;
&lt;li&gt;正则表达式[a]表示匹配单字符a。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;包含忽略字符的例子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示匹配字符串[a]&lt;/li&gt;
&lt;li&gt;[&lt;code class=&quot;tex2jax_ignore&quot;&gt;\[\]&lt;/code&gt;\ab]表示匹配的字符为”[&quot;或者&#39;&#39;]”或者”a”,或者”b”&lt;/li&gt;
&lt;li&gt;[\\&lt;code class=&quot;tex2jax_ignore&quot;&gt;\[\]&lt;/code&gt;]表示匹配的字符为”\”或者 “[”或者&quot;]“&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在字符类中，字符的重复和出现顺序并不重要。[dabaaabcc]与[abc]是相同的&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;重要提示：字符类中和字符类外的规则有时不同，一些字符在字符类中是元字符，在字符类外是普通字符。一些字符正好相反。还有一些字符在字符类中和字符类外都是元字符，这要视情况而定！&lt;/p&gt;

&lt;/div&gt;
&lt;h3&gt;字符类的范围&lt;/h3&gt;
&lt;p&gt;在字符集中，你可以通过使用短横线来表示匹配字母或数字的范围。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[b-f]与[b,c,d,e,f]相同，都是匹配一个字符”b”或”c”或”d”或”e”或”f”&lt;/li&gt;
&lt;li&gt;[A-Z]与[ABCDEFGHIJKLMNOPQRSTUVWXYZ]相同，都是匹配任意一个大写字母。&lt;/li&gt;
&lt;li&gt;[1-9]与[123456789]相同，都是匹配任意一个非零数字。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;使用目前我们已经讲解的正则表达式相关知识，在字典中匹配找到含有最多连续元音的单词，同时找到含有最多连续辅音的单词。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;[aeiou][aeiou][aeiou][aeiou][aeiou][aeiou]&lt;/code&gt; 这样的正则表达式，可以匹配连续含有六个元音的单词，比如 &lt;code&gt;euouae&lt;/code&gt; 和 &lt;code&gt;euouaes&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;同样的，恐怖的正则表达式&lt;/span&gt;&lt;/code&gt;&lt;code&gt;[bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz]&lt;/code&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt; 可以找到连续含有十个辅音的单词&lt;/span&gt;&lt;code&gt;sulphhydryls&lt;/code&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;下文中，我们会讲解，怎样有效缩短这样的正则表达式长度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在字符类之外，短横线没有特殊含义。正则表达式a-z，表示匹配字符串“以a开头，然后是一个短横线，以z结尾”。&lt;/p&gt;
&lt;p&gt;范围和单独的字符可能在一个字符类中同时出现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[0-9.,]表明匹配一个数字，或者一个全角句号，或者一个逗号&lt;/li&gt;
&lt;li&gt;[0-9a-fA-F]意味着匹配一个十六进制数&lt;/li&gt;
&lt;li&gt;[a-zA-Z0-9\-]意味着匹配一个字母、数字或者一个短横线&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;使用已经介绍过的正则表达式知识，匹配YYYY-MM-DD格式的日期。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;同样的，下文中，我们会介绍怎样有效减少这样的正则表达式长度。&lt;/p&gt;
&lt;p&gt;虽然你可以尝试在正则表达式中使用一些非字母或数字作为范围的最后一个符号，比如abc[!-/]def，但是这并不是在每种实现中都合法。即使这样的语法是合法的，这样的语义也是模糊的。最好不要这样使用。&lt;/p&gt;
&lt;p&gt;同时，你必须谨慎选择范围的边界值。即使[A-z]在你使用的实现中，是合法的，也可能会产生无法预料的运行结果。（注意，在z到a之间，是有字符存在的）&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;b&gt;注意：&lt;/b&gt;范围的字符值代表的是字符而已，并不能代表数值范围，比如[1-31]表示匹配一个数字，是1或者2或者3，而不是匹配一个数值在1到31之间的数。&lt;/p&gt;
&lt;div&gt;
&lt;h3&gt;字符类的反义&lt;/h3&gt;
&lt;p&gt;你可以在字符类的起始位放一个反义符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[^a]表示匹配任何不是“a”的字符&lt;/li&gt;
&lt;li&gt;[^a-zA-Z0-9]表示匹配任何不是字母也不是数字的字符&lt;/li&gt;
&lt;li&gt;[\^abc]匹配一个为“^”或者a或者b或者c的字符&lt;/li&gt;
&lt;li&gt;[^\^]表示匹配任何不为“^”的字符&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在字典中，找到一个不满足“在e之前有i，但是没有c”的例子。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;cie和[^c]ei都要可以找到很多这样的例子，比如ancient,science,viel,weigh&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;转义字符类&lt;/h3&gt;
&lt;p&gt;\d这个正则表达式与[0-9]作用相同，都是匹配任何一个数字。（要匹配\d,应该使用正则表达式\\d）&lt;/p&gt;
&lt;p&gt;\w与[0-9A-Za-z]相同，都表示匹配一个数字或字母字符&lt;/p&gt;
&lt;p&gt;\s意味着匹配一个空字符（空格，制表符，回车或者换行）&lt;/p&gt;
&lt;p&gt;另外&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\D与[^0-9]相同，表示匹配一个非数字字符。&lt;/li&gt;
&lt;li&gt;\W与[^0-9A-Za-z]相同，表示匹配一个非数字同时不是字母的字符。&lt;/li&gt;
&lt;li&gt;\S表示匹配一个非空字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些是你必须掌握的字符。你可能已经注意到了，一个全角句号“.”也是一个字符类，可以匹配任意一个字符。&lt;/p&gt;
&lt;p&gt;很多正则表达式的实现中，提供了更多的字符类，或者是标志位在ASCII码的基础上，扩展现有的字符类。&lt;/p&gt;
&lt;p&gt;特别提示：统一字符集中包含除了0至9之外的更多数字字符，同样的，也包含更多的空字符和字母字符。实际使用正则表达式时，请仔细查看相关文档。&lt;/p&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;简化正则表达式 &lt;code&gt;[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;\d\d\d\d-\d\d-\d\d&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;重复&lt;/h3&gt;
&lt;p&gt;在字符或字符集之后，你可以使用{ }大括号来表示重复&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正则表达式a{1}与a意思相同，都表示匹配字母a&lt;/li&gt;
&lt;li&gt;a{3}表示匹配字符串“aaa”&lt;/li&gt;
&lt;li&gt;a{0}表示匹配空字符串。从这个正则表达式本身来看，它毫无意义。如果你对任何文本执行这样的正则表达式，你可以定位到搜索的起始位置，即使文本为空。&lt;/li&gt;
&lt;li&gt;a\{2\}表示匹配字符串“a{2}”&lt;/li&gt;
&lt;li&gt;在字符类中，大括号没有特殊含义。[{}]表示匹配一个左边的大括号，或者一个右边的大括号&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;简化下面的正则表达式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;z.......z&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\d\d\d\d-\d\d-\d\d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[aeiou][aeiou][aeiou][aeiou][aeiou][aeiou]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz][bcdfghjklmnpqrstvwxyz]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;z.{7}z&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\d{4}-\d{2}-\d{2}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[aeiou]{6}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[bcdfghjklmnpqrstvwxyz]{10}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;指定重复次数范围&lt;/h3&gt;
&lt;p&gt;重复次数是可以指定范围的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x{4,4}与x{4}相同&lt;/li&gt;
&lt;li&gt;colou{0,1}r表示匹配colour或者color&lt;/li&gt;
&lt;li&gt;a{3,5}表示匹配aaaaa或者aaaa或者aaa&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;注意这样的正则表达式会优先匹配最长字符串，比如输入 &lt;/span&gt;&lt;code&gt;I had an aaaaawful day&lt;/code&gt;&lt;code&gt;&lt;span style=&quot;font-family: Tahoma;&quot;&gt;会匹配单词aaaaawful中的aaaaa，而不会匹配其中的aaa。&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;重复次数是可以有范围的，但是有时候这样的方法也不能找到最佳答案。如果你的输入文本是&lt;/span&gt;I had an aaawful daaaaay&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;那么在第一次匹配时，只能找到aaawful，只有再次执行匹配时才能找到daaaaay中的aaaaa.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;重复次数的范围可以是开区间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a{1，}表示匹配一个或一个以上的连续字符a。依然是匹配最长字符串。当找到第一个a之后，正则表达式会尝试匹配尽量多个的连续字母a。&lt;/li&gt;
&lt;li&gt;.{0,}表示匹配任意内容。无论你输入的文本是什么，即使是一个空字符串，这个正则表达式都会成功匹配全文并返回结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;使用正则表达式找到双引号。要求输入字符串可能包含任意个字符。&lt;/p&gt;
&lt;p&gt;调整你的正则表达式使得在一对双引号中间不再包含其他的双引号。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/h4&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;关于重复的转义字符&lt;/h3&gt;
&lt;p&gt;？与{0,1}相同，比如，colou?r表示匹配colour或者color&lt;/p&gt;
&lt;p&gt;*与{0,}相同。比如，.*表示匹配任意内容&lt;/p&gt;
&lt;p&gt;+与{1，}相同。比如,\w+表示匹配一个词。其中”一个词”表示由一个或一个以上的字符组成的字符串，比如_var或者AccountName1.&lt;/p&gt;
&lt;p&gt;这些是你必须知道的常用转义字符，除此之外还有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\?\*\+ 表示匹配字符串”?*+”&lt;/li&gt;
&lt;li&gt;[?*+]表示匹配一个问号，或者一个*号，或者一个加号&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;简化下列的正则表达式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;&quot;.{0,}&quot;&lt;/code&gt; and &lt;code&gt;&quot;[^&quot;]{0,}&quot;&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x?x?x?&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y*y*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;z+z+z+z+&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;&lt;b&gt;答案&lt;/b&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;&quot;.*&quot;&lt;/code&gt; and &lt;code&gt;&quot;[^&quot;]*&quot;&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x{0,3}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;z{4,&lt;/code&gt;}&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;写出正则表达式，寻找由非字母字符分隔的两个单词。如果是三个呢？六个呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\w+\W+\w+&lt;/code&gt;, &lt;code&gt;\w+\W+\w+\W+\w+&lt;/code&gt;, &lt;code&gt;\w+\W+\w+\W+\w+\W+\w+\W+\w+\W+\w+&lt;/code&gt;.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt; 非贪婪匹配&lt;/h3&gt;
&lt;p&gt;正则表达式 “.*” 表示匹配双引号，之后是任意内容，之后再匹配一个双引号。注意，其中匹配任意内容也可以是双引号。通常情况下，这并不是很有用。通过在句尾加上一个问号，可以使得字符串重复不再匹配最长字符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\d{4,5}?表示匹配\d\d\d\d或者\d\d\d\d\d。也就是和\d{4}一样&lt;/li&gt;
&lt;li&gt;colou??r与colou{0,1}r相同，表示找到color或者colour。这与colou?r一样。&lt;/li&gt;
&lt;li&gt;“.*?”表示先匹配一个双引号，然后匹配最少的字符，然后是一个双引号，与上面两个例子不同，这很有用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;选择匹配&lt;/h3&gt;
&lt;p&gt;你可以使用|来分隔可以匹配的不同选择:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cat|dog表示匹配”cat”或者”dog”&lt;/li&gt;
&lt;li&gt;red|blue|以及red||blue以及|red|blue都表示匹配red或者blue或者一个空字符串&lt;/li&gt;
&lt;li&gt;a|b|c与[abc]相同&lt;/li&gt;
&lt;li&gt;cat|dog|\|表示匹配”cat”或者”dog”或者一个分隔符”|“&lt;/li&gt;
&lt;li&gt;[cat|dog]表示匹配a或者c或者d或者g或者o或者t或者一个分隔符“|”&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;简化下列正则表达式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;s|t|u|v|w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aa|ab|ba|bb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[abc]|[^abc]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[^ab]|[^bc]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ab][ab][ab]?[ab]?&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span style=&quot;font-family: &#39;Ubuntu Mono&#39;, monospace;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;答案&lt;/span&gt;&lt;/strong&gt;&lt;br&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[s-w]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ab]{2}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[^b]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ab]{2,4}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;使用正则表达式匹配1到31之间的整数，[1-31]不是正确答案！&lt;/p&gt;
&lt;p&gt;这样的正则表达式不唯一. &lt;code&gt;[1-9]|[12][0-9]|3[01]&lt;/code&gt; 是其中之一。&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;分组&lt;/h3&gt;
&lt;p&gt;你可以使用括号表示分组:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;span style=&quot;font-family: Tahoma;&quot;&gt;通过使用 &lt;/span&gt;Mon|Tues|Wednes|Thurs|Fri|Satur|Sun)day &lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;匹配一周中的某一天&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;(\w*)ility &lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt; &lt;/span&gt;与&lt;/span&gt; \w*ility &lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;相同。都是匹配一个由”ility”结尾的单词。稍后我们会讲解，为何第一种方法更加有用。&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span class=&quot;MathJax_Preview&quot;&gt;\(\)&lt;/span&gt;表示匹配一对括号。&lt;/li&gt;
&lt;li&gt;[()]表示匹配任意一个左括号或者一个右括号&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在《时间机器中》找到一对括号中的内容，然后通过修改正则表达式，找到不含括号的内容。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/h4&gt;

&lt;/div&gt;
&lt;p&gt;分组可以包括空字符串：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(red|blue)表示匹配red或者blue或者是一个空字符串&lt;/li&gt;
&lt;li&gt;abc()def与abcdef相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你也可以在分组的基础上使用重复：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(red|blue)？与(red|blue|)相同&lt;/li&gt;
&lt;li&gt;\w+(\s+\w+)表示匹配一个或多个由空格分隔的单词&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;简化正则表达式 &lt;code&gt;\w+\W+\w+\W+\w+&lt;/code&gt; 以及 &lt;code&gt;\w+\W+\w+\W+\w+\W+\w+\W+\w+\W+\w+&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;\w+(\W+\w+){2}&lt;/code&gt;, &lt;code&gt;\w+(\W+\w+){5}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;单词分隔符&lt;/h3&gt;
&lt;p&gt;在单词和非单词之间有单词分隔符。记住，一个单词\w是[0-9A-Za-z_]，而非单词字符是\W(大写)，表示[^0-9A-Za-z_].&lt;/p&gt;
&lt;p&gt;在文本的开头和结尾通常也有单词分隔符。&lt;/p&gt;
&lt;p&gt;在输入文本it’s a cat中，实际有八个单词分隔符。如果我们在cat之后在上一个空格，那就有九个单词分隔符。.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\b表示匹配一个单词分隔符&lt;/li&gt;
&lt;li&gt;\b\w\w\w\b表示匹配一个三字母单词&lt;/li&gt;
&lt;li&gt;a\ba表示匹配两个a中间有一个单词分隔符。这个正则表达式永远不会有匹配的字符，无论输入怎样的文本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;单词分隔符本身并不是字符。它们的宽度为0。下列正则表达式的作用不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(\bcat)\b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(\bcat\b)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\b(cat)\b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\b(cat\b)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在词典中找到最长的单词。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/h4&gt;

&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;换行符&lt;/h3&gt;
&lt;p&gt;一篇文本中可以有一行或多行，行与行之间由换行符分隔，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Line一行文字&lt;/li&gt;
&lt;li&gt;Line break换行符&lt;/li&gt;
&lt;li&gt;Line一行文字&lt;/li&gt;
&lt;li&gt;Line break换行符&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;li&gt;Line break换行符&lt;/li&gt;
&lt;li&gt;Line一行文字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，所有的文本都是以一行结束的，而不是以换行符结束。但是，任意一行都可能为空，包括最后一行。&lt;/p&gt;
&lt;p&gt;行的起始位置，是在换行符和下一行首字符之间的空间。考虑到单词分隔符，文本的起始位置也可以当做是首行位置。&lt;/p&gt;
&lt;p&gt;最后一行是最后一行的尾字符和换行符之间的空间。考虑到单词分隔符，文本的结束也可以认为是行的结束。&lt;/p&gt;
&lt;p&gt;那么新的格式表示如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Start-of-line, line, end-of-line&lt;/li&gt;
&lt;li&gt;Line break&lt;/li&gt;
&lt;li&gt;Start-of-line, line, end-of-line&lt;/li&gt;
&lt;li&gt;Line break&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;li&gt;Line break&lt;/li&gt;
&lt;li&gt;Start-of-line, line, end-of-line&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于上述概念:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;^表示匹配行的开始位置&lt;/li&gt;
&lt;li&gt;$表示匹配行的结束位置&lt;/li&gt;
&lt;li&gt;^&amp;amp;表示一个空行&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;^.*&amp;amp;&lt;/code&gt;&lt;code&gt;&lt;span style=&quot;font-family: Tahoma;&quot;&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt; &lt;/span&gt;表示匹配全文内容，因为行的开始符号也是一个字符，&quot;.&quot;会匹配这个符号。找到单独的一行，可以使用&lt;/span&gt;&lt;/code&gt; ^.*?$&lt;/li&gt;
&lt;li&gt;\^\$表示匹配字符串“^$”&lt;/li&gt;
&lt;li&gt;[$]表示匹配一个$。但是，[^]不是合法的正则表达式。记住在方括号中，字符有不同的特殊含义。要想在方括号内匹配^，必须用[\^]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与字符分隔符一样，换行符也不是字符。它们宽度为0.如下所示的正则表达式作用不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(^cat)$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(^cat$)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^(cat)$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^(cat$)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;使用正则表达式在《时间机器》中找到最长的一行。&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;答案&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;b&gt;&lt;/b&gt;使用正则表达式^.{73,}$可以匹配长度为73的一行&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;文本分界&lt;/h3&gt;
&lt;p&gt;在很多的正则表达式实现中，将^和$作为文本的开始符号和结束符号。&lt;/p&gt;
&lt;p&gt;还有一些实现中，用\A和\z作为文本的开始和结束符号。&lt;/p&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;捕捉和替换&lt;/h2&gt;
&lt;p&gt;从这里开始，正则表达式真正体现出了它的强大。&lt;/p&gt;
&lt;h3&gt;捕获组&lt;/h3&gt;
&lt;p&gt;你已经知道了使用括号可以匹配一组符号。使用括号也可以捕获子串。假设正则表达式是一个小型计算机程序，那么捕获子串就是它输出的一部分。&lt;/p&gt;
&lt;p&gt;正则表达式(\w*)ility表示匹配以ility结尾的词。第一个被捕获的部分是由\w*控制的。比如，输入的文本内容中有单词accessibility，那么首先被捕获的部分是accessib。如果输入的文本中有单独的ility，则首先被捕获的是一个空字符串。&lt;/p&gt;
&lt;p&gt;你可能会有很多的捕获字符串，它们可能靠得很近。捕获组从左向右编号。也就是只需要对左括号计数。&lt;/p&gt;
&lt;p&gt;假设有这样的正则表达式：(\w+) had a ((\w+) \w+)&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Tahoma;&quot;&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;输入的内容是：&lt;/span&gt;&lt;/span&gt;I had a nice day &lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;捕获组1：I&lt;/li&gt;
&lt;li&gt;捕获组2：nice day&lt;/li&gt;
&lt;li&gt;捕获组3:nice&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一些正则表达式的实现中，你可以从零开始编号，编号零表示匹配整句话：&lt;code&gt;I had a nice day&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在其他的实现中，如果没有制定捕获组，那么捕获组1会自动地填入捕获组0的信息。&lt;/p&gt;
&lt;p&gt;是的，这也意味着会有很多的括号。有一些正则表达式的实现中，提供了“非捕获组”的语法，但是这样的语法并不是标准语法，因此我们不会介绍。&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;从一个成功的匹配中返回的捕获组个数，与使用原来的正则表达式获得的捕获组个数相同。记住这一点，你可以解释一些奇怪的现象。.&lt;/p&gt;
&lt;p&gt;正则表达式（（cat）|dog）表示匹配cat或者dog。这里有两个捕获组，如果输入文本是dog，那么捕获组1是dog,捕获组2为空。&lt;/p&gt;
&lt;p&gt;正则表达式a(\w)*表示匹配一个以a开头的单词。这里只有一个捕获组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果输入文本为a,捕获组1为空。&lt;/li&gt;
&lt;li&gt;如果输入文本为ad,捕获组为d&lt;/li&gt;
&lt;li&gt;如果输入文本为avocado，捕获组1为v。但是捕获组0表示整个单词avocado.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;替换&lt;/h3&gt;
&lt;p&gt;假如你使用了一个正则表达式去匹配字符串，你可以描述另外一个字符串来替换其中的匹配字符。用来替换的字符串称为替换表达式。它的功能类似于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常规的Replace会话&lt;/li&gt;
&lt;li&gt;Java中的String.replace()函数&lt;/li&gt;
&lt;li&gt;PHP的str_replace()函数&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;将《时间机器》中所有的元音字母替换为r。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/h4&gt;

&lt;/div&gt;
&lt;p&gt;但是，你可以在替换表达式中引用捕获组。这是在替换表达式中，你可以唯一操作的地方。这也是非常有效的，因为这样你就不用重构你找到的字符串。&lt;/p&gt;
&lt;p&gt;假设你正在尝试将美国风格的日期表示MM/DD/YY替换为ISO 8601日期表示YYYY-MM-DD&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从正则表达式&lt;span style=&quot;color: #0000ff;&quot;&gt;(\d\d)/(\d\d)/(\d\d)&lt;/span&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;开始。注意，这其中有三个捕获组：月份，日期和两位的年份。&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;.捕获组的内容和捕获组编号之间用反斜杠分隔，因此你的替换表达式应该是&lt;code&gt;20\3-\1-\2&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;如果我们输入的文本中包含03/04/05表示2005年3月4日那么：
&lt;ul&gt;
&lt;li&gt;捕获组1:03&lt;/li&gt;
&lt;li&gt;捕获组2：04&lt;/li&gt;
&lt;li&gt;捕获组3：05&lt;/li&gt;
&lt;li&gt;替换字符串&lt;code style=&quot;font-style: inherit; font-weight: inherit;&quot;&gt;2005-03-04&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在替换表达式中，你可以多次使用捕获组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于双元音，正则表达式为([aeiou])，替换表达式为\l\l&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;font-family: Tahoma;&quot;&gt;在替换表达式中不能使用反斜杠。&lt;/span&gt;&lt;span style=&quot;color: #888888; font-family: &#39;Ubuntu Mono&#39;, monospace; font-size: medium;&quot;&gt;比如，你&lt;/span&gt;&lt;span style=&quot;font-family: Tahoma;&quot;&gt;在计算机程序中希望使用字符串中使用部分文本。那么，你必须在每个双引号或者反斜杠之前加上反斜杠。&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;你的正则表达式可以是&lt;span style=&quot;font-family: &#39;Ubuntu Mono&#39;, monospace;&quot;&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;([\\&quot;])&lt;/span&gt;&lt;span style=&quot;color: #262626;&quot;&gt;。&lt;/span&gt;&lt;span style=&quot;color: #262626; font-size: medium;&quot;&gt;捕获组1是双引号或者反斜杠&lt;/span&gt;&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: #262626; font-family: &#39;Ubuntu Mono&#39;, monospace; font-size: medium;&quot;&gt;你的替换表达式应该是\\\l&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;

&lt;/div&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;使用正则表达式和替换表达式，将23h59这样的时间戳转化为23:59.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/h4&gt;

&lt;/div&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;反向引用&lt;/h3&gt;
&lt;p&gt;在一个正则表达式中，你也可以引用捕获组。这称作：反向引用&lt;/p&gt;
&lt;p&gt;比如，[abc]{2}表示匹配aa或者ab或者ac或者ba或者bb或者bc或者ca或者cb或者cc.但是{[abc]}\1表示只匹配aa或者bb或者cc.&lt;/p&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在字典中，找到包含两次重复子串的最长单词，比如&lt;code&gt;papa&lt;/code&gt;, &lt;code&gt;coco&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\b(.{6,})\1\b&lt;/code&gt; 匹配 &lt;code&gt;chiquichiqui&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;如果我们不在乎单词的完整性，我们可以忽略单词的分解，使用正则表达式 &lt;/span&gt;&lt;code&gt;(.{7,})\1&lt;/code&gt;&lt;code&gt;&lt;span style=&quot;font-family: Tahoma;&quot;&gt;匹配&lt;/span&gt;&lt;/code&gt;&lt;code&gt;countercountermeasure&lt;/code&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt; 以及 &lt;/span&gt;&lt;code&gt;countercountermeasures&lt;/code&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;使用正则表达式编程&lt;/h2&gt;
&lt;p&gt;特别提醒：&lt;/p&gt;
&lt;h3&gt;过度使用的反斜杠&lt;/h3&gt;
&lt;p&gt;在一些编程语言，比如Java中，对于包含正则表达式的字符串没有特殊标记。字符串有着自己的过滤规则，这是优先于正则表达式规则的，这是频繁使用反斜杠的原因。&lt;/p&gt;
&lt;p&gt;比如在Java中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配一个数字，使用的正则表达式从\d变为代码中的String re= “\\d”&lt;/li&gt;
&lt;li&gt;匹配双引号字符串的正则表达式从&lt;code style=&quot;font-style: inherit; font-weight: inherit;&quot;&gt;&quot;[^&quot;]*&quot;&lt;/code&gt; 变为String re = “\”[^\&quot;]*\”&quot;&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;font-family: Tahoma;&quot;&gt;匹配反斜杠或者是左边方括号，或者右边方括号的正则表达式从&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;[\\&lt;code class=&quot;tex2jax_ignore&quot;&gt;\[\]&lt;/code&gt;] &lt;/span&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;变为&lt;/span&gt;String re = “[\\\\\]”;&lt;/li&gt;
&lt;li&gt;
&lt;code style=&quot;font-style: inherit; font-weight: inherit;&quot;&gt;String re = &quot;\\s&quot;;&lt;/code&gt; 和&lt;code style=&quot;font-style: inherit; font-weight: inherit;&quot;&gt;String re = &quot;[ \t\r\n]&quot;;&lt;/code&gt; 是等价的. 注意它们实际执行调用时的层次不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在其他的编程语言中，正则表达式是由特殊标明的，比如使用/。下面是JavaScript的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配一个数字，\d会简单写成 &lt;code style=&quot;font-style: inherit; font-weight: inherit;&quot;&gt;var regExp = /\d/;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;匹配一个反斜杠或者一个左边的方括号或者一个右边的方括号， &lt;code style=&quot;font-style: inherit; font-weight: inherit;&quot;&gt;var regExp = /[\\&lt;code class=&quot;tex2jax_ignore&quot;&gt;\[\]&lt;/code&gt;]/;&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;code style=&quot;font-style: inherit; font-weight: inherit;&quot;&gt;var regExp = /\s/;&lt;/code&gt; 和 &lt;code style=&quot;font-style: inherit; font-weight: inherit;&quot;&gt;var regExp = /[ \t\r\n]/;&lt;/code&gt; 是等价的&lt;/li&gt;
&lt;li&gt;当然，这意味着在使用/时必须重复两次。比如找到URL必须使用&lt;code style=&quot;font-style: inherit; font-weight: inherit;&quot;&gt;var regExp = /https?:\/\//;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我希望现在你能明白，我为什么让你特别注意反斜杠。&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;动态正则表达式&lt;/h3&gt;
&lt;p&gt;当你动态创建一个正则表达式的时候请特别小心。如果你使用的字符串不够完善的花，可能会有意想不到的匹配结果。这可能导致语法错误，更糟糕的是，你的正则表达式语法正确，但是结果无法预料。&lt;/p&gt;
&lt;p&gt;错误的Java代码：&lt;/p&gt;
&lt;p&gt;String sep = System.getProperty(“file.separator”); String[] directories = filePath.split(sep);&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Tahoma;&quot;&gt;Bug:&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;String.split() &lt;/span&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;认为sep是一个正则表达式。但是，在Windows中，Sep是表示匹配一个反斜杠，也就是与正则表达式”\\”相同。这个正则表达式是正确的，但是会返回一个异常：&lt;/span&gt;&lt;code&gt;PatternSyntaxException&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;任何好的编程语言都会提供一种良好的机制来跳过字符串中所有的元字符。在Java中，你可以这样实现：&lt;/p&gt;
&lt;p&gt;String sep = System.getProperty(“file.separator”);&lt;/p&gt;
&lt;p&gt;String[] directories = filePath.split(Pattern.quote(sep));&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;循环中的正则表达式&lt;/h3&gt;
&lt;p&gt;将正则表达式字符串加入反复运行的程序中，是一种开销很大的操作。如果你可以在循环中避免使用正则表达式，你可以大大提高效率。&lt;/p&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;其他建议&lt;/h2&gt;
&lt;h3&gt;输入验证&lt;/h3&gt;
&lt;div&gt;正则表达式可以用来进行输入验证。但是严格的输入验证会使得用户体验较差。比如：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h4&gt;信用卡号&lt;/h4&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;在一个网站上，我输入了我的卡号比如 &lt;/span&gt;&lt;code&gt;1234 5678 8765 4321 &lt;/code&gt;&lt;code&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;网站拒绝接收。因为它使用了正则表达式\d{16}。&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span style=&quot;font-family: Tahoma; font-size: medium;&quot;&gt;正则表达式应该考虑到用户输入的空格和短横线。&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;实际上，为什么不先过滤掉所有的非数字字符，然后再进行有效性验证呢？这样做，可以先使用\D以及空的替换表达式。&lt;/p&gt;
&lt;div&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在不先过滤掉所有的非数字字符的情况下，使用正则表达式验证卡号的正确性。&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;答案&lt;/b&gt;&lt;/h4&gt;

&lt;/div&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;名字&lt;/h4&gt;
&lt;p&gt;不要使用正则表达式来验证姓名。实际上，即使可以，也不要企图验证姓名。&lt;/p&gt;
&lt;p&gt;程序员对名字的错误看法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名字中不含空格&lt;/li&gt;
&lt;li&gt;名字中没有连接符号&lt;/li&gt;
&lt;li&gt;名字中只会使用ASCII码字符&lt;/li&gt;
&lt;li&gt;名字中出现的字都在特殊字符集中&lt;/li&gt;
&lt;li&gt;名字至少要有M个字的长度&lt;/li&gt;
&lt;li&gt;名字不会超过N个字的长度&lt;/li&gt;
&lt;li&gt;人们只有一个名&lt;/li&gt;
&lt;li&gt;人们只有一个中间名&lt;/li&gt;
&lt;li&gt;人们只有一个姓（最后三条是从英语的人名考虑）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;电子邮件地址&lt;/h4&gt;
&lt;p&gt;不要使用正则表达式验证邮箱地址的正确性。&lt;/p&gt;
&lt;p&gt;首先，这样的验证很难是精确的。电子邮件地址是可以用正则表达式验证的，但是表达式会非常的长并且复杂。&lt;/p&gt;
&lt;p&gt;短的正则表达式会导致错误。（你知道吗？电子邮箱地址中会有一些注释）&lt;/p&gt;
&lt;p&gt;第二，即使一个电子邮件地址可以成功匹配正则表达式，也不代表这个邮箱实际存在。邮箱的唯一验证方法，是发送验证邮件。&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;注意&lt;/h3&gt;
&lt;p&gt;在严格的应用场景中，不要使用正则表达式来解析HTML或者XML。解析HTML或者XML：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用简单的正则表达式不能完成&lt;/li&gt;
&lt;li&gt;总体来说非常困难&lt;/li&gt;
&lt;li&gt;已经有其他的方法解决&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;找到一个已经有的解析库来完成这个工作&lt;/p&gt;
&lt;h2&gt;这就是55分钟的全部内容&lt;/h2&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符: &lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; &lt;code&gt;2&lt;/code&gt; &lt;code&gt;3&lt;/code&gt; &lt;code&gt;4&lt;/code&gt; etc.&lt;/li&gt;
&lt;li&gt;字符类: &lt;code&gt;.&lt;/code&gt; &lt;code&gt;[abc]&lt;/code&gt; &lt;code&gt;[a-z]&lt;/code&gt; &lt;code&gt;\d&lt;/code&gt; &lt;code&gt;\w&lt;/code&gt; &lt;code&gt;\s&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;.&lt;/code&gt; 代表任何字符&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;\d &lt;/code&gt;&lt;code&gt;&lt;span style=&quot;color: #262626; font-family: Tahoma; font-size: medium;&quot;&gt;表示&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;font-family: Tahoma;&quot;&gt;“数字”&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;\w&lt;/code&gt;   表示”字母”, &lt;code&gt;[0-9A-Za-z_]&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;\s  &lt;/code&gt; 表示 “空格, 制表符,回车或换行符”&lt;/li&gt;
&lt;li&gt;否定字符类: &lt;code&gt;[^abc]&lt;/code&gt; &lt;code&gt;\D&lt;/code&gt; &lt;code&gt;\W&lt;/code&gt; &lt;code&gt;\S&lt;/code&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重复: &lt;code&gt;{4}&lt;/code&gt; &lt;code&gt;{3,16}&lt;/code&gt; &lt;code&gt;{1,}&lt;/code&gt; &lt;code&gt;?&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;+&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;?&lt;/code&gt; 表示 “零次或一次”&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;*&lt;/code&gt; 表示 “大于零次”&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;+&lt;/code&gt; 表示 “一次或一次以上”&lt;/li&gt;
&lt;li&gt;如果不加上？，所有的重复都是最长匹配的（贪婪）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分组: &lt;code&gt;(Septem|Octo|Novem|Decem)ber&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;词，行以及文本的分隔: &lt;code&gt;\b&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;$&lt;/code&gt; &lt;code&gt;\A&lt;/code&gt; &lt;code&gt;\z&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;转义字符: &lt;code&gt;\1&lt;/code&gt; &lt;code&gt;\2&lt;/code&gt; &lt;code&gt;\3&lt;/code&gt; etc. (在匹配表达式和替换表达式中都可用)&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;元字符: &lt;code&gt;.&lt;/code&gt; &lt;code&gt;\&lt;/code&gt; &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; &lt;code&gt;?&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;$&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;在字符类中使用元字符: &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; &lt;code&gt;\&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;^&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;使用反斜杠可以忽略元字符: &lt;code&gt;\&lt;/code&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt; 致谢&lt;/h3&gt;
&lt;p&gt;正则表达式非常常用而且非常有用。每个人在编辑文本或是编写程序时都必须了解怎样使用正则表达式。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/h4&gt;
&lt;h4&gt;选择正则表达式的某种实现，阅读相关文档。我保证，你会学到更多。&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 25 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-25-63398-97adb9f33.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-25-63398-97adb9f33.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>模式匹配初析</title>
        <description>
&lt;pre&gt;&lt;code&gt;前几天看到篇C#6.0的draft spec，发现C#6.0里将惊现模式匹配。如是便在做了翻宣讲说“模式匹配”是一个很好用的特性，
但是不知道跟C#的结合会怎么样。而同时却又发现周边了解“模式匹配”的人好少，于是诞生了写一篇文章稍微介绍下这
一功能特性的想法。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果说模式匹配这一概念有人不知道，但是正则表达式应该绝大多数的程序员都知道的了。而简言之，&lt;strong&gt;模式匹配就是更强大的正则表达式，或者说正则表达式是模式匹配这一概念在字符串处理上的一个应用&lt;/strong&gt;。有了正则表达式为例，我们可以为模式匹配定义一个更为通用的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;模式匹配是判断输入的数据（信息）是否与特定的结构相匹配，并按模式从中取得数据（信息）。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下以正则表达式为例，从输入数据value里按pattern提取数据digits的模式匹配过程。&lt;/p&gt;

&lt;figure class=&quot;code&quot;&gt;&lt;figcaption&gt;&lt;span&gt;&lt;/span&gt;&lt;/figcaption&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;
&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;abc123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/\d/g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//定义模式&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;digits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]&lt;/span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;


&lt;p&gt;那更广泛意义上的模式匹配是什么呢？其实很简单，就是输入/提取数据（信息）的范围不再局限为字符串了，甚至可以是编程语言支持的所有数据结构。第一次接触模式匹配这一概念，是前几年学习erlang的时候，下面就主要以erlang为例，来对模式匹配稍作介绍。&lt;/p&gt;

&lt;p&gt;先上点erlang里的”甜点”为例来说明：&lt;/p&gt;

&lt;p&gt;(erlang基础知识：大写字母开头的声明为变量，比如下面例子里的P，H,T;小写字母的声明是原子,比如abc)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;模式{abc，P}与输入数据项{abc,123}匹配，并在匹配的同时，发生绑定P-&amp;gt;123

模式[H|T]与输入数据项[1,2,3,4]匹配，并在匹配的同时，发生绑定H-&amp;gt;1,T-&amp;gt;[2,3,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个例子匹配的过程如下：&lt;/p&gt;

&lt;p&gt;1.先进行类型匹配：模式和数据项都是一个元组（“{}”），匹配通过。&lt;/p&gt;

&lt;p&gt;2.模式元组的第一个元素为常量，进行匹配：模式和数据项都是“abc”,匹配通过。&lt;/p&gt;

&lt;p&gt;3.模式元组的第二个元素是一个变量P，同时后面不再有任何元素，结束匹配，并将P绑定到数据项第一个元素后的所有元素。&lt;/p&gt;

&lt;p&gt;第二个例子匹配过程如下：&lt;/p&gt;

&lt;p&gt;1.先进行类型匹配，模式和数据项都是一个列表（“[]”），匹配通过。&lt;/p&gt;

&lt;p&gt;2.模式”[H|T]”表示的是一个“首尾”匹配，用“|”分开两个变量（H，T），H表示的首元素匹配，T表示尾部（除首元素外的所有元素）匹配。匹配是通过的,并绑定H和T的值为首元素和尾元素。&lt;/p&gt;

&lt;p&gt;再来一个高级点的例子：&lt;strong&gt;使用模式匹配来处理消息的接收&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;(erlang基础知识：erlang的调用是基于CSP的，各个actor之间通过消息通讯带完成调用;receive原语是erlang提供的消息接收机制，可监听和接收来自其它actor发送来的消息;”！”标识符用于向对应的actor发送消息)。&lt;/p&gt;

&lt;figure class=&quot;code&quot;&gt;&lt;figcaption&gt;&lt;span&gt;&lt;/span&gt;&lt;/figcaption&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;
&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;9&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;11&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;12&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;13&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;14&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;erlang&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;nf&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;k&quot;&gt;receive&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;%消息接收的原语，获取调用方的消息&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;%匹配数据存储的消息，&quot;store&quot;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;%真实的存储&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;From&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;%匹配数据获取的消息, From匹配消息来源，&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;nv&quot;&gt;From&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;%向查询请求消息来源发送查询结果消息&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;%尾递归：持续监听新的消息 &lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;nv&quot;&gt;Pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;spawn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;%启动一个进程(actor)，Pid为进程号&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;nv&quot;&gt;Pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;%向进程发送一个键值对存储消息&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;nv&quot;&gt;Pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;%发送一个查询消息，获取&quot;key1&quot;对应的值&lt;/span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;


&lt;p&gt;上面展示例子模式匹配在erlang中进行消息匹配的使用，需要注意的一点是，这里的&lt;strong&gt;匹配是从上到下来进行的&lt;/strong&gt;，即会先进行“store”的匹配，匹配失败的话才进行“get”匹配。消息匹配是erlang里的一项杀手锏特性，它能大大减少在消息处理的代码量，代码只要专注于实际算法的实现即可，将相应消息的解析和内容提取，交给模式匹配来完成。&lt;/p&gt;

&lt;p&gt;从本质上来讲，&lt;strong&gt;模式匹配体现的是一个解构的过程和手段&lt;/strong&gt;，解构是日常编程过程中一个非常常见的场景，比如编译器将程序代码解析为一个抽象语法树（AST）就是一个解构的过程，再比如，将XML/JSON进行反序列化为程序对象也是一例。对于许多语言，并未提供强大的模式匹配特性，但是为了提供&lt;strong&gt;可扩展&lt;/strong&gt;的解构功能，一般都会采取一些设计模式来解决。比如面向对象编程里，将&lt;strong&gt;解析操作抽离出独立的模块&lt;/strong&gt;，采取基于基类的虚方法/抽象方法扩展的方式，然后结合想对应的规则配置，来完成有区别性的模式解构。但是，这样的方式，稍显笨重，代码量也更多，与模式匹配相比，不在一个复杂度等级之上。&lt;/p&gt;

&lt;p&gt;去年我用golang写了一个web框架，其中的路由解析过程就采取了类似的方式（代码位置：&lt;a href=&quot;https://github.com/JustinHuang917/gof&quot;&gt;https://github.com/JustinHuang917/gof&lt;/a&gt;）。通过如以下路由规则配置，匹配不同的URL模式，从URL中提取相应的参数：&lt;/p&gt;

&lt;figure class=&quot;code&quot;&gt;&lt;figcaption&gt;&lt;span&gt;&lt;/span&gt;&lt;/figcaption&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;
&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;9&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&quot;RouteRules&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;nt&quot;&gt;&quot;/Order/{id:[0-9]+}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;controller&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Order&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;action&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Order&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;nt&quot;&gt;&quot;/{controller}/{action}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;controller&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Home&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;action&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Index&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;


&lt;p&gt;这个看似简单功能，我花了200多行代码才得以完成，使用的还是堪称语法最为精简的Golang，而如果使用Java/C#来完成，代码量肯定还要增加不少。而如果语言本身具有强大的模式匹配的话，实现代码将会变得非常精简。而这一次C#6.0声称引入模式匹配，希望是面向对象语言领域的一次有益尝试。&lt;/p&gt;

&lt;p&gt;同时，我也希望我喜欢的Golang在模式匹配上迈开尝试的脚步，在现有的goroutine+channel的组合上应用模式匹配，将是一件非常有效率的实践。现在Golang提供”select..case…“机制只能识别不同channel返回的消息，而不能识别实际消息的内容，这一点来说，与erlang相比，降低了CSP的编程效率。&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;模式匹配是来自函数式编程领域的高效的编程功能特性，它能成倍增加“解构”代码的编写效率，明显降低代码复杂度。同时，尽管大多数的编程语言，尚未提供这一功能，但是实际代码编写过程中，我们可以借鉴其基于模式声明的思想，抽离出相应的模式匹配模块，在保证可扩展性的同时，控制数据（信息）匹配带来的代码复杂度。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;如果您觉得这篇文字有意思，欢迎转发！欢迎更多的朋友们关注我的微信公众号：&lt;strong&gt;JustinNotes&lt;/strong&gt;&lt;/p&gt;

&lt;hr&gt;

</description>
        <pubDate>Sun, 24 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-24-mo-shi-pi-pei-chu-xi-f1aad7aeb.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-24-mo-shi-pi-pei-chu-xi-f1aad7aeb.html</guid>
        
        
        <category>sharecore</category>
        
      </item>
    
      <item>
        <title>如何学习Vim</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;我已经学习Vim多年了。下面是我推荐开始学习Vim的一些建议。&lt;/p&gt;
&lt;h3&gt;如果你不想学，就不要去学Vim&lt;/h3&gt;
&lt;p&gt;我深爱Vim，无法想象一整天用其它编辑器去写代码的情景，但是我从来不推荐谁去选择它。为什么？你不得不想选择它。我不能强迫谁；他们会恨它的。我能做的、最好的就是告诉人们我为什么喜欢它，让他们明白，它实际上是一个非常不错的编辑器。&lt;/p&gt;
&lt;p&gt;因此如果你还没有兴趣去学，就不要让任何人强迫你。你不得不真正喜欢学习Vim，否则你永远不可能学到精通的境界。&lt;/p&gt;
&lt;h3&gt;学到过得去的程度&lt;/h3&gt;
&lt;p&gt;第一步要学到刚刚能够勉强维持的水平。起初这就像被虐待。在你开始学得更快之前，你一定是缓慢的。因此你需要在工作之外花些时间，这样你的工作效率就不会受影响。&lt;/p&gt;
&lt;p&gt;我开始使用Vim时，我知道打开一个文件，向上、下、左、右移动，知道如何切换进/出编辑模式，如何删除，如何退出Vim，就这些。很明显，你不得不坚持多学一些，否则它就不值得了，不过你不得不从某个地方开始。&lt;/p&gt;
&lt;h3&gt;尽可能多地坚持使用&lt;/h3&gt;
&lt;p&gt;如果你坚持使用它，某些命令就变成了肌肉记忆，这是好的，因为你可以只是在脑子里记住了如此多的命令。如果你尽可能多使用，更多的命令就变成了第二本能，这样你可以关注越来越多的命令。&lt;/p&gt;
&lt;h3&gt;拥抱Vim，尽可能长时间地使用它&lt;/h3&gt;
&lt;p&gt;当你每天投入工作的时候，你精力充沛，不要打开你平常的编辑器，而是调出Vim。想用多长时间就用多长时间。如果你想了，或真的想去用另一款编辑器，不要着急，这一天的剩余时间再去用。当你有进步了，你会发现自己想用Vim的时间正越来越长，最终你用Vim时的产出才更多。&lt;/p&gt;
&lt;h3&gt;不要关闭方向键，只是尽量不要使用&lt;/h3&gt;
&lt;p&gt;会有个学派对你说，你需要关闭Vim里的方向键，使用h、j、k、l键移动。实际上这是我用过的方法，不过只是我想这样做的。&lt;/p&gt;
&lt;p&gt;要我说，你怎么舒服就怎么来。如果保留方向键让你舒服，那么无论如何，都要保留。不过，一定尽可能多地忍住不用方向键。&lt;/p&gt;
&lt;p&gt;现在我相当精通了，我后来打开了方向键，我还开启了鼠标滚动和点击。这样做的理由是，我不想完全疏离同事，因为他们会用我的电脑看代码。&lt;/p&gt;
&lt;h3&gt;坚持做笔记&lt;/h3&gt;
&lt;p&gt;我认为学习过程中做笔记是相当重要的。我现在仍然就我需要记住的东西做笔记，我想随后研究，并完善我的Vim配置。做笔记的范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于你不知道的&lt;/li&gt;
&lt;li&gt;关于让你沮丧的&lt;/li&gt;
&lt;li&gt;关于你需要记住的&lt;/li&gt;
&lt;li&gt;你碰到的任何问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;尽量学会使用Vim文档&lt;/h3&gt;
&lt;p&gt;有一块我本人不擅长。我倾向于在线研究，在&lt;a href=&quot;http://stackoverflow.com/questions/24345331/vim-real-tab-characters-start-at-column-8-i-cant-move-all-the-way-left&quot; target=&quot;_blank&quot;&gt;StackOverflow&lt;/a&gt;提问，但是Vim有不错的文档（只是你要习惯），它就内置在Vim里。你只需运行 :h 命令，就可以学到关于Vim的不错的资料。&lt;/p&gt;
&lt;h3&gt;享受欢乐&lt;/h3&gt;
&lt;p&gt;尽量不要沮丧。学习Vim应该是充满乐趣的，甚至是一个冒险。&lt;/p&gt;
&lt;h3&gt;让Vim更好&lt;/h3&gt;
&lt;p&gt;默认设置下的命令行和Vim与其它文本编辑器相比，看起来不太漂亮。我认为你的编辑器应该是美丽的，你应该乐于使用并以此为荣。尝试一些不同颜色的scheme，确保你有语法着色。我推荐&lt;a href=&quot;http://ethanschoonover.com/solarized&quot; target=&quot;_blank&quot;&gt;Solarized&lt;/a&gt;颜色scheme。我也推荐使用&lt;a href=&quot;http://iterm2.com/&quot; target=&quot;_blank&quot;&gt;iTerm2&lt;/a&gt;（有上面提到的鼠标滚动和点击）&lt;a href=&quot;http://www.zsh.org/&quot; target=&quot;_blank&quot;&gt;zsh&lt;/a&gt;，&lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot; target=&quot;_blank&quot;&gt;oh my zsh&lt;/a&gt;，&lt;a href=&quot;http://tmux.sourceforge.net/&quot; target=&quot;_blank&quot;&gt;tmux&lt;/a&gt;和&lt;a href=&quot;https://github.com/Lokaltog/powerline&quot; target=&quot;_blank&quot;&gt;powerline&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;慢慢地创建你的Vim配置&lt;/h3&gt;
&lt;p&gt;你可以完全拷贝其他人的Vim配置，但是很难知道每个细节做了什么，做自己的配置也是很难的。仅仅从基本的Vim开始，慢慢添加东西到你的vimrc和插件里。&lt;/p&gt;
&lt;h3&gt;dotfiles的版本控制&lt;/h3&gt;
&lt;p&gt;在数年里，你会对配置做出大量修改，所有dotfiles和配置具有一个版本控制的历史是真正不错的。如果你托管在github，你可以与其他人分享，你从来不会丢失。这让安装一台新电脑也变得容易了。这里是&lt;a href=&quot;https://github.com/aharris88/dotfiles&quot; target=&quot;_blank&quot;&gt;我的dotfiles&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;找到一个使用Vim的朋友&lt;/h3&gt;
&lt;p&gt;我最好的、也可能是最难的建议，就是找到一个使用Vim的、或至少支持你使用Vim的朋友。&lt;/p&gt;
&lt;p&gt;我参加奥格登【译者注：美国的一个城市】的&lt;a href=&quot;http://startupweekend.org/&quot; target=&quot;_blank&quot;&gt;Startup Weekend&lt;/a&gt;，在我们组有个家伙，&lt;a href=&quot;https://twitter.com/cwoodcox&quot; target=&quot;_blank&quot;&gt;Corey Woodcox&lt;/a&gt;一直在使用Vim。我第一次意识到这是可行的，我完全独自一个人这样。得知有人实际上在使用、且热爱使用Vim，是非常酷的。他也在Twitter上为我解答了一些问题。&lt;/p&gt;
&lt;p&gt;当你的朋友不屑你的编辑器选择，而且你或许不能让他们信服，是非常让人沮丧的。另一方面，有一个使用Vim的朋友，在你学习的早期阶段可以极大地鼓励你。&lt;/p&gt;
&lt;h3&gt;永远坚持学习&lt;/h3&gt;
&lt;p&gt;学习Vim吧，祝你好运。这应该是一次充满乐趣的旅行！&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Sat, 23 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-23-75783-c3c90f421.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-23-75783-c3c90f421.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>grep是什么？怎么用？</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;经常读一些介绍unix命令的文章，但是文章所举的例子普遍价值不大，这就导致了看完了文章后我们并不知道如何有效地运用这些unix命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;三年前，作为面试官，我负责招聘unix系统管理员。那次来竞聘该岗位的共有8个人，其中两人是技术一流的自由职业者。我认为系统管理员没必要把所有的配置方法熟记于心，需要某个软件的时候，只要你想把它玩转并且玩得更酷，多读些文章，你便会自然而然地熟悉它的各种用法与配置。于是，我让这些应聘者解决下面两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span style=&quot;color: #333333; font-style: normal;&quot;&gt;创建一个例行任务，它在每个偶数点（比如2点、12点）和3点执行；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: #333333; font-style: normal;&quot;&gt;通过/var/run/dmesg.boot文件打印处理器信息。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我吃惊的是，8位应聘者中没有一个人能解决上述问题，其中两人竟对grep命令一无所知。&lt;/p&gt;
&lt;p&gt;介于此，我们就好好说说grep。&lt;/p&gt;
&lt;p&gt;首先，以下所有的操作都是基于grep 2.5.1-FreeBSD：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;# grep --version | grep grep
grep (GNU grep) 2.5.1-FreeBSD&lt;/pre&gt;
&lt;p&gt;有必要先交待下grep版本，因为某些用法只限定于特定的版本：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;# man grep | grep -iB 2 freebsd
       -P, --perl-regexp
              Interpret PATTERN as a Perl regular expression.  This option  is
              not supported in FreeBSD.&lt;/pre&gt;
&lt;p&gt;好了，言归正传，我们经常会这样grep文件：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # cat /var/run/dmesg.boot | grep CPU:
CPU: Intel Core(TM)2 Quad CPU    Q9550  @ 2.83GHz (2833.07-MHz K8-class CPU)&lt;/pre&gt;
&lt;p&gt;还可以这样做：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep CPU: /var/run/dmesg.boot
CPU: Intel Core(TM)2 Quad CPU    Q9550  @ 2.83GHz (2833.07-MHz K8-class CPU)&lt;/pre&gt;
&lt;p&gt;这样也是可以的（虽然我很讨厌这种操作方式）：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # &amp;lt;/var/run/dmesg.boot grep CPU:
CPU: Intel Core(TM)2 Quad CPU    Q9550  @ 2.83GHz (2833.07-MHz K8-class CPU)&lt;/pre&gt;
&lt;p&gt;你肯定会遇到这样的场景：统计文件中带有某些关键字的行出现的次数。grep+wc可以帮到你：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep WARNING /var/run/dmesg.boot | wc -l
       3&lt;/pre&gt;
&lt;p&gt;条条大路通罗马，下面是另一条路：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep WARNING /var/run/dmesg.boot -c
3&lt;/pre&gt;
&lt;p&gt;下面我们新建一个测试用的文档：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep &quot;.*&quot; test.txt
one two three
seven eight one eight three
thirteen fourteen fifteen
 sixteen seventeen eighteen seven
sixteen seventeen eighteen
        twenty seven
one 504 one
one 503 one
one     504     one
one     504 one
#comment UP
twentyseven
        #comment down
twenty1
twenty3
twenty5
twenty7&lt;/pre&gt;
&lt;p&gt;继续grep的搜索之旅。&lt;/p&gt;
&lt;p&gt;-w选项指定要搜索的单词：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep -w &#39;seven&#39; test.txt
seven eight one eight three
 sixteen seventeen eighteen seven
        twenty seven&lt;/pre&gt;
&lt;p&gt;如果想搜以特定字符开头（结尾）的单词，可以这样：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep &#39;\&amp;lt;seven&#39; test.txt
seven eight one eight three
 sixteen seventeen eighteen seven
sixteen seventeen eighteen
        twenty seven
root@nm3:/ # grep &#39;seven\&amp;gt;&#39; test.txt
seven eight one eight three
 sixteen seventeen eighteen seven
        twenty seven
twentyseven&lt;/pre&gt;
&lt;p&gt;如果想搜以特定字符开头（结尾）的行，可以这样：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep &#39;^seven&#39; test.txt
seven eight one eight three
root@nm3:/ # grep &#39;seven$&#39; test.txt
 sixteen seventeen eighteen seven
        twenty seven
twentyseven
root@nm3:/ #&lt;/pre&gt;
&lt;p&gt;想要显示目标行的上下文吗？&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep -C 1 twentyseven test.txt
#comment UP
twentyseven
        #comment down&lt;/pre&gt;
&lt;p&gt;到底是显示上文还是下文？&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep -A 1 twentyseven test.txt
twentyseven
        #comment down
root@nm3:/ # grep -B 1 twentyseven test.txt
#comment UP
twentyseven&lt;/pre&gt;
&lt;p&gt;我们还可以这样玩grep：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep &quot;twenty[1-4]&quot; test.txt
twenty1
twenty3&lt;/pre&gt;
&lt;p&gt;或者取非：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep &quot;twenty[^1-4]&quot; test.txt
        twenty seven
twentyseven
twenty5
twenty7&lt;/pre&gt;
&lt;p&gt;grep是个强大的指令，除上述列举的之外，它还支持许多限定符、通配符以及正则表达式。下面是一些例子：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # cat /etc/resolv.conf
#options edns0
#nameserver 127.0.0.1
nameserver 8.8.8.8
nameserver 77.88.8.8
nameserver 8.8.4.4&lt;/pre&gt;
&lt;p&gt;只获取IP地址相关的行：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep -E &quot;[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}&quot; /etc/resolv.conf
#nameserver 127.0.0.1
nameserver 8.8.8.8
nameserver 77.88.8.8
nameserver 8.8.4.4&lt;/pre&gt;
&lt;p&gt;上面的方法可行，但下面这种方法更好：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep -E &#39;\b[0-9]{1,3}(\.[0-9]{1,3}){3}\b&#39; /etc/resolv.conf
#nameserver 127.0.0.1
nameserver 8.8.8.8
nameserver 77.88.8.8
nameserver 8.8.4.4&lt;/pre&gt;
&lt;p&gt;希望去掉注释行？&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep -E &#39;\b[0-9]{1,3}(\.[0-9]{1,3}){3}\b&#39; /etc/resolv.conf | grep -v &#39;#&#39;
nameserver 8.8.8.8
nameserver 77.88.8.8
nameserver 8.8.4.4&lt;/pre&gt;
&lt;p&gt;只要IP：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep -oE &#39;\b[0-9]{1,3}(\.[0-9]{1,3}){3}\b&#39; /etc/resolv.conf | grep -v &#39;#&#39;
127.0.0.1
8.8.8.8
77.88.8.8
8.8.4.4&lt;/pre&gt;
&lt;p&gt;哎呀，被注释掉的127.0.0.1又回来了，这是指令执行顺序不当导致的，怎么破？&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep -v &#39;#&#39; /etc/resolv.conf | grep -oE &#39;\b[0-9]{1,3}(\.[0-9]{1,3}){3}\b&#39;
8.8.8.8
77.88.8.8
8.8.4.4&lt;/pre&gt;
&lt;p&gt;下面看下-v（反向查找）选项的使用。&lt;/p&gt;
&lt;p&gt;假设要执行指令“ps –afx | grep ttyv ”：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # ps -afx | grep ttyv
 1269 v1  Is+       0:00.00 /usr/libexec/getty Pc ttyv1
 1270 v2  Is+       0:00.00 /usr/libexec/getty Pc ttyv2
 1271 v3  Is+       0:00.00 /usr/libexec/getty Pc ttyv3
 1272 v4  Is+       0:00.00 /usr/libexec/getty Pc ttyv4
 1273 v5  Is+       0:00.00 /usr/libexec/getty Pc ttyv5
 1274 v6  Is+       0:00.00 /usr/libexec/getty Pc ttyv6
 1275 v7  Is+       0:00.00 /usr/libexec/getty Pc ttyv7
48798  2  S+        0:00.00 grep ttyv&lt;/pre&gt;
&lt;p&gt;OK，但是我们不需要“48798 2 S+ 0:00.00 grep ttyv”一行，使用-v：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # ps -afx | grep ttyv | grep -v grep
 1269 v1  Is+       0:00.00 /usr/libexec/getty Pc ttyv1
 1270 v2  Is+       0:00.00 /usr/libexec/getty Pc ttyv2
 1271 v3  Is+       0:00.00 /usr/libexec/getty Pc ttyv3
 1272 v4  Is+       0:00.00 /usr/libexec/getty Pc ttyv4
 1273 v5  Is+       0:00.00 /usr/libexec/getty Pc ttyv5
 1274 v6  Is+       0:00.00 /usr/libexec/getty Pc ttyv6
 1275 v7  Is+       0:00.00 /usr/libexec/getty Pc ttyv7&lt;/pre&gt;
&lt;p&gt;看着不爽？现在呢？&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # ps -afx | grep &quot;[t]tyv&quot;
 1269 v1  Is+       0:00.00 /usr/libexec/getty Pc ttyv1
 1270 v2  Is+       0:00.00 /usr/libexec/getty Pc ttyv2
 1271 v3  Is+       0:00.00 /usr/libexec/getty Pc ttyv3
 1272 v4  Is+       0:00.00 /usr/libexec/getty Pc ttyv4
 1273 v5  Is+       0:00.00 /usr/libexec/getty Pc ttyv5
 1274 v6  Is+       0:00.00 /usr/libexec/getty Pc ttyv6
 1275 v7  Is+       0:00.00 /usr/libexec/getty Pc ttyv7&lt;/pre&gt;
&lt;p&gt;别忘了| （或）符号：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # vmstat -z | grep -E &quot;(sock|ITEM)&quot;
ITEM                   SIZE  LIMIT     USED     FREE      REQ FAIL SLEEP
socket:                 696, 130295,      30,      65,   43764,   0,   0&lt;/pre&gt;
&lt;p&gt;殊途同归：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # vmstat -z | grep &quot;sock\|ITEM&quot;
ITEM                   SIZE  LIMIT     USED     FREE      REQ FAIL SLEEP
socket:                 696, 130295,      30,      65,   43825,   0,   0&lt;/pre&gt;
&lt;p&gt;许多人都会在grep中用正则表达式，但你仍会忘了用POSIX字符集，即便它们也非常有用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;POSIX：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;[:alpha:] Any alphabetical character, regardless of case
[:digit:] Any numerical character
[:alnum:] Any alphabetical or numerical character
[:blank:] Space or tab characters
[:xdigit:] Hexadecimal characters; any number or A–F or a–f
[:punct:] Any punctuation symbol
[:print:] Any printable character (not control characters)
[:space:] Any whitespace character
[:graph:] Exclude whitespace characters
[:upper:] Any uppercase letter
[:lower:] Any lowercase letter
[:cntrl:] Control characters&lt;/pre&gt;
&lt;p&gt;找有大写字母的行：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep &quot;[[:upper:]]&quot; test.txt
#comment UP&lt;/pre&gt;
&lt;p&gt;搜索结构不够醒目？高亮显示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/08/2cd4b9810e028069a61cd23343072f8c.png&quot; rel=&quot;lightbox[75410]&quot; title=&quot;grep是什么？怎么用？&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-75455&quot; alt=&quot;grep1&quot; src=&quot;/images/jobbole.com/335b3eae428745e41d7f8e3ad5fcdaf2.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多的grep小窍门。第一个稍显专业，我已经15年没用过了。&lt;/p&gt;
&lt;p&gt;选择包含six，seven或者eight的行，很简单：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep -E &quot;(six|seven|eight)&quot; test.txt
seven eight one eight three
 sixteen seventeen eighteen seven
sixteen seventeen eighteen
        twenty seven
twentyseven&lt;/pre&gt;
&lt;p&gt;那么现在只选择包含six，seven或者eight若干次的行。这种用法叫回溯引用：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep -E &quot;(six|seven|eight).*\1&quot; test.txt
seven eight one eight three
 sixteen seventeen eighteen seven&lt;/pre&gt;
&lt;p&gt;第二个窍门，这个更有用一些。打印504前后有tab的行（如果PCRE能够支持这个特性就好了）。&lt;/p&gt;
&lt;p&gt;POSIX字符集在此失效了：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep &quot;[[:blank:]]504[[:blank:]]&quot; test.txt
one 504 one
one     504     one
one     504 one&lt;/pre&gt;
&lt;p&gt;[CTRL+V][TAB]生效：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep &quot;     504     &quot; test.txt
one     504     one&lt;/pre&gt;
&lt;p&gt;我漏讲什么了吗？grep具备递归搜索文件/目录功能。如果我们想在源码目录中搜索允许Intel使用外部SFPs的代码，但是又没清楚完整地记着函数名allow_unsupported_stp和unsupported_allow_sfp。肿么办？这正是grep的菜：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;root@nm3:/ # grep -rni allow /usr/src/sys/dev/ | grep unsupp
/usr/src/sys/dev/ixgbe/README:75:of unsupported modules by setting the static variable &#39;allow_unsupported_sfp&#39;
/usr/src/sys/dev/ixgbe/ixgbe.c:322:static int allow_unsupported_sfp = TRUE;
/usr/src/sys/dev/ixgbe/ixgbe.c:323:TUNABLE_INT(&quot;hw.ixgbe.unsupported_sfp&quot;, &amp;amp;allow_unsupported_sfp);
/usr/src/sys/dev/ixgbe/ixgbe.c:542:     hw-&amp;gt;allow_unsupported_sfp = allow_unsupported_sfp;
/usr/src/sys/dev/ixgbe/ixgbe_type.h:3249:       bool allow_unsupported_sfp;
/usr/src/sys/dev/ixgbe/ixgbe_phy.c:1228:                                if (hw-&amp;gt;allow_unsupported_sfp == TRUE) {&lt;/pre&gt;
&lt;p&gt;希望你还没晕，因为这些grep用法只是grep的冰山一角呢！&lt;/p&gt;
&lt;p&gt;最后祝大家 Happy grepping！&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Wed, 20 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-20-75410-40a117b94.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-20-75410-40a117b94.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>黑客故事：如何接管Java/Clojure/Scala程序员的电脑</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;Sonatype已经对此帖做出了相应的反应，并在他们的&lt;a href=&quot;http://blog.sonatype.com/2014/07/ssl_connectivity_for_central/&quot; title=&quot;SSL Connectivity&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;上声明将会对所有的用户开启SSL链接。这变化让Java程序的生态系统变得更加安全可靠，我为此感到非常高兴。&lt;/p&gt;
&lt;p&gt;虽说如此，但如果当你看到这个博客，并考虑花10美元来评估你的产品是否需要这个安全性的需要时，答案是否定的。这就好比汽车公司决定花10美元来评估他们的汽车是否需要气囊。幸运的是，现实生活中汽车公司必须安装气囊。&lt;/p&gt;
&lt;p&gt;Sonatype的这次机制修改令我感到很开心，希望他们能够继续减少安全性与产品的冲突。对于我们开发者而已，为用户提供最安全的最有保障的产品是我们的责任。用户对于不能处理好产品与安全性的容忍度能有多大。&lt;/p&gt;
&lt;p&gt;有一天，我看到我的防火墙是这么设置的，于是我开始对我的一个Clojure项目进行入侵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jobbole.com/8dc6daceea3036f60246b8ac26612f00.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后我通过80端口在 &lt;a href=&quot;http://repo.maven.apache.org/&quot; target=&quot;_blank&quot;&gt;http//repo.maven.apache.org&lt;/a&gt;下载了clojure.jar。这意味着我将能够通过一个未加密的http来下载包。我一开始认为这是&lt;a href=&quot;http://leiningen.org/&quot; target=&quot;_blank&quot;&gt;leiningen&lt;/a&gt;的&lt;a href=&quot;https://github.com/technomancy/leiningen/issues/1604&quot; target=&quot;_blank&quot;&gt;问题&lt;/a&gt;。但结果完全不是。Clojure.jar和其他许多的jar包在Java/Clojure/Scala领域都很重要，他们都会被正式的放在Sonatype提供的一个公共服务 -&lt;a href=&quot;http://search.maven.org/&quot; target=&quot;_blank&quot;&gt; Maven Central&lt;/a&gt;。&lt;a href=&quot;http://www.sonatype.com/&quot; target=&quot;_blank&quot;&gt;Sonatype&lt;/a&gt;有一个机制：只有那些拥有身份标识的人才允许SSL链接。你需要通过捐给Apache基金会十美元，才能获得身份标识和SSL链接。如果你不相信我说的话，捐赠的网页&lt;a href=&quot;http://www.sonatype.com/clm/secure-access-to-central&quot; target=&quot;_blank&quot;&gt;在这&lt;/a&gt;，此机制&lt;a href=&quot;http://www.sonatype.com/clm/secure-access-to-central&quot; target=&quot;_blank&quot;&gt;在此&lt;/a&gt;博客上声明。这里面甚至提到了中间人攻击。&lt;/p&gt;
&lt;p&gt;因为身份标识是针对个人或者组织分发，所以像maven或者leiningen这些工具不能绑定它。如果你使用这些工具，那么下载java程序或者安装它的一些依赖不会通过SSL。经过我在twitter和Sonatype的一个员工对此事进行了争论，确认了此事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jobbole.com/333163c5f60b55e668e873e4cc12e7f2.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;你下载的jar包会来自中间人的，并且你执行的代码会被恶意软件替换过。要想阻止这类的事情发生，你需要小心的执行每一步操作，稍有不慎就会支付别人十美元。&lt;/p&gt;
&lt;p&gt;通常什么时候会发生这类事情？如果你曾链接过咖啡店的公共网络或者&lt;a href=&quot;https://ettercap.github.io/ettercap/&quot; target=&quot;_blank&quot;&gt;别人的无线网络&lt;/a&gt;，中间人就能和你通信了。你的网络服务提供者应能够随意的跟你通信，有的人这么做是为了打广告。或者，你也会还会遭受来自&lt;a href=&quot;http://www.renesys.com/2013/11/mitm-internet-hijacking/&quot; target=&quot;_blank&quot;&gt;国家操纵&lt;/a&gt;的这类攻击。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dilettante&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了证明这有多么容易，我写了一个中间人代理&lt;a href=&quot;https://github.com/mveytsman/dilettante&quot; target=&quot;_blank&quot;&gt;dilettante&lt;/a&gt;，它功能是拦截来自于maven central的JAR包然后再注入恶意代码进去。&lt;/p&gt;
&lt;p&gt;通过dilettante来代理http的传输，然后给任何在maven central下载的JAR包设置后门。那个设置了后门的版本同时会保留原有的功能，但是当他们使用的这个类库的时候，将会提示一个友好的信息。你可以&lt;a href=&quot;http://blog.ontoillogical.com/blog/2014/07/28/how-to-take-over-any-java-developer/&quot; target=&quot;_blank&quot;&gt;看这个视频&lt;/a&gt;：&lt;br&gt;
或者截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jobbole.com/95eb51d5b251e469edde5cb3601a3ab3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;源代码&lt;a href=&quot;https://github.com/mveytsman/dilettante&quot; target=&quot;_blank&quot;&gt;在这&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JAR包从maven central 下载的时候，由于是通过HTTP进行传输的，因此中间人可以随意的替换。JAR包是可以被标识的，但是根据我对于标准工具使用的经验，这些标识是不会被检查的。其他唯一的方法可以验证一个也是通过HTTP传输的SHA1和。当dilettante发现有JAR来自maven central，它将会把一个拥有后门的版本来替换成原来的。然后替换后的版本将会在受害者的电脑上运行恶意的代码。由于SHA1仅是通过HTTP传输，那么dilettante会简单地将它所能看到的所有哈希表替换成对应的拥有后面JAR包的哈希表。&lt;/p&gt;
&lt;p&gt;我用优秀的mitproxy类库来创建我的工具。我先为代理写一个inline script，然后又用libmproxy创建一个独立的工具。&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;package dilettante;

public class Dilettante {
    public static void() {
        // do some evil stuff
    }
}&lt;/pre&gt;
&lt;p&gt;JAR包只是一个包含资源，类和元数据的压缩包。我通过添加自己的类到JAR，从而给这个JAR设置了后门。&lt;/p&gt;
&lt;p&gt;稍微头疼的是想办法如何调用我的恶意代码。我知道受害者肯定会下载一些类库。然而我需要不管用户调用类库中的哪个类，它都能运行我的代码，并且还不能影响以前类库的正常使用。&lt;/p&gt;
&lt;p&gt;Java有静态类块这一概念，它能在类级别进行初始化。当类加载到内存的时候，静态类里面的代码会只被调用这一次。在我把恶意的类插入到Jar包之后，我就能像下面这样在静态块里面调用代码：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;import dilettante.*;
static {
    Dilettante.backdoor();
}&lt;/pre&gt;
&lt;p&gt;为了插入上面的代码，我需要将它直接插入到Java  class里面，而不是source文件。我是使用&lt;a href=&quot;https://github.com/Storyyeller/Krakatau&quot; target=&quot;_blank&quot;&gt;Karakatau&lt;/a&gt;将代码以&lt;a href=&quot;http://jasmin.sourceforge.net/&quot; target=&quot;_blank&quot;&gt;Jasmin&lt;/a&gt;的格式插入进去。Karakatau是一个针对Python的Java 反编译/编译类库。&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;.method static &amp;lt;clinit&amp;gt; : ()V
  ; method code size: 4 bytes
  .limit stack 0
  .limit locals 0
  invokestatic dilettante/Dilettante backdoor ()V
  return
.end method&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;局限性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这只是个概念化的试验，同时它还是存在局限性。&lt;/p&gt;
&lt;p&gt;1.目前由于一些原因，它还不是很快：&lt;/p&gt;
&lt;p&gt;我必须进行反编译和编译。如果能够直接插入编译好的代码到类里面，那就更高效了。&lt;/p&gt;
&lt;p&gt;我实际上是通过使用Python的zipfile类库将压缩包的类文件都创建了个副本。从空间和速度方面而言，这是不高效的。如果能够更加了解zip的功能，可能会找到一个高效插入数据的方法。&lt;/p&gt;
&lt;p&gt;2.如果用户同时下载多个JAR包。那么我将会逐个设置后门。恶意的代码在每个JAR只会被执行一次。但是如果多个jar被设置了后门，那么它将会被执行多次。如果我们将那个猫的图片替换成一个高质量，稳定的后门并且它能够只影响系统一次，那么这个问题就不会再出现。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Tue, 19 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-19-75167-6caddfcf2.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-19-75167-6caddfcf2.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title> Access Control and protected </title>
        <description>

						
						

						&lt;p&gt;The response to support for access control in Swift has been extremely positive. However, some developers have been asking, “Why doesn’t Swift have something like &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt;?” Many other programming languages have an access control option that restricts certain methods from being accessed from anywhere except subclasses.&lt;/p&gt;
&lt;p&gt;When designing access control levels in Swift, we considered two main use cases:&lt;/p&gt;
&lt;ul class=&quot;tight&quot;&gt;
&lt;li&gt;keep &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; details of a class hidden from the rest of the app&lt;/li&gt;
&lt;li&gt;keep &lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt; details of a framework hidden from the client app&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These correspond to &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; and &lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt; levels of access, respectively.&lt;/p&gt;
&lt;p&gt;In contrast, &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; conflates access with inheritance, adding an entirely new control axis to reason about. It doesn’t actually offer any real protection, since a subclass can always expose “protected” API through a new public method or property. It doesn’t offer  additional optimization opportunities either, since new overrides can come from anywhere. And it’s unnecessarily restrictive — it allows subclasses, but not any of the subclass’s helpers, to access something.&lt;/p&gt;
&lt;p&gt;As some developers have pointed out, Apple frameworks do occasionally separate parts of API intended for use by subclasses. Wouldn’t &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; be helpful here? Upon inspection, these methods generally fall into one of two groups. First, methods that aren’t really useful outside the subclass, so protection isn’t critical (and recall the helper case above). Second, methods that are designed to be overridden but not called. An example is &lt;span class=&quot;keyword&quot;&gt;drawRect(_:)&lt;/span&gt;, which is certainly used within the UIKit codebase but is not to be called outside UIKit.&lt;/p&gt;
&lt;p&gt;It’s also not clear how &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; should interact with extensions. Does an extension to a class have access to that class’s protected members? Does an extension to a subclass have access to the superclass’s protected members? Does it make a difference if the extension is declared in the same module as the class?&lt;/p&gt;
&lt;p&gt;There was one other influence that led us to the current design: existing practices of Objective-C developers both inside and outside of Apple. Objective-C methods and properties are generally declared in a public header (.h) file, but can also be added in class extensions within the implementation (.m) file. When parts of a public class are intended for use elsewhere within the framework but not outside, developers create a second header file with the class’s “internal” bits. These three levels of access correspond to &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;, and &lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt; in Swift.&lt;/p&gt;
&lt;p&gt;Swift provides access control along a single, easy-to-understand axis, unrelated to inheritance. We believe this model is simpler, and provides access control the way it is most often needed: to isolate implementation details to within a class or within a framework. It may be different from what you’ve used before, but we encourage you to try it out.&lt;/p&gt;

						
												
											

</description>
        <pubDate>Tue, 19 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-19--id=11-d6318f574.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-19--id=11-d6318f574.html</guid>
        
        
        <category>apple_swift</category>
        
      </item>
    
      <item>
        <title>用 ES 的 RangeFacets 接口实现一个查看区间占比的 Kibana 面板 </title>
        <description>

  
  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;公司用 kibana 的同事提出一个需求，希望查看响应时间在不同区间内占比的饼图。第一想法是用 1.3.0 新加的 percentile rank aggregation 接口。不过仔细想想，其实并不合适 —— 这个接口目的是计算固定的 &lt;code&gt;[0 TO $value]&lt;/code&gt; 的比例。不同的区间反而还得自己做减法来计算。稍微查了一下，更适合的做法是专门的 range aggregation。考虑到 kibana 内大多数还是用 facet 接口，这里也沿用：&lt;a href=&quot;http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-facets-range-facet.html&quot;&gt;http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-facets-range-facet.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;range facet 本身的使用非常简单，就像官网示例那样，直接 curl 命令就可以完成调试：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;
curl -XPOST http://localhost:9200/logstash-2014.08.18/_search?pretty=1 -d &#39;{
    &quot;query&quot; : {
        &quot;match_all&quot; : {}
    },
    &quot;facets&quot; : {
        &quot;range1&quot; : {
            &quot;range&quot; : {
                &quot;field&quot; : &quot;resp_ms&quot;,
                &quot;ranges&quot; : [
                    { &quot;to&quot; : 100 },
                    { &quot;from&quot; : 101, &quot;to&quot; : 500 },
                    { &quot;from&quot; : 500 }
                ]
            }
        }
    }
}&#39;
&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不过在 kibana 里，我们就不要再自己拼 JSON 发请求了 —— 虽然之前我实现 percentile panel 的时候就是这么做的 —— 前两天合并了 github 上一个 commit 后，现在可以用高版本的 elastic.js 了，所以我也把原来用原生 &lt;code&gt;$http.post&lt;/code&gt; 方法写的 percentile panel 用 elastic.js 对象重写了。&lt;/p&gt;
&lt;p&gt;elastic.js 关于 range facet 的文档见：&lt;a href=&quot;http://docs.fullscale.co/elasticjs/ejs.RangeFacet.html&quot;&gt;http://docs.fullscale.co/elasticjs/ejs.RangeFacet.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为 range facet 本身比较简单，所以 RangeFacet 对象支持的方法也比较少。一个 &lt;code&gt;addRange&lt;/code&gt; 方法添加 ranges 数组，一个 &lt;code&gt;field&lt;/code&gt; 方法添加 field 名称，就没了。&lt;/p&gt;
&lt;p&gt;所以这个新 panel 的实现，更复杂的地方在如何让 range 范围值支持自定义填写。这一部分借鉴了同样是前两天合并的 github 上另一个第三方面板 multifieldhistogram 的写法。&lt;/p&gt;
&lt;p&gt;另一个需要注意的地方是饼图出来以后，单击饼图区域，自动生成的 &lt;code&gt;filterSrv&lt;/code&gt; 内容。一般的面板这里都是 &lt;code&gt;terms&lt;/code&gt; 类型的 &lt;code&gt;filterSrv&lt;/code&gt;，传递的是面板的 label 值。而我们这里 label 值显然不是 ES 有效的 terms 语法，还好 &lt;code&gt;filterSrv&lt;/code&gt; 有 &lt;code&gt;range&lt;/code&gt; 类型(histogram 面板的 &lt;code&gt;time&lt;/code&gt; 类型的 &lt;code&gt;filterSrv&lt;/code&gt; 是在 daterange 基础上实现的)，所以稍微修改就可以了。&lt;/p&gt;
&lt;p&gt;最终效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/chenlinux.com/346387fdd05063ce113983e8f47a4cab.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;面板的属性界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/chenlinux.com/7bd79c8c8c66f951098b2111084e5e25.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码已经上传到我个人 fork 的 kibana 项目里：&lt;a href=&quot;https://github.com/chenryn/kibana.git&quot;&gt;https://github.com/chenryn/kibana.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我这个 kibana 里已经综合了 8 个第三方面板或重要修改。在官方年底推出 4.0 版本之间，自觉还是值得推荐给大家用的。具体修改说明和效果图见 README。&lt;/em&gt;&lt;/p&gt;
    &lt;hr&gt;
    
    &lt;hr&gt;
  &lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;
  &lt;/div&gt;

</description>
        <pubDate>Mon, 18 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-18-intro-range-facet-and-implement-panel-for-it-9f5a65b7a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-18-intro-range-facet-and-implement-panel-for-it-9f5a65b7a.html</guid>
        
        
        <category>chenlinux</category>
        
      </item>
    
      <item>
        <title>一个快速、高效的Levenshtein算法实现</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;Levenshtein算法，用于计算两个字符串之间的Levenshtein距离。而&lt;a href=&quot;http://baike.baidu.com/view/4123766.htm&quot; target=&quot;_blank&quot;&gt;Levenshtein&lt;/a&gt;距离又称为编辑距离，是指两个字符串之间，由一个转换成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;Levenshtein距离用来描述两个字符串之间的差异。我在一个网络爬虫程序里面使用这个算法来比较两个网页之间的版本，如果网页的内容有足够多的变动，我便将它更新到我的数据库。&lt;/p&gt;
&lt;h2&gt;说明&lt;/h2&gt;
&lt;p&gt;原来的算法是创建一个大小为StrLen1*StrLen2的矩阵。如果所有字符串加起来是1000个字符那么长的话，那么这个矩阵就会是1M；如果字符串是10000个字符，那么矩阵就是100M。如果元素都是整数（这里是指数字，Int32）的话，那么矩阵就会是4*100M == 400MB这么大，唉……&lt;/p&gt;
&lt;p&gt;现在的算法版本只使用2*StrLen个元素，这使得后面给出的例子成为2*10,000*4 = 80 KB。其结果是，不但内存占用更少，而且速度也变快了！因为这使得内存分配只需要很少的时间来完成。当两个字符串的长度都是1k左右时，新算法的效率是旧算法的两倍！&lt;/p&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;p&gt;原来的版本将会创建一个矩阵[6+1, 5+1]，而我的新算法将会创建两个向量[6+1]（黄色元素）。在这两个算法版本中，字符串的顺序是无关紧要、无所谓的，也就是说，它也可以是矩阵[5+1, 6+1]和两个向量[5+1]。&lt;/p&gt;
&lt;h2&gt;新的算法&lt;/h2&gt;
&lt;h3&gt;步骤&lt;/h3&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;1&quot; cellpadding=&quot;2&quot; align=&quot;center&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th bgcolor=&quot;#ffffcc&quot;&gt;步骤&lt;/th&gt;
&lt;th bgcolor=&quot;#ffffcc&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;1&lt;/td&gt;
&lt;td&gt;设置n为字符串s的长度。(“GUMBO”)&lt;br&gt;
设置m为字符串t的长度。(“GAMBOL”)&lt;br&gt;
如果n等于0，返回m并退出。&lt;br&gt;
如果m等于0，返回n并退出。&lt;br&gt;
构造两个向量v0[m+1] 和v1[m+1]，串联0..m之间所有的元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;2&lt;/td&gt;
&lt;td&gt;初始化 v0 to 0..m。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;3&lt;/td&gt;
&lt;td&gt;检查 s (i from 1 to n) 中的每个字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;4&lt;/td&gt;
&lt;td&gt;检查 t (j from 1 to m) 中的每个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;5&lt;/td&gt;
&lt;td&gt;如果 s[i] 等于 t[j]，则编辑代价为 0；&lt;br&gt;
如果 s[i] 不等于 t[j]，则编辑代价为1。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;6&lt;/td&gt;
&lt;td&gt;设置单元v1[j]为下面的最小值之一：&lt;br&gt;
a、紧邻该单元上方+1：v1[j-1] + 1&lt;br&gt;
b、紧邻该单元左侧+1：v0[j] + 1&lt;br&gt;
c、该单元对角线上方和左侧+cost：v0[j-1] + cost&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;7&lt;/td&gt;
&lt;td&gt;在完成迭代 (3, 4, 5, 6) 之后，v1[m]便是编辑距离的值。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;本小节将演示如何计算”GUMBO”和”GAMBOL”两个字符串的Levenshtein距离。&lt;/p&gt;
&lt;h4&gt;步骤1、2&lt;/h4&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;v0&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;v1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;0&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;5&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;6&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;步骤3-6，当 i = 1&lt;/h4&gt;
&lt;p&gt; &lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;v0&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;v1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;0&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;5&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;6&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;步骤3-6，当 i = 2&lt;/h4&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;v0&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;v1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;0&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;5&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;步骤3-6，当 i = 3&lt;/h4&gt;
&lt;p&gt; &lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;v0&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;v1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;5&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;步骤3-6，当 i = 4&lt;/h4&gt;
&lt;p&gt; &lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;v0&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;v1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;步骤3-6，当 i = 5&lt;/h4&gt;
&lt;p&gt; &lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;v0&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;v1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;yellow&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;步骤7&lt;/h4&gt;
&lt;p&gt;编辑距离就是矩阵右下角的值，v1[m] == 2。由”GUMBO”变换为”GAMBOL”的过程对于我来说是很只管的，即通过将”A”替换为”U”，并在末尾追加”L”这样子（实际上替换的过程是由移除和插入两个操作组合而成的）。&lt;/p&gt;
&lt;h2&gt;改良&lt;/h2&gt;
&lt;p&gt;如果您确信你的字符串永远不会超过2^16（65536）个字符，那么你可以使用ushort来表示而不是int，如果字符串少于2^8个，还可以使用byte。我觉得这个算法用非托管代码实现的话可能会更快，但我没有试过。&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.merriampark.com/ld.htm&quot; target=&quot;_blank&quot;&gt;Levenshtein Distance, in Three Flavors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;下载代码请前往原文：&lt;a href=&quot;http://www.codeproject.com/Articles/13525/Fast-memory-efficient-Levenshtein-algorithm&quot;&gt;http://www.codeproject.com/Articles/13525/Fast-memory-efficient-Levenshtein-algorithm&lt;/a&gt;&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 18 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-18-75496-98e05ea76.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-18-75496-98e05ea76.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Vagrant介绍</title>
        <description>

	
	

	&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/3a784269d7a14c662d09ad64711997df.jpg&quot; title=&quot;Vagrant&quot; alt=&quot;Vagrant&quot;&gt;&lt;/p&gt;

&lt;h1&gt;介绍&lt;/h1&gt;

&lt;p&gt;Vagrant可以为你提供可配置、可再生、便携的工作环境，它主要是一个中间层技术，它的下层是VirtualBox, VMware, AWS或者其他&lt;a href=&quot;http://docs.vagrantup.com/v2/providers/&quot;&gt;provider&lt;/a&gt;，它的上层是&lt;a href=&quot;http://docs.vagrantup.com/v2/provisioning/&quot;&gt;provisioning工具&lt;/a&gt;，比如shell scripts, Chef, or Puppet等可以自动化安装和配置软件的工具。&lt;/p&gt;

&lt;h1&gt;对你有什么用&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于开发人员来说，Vagrant可以帮你统一团队成员的开发环境。如果你或者你的伙伴创建了一个&lt;a href=&quot;http://docs.vagrantup.com/v2/vagrantfile/&quot;&gt;Vagrantfile&lt;/a&gt;，那么你只需要执行&lt;code&gt;vagrant up&lt;/code&gt;就行了，所有的软件都会安装并且配置好。团队成员可以通过相同的Vagrantfile来创建他们的开发环境，无论他们是在Linux, Mac OS X, 或者Windows下，这样就可以保证你团队成员的代码是跑在相同的环境中，从而避免令人烦躁的【在我的机器上是可以的】问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于运维人员来说，Vagrant可以给你提供一次性，并且与线上一致的服务器环境，你可以利用VirtualBox或者VMware来测试你的shell scripts, Chef cookbooks, Puppet modules等管理脚本。你不需要再苦逼的登录到线上服务器提心吊胆的测试了，Vagrant可以解救你。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于设计人员来说，Vagrant可以帮你处理一切，你只需要专注在设计上就好了。一旦开发人员帮你配置好了Vagrant之后，你只需要执行&lt;code&gt;vagrant up&lt;/code&gt;，然后开始设计。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;安装&lt;/h1&gt;

&lt;p&gt;Vagrant的安装非常简单，直接&lt;a href=&quot;http://www.vagrantup.com/downloads&quot;&gt;下载&lt;/a&gt;对应操作系统的版本就可以了。&lt;/p&gt;

&lt;h1&gt;第一印象&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant init hashicorp/precise32
$ vagrant up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行以上命令之后，你已经拥有了一个Ubuntu 12.04 LTS 32-bit系统运行在VirtualBox中。
你可以通过&lt;code&gt;vagrant ssh&lt;/code&gt;登录到这个虚拟机中，如果你不需要它了，可以通过&lt;code&gt;vagrant destroy&lt;/code&gt;来销毁。&lt;/p&gt;

&lt;h1&gt;建立项目&lt;/h1&gt;

&lt;p&gt;建立Vagrant项目的第一步是配置Vagrantfile。执行如下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir my_vagrant
$ cd my_vagrant
$ vagrant init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会在当前目录下生成一个Vagrantfile文件，这个文件就是一切的开始，对了，你最好把它添加到版本库中，这样你的小伙伴也可以通过它来初始化开发环境了。&lt;/p&gt;

&lt;h1&gt;Box&lt;/h1&gt;

&lt;p&gt;Vagrant使用的image叫做box，如果你执行过上面的命令，那么你已经在本地拥有了一个box。如果没有执行，那么你需要执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant box add hashicorp/precise32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会从&lt;a href=&quot;https://vagrantcloud.com/&quot;&gt;Vagrant Cloud&lt;/a&gt;中下载hashicorp/precise32。
我们接下来需要配置我们的项目来使用这个box，编辑Vagrantfile文件并修改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.box = &quot;hashicorp/precise32&quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了hashicorp/precise32，你可以在Vagrant Cloud找到更多适合你的box。&lt;/p&gt;

&lt;h1&gt;启动&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就这么简单。完成之后，你就拥有了一个Ubuntu系统，你可以通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登录它，然后随意执行任何命令，除了&lt;code&gt;rm -rf /&lt;/code&gt;，原因接下来说明。&lt;/p&gt;

&lt;h1&gt;目录同步&lt;/h1&gt;

&lt;p&gt;虽说如此容易的启动一个虚拟机的确很酷，但不是所有人都喜欢通过终端来编辑文件（Vim党和Emacs党勿喷），所以Vagrant提供了一个目录同步的功能。默认情况下Vagrant会把你的项目目录（存储Vagrantfile的那个）与虚拟机中的&lt;code&gt;/vagrant&lt;/code&gt;进行同步（这就是为什么你不要执行&lt;code&gt;rm -rf /&lt;/code&gt;的原因，否则你会把项目目录删掉）。我们可以登录到虚拟机上验证一下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant up
...
$ vagrant ssh
...
vagrant@precise32:~$ ls /vagrant
Vagrantfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不确信，可以创建一个文件看看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@precise32:~$ touch /vagrant/foo
vagrant@precise32:~$ exit
$ ls
foo Vagrantfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;怎么样？没骗你吧。通过目录同步功能，你还可以继续使用最爱的编辑器来修改虚拟机中的文件。&lt;/p&gt;

&lt;h1&gt;配置&lt;/h1&gt;

&lt;p&gt;假设我们的业务需要安装Apache，传统的做法是在虚拟机上手动安装并配置，如果这样那么使用Vagrant的人都需要重复一遍。幸好Vagrant提供了自动配置（automated provisioning）的功能。通过这个特性，Vagrant会在你执行&lt;code&gt;vagrant up&lt;/code&gt;的时候自动安装所需的软件。&lt;/p&gt;

&lt;p&gt;在你的项目目录（即包含Vagrantfile的目录）下创建Bash脚本bootstrap.sh，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env bash

apt-get update
apt-get install -y apache2
rm -rf /var/www
ln -fs /vagrant /var/www
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们来配置让Vagrant在启动虚拟机的时候自动执行以上脚本，在Vagrantfile中添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.box = &quot;hashicorp/precise32&quot;
  config.vm.provision :shell, path: &quot;bootstrap.sh&quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;provision这一行告诉Vagrant使用shell provisioner来配置虚拟机，要执行的脚本是bootstrap.sh。&lt;/p&gt;

&lt;p&gt;接下来执行&lt;code&gt;vagrant up&lt;/code&gt;来启动虚拟机，之后你可以登录到虚拟机来验证Apache时候已经安装成功：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant ssh
...
vagrant@precise32:~$ wget -qO- 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;网络&lt;/h1&gt;

&lt;p&gt;总是在终端里边访问Apache不是什么好的主意，所以这个部分我们会对Vagrant的网络进行配置，让它可以通过宿主机器（Host machine）来访问。&lt;/p&gt;

&lt;p&gt;我们用端口映射来实现对Apache服务的访问，编辑Vagrantfile文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.box = &quot;hashicorp/precise32&quot;
  config.vm.provision :shell, path: &quot;bootstrap.sh&quot;
  config.vm.network :forwarded_port, host: 4567, guest: 80
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;forwarded_port&lt;/code&gt;这一行把宿主机器的4567端口映射到了客户机器（Guest machine）的80端口。然后通过&lt;code&gt;vagrant reload&lt;/code&gt;重启虚拟机，重启完成之后你用浏览器打开
http://127.0.0.1:4567就可以访问到WEB页面了。&lt;/p&gt;

&lt;h1&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.vagrantup.com/v2/getting-started/index.html&quot;&gt;http://docs.vagrantup.com/v2/getting-started/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.vagrantup.com/v2/getting-started/project_setup.html&quot;&gt;http://docs.vagrantup.com/v2/getting-started/project_setup.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.vagrantup.com/v2/getting-started/boxes.html&quot;&gt;http://docs.vagrantup.com/v2/getting-started/boxes.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.vagrantup.com/v2/getting-started/up.html&quot;&gt;http://docs.vagrantup.com/v2/getting-started/up.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.vagrantup.com/v2/getting-started/provisioning.html&quot;&gt;http://docs.vagrantup.com/v2/getting-started/provisioning.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


	(完)

	&lt;div class=&quot;post-info&quot;&gt;
		17 Aug 2014  
	
		
	
		
	&lt;/div&gt;
	
	&lt;!-- disqus start --&gt;
	
	
	
	
	&lt;!-- disqus end --&gt;

	&lt;!-- related start --&gt;
	
	&lt;!-- related end --&gt;

</description>
        <pubDate>Sun, 17 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-17-learn-vagrant-01.html-f54d13727.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-17-learn-vagrant-01.html-f54d13727.html</guid>
        
        
        <category>weizhifeng</category>
        
      </item>
    
      <item>
        <title>让你的Git水平更上一层楼的10个小贴士</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;最近，我们发表了关于&lt;a href=&quot;http://www.sitepoint.com/git-for-beginners/&quot;&gt;Git基础知识&lt;/a&gt;和&lt;a href=&quot;http://www.sitepoint.com/getting-started-git-team-environment/&quot;&gt;在团队中使用Git&lt;/a&gt;的教程。我们之前讨论的那些命令，已经足够让帮助一个开发者在Git世界里生存了。本篇文章，我们将尝试探索如何更有效的管理您的时间以及如何充分使用Git提供的各种功能。&lt;/p&gt;
&lt;p&gt;注意：本文中，一些命令包含含有方括号的部分(e.g.&lt;code&gt;git add -p [file_name]&lt;/code&gt;).在这些例子中，您要在该处插入所需的数字，标示符等。而不需要保留方括号。&lt;/p&gt;
&lt;h2&gt;1.Git自动补全&lt;/h2&gt;
&lt;p&gt;如果你在命令行中使用Git命令，每次手动输入命令是一件非常烦人的。为了解决这个问题，你可以很方便的开启自动补全功能。&lt;br&gt;
在Unix系统下，运行以下指令来获取脚本：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;cd ~
curl https://raw.github.com/git/git/master/contrib/completion/git-completion.bash -o ~/.git-completion.bash&lt;/pre&gt;
&lt;p&gt;然后，在您的&lt;code&gt;~/.bash_profile&lt;/code&gt;文件中添加以下代码：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;if [ -f ~/.git-completion.bash ]; then
    . ~/.git-completion.bash
fi&lt;/pre&gt;
&lt;p&gt;尽管我之前就提到过，在这里我仍要不厌其烦的说：如果你想使用Git提供的全部功能，你肯定是需要转而使用命令行来操作的。&lt;/p&gt;
&lt;h2&gt;2.在Git中忽略文件&lt;/h2&gt;
&lt;p&gt;你是否对出现在你Git仓库中的已编译文件（比如&lt;code&gt;.pyc&lt;/code&gt;）感到厌烦？&lt;br&gt;
亦或是你已经对把它们加入Git中这件事感到忍无可忍了？&lt;br&gt;
眼下就有一个可以让Git忽略特定文件或是目录的方法。只需要简单的创建一个&lt;code&gt;.gitignore&lt;/code&gt;文件，然后列出你不想让Git跟踪的文件和目录即可。你可以使用感叹号(!)来指出例外的情况。&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;*.pyc
*.exe
my_db_config/

!main.pyc&lt;/pre&gt;
&lt;h2&gt;3.谁动了我的代码？&lt;/h2&gt;
&lt;p&gt;出了问题后去责怪别人，是人类的天性。如果你的成品服务器出了问题，你可以非常轻松的把坏人揪出来——只需要使用&lt;code&gt;git blame&lt;/code&gt;命令。&lt;br&gt;
这个命令会显示文件中每一行的作者，最后一次改动后进行的提交(commit)以及该次提交的时间戳。。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;git blame [file_name]&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/jobbole.com/6b3e5f1146d3df53ebfc586bb41081b7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图中，你可以看到在一个大型仓库中使用该命令是什么样子的。&lt;br&gt;
&lt;img src=&quot;/images/jobbole.com/91c14843dcbe3464bb34fc786360c6bb.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;4.回顾仓库历史&lt;/h2&gt;
&lt;p&gt;在之前的教程中，我们了解了&lt;code&gt;git log&lt;/code&gt;命令的用法，然而，它还有三个选项，你应该了解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;--oneline&lt;/code&gt;——把每次提交间显示的信息压缩成缩减的hash值和提交信息，在一行显示。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--graph&lt;/code&gt;——该选项会在输出界面的左手边用一种基于文本的图形表示法来显示历史。&lt;br&gt;
如果你只是浏览一个单独分支的历史，那么这个功能是没有用的。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--all&lt;/code&gt;——显示全部分支的历史&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里是以上命令综合使用的效果。&lt;br&gt;
&lt;img src=&quot;/images/jobbole.com/e34c063302188f8422aac1a6070de8ed.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;5.绝不丢失一个提交信息&lt;/h2&gt;
&lt;p&gt;比方说，你提交了一个你不想要提交的代码，最后你通过使用硬重置(hard reset)使其回到了之前的状态。稍后，你意识到，在这个过程中你丢失了一些其他的信息，并想要退回或是至少能看一眼。&lt;code&gt;git reflog&lt;/code&gt;命令可以帮你做到这一点。&lt;/p&gt;
&lt;p&gt;一个简单的&lt;code&gt;git log&lt;/code&gt;命令，显示你最近的提交信息，以及上一次，再上一次的提交信息，以此类推。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;git reflog&lt;/code&gt;显示的是所有head移动的信息。记住，它是在本地的，而不是你仓库的一部分，不会包含在推送(push)和合并中(merge)。&lt;br&gt;
如果我使用&lt;code&gt;git log&lt;/code&gt;，我得到的提交信息是我的仓库的一部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jobbole.com/87201bf9ff9fe488b655e8508ac6ebaf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然而&lt;code&gt;git reflog&lt;/code&gt;显示了一个提交信息（&lt;code&gt;b1b0ee9&lt;/code&gt; – &lt;code&gt;HEAD@{4}&lt;/code&gt;），这是我使用硬重置(hard reset)时丢失的那个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jobbole.com/16b4fd76f9d0ddd4df62a830dc249ce3.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;6.暂存一个文件的部分改动&lt;/h2&gt;
&lt;p&gt;通常来讲，创建一个基于特性的提交是一个良好的做法，就是说，每次提交都必须代表一个新特性的产生或者是一个bug的修复。考虑一下，如果你修复了两个bug，或是添加了多个新特性但是却没有提交这些变化会怎样呢？在这种情况下，你可以把这些变化放在一次提交中。但是还有一个更好的方法：把文件分别暂存(Stage)然后分别提交。&lt;/p&gt;
&lt;p&gt;比如说，你对一个文件进行了多次修改并且想把他们分别提交。这种情况下，你可以在添加命令(&lt;code&gt;add&lt;/code&gt;)中加上&lt;code&gt;-p&lt;/code&gt;选项&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;git add -p [file_name]&lt;/pre&gt;
&lt;p&gt;让我们演示一下。我在&lt;code&gt;file_name&lt;/code&gt;文件中添加了3行文字，而且我只想提交第一行和第三行。我们先看一下&lt;code&gt;git diff&lt;/code&gt;显示的结果。&lt;br&gt;
&lt;img src=&quot;/images/jobbole.com/e8415c3ccb47af4a1f1318b01d36b559.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后，我们看一下，在添加命令(add)中加上&lt;code&gt;-p&lt;/code&gt;选项后会发生什么。&lt;br&gt;
&lt;img src=&quot;/images/jobbole.com/6b26c180647c3f45664ef5d04400183a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;看上去，Git假定所有的改变都是针对同一件事情的，因此它把这些都放在了一个块里。你有如下几个选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入&lt;code&gt;y&lt;/code&gt;来缓存该块&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;n&lt;/code&gt;不缓存该块&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;e&lt;/code&gt;来人工编辑该块&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;d&lt;/code&gt;来退出或进入下一个文件&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;s&lt;/code&gt;来分割这个块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对我们而言，我们肯定希望把它分成几个部分，有选择的添加一部分而忽略其他的。&lt;br&gt;
&lt;img src=&quot;/images/jobbole.com/72b09d1bd7cdcbdbd6dd7c7a2c0482bb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;正如你所看到的，我们添加了第一行和第三行而忽略了第二行。你可以在之后查看仓库状态并进行提交。&lt;br&gt;
&lt;img src=&quot;/images/jobbole.com/fd320c663ebd8d06bf7623b8a8f303d0.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;7.合并多次提交&lt;/h2&gt;
&lt;p&gt;当你提交你的代码进行审核并创建一个pull request时(在开源项目中常常发生这样的情况)，你经常会在代码被采纳前，要求修改一些代码。你进行了一些修改，而在下一次审核中，又会被要求进行另外的修改。你不知道还有多少次修改等着你，在你知道以前，你进行了多次额外的提交。理想的状态是，你可以使用&lt;code&gt;rebase&lt;/code&gt;命令，把他们都合并成一次提交。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;git rebase -i HEAD~[number_of_commits]&lt;/pre&gt;
&lt;p&gt;如果你希望合并最后两次提交，您需要以下命令&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;git rebase -i HEAD~2
&lt;/pre&gt;
&lt;p&gt;使用该命令，你会进入一个交互式的界面，显示了最后两次提交，并且询问你要压缩哪些。理想状态是你&lt;code&gt;pick&lt;/code&gt;最近的一次提交并把它和之前的提交&lt;code&gt;squash&lt;/code&gt;。&lt;br&gt;
&lt;img src=&quot;/images/jobbole.com/9e903d23d408f3843347825101e47f3d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来你会被要求为合并后的这次提交填写描述信息。这一个过程实际上重写了你的提交历史。&lt;br&gt;
&lt;img src=&quot;/images/jobbole.com/9e903d23d408f3843347825101e47f3d.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;8.保存尚未提交的改动&lt;/h2&gt;
&lt;p&gt;比方说你正在解决一个bug或是添加某个新功能，这时你突然被要求展示你的工作。你当前的工作还没有完成到进行提交的地步，而且你在这个阶段也没办法展示你的工作（如果不回退所有变化的话）。在这种情况下，&lt;code&gt;git stash&lt;/code&gt;可以拯救你。stash命令本质上是保存了你全部的改动以供将来使用。保存你的改动，你只需要运行如下命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;git stash&lt;/pre&gt;
&lt;p&gt;查看暂存列表，你可以运行如下命令：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;git stash list&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/jobbole.com/a37cb041871952537678e1a1347f2364.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你不想保存了或是想要恢复这些改动，你使用如下命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;git stash apply&lt;/pre&gt;
&lt;p&gt;在最后一张截图中，你可以看到，每一次保存都有一个标示符，一个独一无二的数字（尽管我们此处只有一次保存），万一你只想使用某些保存，你需要在&lt;code&gt;apply&lt;/code&gt;命令后指明标示符。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;git stash apply stash@{2}&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/jobbole.com/218a4fe2c22652d0f144bfc63541c810.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;9.检查丢失的提交&lt;/h2&gt;
&lt;p&gt;尽管&lt;code&gt;reflog&lt;/code&gt;是一种查看丢失提交的方法，但是它在大型仓库中行不通。这时就该&lt;code&gt;fsck&lt;/code&gt;&lt;br&gt;
(file system check)出场了。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;git fsck --lost-found&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/jobbole.com/025d8cdcf910f029a695ff814a78e024.jpg&quot;&gt;&lt;br&gt;
这里你可以看到丢失的提交，你可以使用&lt;code&gt;git show [commit_hash]&lt;/code&gt;来查看这些提交所包含的改动或者是使用&lt;code&gt;git merge [commit_hash]&lt;/code&gt;来恢复它。&lt;br&gt;
&lt;code&gt;git fsck&lt;/code&gt;比&lt;code&gt;reglog&lt;/code&gt;有一个优势。比如你删除了一个远端分支并且克隆了仓库，使用&lt;code&gt;fsck&lt;/code&gt;命令你可以搜索并恢复该远端分支。&lt;/p&gt;
&lt;h2&gt;10.cherry-pick命令&lt;/h2&gt;
&lt;p&gt;我把最优雅的Git命令留在了最后。&lt;code&gt;cherry-pick&lt;/code&gt;是我最爱的Git命令，因为它的名字就意味着它的功能！&lt;/p&gt;
&lt;p&gt;简而言之，&lt;code&gt;cherry-pick&lt;/code&gt;是指从不同的分支里选择某次提交并且把它合并到当前的分支来。如果你在并行的开发某两个或多个分支，你可能会注意到有一个bug存在于所有的分支中。如果你在一个分支中解决了它，你可以使用&lt;em&gt;cherry-pick&lt;/em&gt;来把这次提交合并进其他的分支而不会搞乱其他的文件或是提交。&lt;/p&gt;
&lt;p&gt;让我们想象一个可以使用该命令的场景。我有两个分支，并且我想要把&lt;code&gt;b20fd14: Cleaned junk&lt;/code&gt;这次提交使用&lt;em&gt;cherry-pick&lt;/em&gt;的方法放入到另一个分支。&lt;br&gt;
&lt;img src=&quot;/images/jobbole.com/bc31cd847e25f8d60114bfedfd296c95.jpg&quot;&gt;&lt;br&gt;
我切换到我想要放入该提交的分支，然后运行如下命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;git cherry-pick [commit_hash]&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/jobbole.com/48c03cbbf8b0fe9804fa50a17217038c.jpg&quot;&gt;&lt;br&gt;
尽管我们本次使用&lt;code&gt;cherry-pick&lt;/code&gt;没什么问题，但是你应该清楚这个命令会带来冲突，请谨慎使用。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;说着说着我们就来到了文章的末尾，我认为这些技巧会让你的Git水平更上一层楼。&lt;br&gt;
Git是最棒的，只要你能想得到，它就能做得到。&lt;br&gt;
因此，要经常挑战自己的Git水平。最后你很有可能会学到新的东西。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Sun, 17 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-17-75348-c0b370f73.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-17-75348-c0b370f73.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>黑客入侵后，重新夺回我的网站</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;自2012年3月开始我就一直运营的一个网站：RamshackleGlam.com 在上周被别人给盗了。它被一个叫“bahbouh”的家伙放到了一个名叫Flippa.com的拍卖网站上，差点就被卖给了出价最高的竞争者（大概3万刀的样子）。他答应给竞标人提供我的流量、文件以及数据，并且建议我可以受雇佣的形式继续写文章（或者说，他希望提供给竞标人“高质量的文章”和“SEO(搜索引擎优化)建议”来维持网站的流量售后服务）。&lt;/p&gt;
&lt;p&gt;我是在上周六意识到我的网站被盗的。三天过后我把它给找了回来，而这中间经历了6个部门，超过50多名雇员的参与，和律师们的午夜会议，FBI的介入，以及一个诱捕行动——可能在Sandra Bullock主演的影片中出现过，只不过这次主角换成了…我。&lt;/p&gt;
&lt;p&gt;当然，我之前就听说过身份盗用以及网络黑客的故事，但说实话，当这些事情发生在我身上时我的第一反应就是“这不可能！”即便是在发生后，我也没有完全弄懂为什么这是一件非常严重的事情。你（指黑客）难道就不能给我解释一下到底发生了什么事情，证明你是谁，怎么安排了这一切吗？！我们生活在这样一个高度被记录的世界，我完全想象不到有人能够伪装成别人带走任何真实的东西最后却全身而退，仅仅留下几个电话和我的一些懊恼。&lt;/p&gt;
&lt;p&gt;这非常非常糟糕——它让我更惊恐、沮丧、难以适应——超乎了我的想象。&lt;/p&gt;
&lt;p&gt;我从父亲那里找到了黑客的痕迹。他的朋友Anthony（也是他在&lt;a href=&quot;http://www.store.proitalia.com/&quot;&gt;Pro Italia Online&lt;/a&gt;上的合伙人，经营着一家名叫&lt;a href=&quot;http://thoughtbox.net/&quot;&gt;ThoughtBox&lt;/a&gt;的网站开发和咨询公司）曾经在Flippa上面浏览过——现在来看真是非常的巧——并发现了我的网站被放在了上面，并且列着一大堆可疑的清单。突然，我记起了在那天之前收到的一封邮件——它被我我当作垃圾邮件忽视掉了——来自于某人，说他“有兴趣购买”我的“博客”。我记得一个来自于YouTube的通知，有人在别处访问了我的账户——而我忽略了，上面说我登陆了一个移动设备，当时我以为是我的丈夫偶然登陆了我的账户。&lt;/p&gt;
&lt;p&gt;但即便在我看到清单之后，我也没有在意：这看上去就像什么东西用几封邮件就能定下来一样。只是那个拍卖网站被定位在澳大利亚，并且没有联系电话，而当我发送了一封附带身份证复印件和网站的所有权证明后得到的却是一封打印信件。我询问了HostMonster——我花钱让他们运营我的网站，悲剧的发现我已经不再是我的网站的拥有者了：有人用他们的邮箱验证系统授权了我的域名转移给一个在GoDaddy（另外一个web注册服务，我也是他们的客户）上的私人账户。&lt;/p&gt;
&lt;h4&gt;为什么事情很严重？&lt;/h4&gt;
&lt;p&gt;如果你有一个依赖于URL的业务，你就会明白为什么这是一个非常让人沮丧的新闻：通过控制我的网站的域名，一个黑客就可以将这个网站完全拿下，或者将其重定向至任何地方。进一步讲，后来被证实这个黑客也同样控制了网站上的所有内容；他可以将我写的东西改道发送至任何他想要到的地方。&lt;/p&gt;
&lt;p&gt;Ramshackle Glam可能“仅仅”是一个关于育儿、时尚和装饰的生活类博客，但这也是我花了五年的时间苦心经营的一个网站，而它却落到了某些不坏好意的人手中，这伤透了我的心。我本可以转移到一个新的URL，并导出我所都的内容到那上面（我确实做了备份），但这会让我损失大量的流量。这个网站可是我的主要收入来源，它关系到&lt;a href=&quot;http://www.ramshackleglam.com/2012/08/13/jordan-in-the-house-moving-day/&quot;&gt;我的房子&lt;/a&gt;，我的&lt;a href=&quot;http://www.ramshackleglam.com/2011/10/22/this-is-the-first-day/&quot;&gt;两个孩子&lt;/a&gt;（&lt;a href=&quot;http://www.ramshackleglam.com/2014/01/13/here-we-go-again/&quot;&gt;另一个&lt;/a&gt;马上就要出生了），我这周即将要出版的&lt;a href=&quot;http://www.amazon.com/Ramshackle-Glam-Haphazard-Almost-Having/dp/0762453044/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1396361642&amp;amp;sr=1-1&amp;amp;keywords=ramshackle+glam&quot;&gt;一本书&lt;/a&gt;，和我在工商学院的&lt;a href=&quot;http://www.ramshackleglam.com/2013/08/06/developments-and-exciting-things/&quot;&gt;老公&lt;/a&gt;，这可不是开玩笑。失去这个URL很可能会对我的事业和生活造成实实在在的打击。&lt;/p&gt;
&lt;h4&gt;所以我做了什么？&lt;/h4&gt;
&lt;p&gt;这个事件之后的接下来几天很复杂，所以我会解释我所走的每一步到最后导致的结果（我会详细的描述细节，希望能为那些有类似经历的人提供帮助）。&lt;/p&gt;
&lt;h5&gt;1、我试图直接通过GoDaddy和HostMonster来解决问题，但这不管用。&lt;/h5&gt;
&lt;p&gt;从周日到周二，我花了大量的时间（而且很多都是在晚上）与GoDaddy和HostMonster进行电话沟通，而几乎所有的人都给了我同样的回答：“对不起，我们对此无能为力。”&lt;/p&gt;
&lt;p&gt;HostMonster坚持认为由于他们不再控制这个域名，他们就没有什么能做的了。GoDaddy则认为由于该账户是私人的，并且那个人通过HostMonster的转移获取了域名的所有权，所以他们也不能做什么。&lt;/p&gt;
&lt;p&gt;要说最后有什么进展：我引用了&lt;a href=&quot;http://www.ramshackleglam.com/2013/08/06/developments-and-exciting-things/&quot;&gt;ICANN的关于域名的争端解决方案&lt;/a&gt;。这让我的案子升级了，但这也并没有导致什么实际行动。&lt;/p&gt;
&lt;p&gt;原因在此：HostMonster的法律部门向我告知，他们启动转让纠纷需要以GoDaddy向我返还域名为前提，他们的“内部调查”才能找出证据证明在释放网站的过程中出现了哪些问题。换句话说，他们到时候就不得不承认他们把事情给搞砸了…而这将打开对他们的诉讼。&lt;/p&gt;
&lt;p&gt;不用说，我不会再听什么法律部门的胡扯了。尽管乍一看大家好像都是清白的，但事实是我拥有的网站在没经我授权的情况下被转移了，要是我不启动一个耗时且费钱的诉讼我将什么也做不了，总之，这些都不能很快挽回我那个即将要被出售的网站。&lt;/p&gt;
&lt;p&gt;所以这条道走不通了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ramshackleglam.com/wp-content/uploads/2014/03/Screen-Shot-2014-03-31-at-10.15.47-PM.png&quot; rel=&quot;lightbox[75334]&quot; title=&quot;黑客入侵后，重新夺回我的网站&quot;&gt;&lt;img alt=&quot;Screen Shot 2014-03-31 at 10.15.47 PM&quot; src=&quot;/images/jobbole.com/925710ec858fc419c9e156117cfe6d61.jpg&quot; width=&quot;552&quot; height=&quot;73&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;译者注：如果你的域名在未经你授权的情况下被转移了，让支持人员告诉注册热线，说你有一个TEAC的适用场景并且需要立刻联系主管人。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;2、我联系了FBI。这是我在正确的方向上走的关键的一步&lt;/h5&gt;
&lt;p&gt;在我发现转让的那个早上我就联系了FBI。我当时觉得自己蠢爆了，居然打了这样的电话，但事实却是这是一个国际网络犯罪事件，而FBI正好是干这个的。何况这也是我的事业。可能放到大背景下我这种事情简直就是鸡毛蒜皮的小事，可对我来说却不是，它可支撑着我的家庭。&lt;/p&gt;
&lt;p&gt;那么让我来告诉你吧：所有在过去这一周遇到的令人吃惊的事情，绝大多数都是来自FBI。那天他们没过多久就给了我回应，包括几次电话和邮件的沟通，还在当天就派了两名特工来我家和我进行了一次当面的交流，一直到昨天，他们又来了一次。除此之外，过去这周我接触的每一个特工都非常能干，而且很友善，很体贴，也很投入并且行动非常迅速。他们待我并不是一个简单的号码，而是一个活生生的人。总而言之，他们令人尊敬。&lt;/p&gt;
&lt;p&gt;而我所期望的是在一个邮箱上留言并在某个时刻收到一封信件；当然我并不想要立马就看到一封调查报告。当然，在这里我也不打算写这些调查过程，因为它还没有结束（尽管我得到了他们的授权），但是我觉得非常有必要讲一下我是如何对FBI的回应感到惊喜的。&lt;/p&gt;
&lt;h5&gt;3、我试图直接联系那个“卖家”要回我的网站。这起作用了，但也相当有戏剧性&lt;/h5&gt;
&lt;p&gt;当前面的工作都在进行的时候，我也在想办法直接找那个要卖我网站的家伙要回它。&lt;/p&gt;
&lt;p&gt;我可不想直接联系那个“卖家”，要是让那个家伙知道网站的真实主人已经意识到了这笔交易，他很有可能会向我敲诈更多的钱。所以我找了Anthony——是他看到的最原始的清单，而且他还在Flippa上面有个有效账户——让他联系“bahbouh”问他是否有兴趣私下交易。经过一番讨价还价，我们最终得到了同意，并最终决定在一个第三方的交易网站（&lt;a href=&quot;https://www.escrow.com/&quot;&gt;Escrow.com&lt;/a&gt;）上面完成交易：当确认卖家将域名转移给我之后钱才会打给他。&lt;/p&gt;
&lt;p&gt;正当我以为一切都很顺利的时候，在周二的晚上，那个卖家突然要求我立即把钱打给他（在收到网站之前）。我拒绝了，结果他声称他要将网站卖给另外一个人：“sorry,bye”&lt;/p&gt;
&lt;p&gt;以下是我当时的想法：如果我不给钱，那肯定是收不回我的网站了。如果给钱，那么有一种可能是他拿了钱立马跑掉，但也有可能他会履行他的承诺，把网站还给我。这就像一场赌博…但显然我毫无选择。所以我最后还是同意了。&lt;/p&gt;
&lt;p&gt;我花了20几分钟的时间坐在这该死的GoDaddy账户面前，等着看我的钱是不是打了水漂。&lt;/p&gt;
&lt;p&gt;然后我的网站回来了。&lt;/p&gt;
&lt;p&gt;我立即将这个域名（和我的其它域名一起）转移到另一个账户上，并锁定了它们。并致电汇款公司让他们终止交易。&lt;/p&gt;
&lt;h4&gt;结果&lt;/h4&gt;
&lt;p&gt;RamshackleGlam.com又重新回到了我的怀抱，感谢那些不辞辛劳尽其所能帮助我的人。我的其它账户（包括银行账户及其它）都安全了。我最终也没有把钱给要回来，但那个小偷也没有得到它，永远都别想了。&lt;/p&gt;
&lt;p&gt;这件事情总算结束了。该死的！&lt;/p&gt;
&lt;h4&gt;那么为什么我依然感到愤怒？&lt;/h4&gt;
&lt;p&gt;当然我会因为网站被偷而生气，但我对此无能为力。我之所以写这篇文章有一部分原因是我要让人们知道这种事情是确实会发生在我们每一个人身边的，也希望通过我的一些建议去帮助大家尽量避免悲剧的发生，但除此之外，真正激发我动笔的是我对GoDaddy和HostMonster的愤愤愤愤愤愤怒。我希望你们能明白。&lt;/p&gt;
&lt;p&gt;这两家公司都没有质疑我的声明（有书面证据的支持）即我对网站的所有权，也没有怀疑网站在未经我授权的情况下被转移。而我仍然话花了几天的时间自己去找那个黑客——这几天足以让他做任何想做的事情——就是因为那群技术支持和监察员除了说“天啊，真糟糕。我们帮不了你”之外什么也做不了！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ramshackleglam.com/wp-content/uploads/2014/03/Screen-Shot-2014-03-27-at-11.38.53-AM.png&quot; rel=&quot;lightbox[75334]&quot; title=&quot;黑客入侵后，重新夺回我的网站&quot;&gt;&lt;img alt=&quot;Screen Shot 2014-03-27 at 11.38.53 AM&quot; src=&quot;/images/jobbole.com/dd4fb9027669eb36a89d225664f2c9de.jpg&quot; width=&quot;625&quot; height=&quot;236&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ramshackleglam.com/wp-content/uploads/2014/03/Screen-Shot-2014-03-27-at-11.40.01-AM.png&quot; rel=&quot;lightbox[75334]&quot; title=&quot;黑客入侵后，重新夺回我的网站&quot;&gt;&lt;img alt=&quot;Screen Shot 2014-03-27 at 11.40.01 AM&quot; src=&quot;/images/jobbole.com/3cd1999b377e3fc5b05e7095697f5d7c.jpg&quot; width=&quot;625&quot; height=&quot;200&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而当我找到真正能帮我的人——我是指那些能为我打一个电话或者按一个钮然后把我的财产还给我的人（亦或是简单的冻结它而避免被卖掉或摧毁），他们才不会跟我说这些。这帮人（指两家公司的人员）只会躲在他们的法律部门后面而不会做任何事，即使知道他们的不作为会逼我不得不跟一个罪犯做交易，或让我失去我事业的重要部分。&lt;/p&gt;
&lt;p&gt;而黑客们也知道这些公司会这样做。&lt;/p&gt;
&lt;p&gt;它们指着这活呢。&lt;/p&gt;
&lt;p&gt;这是一个很严重的问题——一个犯罪组织不仅“无视”公司的政策，而且事实上导致了公司将自身的利益至于其所声称的对用户的“保护”之上。我能理解像HostMonster和GoDaddy这样的公司为什么会把精力都放在保护自己免受诉讼上吗？当然！但事实是他们并没有去“保护”他们的用户，而且刚好相反地加深了对他们所支持的那些小型企业和家庭的威胁。&lt;/p&gt;
&lt;p&gt;这些公司知道如果他们堵住了那扇帮助的大门那些资产收到侵犯的用户将没有其他的依靠，他们不得不向罪犯妥协或是眼睁睁看着自己的事业——也很可能是生活——毁掉。这些公司也知道他们的不作为给那些依赖于用这种手段赚钱的黑客创造了良好的环境。而他们什么也不做。&lt;/p&gt;
&lt;p&gt;这种情况必须得改变了。&lt;/p&gt;
&lt;h4&gt;我的意见，在我看来是值得去做的：&lt;/h4&gt;
&lt;p&gt;在代理公司的支持人员必须要非常熟悉ICANN有关域名分配的相关条例，同时也需要在第一时间从客户那了解情况后就制定一个行动计划，别让客户一个又一个电话的催。&lt;/p&gt;
&lt;p&gt;此外，建立一个TEAC**可以让争议账户立即被冻结，直到事情得到圆满解决。这也不会需要任何一方去承认罪责；基于这样一个尝试：当存在争议时，我们需要确保域名必须是被安全的转移。&lt;/p&gt;
&lt;h4&gt;怎样做可以降低悲剧发生在你身上的概率：&lt;/h4&gt;
&lt;p&gt;1、要有一个非常非常靠谱的密码，并且经常更换。密码不要含有“明显”的单词（当然也不要有像“whitecat”或“angrybird”这样两个或多个连在一起的单词），而且应该包含大写字母、数字和符号。最好的密码看上去应该是杂乱无章的。&lt;/p&gt;
&lt;p&gt;2、如果可以的话，最好使用一个单独的计算机（可以是个旧的或买个便宜点的）来处理跟财产有关的业务，比方说银行转账等等，否则的话指不准哪天你家小孩点了一个恶意链接就可能会招来黑客。&lt;/p&gt;
&lt;p&gt;3、当你不再使用电脑和个人设备的时候就关掉它。&lt;/p&gt;
&lt;p&gt;4、装一个杀毒软件（但是记住这也只能让你扫描到30-40%的病毒，所以哪怕是一次“彻底”的检查也不代表你的电脑是安全的）。&lt;/p&gt;
&lt;p&gt;5、购买&lt;a href=&quot;https://www.travelers.com/business-insurance/management-professional-liability/cyber-risk.aspx&quot;&gt;CyberRisk保险&lt;/a&gt;（可以点击链接查看更多信息，它可以确保你的利益不会因为网络攻击和数据泄露遭到大的损失）。&lt;/p&gt;
&lt;h4&gt;但要是悲剧真的发生了，那你该怎么做：&lt;/h4&gt;
&lt;p&gt;1、立即仔细的检查（并且截图）。不要删除任何的邮件以及其它信息，它们很有可能在后面起到重要作用。&lt;/p&gt;
&lt;p&gt;2、立刻更改你所有的密码（包括——但不限于——域名注册商、网站托管、网站登录信息、邮箱、银行账户、无线家用电子产品、以及Apple ID）根据以下的规则。在情况还没有确定下来时我每隔几个小时都会改一次密码，并且在这之后我仍然会每隔几天都会改一次密码。&lt;/p&gt;
&lt;p&gt;3、联系注册商，引用下面的ICANN方案，然后看是否能快速解决。要是你发现你自己走近死胡同也不要惊讶。&lt;/p&gt;
&lt;p&gt;4、查看你的邮件的“过滤器”和“规则”（通常情况下，任何可能的设备都会被黑客推送邮件，比方说cetera）。&lt;/p&gt;
&lt;p&gt;5、联系合适的执法部门（我联系了FBI是因为这看上去像是一个国际犯罪，至少也是个洲际犯罪——因为Escrow.com在加利福利亚而我在纽约）。&lt;/p&gt;
&lt;p&gt;注意：每一种情况都会不同，而且我也不会全力推荐这些方法——虽然它们让我最终夺回了我的域名的控制权，但是让我不得已跟罪犯打交道。很明显这并不理想，而且也可能导致不可预料的结果。（尽管我老公说他也很想让大家知道我是个大坏蛋，但很明显这也不是事实…好吧，至少是在这件事上）&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;
&lt;h5&gt;伯乐在线译者注：&lt;/h5&gt;
&lt;p&gt;*Icann.Org全名为互联网域名和号码管理组织，负责管理并协调&lt;a href=&quot;https://www.icann.org/en/node/1145082#dns&quot;&gt;DNS&lt;/a&gt;。&lt;a href=&quot;https://www.icann.org/resources/pages/policy-2012-03-07-en&quot;&gt;ICANN的域名争议解决方案&lt;/a&gt;基本规定了在域名纠纷的案件下，原注册商（“Losing Registrar”，在转移发生前的域名持有人，与之相对的“Winning Registrar”，指在转移发生后的域名持有人）需要立即启动紧急转移行动接触方式（“&lt;a href=&quot;https://www.icann.org/resources/pages/policy-2012-03-07-en&quot;&gt;TEAC&lt;/a&gt;”）将球踢到立刻解决的方向上来。当初一得到这个信息，我的案子就立刻升级了。&lt;/p&gt;
&lt;p&gt;**TEAC：由ICANN建立的一种接触方式，用于其它注册商和ICANN在必要时快速解决两个注册商之间的域名转移问题。该接触必须在调查开始四小时之内响应，尽管最终的解决时间会很长。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Sat, 16 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-16-75334-fe22b32a2.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-16-75334-fe22b32a2.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>分布式消息系统：Kafka</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项目的一部分。Kafka是一个分布式的，可划分的，冗余备份的持久性的日志服务。它主要用于处理活跃的流式数据。&lt;/p&gt;
&lt;p&gt;在大数据系统中，常常会碰到一个问题，整个大数据是由各个子系统组成，数据需要在各个子系统中高性能，低延迟的不停流转。传统的企业消息系统并不是非常适合大规模的数据处理。为了已在同时搞定在线应用（消息）和离线应用（数据文件，日志）Kafka就出现了。Kafka可以起到两个作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低系统组网复杂度。&lt;/li&gt;
&lt;li&gt;降低编程复杂度，各个子系统不在是相互协商接口，各个子系统类似插口插在插座上，Kafka承担高速数据总线的作用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Kafka主要特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同时为发布和订阅提供高吞吐量。据了解，Kafka每秒可以生产约25万消息（50 MB），每秒处理55万消息（110 MB）。&lt;/li&gt;
&lt;li&gt;可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication防止数据丢失。&lt;/li&gt;
&lt;li&gt;分布式系统，易于向外扩展。所有的producer、broker和consumer都会有多个，均为分布式的。无需停机即可扩展机器。&lt;/li&gt;
&lt;li&gt;消息被处理的状态是在consumer端维护，而不是由server端维护。当失败时能自动平衡。&lt;/li&gt;
&lt;li&gt;支持online和offline的场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Kafka的架构：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/08/975609a391574a15645c2d2e2494114f.png&quot; rel=&quot;lightbox[75328]&quot; title=&quot;分布式消息系统：Kafka&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-75329&quot; alt=&quot;kafka&quot; src=&quot;/images/jobbole.com/3802d534d36cb8eafd8110b2bb5d10ff.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;Kafka的整体架构非常简单，是显式分布式架构，producer、broker（kafka）和consumer都可以有多个。Producer，consumer实现Kafka注册的接口，数据从producer发送到broker，broker承担一个中间缓存和分发的作用。broker分发注册到系统中的consumer。broker的作用类似于缓存，即活跃的数据和离线处理系统之间的缓存。客户端和服务器端的通信，是基于简单，高性能，且与编程语言无关的TCP协议。几个基本概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Topic：特指Kafka处理的消息源（feeds of messages）的不同分类。&lt;/li&gt;
&lt;li&gt;Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。&lt;/li&gt;
&lt;li&gt;Message：消息，是通信的基本单位，每个producer可以向一个topic（主题）发布一些消息。&lt;/li&gt;
&lt;li&gt;Producers：消息和数据生产者，向Kafka的一个topic发布消息的过程叫做producers。&lt;/li&gt;
&lt;li&gt;Consumers：消息和数据消费者，订阅topics并处理其发布的消息的过程叫做consumers。&lt;/li&gt;
&lt;li&gt;Broker：缓存代理，Kafa集群中的一台或多台服务器统称为broker。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;消息发送的流程：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/08/cb5892023c894331a55de5ac7f64582d.png&quot; rel=&quot;lightbox[75328]&quot; title=&quot;分布式消息系统：Kafka&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-75330&quot; alt=&quot;message&quot; src=&quot;/images/jobbole.com/3e6f80a8240222771de43eb217ec2e6d.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Producer根据指定的partition方法（round-robin、hash等），将消息发布到指定topic的partition里面&lt;/li&gt;
&lt;li&gt;kafka集群接收到Producer发过来的消息后，将其持久化到硬盘，并保留消息指定时长（可配置），而不关注消息是否被消费。&lt;/li&gt;
&lt;li&gt;Consumer从kafka集群pull数据，并控制获取消息的offset&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Kafka的设计：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、吞吐量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高吞吐是kafka需要实现的核心目标之一，为此kafka做了以下一些设计：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据磁盘持久化：消息不在内存中cache，直接写入到磁盘，充分利用磁盘的顺序读写性能&lt;/li&gt;
&lt;li&gt;zero-copy：减少IO操作步骤&lt;/li&gt;
&lt;li&gt;数据批量发送&lt;/li&gt;
&lt;li&gt;数据压缩&lt;/li&gt;
&lt;li&gt;Topic划分为多个partition，提高parallelism&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;producer根据用户指定的算法，将消息发送到指定的partition&lt;/li&gt;
&lt;li&gt;存在多个partiiton，每个partition有自己的replica，每个replica分布在不同的Broker节点上&lt;/li&gt;
&lt;li&gt;多个partition需要选取出lead partition，lead partition负责读写，并由zookeeper负责fail over&lt;/li&gt;
&lt;li&gt;通过zookeeper管理broker与consumer的动态加入与离开&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;拉取系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于kafka broker会持久化数据，broker没有内存压力，因此，consumer非常适合采取pull的方式消费数据，具有以下几点好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简化kafka设计&lt;/li&gt;
&lt;li&gt;consumer根据消费能力自主控制消息拉取速度&lt;/li&gt;
&lt;li&gt;consumer根据自身情况自主选择消费模式，例如批量，重复消费，从尾端开始消费等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当需要增加broker结点时，新增的broker会向zookeeper注册，而producer及consumer会根据注册在zookeeper上的watcher感知这些变化，并及时作出调整。&lt;/p&gt;
&lt;p&gt;Kafka的应用场景：&lt;/p&gt;
&lt;p&gt;1.消息队列&lt;/p&gt;
&lt;p&gt;比起大多数的消息系统来说，Kafka有更好的吞吐量，内置的分区，冗余及容错性，这让Kafka成为了一个很好的大规模消息处理应用的解决方案。消息系统一般吞吐量相对较低，但是需要更小的端到端延时，并尝尝依赖于Kafka提供的强大的持久性保障。在这个领域，Kafka足以媲美传统消息系统，如&lt;a href=&quot;http://activemq.apache.org/&quot;&gt;ActiveMR&lt;/a&gt;或&lt;a href=&quot;https://www.rabbitmq.com/&quot;&gt;RabbitMQ&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2.行为跟踪&lt;/p&gt;
&lt;p&gt;Kafka的另一个应用场景是跟踪用户浏览页面、搜索及其他行为，以发布-订阅的模式实时记录到对应的topic里。那么这些结果被订阅者拿到后，就可以做进一步的实时处理，或实时监控，或放到hadoop/离线数据仓库里处理。&lt;/p&gt;
&lt;p&gt;3.元信息监控&lt;/p&gt;
&lt;p&gt;作为操作记录的监控模块来使用，即汇集记录一些操作信息，可以理解为运维性质的数据监控吧。&lt;/p&gt;
&lt;p&gt;4.日志收集&lt;/p&gt;
&lt;p&gt;日志收集方面，其实开源产品有很多，包括Scribe、Apache Flume。很多人使用Kafka代替日志聚合（log aggregation）。日志聚合一般来说是从服务器上收集日志文件，然后放到一个集中的位置（文件服务器或HDFS）进行处理。然而Kafka忽略掉文件的细节，将其更清晰地抽象成一个个日志或事件的消息流。这就让Kafka处理过程延迟更低，更容易支持多数据源和分布式数据处理。比起以日志为中心的系统比如Scribe或者Flume来说，Kafka提供同样高效的性能和因为复制导致的更高的耐用性保证，以及更低的端到端延迟。&lt;/p&gt;
&lt;p&gt;5.流处理&lt;/p&gt;
&lt;p&gt;这个场景可能比较多，也很好理解。保存收集流数据，以提供之后对接的Storm或其他流式计算框架进行处理。很多用户会将那些从原始topic来的数据进行阶段性处理，汇总，扩充或者以其他的方式转换到新的topic下再继续后面的处理。例如一个文章推荐的处理流程，可能是先从RSS数据源中抓取文章的内容，然后将其丢入一个叫做“文章”的topic中；后续操作可能是需要对这个内容进行清理，比如回复正常数据或者删除重复数据，最后再将内容匹配的结果返还给用户。这就在一个独立的topic之外，产生了一系列的实时数据处理的流程。&lt;a href=&quot;http://storm.incubator.apache.org/&quot;&gt;Strom&lt;/a&gt;和&lt;a href=&quot;http://samza.incubator.apache.org/&quot;&gt;Samza&lt;/a&gt;是非常著名的实现这种类型数据转换的框架。&lt;/p&gt;
&lt;p&gt;6.事件源&lt;/p&gt;
&lt;p&gt;事件源是一种应用程序设计的方式，该方式的状态转移被记录为按时间顺序排序的记录序列。Kafka可以存储大量的日志数据，这使得它成为一个对这种方式的应用来说绝佳的后台。比如动态汇总（News feed）。&lt;/p&gt;
&lt;p&gt;7.持久性日志（commit log）&lt;/p&gt;
&lt;p&gt;Kafka可以为一种外部的持久性日志的分布式系统提供服务。这种日志可以在节点间备份数据，并为故障节点数据回复提供一种重新同步的机制。Kafka中日志压缩功能为这种用法提供了条件。在这种用法中，Kafka类似于Apache BookKeeper项目。&lt;/p&gt;
&lt;p&gt;Kafka的设计要点：&lt;/p&gt;
&lt;p&gt;1、直接使用linux 文件系统的cache，来高效缓存数据。&lt;/p&gt;
&lt;p&gt;2、采用linux Zero-Copy提高发送性能。传统的数据发送需要发送4次上下文切换，采用sendfile系统调用之后，数据直接在内核态交换，系统上下文切换减少为2次。根据测试结果，可以提高60%的数据发送性能。Zero-Copy详细的技术细节可以参考：https://www.ibm.com/developerworks/linux/library/j-zerocopy/&lt;/p&gt;
&lt;p&gt;3、数据在磁盘上存取代价为O(1)。kafka以topic来进行消息管理，每个topic包含多个part（ition），每个part对应一个逻辑log，有多个segment组成。每个segment中存储多条消息（见下图），消息id由其逻辑位置决定，即从消息id可直接定位到消息的存储位置，避免id到位置的额外映射。每个part在内存中对应一个index，记录每个segment中的第一条消息偏移。发布者发到某个topic的消息会被均匀的分布到多个part上（随机或根据用户指定的回调函数进行分布），broker收到发布消息往对应part的最后一个segment上添加该消息，当某个segment上的消息条数达到配置值或消息发布时间超过阈值时，segment上的消息会被flush到磁盘，只有flush到磁盘上的消息订阅者才能订阅到，segment达到一定的大小后将不会再往该segment写数据，broker会创建新的segment。&lt;/p&gt;
&lt;p&gt;4、显式分布式，即所有的producer、broker和consumer都会有多个，均为分布式的。Producer和broker之间没有负载均衡机制。broker和consumer之间利用zookeeper进行负载均衡。所有broker和consumer都会在zookeeper中进行注册，且zookeeper会保存他们的一些元数据信息。如果某个broker和consumer发生了变化，所有其他的broker和consumer都会得到通知。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://kafka.apache.org/&quot;&gt;Apache Kafka网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://kafka.apache.org/documentation.html#design&quot;&gt;项目设计讨论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/apache/kafka&quot;&gt;Github镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://vimeo.com/62298867&quot;&gt;Morten Kjetland对Apache Kafka的介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.quora.com/RabbitMQ/RabbitMQ-vs-Kafka-which-one-for-durable-messaging-with-good-query-features?share=1&quot;&gt;Quora上与RabbitMQ的对比&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/srikanth/netdb11/netdb11papers/netdb11-final12.pdf&quot;&gt;Kafka: a Distributed Messaging System for Log Processing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/linux/library/j-zerocopy/&quot;&gt;Zero-copy原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sna-projects.com/sna/media/kafka_hadoop.pdf&quot;&gt;Kafka与Hadoop&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Fri, 15 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-15-75328-8f6fc7490.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-15-75328-8f6fc7490.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title> Value and Reference Types </title>
        <description>

						
						

						&lt;p&gt;Types in Swift fall into one of two categories: first, “value types”, where each instance keeps a unique copy of its data, usually defined as a &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt;, or &lt;span class=&quot;keyword&quot;&gt;tuple&lt;/span&gt;. The second, “reference types”, where instances share a single copy of the data, and the type is usually defined as a &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;. In this post we explore the merits of value and reference types, and how to choose between them. &lt;/p&gt; &lt;h3&gt; What’s the Difference? &lt;/h3&gt; &lt;p&gt;The most basic distinguishing feature of a &lt;em&gt;value type&lt;/em&gt; is that copying — the effect of assignment, initialization, and argument passing — creates an &lt;em&gt;independent instance&lt;/em&gt; with its own unique copy of its data:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// Value type example&lt;/span&gt;
&lt;span class=&quot;key&quot;&gt;struct&lt;/span&gt; S { &lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; data: &lt;span class=&quot;title&quot;&gt;Int&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; }
&lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;pointer&quot;&gt;S&lt;/span&gt;()
&lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; b = &lt;span class=&quot;pointer&quot;&gt;a&lt;/span&gt;						&lt;span class=&quot;comment&quot;&gt;// a is copied to b&lt;/span&gt;
&lt;span class=&quot;pointer&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;pointer&quot;&gt;data&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;						&lt;span class=&quot;comment&quot;&gt;// Changes a, not b&lt;/span&gt;
&lt;span class=&quot;method&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;\(&lt;span class=&quot;pointer&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;pointer&quot;&gt;data&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;,&lt;/span&gt; \(&lt;span class=&quot;pointer&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;pointer&quot;&gt;data&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;)	&lt;span class=&quot;comment&quot;&gt;// prints &quot;42, -1&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Copying a reference type, on the other hand, implicitly creates a shared instance. After a copy, two variables then refer to a single instance of the data, so modifying data in the second variable also affects the original, e.g.:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// Reference type example&lt;/span&gt;
&lt;span class=&quot;key&quot;&gt;class&lt;/span&gt; C { &lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; data: &lt;span class=&quot;title&quot;&gt;Int&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; }
&lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;pointer&quot;&gt;C&lt;/span&gt;()
&lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; y = &lt;span class=&quot;pointer&quot;&gt;x&lt;/span&gt;						&lt;span class=&quot;comment&quot;&gt;// x is copied to y&lt;/span&gt;
&lt;span class=&quot;pointer&quot;&gt;x&lt;/span&gt;.&lt;span class=&quot;pointer&quot;&gt;data&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;						&lt;span class=&quot;comment&quot;&gt;// changes the instance referred to by x (and y)&lt;/span&gt;
&lt;span class=&quot;method&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;\(&lt;span class=&quot;pointer&quot;&gt;x&lt;/span&gt;.&lt;span class=&quot;pointer&quot;&gt;data&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;,&lt;/span&gt; \(&lt;span class=&quot;pointer&quot;&gt;y&lt;/span&gt;.&lt;span class=&quot;pointer&quot;&gt;data&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;)	&lt;span class=&quot;comment&quot;&gt;// prints &quot;42, 42&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;The Role of Mutation in Safety&lt;/h3&gt; &lt;p&gt;One of the primary reasons to choose value types over reference types is the ability to more easily reason about your code. If you always get a unique, copied instance, you can trust that no other part of your app is changing the data under the covers. This is especially helpful in multi-threaded environments where a different thread could alter your data out from under you. This can create nasty bugs that are extremely hard to debug.&lt;/p&gt; &lt;p&gt;Because the difference is defined in terms of what happens when you change data, there’s one case where value and reference types overlap: when instances have no writable data. In the absence of mutation, values and references act exactly the same way.&lt;/p&gt; &lt;p&gt;You may be thinking that it could be valuable, then, to have a case where a &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; is completely immutable. This would make it easier to use Cocoa &lt;span class=&quot;keyword&quot;&gt;NSObject&lt;/span&gt; objects, while maintaining the benefits of value semantics. Today, you can write an immutable class in Swift by using only immutable stored properties and avoiding exposing any APIs that can modify state. In fact, many common Cocoa classes, such as &lt;span class=&quot;keyword&quot;&gt;NSURL&lt;/span&gt;, are designed as immutable classes. However, Swift does not currently provide any language mechanism to enforce &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; immutability (e.g. on subclasses) the way it enforces immutability for &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; and &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt;.&lt;/p&gt; &lt;h3&gt;How to Choose?&lt;/h3&gt; &lt;p&gt;So if you want to build a new type, how do you decide which kind to make? When you’re working with Cocoa, many APIs expect subclasses of &lt;span class=&quot;keyword&quot;&gt;NSObject&lt;/span&gt;, so you have to use a &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;. For the other cases, here are some guidelines:&lt;/p&gt; &lt;p&gt;Use a value type when:&lt;/p&gt; &lt;ul class=&quot;tight&quot;&gt; &lt;li&gt;Comparing instance data with &lt;span class=&quot;keyword&quot;&gt;==&lt;/span&gt; makes sense&lt;/li&gt; &lt;li&gt;You want copies to have independent state&lt;/li&gt; &lt;li&gt;The data will be used in code across multiple threads&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Use a reference type (e.g. use a &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;) when:&lt;/p&gt; &lt;ul class=&quot;tight&quot;&gt; &lt;li&gt;Comparing instance identity with &lt;span class=&quot;keyword&quot;&gt;===&lt;/span&gt; makes sense&lt;/li&gt; &lt;li&gt;You want to create shared, mutable state&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;In Swift, &lt;span class=&quot;keyword&quot;&gt;Array&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt;, and &lt;span class=&quot;keyword&quot;&gt;Dictionary&lt;/span&gt; are all value types. They behave much like a simple &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value in C, acting as a unique instance of that data. You don’t need to do anything special — such as making an explicit copy — to prevent other code from modifying that data behind your back. Importantly, you can safely pass variables across threads without synchronization. In the spirit of improving safety, this model will help you write more predictable code in Swift.&lt;/p&gt;

						
												
											

</description>
        <pubDate>Fri, 15 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-15--id=10-9e7bc9520.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-15--id=10-9e7bc9520.html</guid>
        
        
        <category>apple_swift</category>
        
      </item>
    
      <item>
        <title>字符编码常识及问题解析</title>
        <description>
&lt;pre&gt;&lt;code&gt;在面试的笔试题里出了一道开放性的题：请简述Unicode与UTF-8之间的关系。一道看似简单的题，能给出满意答案的却寥寥无几
，确实挺失望的。所以今天就结合我以前做过的一个关于字符编码的分享，总结一些与字符编码相关的知识和问题。如果你这方面的
知识已经掌握的足够了，可以忽略这篇文字。但如果你没法很好的回答我上面的面试题，或经常被乱码的问题所困扰，还是不妨一读。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;基本常识&lt;/h2&gt;

&lt;h3&gt;1.位和字节&lt;/h3&gt;

&lt;p&gt;说起编码，我们必须从最基础的说起，&lt;strong&gt;位和字节&lt;/strong&gt;(别觉得这个过于简单不值一说，我还真见过很多个不能区分这两者的程序员)。位（bit）是指计算机里存放的二进制值(0/1)，而8个位组合成的“位串”称为一个字节，容易算出，8个位的组合有256（ 2&lt;sup&gt;8&lt;/sup&gt; ）个组合方式，其取值范围是“00000000-11111111”，常用十六进制来表示。比如“01000001”就是一个字节，其对应的十六进制值为“0x41”。&lt;/p&gt;

&lt;p&gt;而我们通常所讲的字符编码，就是指&lt;strong&gt;定义一套规则&lt;/strong&gt;，将真实世界里的字母/字符与计算机的二进制序列进行相互转化。如我们可以针对上面的字节定义如下的转换规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 01000001（0x41）&amp;lt;-&amp;gt; 65 &amp;lt;-&amp;gt; &#39;A&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即用字位序“01000001”来表示字母’A’。&lt;/p&gt;

&lt;h3&gt;2.拉丁字符&lt;/h3&gt;

&lt;p&gt;拉丁字符是当今世界使用最广泛的符号了。通常我们说的拉丁字母，指的的是&lt;strong&gt;基础拉丁字母&lt;/strong&gt;,即指常见的”ABCD“等26个英文字母，这些字母与英语中一些常见的符号（如数字，标点符号）称为&lt;strong&gt;基础拉丁字符&lt;/strong&gt;，这些基础拉丁字符在使用英语的国家广为流行，当然在中国，也被用来当作汉语拼音使用。在欧洲其它一些非英语国家，为满足其语言需要，在基础拉丁字符的基础上，加上一些连字符，变音字符(如’Á’)，形成了&lt;strong&gt;派生拉丁字母&lt;/strong&gt;，其表示的字符范围在各种语言有所不同，而&lt;strong&gt;完整意义上的拉丁字符是指这些变体字符与基础拉丁字符的全集&lt;/strong&gt;。是比基础拉丁字符集大很多的一个集合。&lt;/p&gt;

&lt;h2&gt;编码标准&lt;/h2&gt;

&lt;p&gt;前文提到，字符编码是一套规则。既然是规则，就必须有标准。下面我就仔细说说常见的字符编码标准。&lt;/p&gt;

&lt;h3&gt;1.拉丁编码&lt;/h3&gt;

&lt;p&gt;ASCII的全称是American Standard Code for Information Interchange（美国信息交换标准代码）。顾名思义，这是现代计算机的发明国美国人设计的标准，而美国是一个英语国家，他们设定的&lt;strong&gt;ASCII编码也只支持基础拉丁字符&lt;/strong&gt;。ASCII的设计也很简单，&lt;strong&gt;用一个字节（8个位）来表示一个字符，并保证最高位的取值永远为’0’&lt;/strong&gt;。即表示字符含义的位数为7位，不难算出其可表达字符数为2&lt;sup&gt;7&lt;/sup&gt; =128个。这128个字符包括95个可打印的字符（涵盖了26个英文字母的大小写以及英文标点符号能）与33个控制字符（不可打印字符）。例如下表，就是几个简单的规则对应：&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;字符类型&lt;/th&gt;
&lt;th&gt;   字符&lt;/th&gt;
&lt;th&gt;二进制  &lt;/th&gt;
&lt;th&gt; 16进制&lt;/th&gt;
&lt;th&gt;10进制&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可打印字符&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;  01000001&lt;/td&gt;
&lt;td&gt;   0x41&lt;/td&gt;
&lt;td&gt;65&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可打印字符&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;  01100001&lt;/td&gt;
&lt;td&gt;   0x61&lt;/td&gt;
&lt;td&gt;97&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;控制字符&lt;/td&gt;
&lt;td&gt;   \r&lt;/td&gt;
&lt;td&gt;00001101&lt;/td&gt;
&lt;td&gt;    0x0D&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;控制字符&lt;/td&gt;
&lt;td&gt;   \n&lt;/td&gt;
&lt;td&gt;00001010&lt;/td&gt;
&lt;td&gt;    0xA&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;前面说到了，ASCII是美国人设计的，只能支持基础拉丁字符，而当计算机发展到欧洲，欧洲其它不只是用的基础拉丁字符的国家（即用更大的派生拉丁字符集）该怎么办呢？&lt;/p&gt;

&lt;p&gt;当然，最简单的办法就是将美国人没有用到的&lt;strong&gt;第8位也用上&lt;/strong&gt;就好了，这样能表达的字符个数就达到了2&lt;sup&gt;8&lt;/sup&gt; =256个，相比较原来，增长了一倍， 这个编码规则也常被称为&lt;strong&gt;EASCII&lt;/strong&gt;。EASCII基本解决了整个西欧的字符编码问题。但是对于欧洲其它地方如北欧，东欧地区，256个字符还是不够用，如是出现了&lt;strong&gt;ISO 8859&lt;/strong&gt;,为解决256个字符不够用的问题，&lt;strong&gt;ISO 8859采取的不再是单个独立的编码规则，而是由一系列的字符集（共15个）所组成&lt;/strong&gt;，分别称为ISO 8859-n(n=1,2,3…11,13…16,没有12)。其每个字符集对应不同的语言,如ISO 8859-1对应西欧语言，ISO 8859-2对应中欧语言等。其中大家所熟悉的&lt;strong&gt;Latin-1就是ISO 8859-1的别名,它表示整个西欧的字符集范围&lt;/strong&gt;。
&lt;strong&gt;需要注意的一点的是，ISO 8859-n与ASCII是兼容的，即其0000000(0x00)-01111111(0x7f)范围段与ASCII保持一致，而10000000（0x80）-11111111(0xFF)范围段被扩展用到不同的字符集。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;2.中文编码&lt;/h3&gt;

&lt;p&gt;以上我们接触到的拉丁编码，都是单字节编码，即用一个字节来对应一个字符。但这一规则对于其它字符集更大的语言来说，并不适应，比如中文，而是出现了用多个字节表示一个字符的编码规则。常见的中文GB2312（国家简体中文字符集）就是用两个字节来表示一个汉字（注意是表示一个汉字，对于拉丁字母，GB2312还是是用一个字节来表示以兼容ASCII）。我们用下表来说明各中文编码之间的规则和兼容性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sharecore.net/24f49bfe6e2506470d87f565f56bbcb3.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;

&lt;p&gt;对于中文编码，其规则实现上是很简单的，一般都是简单的&lt;strong&gt;字符查表&lt;/strong&gt;即可，重要的是要注意其相互之间的&lt;strong&gt;兼容性&lt;/strong&gt;问题。如如果选择BIG5字符集编码，就不能很好的兼容GB2312，当做繁转简时有可能导致个别字的冲突与不一致，但是GBK与GB2312之间就不存在这样的问题。&lt;/p&gt;

&lt;h3&gt;3.Unicode&lt;/h3&gt;

&lt;p&gt;以上可以看到，针对不同的语言采用不同的编码，有可能导致冲突与不兼容性，如果我们打开一份字节序文件，如果不知道其编码规则，就无法正确解析其语义，这也是产生乱码的根本原因。有没有一种规则是全世界字符统一的呢？当然有，Unicode就是一种。为了能独立表示世界上所有的字符，Unicode采用&lt;strong&gt;4个字节表示一个字符&lt;/strong&gt;,这样理论上Unicode能表示的字符数就达到了2&lt;sup&gt;31&lt;/sup&gt; = 2147483648 = 21 亿左右个字符，完全可以涵盖世界上一切语言所用的符号。我们以汉字”微信“两字举例说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;微 &amp;lt;-&amp;gt;  \u5fae   &amp;lt;-&amp;gt;  00000000 00000000 01011111 10101110
信 &amp;lt;-&amp;gt; \u4fe1   &amp;lt;-&amp;gt;  00000000 00000000 01001111 11100001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;容易从上面的例子里看出，Unicode对所有的字符编码均需要四个字节，而这对于拉丁字母或汉字来说是浪费的，其前面三个或两个字节均是0,这对信息存储来说是极大的浪费。另外一个问题就是，如何区分Unicode与其它编码这也是一个问题，比如计算机怎么知道四个字节表示一个Unicode中的字符，还是分别表示四个ASCII的字符呢？&lt;/p&gt;

&lt;p&gt;以上两个问题，困扰着Unicode，让Unicode的推广上一直面临着困难。直至UTF-8作为Unicode的一种实现后，部分问题得到解决，才得以完成推广使用。说到此，我们可以回答文章一开始提出的问题了，&lt;strong&gt;UTF-8是Unicode的一种实现方式，而Unicode是一个统一标准规范，Unicode的实现方式除了UTF-8还有其它的，比如UTF-16等。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;话说当初大牛Ben Thomson吃饭时，在一张餐巾纸上，设计出了UTF-8，然后回到房间，实现了第一版的UTF-8。关于UTF-8的基本规则，其实简单来说就两条（来自阮一峰老师的总结）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;规则1：对于单字节字符，字节的第一位为0，后7位为这个符号的Unicode码，所以对于拉丁字母，UTF-8与ASCII码是一致的。

规则2：对于n字节(n&amp;gt;1)的字符，第一个字节前n位都设为1，第n+1位为0，后面字节的前两位一律设为10，
剩下没有提及的位，全部为这个符号的Unicode编码。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过，根据以上规则，可以建立一个Unicode取值范围与UTF-8字节序表示的对应关系，如下表，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sharecore.net/c5e88dc37d1f58ce4b03a448d4839885.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;

&lt;p&gt;举例来说，’微’的Unicode是’\u5fae’，二进制表示是”00000000 00000000 01011111 10101110“，其取值就位于’0000 0800-0000 FFFF’之间，所以其UTF-8编码为’&lt;strong&gt;111&lt;/strong&gt;00101 &lt;strong&gt;10&lt;/strong&gt;111110 &lt;strong&gt;10&lt;/strong&gt;101110’ （加粗部分为固定编码内容）。&lt;/p&gt;

&lt;p&gt;通过以上简单规则，UTF-8采取变字节的方式，解决了我们前文提到的关于Unicode的两大问题。同时，作为中文使用者需要注意的一点是&lt;strong&gt;Unicode(UTF-8)与GBK，GB2312这些汉字编码规则是完全不兼容的，也就是说这两者之间不能通过任何算法来进行转换,如需转换，一般通过GBK查表的方式来进行&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;常见问题及解答&lt;/h2&gt;

&lt;h3&gt;1.windows Notepad中的编码ANSI保存选项，代表什么含义？&lt;/h3&gt;

&lt;p&gt;ANSI是windows的默认的编码方式，对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。所以，&lt;strong&gt;如果将一个UTF-8编码的文件，另存为ANSI的方式，对于中文部分会产生乱码&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;2.什么是UTF-8的BOM？&lt;/h3&gt;

&lt;p&gt;BOM的全称是Byte Order Mark，BOM是微软给UTF-8编码加上的，用于标识文件使用的是UTF-8编码，即在UTF-8编码的文件起始位置，加入三个字节“EE BB BF”。这是微软特有的，标准并不推荐包含BOM的方式。采用加BOM的UTF-8编码文件，对于一些只支持标准UTF-8编码的环境，可能导致问题。比如，在Go语言编程中，对于包含BOM的代码文件，会导致编译出错。详细可见我的&lt;a href=&quot;http://sharecore.info/blog/2013/04/05/parse-csv-to-sql-for-insert/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;3.为什么数据库Latin1字符集（单字节）可以存储中文呢？&lt;/h3&gt;

&lt;p&gt;其实不管需要使用几个字节来表示一个字符，但最小的存储单位都是字节,所以，&lt;strong&gt;只要能保证传输和存储的字节顺序不会乱即可&lt;/strong&gt;。作为数据库，只是作为存储的使用的话，只要能保证存储的顺序与写入的顺序一致，然后再按相同的字节顺序读出即可，翻译成语义字符的任务交给应用程序。比如’微’的UTF-8编码是’0xE5 0xBE 0xAE’，那数据库也存储’0xE5 0xBE 0xAE’三个字节，其它应用按顺序从数据库读取，再按UTF-8编码进行展现。这当然是一个看似完美的方案，但是只要写入，存储，读取过程中岔出任何别的编码，都可能导致乱码。&lt;/p&gt;

&lt;h3&gt;4.Mysql数据库中多个字符集变量（其它数据库其实也类似），它们之间分别是什么关系？&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/sharecore.net/fe3b60523b621b3ac871f45c83692d11.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们分别解释：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;character_set_client&lt;/strong&gt;：客户端来源的数据使用的字符集，用于客户端显式告诉客户端所发送的语句中的的字符编码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;character_set_connection&lt;/strong&gt;：连接层的字符编码，mysql一般用character_set_connection将客户端的字符转换为连接层表示的字符。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;character_set_results&lt;/strong&gt;:查询结果从数据库读出后，将转换为character_set_results返回给前端。&lt;/p&gt;

&lt;p&gt;而我们常见的解决乱码问题的操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql_query(&#39;SET NAMES GBK&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其相当于将以上三个字符集统一全部设置为GBK，这三者一致时，一般就解决了乱码问题。&lt;/p&gt;

&lt;p&gt;character_set_database:当前选中数据库的默认字符集，如当create table时没有指定字符集，将默认选择该字符集。&lt;/p&gt;

&lt;p&gt;character_set_database已经character_set_system，一般用于数据库系统内部的一些字符编码，处理数据乱码问题时，我们基本可以忽略。&lt;/p&gt;

&lt;h3&gt;5.什么情况下，表示信息丢失？&lt;/h3&gt;

&lt;p&gt;对于mysql数据库，我们可以通过&lt;strong&gt;hex(colname)&lt;/strong&gt;函数（其它数据库也有类似的函数，一些文本文件编辑器也具有这个功能），查看实际存储的字节内容，如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sharecore.net/259d5bdc7de57ebf071e5349db857417.jpg&quot; style=&quot;width:500px&quot;&gt;&lt;/p&gt;

&lt;p&gt;通过查看存储的字节序，我们可以从根本上了解存储的内容是什么编码了。而当发现&lt;strong&gt;存储的内容全部是’3F’时，就表明存储的内容由于编码问题，信息已经丢失了，无法再找回&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;之所以出现这种信息丢失的情况，一般是将不能相互转换的字符集之间做了转换，比如我们在前文说到，UTF-8只能一个个字节地变成Latin-1，但是根本不能转换的，因为两者之间没有转换规则，Unicode的字符对应范围也根本不在Latin-1范围内，所以只能用’?(0x3F)’代替了。&lt;/p&gt;

&lt;h2&gt;总结：&lt;/h2&gt;

&lt;p&gt;本文从基础知识与实际中碰到的问题上，解析了字符编码相关内容。而之所以要从头介绍字符编码的基础知识，是为了更好的从原理上了解与解决日常碰到的编码问题，只有从根本上了解了不同字符集的规则及其之间的关系与兼容性，才能更好的解决碰到的乱码问题，也能避免由于程序中不正确的编码转换导致的信息丢失问题。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;如果您觉得这篇文字有意思，欢迎转发！欢迎更多的朋友们关注我的微信公众号：&lt;strong&gt;JustinNotes&lt;/strong&gt;&lt;/p&gt;

&lt;hr&gt;

</description>
        <pubDate>Sun, 10 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-10-zi-fu-bian-ma-chang-shi-ji-wen-ti-jie-xi-6cc6d9c3f.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-10-zi-fu-bian-ma-chang-shi-ji-wen-ti-jie-xi-6cc6d9c3f.html</guid>
        
        
        <category>sharecore</category>
        
      </item>
    
      <item>
        <title>递归是如何进入编程的？</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;现在我们很难想象，曾经有段时间，在编程中使用递归的实用性甚至是可能性是受到怀疑的。然而，这种现象在1960年左右的编程社区中是真实的。创造了Algol 60的委员会也甚至在这个问题上存在分歧。递归如何进入编程语言是一个阴谋和误解的故事。当我读Gauthier van den Hove的优秀硕士论文[11]时，我第一次知道了这个故事。这也是[12]中第3章的主题。&lt;/p&gt;
&lt;p&gt;在20世纪50年代末，成立了一个委员会，他们致力于设计一种通用的、与机器无关的编程语言。在当时，这样一种语言并不是多余的奢侈品：程序员们使用的编程系统由硬件制造商提供，这些编程系统甚至没有在不同的模型间进行统一。Fortran语言是第一个例外，但它在当时仍然依赖于单一制造商。Lisp语言预示这某些事情的到来：与机器无关且不依赖于制造商。这就是Algol想要做的，但后来有更多的官方介入：在联合国教科文组织的主持下成立的IFIP（国际信息处理联合会）资助了Algol。&lt;/p&gt;
&lt;p&gt;McCarthy刚刚从他的Lisp项目中获得成功，他热衷于将递归作为一种优雅的方式让计算机做它们最擅长的事：每次重复代码并做适当的修改。事实上，在最开始的Lisp语言中没有迭代，因此添加线性表中所有元素的唯一方法是写一个递归定义的函数。作为Algol 委员会的成员，McCarthy提出让递归成为新语言的一个特征的可能性。这个提案被更紧迫的问题所排挤。结果在1960年的前几个月，当报告最终敲定时，大家在递归问题上并没有达成共识。&lt;/p&gt;
&lt;p&gt;这里有充足的理由来反对。目前还不清楚它是否能实现：该委员会中的德国派认为，像Lisp解释器这样古怪的实验研究对于可靠、高效的编译器而言，并不是一个鼓舞人心的例子。但委员会成员Naur和van Wijngaarden赞同McCarthy的观点，他们认为递归是一个太诱人的机会，不容错过。Van Wijngaarden一直怂恿他的搭档Edsger W. Dijkstra，谁赞成递归，谁就可能给他们提供新的、尚未发表的实现递归的想法。&lt;/p&gt;
&lt;p&gt;Naur是编辑Algol报告最终版本的委员会成员。二十年后，Naur想起它来，如下[1]：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;编程语言概念的最后一个重大的变化是允许递归程序激活。这如下发生。 [...] 大约在2月10日， [...] 我接到了A. van Wijngaarden的电话，通话的人同时还有E.W. Dijkstra。他们指出在报告草案中缺少一个重要的定义，即程序标识符在声明中出现的意义不同于它出现在赋值语句的左边部分。他们还明确表示，通过描述的规则防止递归激活会使情况变得复杂，因为递归有可能通过程序及其参数间接激活。他们建议在5.4.4节增加一个句子来澄清此事：“在程序中任何其他程序标识符的出现都表示程序的激活”。尽管考虑到这个问题随后带来麻烦的风险，我被这个建议的大胆和简单所迷住，并决定这样做。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;结果发现在这个问题上确实存在麻烦。一些委员会成员已经被骗批准这个最终版本的报告，报告中包含一个后期加入的容易被忽略的内容，这在与委员们期望相反的方向上试图解决争论。委员会成员F.L. Bauer通过将语言中增加的递归视为“阿姆斯特丹阴谋”[1, 附录5]来表明自己的抗议。&lt;/p&gt;
&lt;p&gt;Dijkstra在2001年接受采访时明确表明，这不是Bauer部分的偏执[2]：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;递归是很重要的一步。它偷偷摸摸的被介绍。ALGOL-60报告草案在十二月最后一周被发布。我们研究它，并意识到递归调用虽然没有被说明，但已被允许。我打电话给Peter Naur—打到哥本哈根是我的第一个国际电话，我永远不会忘记这种兴奋！—并给他口头提供了一个建议，而他在报告中包含了这个建议。这个建议是这样的，“在程序中任何其他程序标识符的出现都表示程序的激活。”基本上就是这个情况。这个句子被暗中插入。并且所有人，包括没有看到这句话的人，可以说都不得不同意这个报告。这就是递归是如何被明确列入的过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是，是什么原因Bauer没有实现而Dijkstra实现了递归？事实上，“递归”意味着什么呢？仔细看看Naur和Dijkstra对上述的说明，结果显示Naur说“递归程序激活”，这是一个运行时的概念；而Dijkstra说“递归”，这可以解释为源程序的属性。&lt;/p&gt;
&lt;p&gt;这里有一些澄清“递归”含义的尝试。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它有可能在执行一个程序时被调用，这使得存在一个先前调用的激活记录。&lt;/li&gt;
&lt;li&gt;可能通过调用被命名为形式参数的程序，直接或间接地调用自身。&lt;/li&gt;
&lt;li&gt;间接通过调用未命名形式参数的程序，直接或间接地调用自身。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Naur想的是第一个含义，而Dijkstra想到的可能是第二个含义。&lt;/p&gt;
&lt;p&gt;当Algol委员会中的Bauer派发现他们是阿姆斯特丹阴谋的受害者时，删除有问题的句子，这似乎是定义他们的首选版Algol的一件简单事情。他们发现这并不能消除递归。至少根据第一个含义不是递归。而这正是他们想要去掉的，因为他们希望静态分配程序的激活记录。&lt;/p&gt;
&lt;p&gt;公布的Algol-60报告通过一些努力重新定义语言：SMALGOL [3], ECMA子集 [4], 和SUBSET Algol [5]。这些人基于他们的期望而联合，共同禁止那些需要动态分配程序激活记录的方案。所有这三种语言都一致删除了Algol-60报告5.4.4节中的最后一句。他们一致认为，对于消除递归这是不够的，在这个方向上他们进行了不同的尝试。例如，在Algol-60报告中最后添加了4.7.5.6节：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;不调用程序本身，在执行任何程序中的语句和给实参赋值期间，可能发生通过名字调用相应形参的情况。在表达式赋值的期间，这也会发生在程序内部声明中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;据我所知，Algol-60报告中没有这句话。但定义子集的人像我一样为他们提供了一个替代的表达：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;不要写递归程序。不要使用递归程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;正如Dijkstra已经预见到的，他们应该加入：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;不要尝试对程序的参数做任何偷偷摸摸的事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样Algol 60失去了它的一大成就：对实施者和使用者而言的一个单一文件。&lt;/p&gt;
&lt;p&gt;对递归而言的一种有效治疗是消除嵌套程序声明并要求程序在第一次调用前声明。我们看看这个，例如在C中，它已经被描述为“荣耀的汇编语言”，更重要的是被Bauer派视为注重效率的典范成果。具有讽刺意味的是，这个效率典范的设计者认为在动态分配程序激活记录或允许程序调用自身两个方面都没有问题。无需修改，在调用前声明的要求将消除相互递归的可能性。因为这不会带来动态激活记录的问题，Ritchie放宽了之前使用定义的规则，允许程序头部的冗余声明。以冗余的预先声明为代价，程序员能在C中定义相互递归的程序。&lt;/p&gt;
&lt;p&gt;当然，我们不能责备Bauer派，因为后来的人没有在这个领域的经验。有趣的是，在1960年确实存在知识表明，当有人想要有吸引力的Algol程序机制时，避免动态分配的需要是多么困难。这个程序机制与20世纪30年代以来众所周知的lambda演算类似。根据当前的标准，Algol-60报告是一个及其紧凑的文件。但与lambda演算的定义相比，它有些相形见拙。例如，在[6]中，lambda演算被定义86行，分布在10个定义中。很明显，在这个紧凑的定义中，lambda演算不允许递归函数的定义。然而在1935年，lambda演算的表达至少已经发现有两个版本的Y组合子。而这个组合子使得递归函数可能在lambda 演算中定义。&lt;/p&gt;
&lt;p&gt;一旦有人有一个简单而通用的函数定义机制时，对于避免递归是多么困难，lambda演算是另一个例子。同样，我们不能责备Bauer派不知道这些事情。事实上，直到20世纪60年代，出版了如[7]这样的书籍，使用递归的Y组合子才变得家喻户晓。&lt;/p&gt;
&lt;p&gt;这是一个安全的假设，阿姆斯特丹阴谋的肇事者并不知道。那为什么他们如此肯定他们是在正确的道路上呢？我们知道，就其中的一个策划者E.W. Dijkstra而言，他在1961年10月出版了数学中心的报告MR34“与机器无关的编程语言的设计”。在这篇报告中，Dijkstra当时考虑到相关性，提出了语言设计的一般原则，在我看来，今天仍然适用。一个安全的假设是，在一年之前，他已经确信这些原则。这些原则的普遍性使他有可能运用知识实现Y组合子，并随后获得有效实现动态分配程序激活记录的经验。&lt;/p&gt;
&lt;p&gt;在被引用最多的一篇论文中， F.P. Brooks [9]将有着狂热追随者的编程系统或语言与一系列无聊却尽管可能有用，但没有狂热追随者的项目进行对比。他指出，前者是由个人创建的，后者是由委员会创建的。他的言外之意是委员会设计的东西一定要归到无聊的类别下。为了概念上的完整性，Brooks指明了区分的标准。因为委员会设计的东西一般被认为必定没有概念上的完整性，Brooks将Algol 60放在后一类中。&lt;/p&gt;
&lt;p&gt;通过Dijkstra，我从第二种观点中走出来，并发现这一点[10, 第4页]：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;然后60年代与一个绝对的奇迹，即ALGOL 60，一起开始。这是一个奇迹，因为，一方面这种编程语言已经被一个委员会设计出来，而另一方面它的优点是那样的突出，在回顾中，它已经被认为是“大多数继承者中的一个重大的进步”(C. A. R. Hoare)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;奇迹是怎样发生的？对于Algol委员会这样一个拥有各种成员的委员会而言，它引人注目地超越理想状态，然后撰写出简明、完整的文档，并在概念的完整性上描述了一门语言，其优点得到Brooks的高度赞赏。这一切怎么可能呢？&lt;/p&gt;
&lt;p&gt;答案是这有一个酝酿期，我估计它开始于1955年10月在达姆施塔特举办的自动计算国际研讨会。几位发言者提出需要一种通用的、与机器无关的算法语言。委员会的第一个继承者开始做这项工作。他在美国接触并寻找志同道合的人。这是一个欧洲/美国的联合委员会，他们在苏黎世会面，并商定这样的语言标准。他们的文档制作得足够详细，以便该语言标准值得被称为Algol 58。&lt;/p&gt;
&lt;p&gt;这个报告的公布引起了语言进一步发展的兴趣。Peter Naur是加入Algol委员会的新成员之一。Algol 58是需要进一步发展的。许多新的想法被提出来。在一些方面，委员会超前的超越了现有最先进的理念和他们自己的理解力。&lt;/p&gt;
&lt;p&gt;同时，委员会陷入困境。尽管Naur是新成员，他看到了结构化讨论方式的需求，并创建了Algol会刊。他开始以语言定义的形式统一成果。他为了语法定义研究了Backus的形式主义，并将其应用在新语言不堪重负的语法清单上。为了赶上在1960年1月巴黎举办的最终设计会议上上交报告，他及时准备好了它。他没有时间来准备政治。&lt;/p&gt;
&lt;p&gt;Bauer1978年的回忆[1, 第41页]:&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt; &lt;span style=&quot;color: #888888;&quot;&gt;… 解释了巴黎ALGOL-60会议上一个奇怪的事件 … 在巴黎会议的开始，Peter Naur交给他们一份他的18页的报告草案，这让他们很惊讶。Peter Naur并没有被委托做这件事，这是一个既成事实。因此，如果他写的这个报告草案被“选”为讨论的基础，这听起来充满诗意；而在Peter Naur已经获得这种优势之后，该委员会只是被迫这么做。同样，他自动成为了编辑；这只是一个邀请他的礼貌问题。由于有一些担心，他会利用这个位置在语言上发挥他自己的一些影响力（发生的事情的确如此，正如他表示的），这种发展被一些委员会成员认为是非常不健康的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;换句话说，一些委员会成员真的生气了。在接下来的一页：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;但是，应当提到，不仅委员会成员之中存在怀疑态度，而且当编辑随意修改会议的结果时，成员们无奈地表示没有谁可以做些什么。为了忠诚度，他被吞噬了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然而，Bauer写道：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;在另一方面，尽管六天巴黎会议的时间进度非常紧迫，这样的情况对获得报告完成的草稿有一定的帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这就解释了奇迹：在经过了Algol计划的创造、探索和挣扎阶段后，新人出现了并接管了它。前辈隐约意识到，那个人拯救了这个计划，但他曾经受到伤害。Bauer可能永远不会原谅Naur；尽管上述引用写于1978年，在事情发生之后很久。对我而言，他们表明在某种程度上，Algol 60这个“奇迹”是Naur创造的。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;致谢&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;直到最近我才意识到在递归和同一程序的多条激活记录的可能性之间的区别。同样，我认为Peter Naur只是Algol委员会中的一个成员，而他恰好正是个编辑。只是因为Gauthier van den Hove好心的给我看了一些他的研究成果，我才了解到这里有引人入胜的故事。van den Hove先生最近发表了他的文章http://www.fibonacci.org/GHE7.3.pdf。非常感谢Paul McJones在一些方面的帮助。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;[1] “The European Side of the Last Phase of the Development of Algol 60″ by P. Naur; page 3. ACM SIGPLAN Notices 13(8), pp. 13– 44 (1978)&lt;/p&gt;
&lt;p&gt;[2] Oral History interview conducted by Philip L. Frana on August 2, 2001, Austin, Texas. OH 330, Charles Babbage Institute, University of Minneapolis.&lt;/p&gt;
&lt;p&gt;[3] “Smalgol-61″, G.A. Bachelor, J.R.H. Dempster, D.E. Knuth, and J. Speroni, eds. Comm. ACM 4(11), pp. 499–502 (1961).&lt;/p&gt;
&lt;p&gt;[4] “ECMA subset of Algol 60″ Comm. ACM 6(10), pp. 595–597 (1963).&lt;/p&gt;
&lt;p&gt;[5] “Report on SUBSET Algol 60″ Comm. ACM 7(10), pp. 626–628 (1964).&lt;/p&gt;
&lt;p&gt;[6] Introduction to Combinators and Lambda Calculus by G.R. Hindley and J.P. Seldin. Cambridge University Press, 1986.&lt;/p&gt;
&lt;p&gt;[7] Denotational Semantics by Joseph Stoy.&lt;/p&gt;
&lt;p&gt;[8] also Annual Review in Automatic Programming vol.3, Richard Goodman, ed., pp 27 — 42, Pergamon Press 1963.&lt;/p&gt;
&lt;p&gt;[9] “No Silver Bullet: Essence and Accidents of Software Engineering” by F.P. Brooks. Computer, 20 (4), pp. 10–19 (1987).&lt;/p&gt;
&lt;p&gt;[10] “Computing Science: Achievements and Challenges” by E.W. Dijkstra. ACM SIGAPP Applied Computing Review 7 (2), pp. 2–9, 1999.&lt;/p&gt;
&lt;p&gt;[11] Edsger Wybe Dijkstra: First Years in Computing Science (1951–1968) by Gauthier van den Hove. MSc thesis, University of Namur, 2009.&lt;/p&gt;
&lt;p&gt;[12] The Dawn of Software Engineering: from Turing to Dijkstra by Edgar Daylight. Lonely Scholar, 2012.&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Sun, 10 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-10-74422-f81984a70.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-10-74422-f81984a70.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Mojolicious 框架的环境变量列表</title>
        <description>

							&lt;p&gt;
	这是 Mojolicious 中找到的变量列表, 有时好要找, 找不到, 我找到了 Wiki 上的, 然后译成中文拿出来了.备查.&lt;br&gt;
	注意, 这并不保持下面的列表是全的.&lt;/p&gt;
&lt;ul class=&quot;task-list&quot;&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Home#detect&quot;&gt;&lt;strong&gt;MOJO_HOME&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Home, Mojolicious::Commands (command line opt), Mojolicious::Lite] – 当前工作的主目标&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Log#level&quot;&gt;&lt;strong&gt;MOJO_LOG_LEVEL&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;/debug|info|warn|error|fatal/&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Log, Test::Mojo] – 有效的日志级别.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojolicious#mode&quot;&gt;&lt;strong&gt;MOJO_MODE&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;/&#39;development&#39;|&#39;production&#39;/&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojolicious, Mojolicious::Commands (command line opt), Mojolicious::Lite, Mojo::Server::Hypnotoad] – 你写的应用程序工作的模式环境.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojolicious/Commands#start&quot;&gt;&lt;strong&gt;MOJO_APP&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojolicious::Commands] -默认的 MOJO_APP 的值是  Mojo::HelloWorld.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojolicious/Plugin/Config#file&quot;&gt;&lt;strong&gt;MOJO_CONFIG&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojolicious::Plugin::Config] – 全路径的配置文件, 默认是使用的你的应用的 home 目标中的 myapp.conf 文件. &lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojolicious/Commands#run&quot;&gt;&lt;strong&gt;MOJO_NO_DETECT&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;bool&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojolicious::Commands] – no detect environment (PSGI, CGI, …). &lt;span class=&quot;short_text&quot; id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;自动&lt;/span&gt;&lt;span&gt;检测部署所使用的环境&lt;/span&gt;&lt;span&gt;可以&lt;/span&gt;&lt;span&gt;用, 可以通过&lt;/span&gt;&lt;/span&gt; MOJO_NO_DETECT 来修改它.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Server/Daemon#inactivity_timeout&quot;&gt;&lt;strong&gt;MOJO_INACTIVITY_TIMEOUT&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Server::Daemon, Mojolicious::Command::daemon (command line opt),&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/UserAgent#inactivity_timeout&quot;&gt;Mojo::UserAgent&lt;/a&gt;] – 连接后最大的不活动的时间, 超过会被关闭. 默认 MOJO_INACTIVITY_TIMEOUT 的环境变量是 15 ( UserAgent 中是 20 ). 将该值设置为 0 将允许连接到无限期处于非活动状态.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Server/Daemon#listen&quot;&gt;&lt;strong&gt;MOJO_LISTEN&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Server::Daemon, Mojolicious::Command::daemon (command line opt)] – 命令行检查的地址, MOJO_LISTEN 的默认值是 &#39;http://*:3000&#39;.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Server/Hypnotoad#proxy&quot;&gt;&lt;strong&gt;MOJO_REVERSE_PROXY&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;bool&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Server::Hypnotoad, Mojolicious::Command::daemon (command line opt), Mojo::Message::Request, Mojo::Transaction] – 激活反向代理的支持, 这会让 Mojo 来自动的检查 X-Forwarded-For 和 X-Forwarded-HTTPS headers 来自动的检查, 默认是检查  MOJO_REVERSE_PROXY 环境变量.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Content#max_buffer_size&quot;&gt;&lt;strong&gt;MOJO_MAX_BUFFER_SIZE&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Content] – 最大的进行内容 body 解析时的大小, 默认的  MOJO_MAX_BUFFER_SIZE 的值是 262144 (256KB).&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Content#max_leftover_size&quot;&gt;&lt;strong&gt;MOJO_MAX_LEFTOVER_SIZE&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Content] –  pipelined HTTP 请求时最大的缓冲大小,  默认的 MOJO_MAX_LEFTOVER_SIZE 的值是 262144 (256KB).&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Headers#max_line_size&quot;&gt;&lt;strong&gt;MOJO_MAX_LINE_SIZE&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Headers,&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Message#max_line_size&quot;&gt;Mojo::Message&lt;/a&gt;] -最大的 header 行的长度, 单件是字节, 默认的这个 MOJO_MAX_LINE_SIZE 值是 10240 (10KB).&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojolicious/Lite#File_uploads&quot;&gt;&lt;strong&gt;MOJO_MAX_MESSAGE_SIZE&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojolicious::Lite,&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Message#max_message_size&quot;&gt;Mojo::Message&lt;/a&gt;, Mojolicious::Lite] – 为了保护您免受接收过大的文件默认限制是 10MB (&lt;code&gt;10485760&lt;/code&gt;) , 你可以通过 MOJO_MAX_MESSAGE_SIZE 环境变量来调整这个值.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Transaction/WebSocket#max_websocket_size&quot;&gt;&lt;strong&gt;MOJO_MAX_WEBSOCKET_SIZE&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Transaction::WebSocket] – 最大的 WebSocket 消息的大小, 默认是 MOJO_MAX_WEBSOCKET_SIZE 的值是 262144.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/IOLoop#DESCRIPTION&quot;&gt;&lt;strong&gt;MOJO_NO_IPV6&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;bool&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::IOLoop, Mojo::IOLoop::Client, Mojo::IOLoop::Server, Mojo::UserAgent, Mojo::Server::Morbo, Mojo::Server::Daemon, Mojo::Server::Hypnotoad] – IPv6 时&lt;span&gt;禁止&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt; use IO::Socket::IP.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/IOLoop#DESCRIPTION&quot;&gt;&lt;strong&gt;MOJO_NO_TLS&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;bool&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::IOLoop, Mojo::IOLoop::Client, Mojo::IOLoop::Server, Mojo::UserAgent, Mojo::Server::Morbo, Mojo::Server::Daemon, Mojo::Server::Hypnotoad] – SSL 时&lt;span class=&quot;short_text&quot; id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;禁止&lt;/span&gt;&lt;span&gt;使用 &lt;/span&gt;&lt;/span&gt;IO::Socket::SSL.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;task-list&quot;&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc//Mojo/Asset/Memory#max_memory_size&quot;&gt;&lt;strong&gt;MOJO_MAX_MEMORY_SIZE&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Asset::Memory] – 最大只的保持在内存中的字节大小, 超过会自动的使用 Mojo::Asset::File 对象生成临时文件, 默认值是使用 MOJO_MAX_MEMORY_SIZE 环境变量, 或者 262144.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Asset/File#tmpdir&quot;&gt;&lt;strong&gt;MOJO_TMPDIR&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Asset::File] – 本模块生成文件的临时目录, 默认是从 MOJO_TMPDIR 环境变量中取得或者自动检测.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Reactor#detect&quot;&gt;&lt;strong&gt;MOJO_REACTOR&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Reactor] – 检测和加载的最佳的可用的 REACTOR ( 事件驱动 ).这会尝试从 MOJO_REACTOR 环境变量中取指你指定的, 目前有二个 Mojo::Reactor::EV 或者 Mojo::Reactor::Poll.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;
	Mojo::UserAgent (ojo 相同)&lt;/h3&gt;
&lt;ul class=&quot;task-list&quot;&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/UserAgent#ca&quot;&gt;&lt;strong&gt;MOJO_CA_FILE&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::UserAgent] – TLS certificate authority 文件的位置, 默认是从 MOJO_CA_FILE 环境变量中取得. 这会激活主机名验证.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/UserAgent#cert&quot;&gt;&lt;strong&gt;MOJO_CERT_FILE&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::UserAgent] – TLS certificate 文件的位置, 默认是从 MOJO_CERT_FILE 环境变量中取得.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/UserAgent#key&quot;&gt;&lt;strong&gt;MOJO_KEY_FILE&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::UserAgent] –  TLS key 文件的路径, 默认是从  MOJO_KEY_FILE 的环境变量中取得.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/UserAgent#connect_timeout&quot;&gt;&lt;strong&gt;MOJO_CONNECT_TIMEOUT&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::UserAgent] – 建连时的最多的超时时间, 超过会被注销, 默认是  10 或者从环境变量的中的 MOJO_CONNECT_TIMEOUT 取得.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/UserAgent#max_redirects&quot;&gt;&lt;strong&gt;MOJO_MAX_REDIRECTS&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::UserAgent] – 最多可以重定向的数量, 超过会失败, 默认这个是是设置为 0 或者从环境变量的  MOJO_MAX_REDIRECTS 中取得.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/UserAgent#request_timeout&quot;&gt;&lt;strong&gt;MOJO_REQUEST_TIMEOUT&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::UserAgent] - &lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;建立连接的超时时间&lt;/span&gt;, &lt;span class=&quot;short_text&quot; id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;发送请求和&lt;/span&gt;&lt;span&gt;接收整个&lt;/span&gt;&lt;span&gt;响应&lt;/span&gt;&lt;span&gt;可能需要的时间, 超过会被注消. 默认的&lt;/span&gt;&lt;/span&gt; MOJO_REQUEST_TIMEOUT 是使用环境变量的这个值或者 0. 当设置为 0 时会无限斯的等待.  每次 redirect 会自动的重置.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/UserAgent#detect_proxy&quot;&gt;&lt;strong&gt;MOJO_PROXY&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::UserAgent, ojo] – 检查环境变量中的 HTTP_PROXY, http_proxy, HTTPS_PROXY, https_proxy, NO_PROXY 和 no_proxy 中的代理的信息. 通过这个选项, 可以打开自动的检查代理选项.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/kraih/mojo/wiki/%25ENV#debugging&quot; name=&quot;user-content-debugging&quot;&gt;&lt;/a&gt;Debugging&lt;/h3&gt;
&lt;ul class=&quot;task-list&quot;&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Exception#verbose&quot;&gt;&lt;strong&gt;MOJO_EXCEPTION_VERBOSE&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Exception] - &lt;span class=&quot;short_text&quot; id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;激活&lt;/span&gt;&lt;span&gt;渲染时的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;详细信息&lt;/span&gt;,默认 MOJO_EXCEPTION_VERBOSE 是 0.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc//Mojo/IOLoop#DEBUGGING&quot;&gt;&lt;strong&gt;MOJO_IOLOOP_DEBUG&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;bool&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::IOLoop] – 你可以设置 MOJO_IOLOOP_DEBUG 环境变量来打印高级的事件循环诊断信息到标准错误.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/EventEmitter#DEBUGGING&quot;&gt;&lt;strong&gt;MOJO_EVENTEMITTER_DEBUG&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;bool&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::EventEmitter] -你可以设置 MOJO_EVENTEMITTER_DEBUG 环境变量来打印高级的事件调用的诊断信息到标准错误.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Server/Daemon#DEBUGGING&quot;&gt;&lt;strong&gt;MOJO_DAEMON_DEBUG&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;bool&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Server::Daemon] – 你可以设置 MOJO_DAEMON_DEBUG 环境变量来打印高级的守护进程的诊断信息到标准错误.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Template#DEBUGGING&quot;&gt;&lt;strong&gt;MOJO_TEMPLATE_DEBUG&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;bool&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Template] - 你可以设置 MOJO_TEMPLATE_DEBUG  环境变量来打印高级的模板的诊断信息到标准错误.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Transaction/WebSocket#DEBUGGING&quot;&gt;&lt;strong&gt;MOJO_WEBSOCKET_DEBUG&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;bool&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Transaction::WebSocket] - 你可以设置 MOJO_WEBSOCKET_DEBUG 环境变量来打印高级的 WebSocket 的诊断信息到标准错误.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/Base#DEBUGGING&quot;&gt;&lt;strong&gt;MOJO_BASE_DEBUG&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;bool&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::Base] - 你可以设置 MOJO_BASE_DEBUG 环境变量来打印高级的 Mojo::Base 的诊断信息到标准错误.&lt;/li&gt;
&lt;li&gt;
		&lt;a href=&quot;http://cpan.php-oa.com/perldoc/Mojo/UserAgent#DEBUGGING&quot;&gt;&lt;strong&gt;MOJO_USERAGENT_DEBUG&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;bool&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::UserAgent] -你可以设置 MOJO_USERAGENT_DEBUG 环境变量来打印高级的 Mojo::UserAgent 的创建连接的请求和响应的诊断信息到标准错误.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul class=&quot;task-list&quot;&gt;
&lt;li&gt;
		&lt;strong&gt;MOJO_REUSE&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;private&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojo::IOLoop::Server] – ?&lt;/li&gt;
&lt;li&gt;
		&lt;strong&gt;MOJO_EXE&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;private&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojolicious::Lite, Mojolicious::Plugin::Config] – executable&lt;/li&gt;
&lt;li&gt;
		&lt;strong&gt;MOJO_APP_LOADER&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;em&gt;private bool&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojolicious::Commands] – ?&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;task-list&quot; style=&quot;color: rgb(0, 0, 0); font-family: &#39;Microsoft YaHei UI&#39;, &#39;Microsoft YaHei&#39;, SimSun, &#39;Segoe UI&#39;, Tahoma, Helvetica, sans-serif, &#39;Microsoft YaHei&#39;, Georgia, Helvetica, Arial, sans-serif, 宋体, PMingLiU, serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 21px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;&quot;&gt;
&lt;li&gt;
		&lt;strong&gt;PLACK_ENV&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojolicious::Commands::detect] – detect PSGI (Plack)&lt;/li&gt;
&lt;li&gt;
		&lt;strong&gt;HARNESS_ACTIVE&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Mojolicious::Commands] – test&lt;/li&gt;
&lt;li&gt;
		&lt;strong&gt;HARNESS_IS_VERBOSE&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;[Test::Mojo] – test&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以通过下面的命令来找出所有的环境变量&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
for f in $(find $(perl -MMojo -e &#39;print map { $INC{$_} =~ s/Mojo.pm//; $INC{$_} } grep /Mojo.pm/, keys %INC&#39;) -name &#39;*.pm&#39; -path &#39;*ojo*&#39;)
do 
  echo $f;
  grep -n &quot;MOJO_&quot; $f;
done

&lt;/pre&gt;
&lt;ul class=&quot;task-list&quot; style=&quot;color: rgb(0, 0, 0); font-family: &#39;Microsoft YaHei UI&#39;, &#39;Microsoft YaHei&#39;, SimSun, &#39;Segoe UI&#39;, Tahoma, Helvetica, sans-serif, &#39;Microsoft YaHei&#39;, Georgia, Helvetica, Arial, sans-serif, 宋体, PMingLiU, serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 21px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;&quot;&gt;
&lt;li&gt;
		
&lt;div style=&quot;color: gray;&quot;&gt;
			&lt;small&gt;来源： &amp;lt;&lt;a href=&quot;https://github.com/kraih/mojo/wiki/%25ENV&quot;&gt;https://github.com/kraih/mojo/wiki/%25ENV&lt;/a&gt;&lt;small&gt;&amp;gt;&lt;/small&gt;&lt;/small&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;

			&lt;!--[syntaxhighlighter]--&gt;
			&lt;!--代码高亮，请勿编辑--&gt;
			

			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shCoreDefault.css&quot;&gt;
			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shThemeDefault.css&quot;&gt;
			
			&lt;!--[/syntaxhighlighter]--&gt;						

</description>
        <pubDate>Fri, 08 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-08-mojolicious-env.html-318d07a98.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-08-mojolicious-env.html-318d07a98.html</guid>
        
        
        <category>php-oa</category>
        
      </item>
    
      <item>
        <title>算法系列：电梯调度</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p style=&quot;text-align: left;&quot;&gt;在像芝加哥，纽约，东京，新加坡，香港等大城市里，每天都会有上百万的人通过电梯离开他们的大楼。但是我们却很少考虑电梯是如何调度来提供服务的，尤其是在人流高峰期，这个时候办公楼里的大多数人都会企图在大约一个小时左右离开。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;关于这方面主题（&lt;a title=&quot;基于乘客等待时间的电梯分配系统&quot; href=&quot;http://www.google.com/patents/US5304752&quot;&gt;基于乘客等待时间的电梯分配系统&lt;/a&gt;）和研究（&lt;a title=&quot;电梯流量模拟&quot; href=&quot;http://sim.sagepub.com/content/61/4/257.short&quot;&gt;电梯流量模拟&lt;/a&gt;）的算法至少有一个专利，并且出现在&lt;a title=&quot;Quaro&quot; href=&quot;http://www.quora.com/Architecture/What-determines-how-many-elevators-a-building-will-have&quot;&gt;Quaro&lt;/a&gt;上。曾经在一次面试中，面试官问我我会如何调度电梯。：&lt;/p&gt;
&lt;p style=&quot;text-align: left; padding-left: 30px;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我很喜欢这个面试问题。我觉得这个问题很有挑战性而且你可以想得尽量深入，但是也应该足够直接以便于你下手，产生某些解决方案。没有绞尽脑汁想一个月来模拟真实场景，在这篇文章中，我会尝试解决一个简化的电梯调度问题，类似于上面的面试问题。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;创造一个可用于现实生活中电梯运行的算法（很显然，这类算法已被申请专利）是有难度的。因此，我会努力解决一些与我面试问题类似的问题，我会做一点轻微变换：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面是对问题的整体描述，但是如果我们将问题分解，该问题包含以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;楼层数量任意&lt;/li&gt;
&lt;li&gt;电梯数量任意&lt;/li&gt;
&lt;li&gt;给定高峰时段&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;一些我们需要考虑但是未说明的变量或者常量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每层人数：100人&lt;/li&gt;
&lt;li&gt;电梯通过一层的时间（不停）：5秒钟&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;我给上面的变量赋值，而且尽管“电梯通过每一层的时间”有可能不是线性的（即电梯需要花时间从停止位置开始加速），但是我们还是这样假设。虽然做这些假设可能会“过度简化”问题，但是我相信这篇文章已经可以满足面试要求而且可以作为一个很好的契入点，来引发更深的思考和讨论。&lt;/p&gt;
&lt;p&gt;注意，我并没有考虑电梯的容量，在这方面我要做个很大胆的假设。我的假设（贯穿整个方案）是每个电梯的容量无限大。很显然这是不正确的，但是一旦我们有了解决方案，我认为增加像这样的声明会容易得多：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;em&gt;           &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我可能会另外写一篇文章放到这个博客里，或者我会通过我的邮件列表来发布。不管哪种情况，我希望有人能想办法自己来解决！&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;这可能不是最佳方案，尽管它有可能效果不错。你如果找到一个更好的方案，请分享！&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;正如上面图片显示的，我会给特定的楼层指定 一个具体的电梯，我称之为区域电梯分配。这个想法在于我们可以获得每层的平均等待时间和每层的平均负载量。&lt;/p&gt;
&lt;p&gt;我的这个特殊方法是基于我对每个电梯形成一个回路（即在电梯循环里经过所有楼层，例如：0-&amp;gt;1-&amp;gt;2-&amp;gt;0)所花费时间的一些观察。我们所有要知道的就是下面这些，来计算一个电梯完成一次回路所需的时间：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;经过一层楼的时间乘以往返中最高楼层数乘以2（上和下），在我们问题中：(5 seconds * &amp;lt;maxFloor&amp;gt; * 2)&lt;/li&gt;

&lt;/ol&gt;
&lt;p&gt;总的往返时间：&lt;/p&gt;
&lt;p&gt;elevatorsCircuitTime  = (5*&amp;lt;maxFloor&amp;gt;*2)+(20*&amp;lt;floorsServiced&amp;gt;)&lt;/p&gt;
&lt;p&gt;使用下面方程计算一个往返中电梯的平均载人数：&lt;/p&gt;
&lt;p&gt;avgElevatorLoad = &amp;lt;elevatorsCircuitTime&amp;gt;*&amp;lt;floorsServiced&amp;gt;*&amp;lt;peoplePerFloor&amp;gt;/&amp;lt;rushHour&amp;gt;&lt;/p&gt;
&lt;p&gt;变量 &lt;em&gt;rushHour&lt;/em&gt;等于完成运输一个高峰时间段所花费时间，&lt;em&gt;floorsServiced&lt;/em&gt;等于电梯所停的楼层数，指给定楼层的人数。因为我们已经计算出了电梯往返时间，所以我们可以利用这个时间和平均负载性能来实现我们的算法。&lt;/p&gt;
&lt;p&gt;我给这个问题的解决方案需要两个数组：&lt;/p&gt;
&lt;p&gt;大楼的表示：大楼数组中每个元素代表每层的人数。数组的每个单元表示一层楼。例如[100 100 100]可以表示一栋四层楼，只有高三层的人需要使用电梯。&lt;/p&gt;
&lt;p&gt;电梯的表示：电梯数组中的每个单元代表该电梯在它回路中所能到达的最高层（为了简化我把0放进第0个单元）。例如，[0,2,3]表示两个电梯，1号电梯（在1号单元）运载乘客从2楼到1楼到0,2号电梯（在2号单元）运载乘客从3楼到0。&lt;/p&gt;
&lt;p&gt;初始时，1号数组（表示大楼）为空，然后每次我给该数组“增加一层”时，我给这一层分配一个电梯。如你所见，这种分配是可以改变的，但是它会遵从一个相似的形式。拥有最小往返的电梯回路会被分配该新的楼层，除非需要涉及性能问题。我增加了一个小方程：&lt;/p&gt;
&lt;p&gt;elevatorCircuitTime + ((elevatorCircuitTime / 100) * elevatorsAvgLoad)&lt;/p&gt;
&lt;p&gt;因为&lt;em&gt;elevatorCircuitTime&lt;/em&gt; 是一个整数，除非往返时间超过100秒（这对电梯来说是一个很长的时间），将乘到这个方程中。我们的问题描述非常模糊，而且考虑到上面的方程，我的解决方案同样地的确有一些模糊之处。同样地，我用来分配楼层给电梯的函数十分任意，但是在负载管理中却十分有效（尽管可能会有更好的方案）。&lt;/p&gt;
&lt;div id=&quot;crayon-53df51847f48f006968125&quot;&gt;

&lt;/div&gt;
&lt;p&gt;注意，每次一个 “elevatorNumber”被选择后，所有在 “elevatorNumber”之上的电梯所到达的最高楼层数加1：&lt;/p&gt;
&lt;p&gt;for i in range(elevatorNumber, len(e)):&lt;/p&gt;
&lt;p&gt;e[i] += 1&lt;/p&gt;
&lt;p&gt;这是因为在被选择之上的每个电梯往返所到达的最高的楼层会加1，但是我们只希望增加一个额外的电梯到被选择的电梯回路中。附加函数很容易确定在被选择回路中的往返时间和平均载客量。&lt;/p&gt;
&lt;p&gt;一旦我们有了增加楼层的函数，我就可以构造函数来循环通过和创建楼层。注意，在本情况中，所有楼层被设定为统一的。这样如果本问题被扩展为每层人数不同的情况，也会相对容易考虑。&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;# Allocate elevators
# Elevator[] represents the starting
# group of stops.
def elevatorAllocation(building, elevatorCount):
    elevator = []
    for i in range(elevatorCount + 1):
        elevator.append(0)
    for i in range(1, floorCount):
        elevator = addFloor(elevator)
    printeleLoop(elevator)&lt;/pre&gt;
&lt;p&gt;以上便是算法分配部分的大体。本算法相对直接而且留有一定量的的改进空间，我将这部分留给大家来解决！&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;如果将算法的各部分拼接起来，再加一些额外的函数来打印数据，创建一个小巧的模拟器，我们就可以获得一个很酷的小程序（大家可以从我的中fork下来或者查看）。&lt;/p&gt;
&lt;p&gt;变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10层楼&lt;/li&gt;
&lt;li&gt;3部电梯&lt;/li&gt;
&lt;li&gt;1个高峰时段&lt;/li&gt;
&lt;li&gt;通过一层耗时5秒&lt;/li&gt;
&lt;li&gt;电梯需要停等时，每次停20秒&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;[0, 4, 7, 9]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;#1电梯：往返用时140秒，平均每次载客19.44人&lt;/li&gt;
&lt;li&gt;#2电梯：往返用时150秒，平均每次载客16.67人&lt;/li&gt;

&lt;/ol&gt;
&lt;p&gt;总用时：65分钟&lt;/p&gt;
&lt;p&gt;电梯往返时，每层的平均人数变化情况：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;如你所见，我的算法提供了一个良好的但不是最佳的方案（在本情况下）。本算法虽然还有很大的改进空间（我将这部分留给你们来挑战），但是它是一个好的开始。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;计算本算法的时间和空间要求会有一点难度，但也不是很难。算法的运行时取决于以下三个因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;k:最大回路，人数&lt;/li&gt;
&lt;li&gt;n:在最大回路中需要服务楼层的起始人数&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;（1）运行时：O(m * (n/k))&lt;/p&gt;
&lt;p&gt;‘n / k’ ：决定了电梯需要的最大往返次数；‘m’ ：这一项是因为在电梯往返过程中需要对每一层进行迭代。在本情况中，我们忽略了初始化大楼数组这一步骤，该数组代表每一层的人数，因为这一项不是运行时(m*(n/k)+ m)的主要项。&lt;/p&gt;
&lt;p&gt;最大空间需求很直接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e:电梯数量&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;（2）内存要求：O(e + f)&lt;/p&gt;
&lt;p&gt;将以上因素整合起来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;k:最大回路，人数&lt;/li&gt;
&lt;li&gt;n:在最大回路中需要服务楼层的起始人数&lt;/li&gt;
&lt;li&gt;m:总的楼层数&lt;/li&gt;
&lt;li&gt;e:电梯数量&lt;/li&gt;

&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;运行时间：O(m * (n / k))&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;我认识到这并不是一个最佳方案，然而它确实解决了问题。我挑战你们来进行评论，从我的&lt;a title=&quot;github&quot; href=&quot;https://github.com/lettergram/ElevatorAllocation&quot;&gt;github&lt;/a&gt;中fork，改进我的代码或者是在自己的文章中写下自己的方案。我认为这是一个很有趣的问题，而且同你们电脑内部的资源分配类似，我还写了篇基本的的文章，如果你们感兴趣，可以来读一读。我同样十分乐意看到一个不同的（希望更好的）方案，所以如果你们想到了更好的方案，一定不要忘记写下来。&lt;/p&gt;
&lt;p&gt;我本来确实打算另写一篇文章来更深地挖掘这个问题，并提供一个更接近现实世界应用的算法，但是我还没有确定日期（可能是几天，几周或者是几个月）。我希望你们喜欢这篇文章而且我也很乐意听听你们的想法，所以不要犹豫是否评论和跟我发邮件，谢谢！&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Fri, 08 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-08-74672-5ee802e49.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-08-74672-5ee802e49.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>关于推荐系统中的特征工程</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;/p&gt;
&lt;p&gt;在多数数据和机器学习的blog里，特征工程 Feature Engineering 都很少被提到。做模型的或者搞Kaggle比赛的人认为这些搞feature工作繁琐又不重要不如多堆几个模型，想入手实际问题的小朋友又不知道怎么提取feature来建模型。我就用个性化推荐系统做个例子，简单说说特征工程在实际的问题里是怎么做。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;特征工程 Feature Engineering 在一篇Kaggle blog 上有很好的定义：&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;基本上说是，用目标问题所在的特定领域知识或者自动化的方法来生成、提取、删减或者组合变化得到特征。这些特征可能是显而易见比如说商品的品牌，也有可能需要复杂的模型计算，比如Facebook上用户A和用户B之间关系的紧密程度（FB使用了一个决策树来生成一个描述这个程度的向量，这个向量决定了他们News Feed推荐内容。）。这篇blog覆盖了一些用领域知识的方法，自动化方法在这里没有提及。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;个性化推荐系统 Personalized recommender system 比其他的机器学习方法更依赖特征工程，所以我拿它来当作问题的背景，结合我之前做过的一个推荐系统里相关经验来说说特征工程具体是个什么东西。&lt;/p&gt;
&lt;p&gt;关于推荐系统和个性化推荐系统，可以参看 wikipedia 具体不赘述，以下的要点也尽量点到为止，否则这篇又成了“收藏了Mark了”但是不会读的冗余长文。以下如果不特别指出，我就用推荐系统作为“个性化商品推荐系统”的简称。简单来说，推荐系统就是你买了商品A，我们给你算出来个推荐列表 B C D E 等等。商业上来说个性化的推荐比一般化的推荐更能吸引顾客点击或购买，所以利用特征功能提取这些“个性化”的特征放到推荐模型里就很重要，比如在我们的推荐系统里，把“品牌”的特征加进去，相对于 baseline 提高了20%左右的nDCG。推荐系统可以是机器学习的模型也可以是基于关联或者统计规则的模型，对后者来说特征对推荐效果的提升占的比重更大。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;这几乎是特征工程里占大半时间的工作了：如何描述个性化并且用变量表示成特征。一般方法就是，想想你就是该商品的目标用户，你会想要什么样的个性化。&lt;/p&gt;
&lt;p&gt;比如说我们做一个女性衣服类的推荐引擎，这个网站卖各种牌子颜色尺寸等。我们列出可能相关的一些特征，然后在实际购买数据里面检查他们是否对购买结果产生影响和关联性。比如，从购买数据里可以看出，女性对衣服的品牌多数有固定偏好，比如我太太就很喜欢LOFT的衣服。这些能对购买产生影响的因素都可以成为特征。&lt;/p&gt;
&lt;p&gt;这部分工作需要很多领域知识，一般需要一组的研究人员讨论，要认真的思考这个特定问题有些什么和别的问题不同的特征，也建议和市场部销售部等有领域知识的专家讨论。经验上来说，这些特征提取的越多越好，并不用担心特征过多，因为推荐系统的数据量都比较大，并且基于一些规则可以很好的筛选特征。&lt;/p&gt;
&lt;p&gt;很多机器学习的方法也可以拿来提取一些比较不容易得到的直接特征，比如说原始数据里面没有人工标记过商品的颜色，这些颜色可以通过图像识别得到。统计规则也可以从销售数据里得到一些特征，比如该商品的流行程度。&lt;/p&gt;
&lt;p&gt;注意，这些特征可能是固定不变的，比如颜色，品牌等。它也有可能随着时间变化，比如商品的销售排名。实际经验来说，时间变化采样的颗粒度要按照实际推荐效果来决定，很可能过去三个月的销售排名对推荐效果来说可以很稳定，也或许昨天的排名对今天的推荐效果比三个月平均更好。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;大家都知道特征可以是“红”“绿”“蓝”这些离散特征，也可以是1.57这样的连续值特征。一个特征具体如何表达，要看在它在具体模型上怎么用。某些特定问题更倾向于离散特征，因为像推荐系统这样数据很大的情况可以利用模型训练这些特征得到比连续值表达更好的效果。&lt;/p&gt;
&lt;p&gt;比如说，商品的流行度可以是一个特征，因为对于某些流行的商品大家都抢着买，喜欢跟风买热门商品这一特性可以作为推荐的特征。我们可以按照销量排名然后归一化得到每个商品的流行度值，但是直接用这个连续值会有一些问题，比如说用户甲买了流行度分数为 0.75 0.5 0.2 0.1的四个商品，用户乙买了流行度为0.7的一个商品，他们两个怎么比？&lt;/p&gt;
&lt;p&gt;如果还记得算法书上说的，定义几个桶buckets，把流行度分到这几个buckets里面，可以解决这个问题。比如定义三个桶：很流行1-0。95，较流行0.95-0.75，普通0.75-0.4。这样用户甲的特征就是［0，1，1］用户乙的特征就是［0，1，0］，这样你的推荐模型就可以做一些对比他们俩的相似度或者其他推荐计算了。&lt;/p&gt;
&lt;p&gt;顺道提一下就是，为什么在这里直接把0.4之后的丢掉了以及为什么取了三个buckets。这个要看具体问题里面具体特征的用处。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果这个模型是学习训练出来的，可以用一些feature selection的办法自动去掉一些不需要的bucket。对于那些不是学习出来的模型比如是简单的相似性模型，按照实际推荐效果思考一下用户的行为特征，需要丢弃一些特征。我之前包含过0.4以下的部分但是实际测试的时候发现推荐结果会恶化，也就是说对于我们的问题，用户喜欢跟风买热门的，但是不喜欢一直买冷门的。&lt;/li&gt;

&lt;/ol&gt;
&lt;p&gt;一个比较高级的例子是 Facebook 在他们的 Machine Learning meetup 上提到的推荐News feed的特征。每个用户对于其他用户的 news 的点赞和留言以及其他的动作都会得到一个评价值，这是一系列的连续值，直接拿来训练模型效果不好。他们的做法是做了一个简单的决策树，训练的输入是这些连续值，训练目标是看对于用户A是否应该显示用户B的 news 。这个决策树显然很粗糙，但是树的每个叶子节点可以成为一个特征，那么这些叶子节点就可以当作用户A的特征向量，拿来训练其他模型比如Logistic Regression，效果不错。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;直接特征 Extacted Feature 就是比如商品的品牌，间接特征 Derived Feature 可以是从直接特征或者各种数据组合里计算推导出来的。&lt;/p&gt;
&lt;p&gt;间接特征的一个例子还是品牌特征，拿女性服饰类举例。比如我太太很喜欢LOFT的衣服，但如果一个推荐引擎使劲给推荐LOFT牌的衣服，她也会很烦。所以品牌并不完全是一个直接特征，它可以有一些变化。比如从购买数据里面看到，购买了LOFT牌衣服的，有20%也购买了J Crew牌，15%也购买了Ann Taylor牌。所以 LOFT 这个特征应该变成一个向量 [LOFT:1, J_Crew:0.2, Ann_Taylor:0.15, … ]。实际效果上它提高了推荐的多样性，在多个测试函数中都有不错的提升。&lt;/p&gt;
&lt;p&gt;间接特征另外一个高级一些的例子就是用户职业。绝大多数用户都不会填自己的职业等个人相关信息，主要是因为隐私或者就是因为麻烦。从用户的购买记录和浏览记录里面，我们可以定义几个预设的职业类型然后用户的职业预测到这几个类型里。比如用户买过一些转换插头和充电器还有旅行电脑包，所以他可能常外出旅行，所以以后推荐的商品可能是轻便携带；又比如用户买过母婴用品就知道该用户可能自己是妈妈或者家里有小孩。&lt;/p&gt;
&lt;p&gt;关于间接特征我印象最深的是美国亚马逊上的性别特征。我有一次给我太太买了给女生修眉毛的剃刀，亚马逊的推荐内容就立刻从推荐相机鼠标键盘等男性特征较强的变成了推荐时尚杂志这种有女性特征的东西。&lt;/p&gt;
&lt;p&gt;间接特征的提取可以用到很多机器学习的技术，比如根据商品的文本描述提取它的文本向量，以这些文本向量为特征训练多分类的分类器，可以把商品分类对应到各种用户职业特征上。它也可以利用人工标记的类型列表，比如时尚杂志的女性特征。它也可以利用一些统计规则，比如单反相机的购买记录里，男性的比例会高于女性，所以单反相机的性别特征向量可以是购买人数性别的比例值。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;这部分的工作就看起来比较高级一些，比较贴近机器学习的研究工作。一般来说是两个方法：基于领域知识的手工选择以及自动选择方法。&lt;/p&gt;
&lt;p&gt;对于关联规则和统计规则的模型来说，手工选择的比重要大一些。比如我们已有了baseline的特征向量，现在加进去品牌偏好，给一定的权值，看评价函数输出的结果是否增强了推荐效果。对于学习的模型来说，可以通过模型自动选择每个特征的权值，按照和效果的关联来调整模型的参数。这里需要提醒的是，这个选择过程不是单增单减，很可能遇到两个特征组合A＋B效果很好，A＋C效果也很好，但是A＋B＋C效果就呵呵了。个人建议在关联和统计规则里面把最重要的几个特征放进去然后优化关于这几个特征的规则，把复杂的特征选择留给学习出来的模型。&lt;/p&gt;
&lt;p&gt;自动选择方法就很多了，用的也是常用的各种自动选择方法，什么forward selection啊backward selection啊各种regularization等等，全写在这里篇幅就太长，推荐看看一些其他关于机器学习里 feature selection 的blog和综述。值得提醒的是选择方法和评价函数的关联。推荐系统的评价函数一般不是AUC曲线等按照error计算的函数，也就是说推荐的效果并不是按照“精准”来衡量，要遵循特定问题需要的评价函数比如nDCG，所以以error matrix为标准的一些方法可能效果会不好。比如说用PCA降低特征的维度很可能把那些对推荐效果很重要的长尾特征给舍弃了。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;这部分工作看起来就比较碉堡，可发挥的空间就看你的想像力和经验了。这里的组合变化远不限于把已有的特征加减乘除（比如Kernel Tricks之类），我举个比较有想像力的例子。&lt;/p&gt;
&lt;p&gt;现在市面上社交网络里面“你可能认识的人”的推荐算法几乎都是基于补全网络的办法，这样推荐的人可能只是单纯的补充和完善朋友圈，推荐的人可能很无趣，这样会导致推荐效果不好让用户失去接受推荐的兴趣。目测新浪微博用的还是这种补全的方法，因为整天向我推荐丁一晨李开复姚晨等人或者最近关注的人的共同关注人，所以推荐的人很无趣几乎都不会点关注。&lt;/p&gt;
&lt;p&gt;斯坦福小帅哥教授 Jure Leskovec 在2010年的一篇文章“Predicting Positive and Negative Links in Online Social Networks”说到过一种基于用户反馈的推荐“你可能认识的人”的推荐算法，他把邻近三人之间的三角关系总共16种正负反馈的组合当作特征向量用来表达用户A和被推荐目标用户C之间的正负反馈，在图里去掉一些已知正负反馈的边来构建训练数据，用简单的Logistic Regression训练模型达到了不错的效果。可以谷歌找到这篇文章的幻灯片，里面有图示讲解。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;这篇文章就简单提及一些特征工程的常用方法，说的是手工提取特征，从这些入手可以深入研究研究具体问题的具体做法，这是一个很细致的工作可以多钻研钻研。这里面没有说到自动提取方法比如深度学习和卷积网络等等，也没说到推荐系统的其他方面比如大规模用户聚类。构建一个推荐系统需要涉及很多东西，绝对不是GraphLab或者Mahout跑个协同过滤就能上马的，这里面特征工程是很重要的一部分工作，在很多其他数据和机器学习的工作里面特征工程也差不多是从根本上改变模型效果的重要办法之一。大家在欢乐调参的过程中不妨考虑考虑搞搞特征。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Wed, 06 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-06-74951-df59c114f.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-06-74951-df59c114f.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>算法系列：求幂算法</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;h2&gt;1.快速求幂算法&lt;/h2&gt;
&lt;p&gt;在这篇文章我会展示怎样通过求一个数的幂的基本思路，来引导我们发现一些抽象的东西比如半群和含幺半群。&lt;/p&gt;
&lt;p&gt;有一个很有名的对一个数求幂的算法,也就是说,求一个数x的n次方或者这样简单表示：&lt;strong&gt;x^n&lt;/strong&gt;。&lt;a href=&quot;http://en.wikipedia.org/wiki/Donald_Knuth&quot;&gt;Donald Knuth&lt;/a&gt;在&lt;a href=&quot;http://www-cs-faculty.stanford.edu/~uno/taocp.html&quot;&gt;TAOCP&lt;/a&gt;的中提出这个算法。&lt;/p&gt;
&lt;p&gt;这个算法很简单的实现就是x乘以自己n次，但是在这里当然会提供一种比这种方式更快的算法。正在谈论的算法通常被称作&lt;strong&gt;二进制法(binary method)&lt;/strong&gt;、&lt;strong&gt;梯度求幂(the powering ladder)&lt;/strong&gt;或者&lt;/p&gt;
&lt;p&gt;假设我们想计算&lt;strong&gt;2^23&lt;/strong&gt;，在这里&lt;strong&gt;x = 2&lt;/strong&gt;，&lt;strong&gt;n = 23&lt;/strong&gt;，这个算法首先把23表示成&lt;strong&gt;二进制&lt;/strong&gt;的形式&lt;strong&gt;10111&lt;/strong&gt;。扫描这个&lt;strong&gt;二进制数(10111)&lt;/strong&gt;每当遇到&lt;strong&gt;0&lt;/strong&gt;或&lt;strong&gt;1&lt;/strong&gt;，则相应的&lt;strong&gt;求x的平方&lt;/strong&gt;或者&lt;/p&gt;
&lt;p&gt;这个方法有一个问题就是它扫描二进制表示的数是从左到右进行的，但是对于计算机通常以相反的方向能够更容易实现，因此提出一个替代的算法。&lt;/p&gt;
&lt;p&gt;一个出自&lt;a href=&quot;http://www-cs-faculty.stanford.edu/~uno/taocp.html&quot;&gt;TAOCP&lt;/a&gt;的&lt;strong&gt;4.63节&lt;/strong&gt;的的简单实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: php; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;    function power1($x, $n) {
        $y = 1;

        while (true) {
            $t = $n % 2;
            $n = floor($n/2);

            if ($t == 1) {
                $y = $y * $x;
            }

            if ($n == 0) {
                break;
            }

            $x = $x * $x;
        }

        return $y;
    }&lt;/pre&gt;
&lt;p&gt;这个函数需要两个整数，&lt;strong&gt;$x&lt;/strong&gt;和&lt;strong&gt;$n&lt;/strong&gt;然后返回&lt;strong&gt;$x&lt;/strong&gt;的次幂作为结果。&lt;/p&gt;
&lt;p&gt;首先创建一个辅助变量&lt;strong&gt;$y&lt;/strong&gt;并且初始化为，把它作为乘法的主体。&lt;/p&gt;
&lt;p&gt;然后函数在每次循环迭代的时候扫描&lt;code&gt;$n&lt;/code&gt;的二进制表示的数。如果遇到&lt;strong&gt;1&lt;/strong&gt;则&lt;strong&gt;$y&lt;/strong&gt;乘上&lt;strong&gt;$x&lt;/strong&gt;，然后赋值回&lt;strong&gt;$y&lt;/strong&gt;。每次循环都会计算&lt;strong&gt;$x&lt;/strong&gt;的平方，并且把它赋值回。&lt;/p&gt;
&lt;p&gt;遇到&lt;strong&gt;1&lt;/strong&gt;意味着当前&lt;strong&gt;$n&lt;/strong&gt;的值不能被&lt;strong&gt;2&lt;/strong&gt;整除，换句话说就是，。&lt;/p&gt;
&lt;p&gt;同样的每次循环&lt;strong&gt;$n&lt;/strong&gt;都会折半，然后向下取整得到结果。当&lt;strong&gt;$n&lt;/strong&gt;等于&lt;strong&gt;0&lt;/strong&gt;的时候，我们结束循环并且返回的值。&lt;/p&gt;
&lt;p&gt;函数能够这样被调用:&lt;/p&gt;
&lt;pre class=&quot;brush: php; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;    1024 == power1(2, 10);
    =&amp;gt; true&lt;/pre&gt;
&lt;p&gt;我能想象你现在就像这个gif中的男孩。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;尽管这个算法看起来像一个 “呵呵，真有意思” 的故事，实际上当它用来计算非常的大数时时十分高效的。例如有很多的素数测试算法都是依赖这个算法的不同变式。&lt;/p&gt;
&lt;h2&gt;2.增加一些抽象&lt;/h2&gt;
&lt;p&gt;到目前为止还没有什么意想不到的事情发生，但是如果我们注意到求一个数的幂实际上和一个数&lt;strong&gt;自乘&lt;/strong&gt;多次是等价的，我们也可以看到乘法实际上等价于&lt;strong&gt;自加&lt;/strong&gt;多次。举个例子&lt;code&gt;2 * 5&lt;/code&gt;能够像这样被计算。&lt;/p&gt;
&lt;p&gt;我们能把这个算法转换成一种更普遍的形式使它能同样应用在乘法还有加法上吗?当然可以，我们仅仅需要改变几样东西。&lt;/p&gt;
&lt;p&gt;在当前实现中，我们创建&lt;strong&gt;$y&lt;/strong&gt;作为乘法的主体，并设置为&lt;strong&gt;1&lt;/strong&gt;。如果我们想把算法用在加法上，我们需要把&lt;strong&gt;$y&lt;/strong&gt;设置为。因此我们仅需要改变函数的单位元素的值。&lt;/p&gt;
&lt;p&gt;第二步要提供一个函数给我们的算法，它能够作乘法或者加法。为了实现这个目的我们会传递一个担当&lt;strong&gt;二元运算&lt;/strong&gt;的函数。例如：一个需要两个参数的函数。这个函数需要遵循以下的规则。必须满足：。还要求返回结果的类型必须和两个输入参数的类型一致。&lt;/p&gt;
&lt;p&gt;幸运的是&lt;strong&gt;加法&lt;/strong&gt;和&lt;strong&gt;乘法&lt;/strong&gt;都满足&lt;a href=&quot;http://zh.wikipedia.org/zh/%E7%BB%93%E5%90%88%E5%BE%8B&quot;&gt;结合律&lt;/a&gt;，因此我们能够仅在一个函数中包含他们然后把它传递给我们的算法。&lt;/p&gt;
&lt;p&gt;这里是这个算法新的实现：&lt;/p&gt;
&lt;pre class=&quot;brush: php; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;  function power2($x, $n, $id, $f) {
        $y = $id;

        while (true) {
            $t = $n % 2;
            $n = floor($n/2);

            if ($t == 1) {
                $y = $f($y, $x);
            }

            if ($n == 0) {
                break;
            }

            $x = $f($x, $x);
        }

        return $y;
    }&lt;/pre&gt;
&lt;p&gt;我们能够像这样调用它:&lt;/p&gt;
&lt;pre class=&quot;brush: php; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;   1024 == power2(2, 10, 1, function ($a, $b) { return $a * $b; });
    =&amp;gt; true&lt;/pre&gt;
&lt;p&gt;记住传递进我们算法的运算必须是可结合的,举个例子,减法不能被用在这里由于&lt;code&gt;10 - ( 5 - 3) = 8&lt;/code&gt;但是。&lt;/p&gt;
&lt;h2&gt;3.附加更抽象的概念&lt;/h2&gt;
&lt;p&gt;从数学的角度说这个算法能够在任何满足结合律的代数结构中有效(在这个案例中就是整数的乘法和加法)，换言之，它能够用在&lt;strong&gt;半群&lt;/strong&gt;中，引用一本关于的书。&lt;/p&gt;
&lt;pre&gt;一个半群的集合S含有一个可结合的运算 · ；
也就是说,x·(y · z) = (x · y) · z 对于所有的x, y, z ∈ S都成立。&lt;/pre&gt;
&lt;p&gt;同样，这个集合必须有一个&lt;code&gt;单位元素&lt;/code&gt;使得它有一个:&lt;/p&gt;
&lt;pre&gt;一个独异点是一个集合M含有一个可结合运算·；伴有一个单位元素e∈ M满足e·x = x· e =  x对于所有x∈ M都成立。&lt;/pre&gt;
&lt;p&gt;在这个预设条件下，有什么我们经常用在编程上的结构能使用这个算法的呢？如果你是一个web开发者，你不需要费大力气去获取strings。对于字符串（strings），使用&lt;strong&gt;string append&lt;/strong&gt;作为二元操作而且&lt;strong&gt;空字符串(empty string)&lt;/strong&gt;作为单位元素同样会带来类似的结果。如果一个字符串想重复次,我们创建下面的函数:&lt;/p&gt;
&lt;pre class=&quot;brush: php; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;    function repeat($s, $n) {
        return power2($s, $n, &quot;&quot;, function ($a, $b) {
                   return $a . $b;
               });
    }&lt;/pre&gt;
&lt;p&gt;测试:&lt;/p&gt;
&lt;pre class=&quot;brush: php; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;    &quot;aaaaaaaaaa&quot; == repeat(&quot;a&quot;, 10);
    =&amp;gt; true&lt;/pre&gt;
&lt;p&gt;现在考虑一下&lt;strong&gt;数组(arrays)&lt;/strong&gt;(或者其它语言称为&lt;strong&gt;列表(lists)&lt;/strong&gt;)。我们想把一个数组复制n次。在这里空数组是单位元素，对PHP来说会用来作为二元操作。&lt;/p&gt;
&lt;pre class=&quot;brush: php; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;    function repeat_el($el, $n) {
        return power2(array($el), $n, array(), function ($a, $b) {
                return array_merge($a, $b);
               });
    }&lt;/pre&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;pre class=&quot;brush: php; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;    $arr = repeat_el(&quot;a&quot;, 10);
    10 == count($arr);
    =&amp;gt; true&lt;/pre&gt;
&lt;p&gt;从上不难看出,像求一个数幂运算的这样简单事情给我们带来一个优雅的算法,它能被运用一些事情上,像重复的东西还有数组里的元素。&lt;/p&gt;
&lt;h2&gt;4.延伸阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这里的快速求幂算法是基于&lt;a href=&quot;http://www-cs-faculty.stanford.edu/~uno/taocp.html&quot;&gt;TAOCP&lt;/a&gt;中，&lt;code&gt;卷二&lt;/code&gt;的。&lt;/li&gt;
&lt;li&gt;所有的关于工作原理的解答都可以在&lt;strong&gt;TAOCP&lt;/strong&gt;或者在这本书&lt;a href=&quot;http://shoup.net/ntb/&quot;&gt;《A Computational Introduction to Number Theory and Algebra》&lt;/a&gt;上找到,这本书的PDF版本在作者的主页上可以免费下载。浏览章节：&lt;/li&gt;
&lt;li&gt;如果你想学习这个算法的一些用法或者想知道更多这个算法背后的理论,请查阅这本叫做&lt;a href=&quot;http://www.amazon.com/Elements-Programming-Alexander-Stepanov/dp/032163537X&quot;&gt;《Elements of Programming》&lt;/a&gt;的书。这本书非常了不起，它定义了不同类型的函数和使用类型系统确定函数是否是可结合的，二元的等等。作者是&lt;code&gt;C++STL&lt;/code&gt;的设计者,所以这本书的内容可能会比较,然后它能够直接应用在面向对象编程(OOP)。&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;半群&lt;/strong&gt; 和 &lt;strong&gt;含幺半群&lt;/strong&gt;的引用来自于&lt;a href=&quot;http://www.amazon.com/Handbook-Computational-Discrete-Mathematics-Applications/dp/1584883723/&quot;&gt;《Handbook of Computational Group Theory.》&lt;/a&gt;。一本非常有趣的书，如果你对有兴趣的话。&lt;/li&gt;
&lt;li&gt;如果你想学习更多有关&lt;code&gt;幺半群&lt;/code&gt;还有它们的实现。&lt;a href=&quot;http://learnyouahaskell.com/&quot;&gt;《Learn You a Haskell》&lt;/a&gt;里的有个&lt;strong&gt;章节&lt;/strong&gt;非常有趣的介绍它:&lt;/li&gt;

&lt;/ul&gt;
&lt;h2&gt;5.你是想说Haskell?&lt;/h2&gt;
&lt;p&gt;既然我已经提及一本&lt;strong&gt;Haskell&lt;/strong&gt;的书，这里有一个Haskell实现的求幂算法，使用的递归算法来自于这本书&lt;/p&gt;
&lt;pre class=&quot;brush: perl; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;    power :: (Eq a, Integral b) =&amp;gt; (a -&amp;gt; a -&amp;gt; a) -&amp;gt; a -&amp;gt; b -&amp;gt; a
    power f a n
      | n == 1 = a
      | even n = square a (n `div` 2)
      | otherwise = f a (square a ((n-1) `div` 2))
      where
        square a&#39; n&#39; = f (power f a&#39; n&#39;) (power f a&#39; n&#39;)&lt;/pre&gt;
&lt;p&gt;几个函数调用的结果：&lt;/p&gt;
&lt;pre class=&quot;brush: perl; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;  *Main&amp;gt; :load pow.hs
    [1 of 1] Compiling Main             ( pow.hs, interpreted )
    Ok, modules loaded: Main.
    *Main&amp;gt; power (*) 2 10
    1024
    *Main&amp;gt; power (+) 2 10
    20
    *Main&amp;gt; power (++) &quot;a&quot; 10
    &quot;aaaaaaaaaa&quot;&lt;/pre&gt;
&lt;p&gt;正如你所看到的,这个函数调用一个function&lt;strong&gt;(a-&amp;gt;a-&amp;gt;a)&lt;/strong&gt;，例子中，对于&lt;strong&gt;integers&lt;/strong&gt;使用&lt;code&gt;*&lt;/code&gt;或者&lt;code&gt;+&lt;/code&gt;,对于&lt;strong&gt;lists&lt;/strong&gt;使用。&lt;/p&gt;
&lt;p&gt;我希望你会觉得这边文章有趣或者激起你学习与编程有关的数学的欲望。因为我认为我们掌握得越多数学方面的知识，我们就能更好的使用抽象的东西。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Wed, 06 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-06-74468-5d8d42a9b.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-06-74468-5d8d42a9b.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>使用 Mojo::UserAgent 的 Get 方法来模拟 Head 方法</title>
        <description>

							&lt;p&gt;在我们做一些测试, 接口和监控的服务时, 我们常常需要发送 Get 之类的请求, 去取得一些信息. 比如很常见的一个需求. 在监控的时候, 我们需要记录解析时间, header 取得的时间, 首字节的时间. 然后只取前 2M 断开之类, 各种小需求.&lt;/p&gt;
&lt;p&gt;在这, 我来演示一下怎么用 Mojo::UserAgent 来实现其中一些需求.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
my $ua = Mojo::UserAgent-&amp;gt;new;

my $tx = $ua-&amp;gt;build_tx(GET =&amp;gt; &#39;http://www.php-oa.com&#39;);

$tx-&amp;gt;res-&amp;gt;content-&amp;gt;on(body =&amp;gt;sub {
    my $single = shift;
    my $length = $single-&amp;gt;headers-&amp;gt;content_length || 0;
    my $stat = $tx-&amp;gt;client_close; 
});
$ua-&amp;gt;start($tx);

Mojo::IOLoop-&amp;gt;start unless Mojo::IOLoop-&amp;gt;is_running;

&lt;/pre&gt;
&lt;p&gt;象上面这样, 使得原本的 Get 请求, 基本变得象 Head 一样的请求.因为有些服务就不支持 Head . 在这个地方, 也可以用来做首字节, 和 2M 以后立即断开之类来进行速度测试.&lt;/p&gt;
&lt;p&gt;因为上面的 content 的写事件会触发 body , 这个 body 的事件是在 header 解析之后,  body 取得之前的事件. 所以可以在这做任何事情.&lt;/p&gt;
&lt;p&gt;注意这个地方, 还是一样可以使用回调的, $ua-&amp;gt;start($tx) , 也可以是 $ua-&amp;gt;start($tx, sub {xxoo})&lt;/p&gt;

			&lt;!--[syntaxhighlighter]--&gt;
			&lt;!--代码高亮，请勿编辑--&gt;
			

			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shCoreDefault.css&quot;&gt;
			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shThemeDefault.css&quot;&gt;
			
			&lt;!--[/syntaxhighlighter]--&gt;						

</description>
        <pubDate>Wed, 06 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-06-%25e4%25bd%25bf%25e7%2594%25a8-mojo-usergent-%25e7%259a%2584-get-%25e6%2596%25b9%25e6%25b3%2595%25e6%259d%25a5%25e6%25a8%25a1%25e6%258b%259f-head-%25e6%2596%25b9%25e6%25b3%2595.html-c5168ea10.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-06-%25e4%25bd%25bf%25e7%2594%25a8-mojo-usergent-%25e7%259a%2584-get-%25e6%2596%25b9%25e6%25b3%2595%25e6%259d%25a5%25e6%25a8%25a1%25e6%258b%259f-head-%25e6%2596%25b9%25e6%25b3%2595.html-c5168ea10.html</guid>
        
        
        <category>php-oa</category>
        
      </item>
    
      <item>
        <title>我是如何绕过Google和Facebook等大站的两步验证的</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;我记得在两年前，两步验证(2-Factor-Authentication, 2FA)变得非常普及并且在各大主流网站(Google, Facebook, Yahoo 等)广泛应用。那时我十六岁，天真的我想不通为什么这么天才的想法之前没有人想到过。在那时，我认为2FA就是一个可以保护自己的金色盾牌，它可以抵御那些最复杂的网络欺诈。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当两步验证依旧是你所使用的主要应用的金色盾牌时，我开始列出以下文档—我是如何用一系列的方法来绕过Google, Facebook, Yahoo, LinkedIn的两步验证以及几乎任何向语音信箱发送两步验证标记的服务的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注：超过959万的澳大利亚Optus公司的手机用户会受到我下面所说的语音信箱的攻击。这959万使用两步验证的用户中任何一人，都很有可能会受到我下文所说的绕过两步验证的攻击。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;两步验证的分析，概念以及流程&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;两步验证的分析&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;当将两步验证看做一个整体时，从一个攻击者的角度看来仅仅有这些东西。在我第一次对两步验证的分析中，我经常在想是否可能进行以下的攻击:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;暴力搜索两步验证的pin码（有一些服务，比如苹果，只有四位的pin，并且几乎没有任何频率的限制）。&lt;/li&gt;
&lt;li&gt;发现pin生成的漏洞。&lt;/li&gt;

&lt;/ul&gt;
&lt;p align=&quot;left&quot;&gt;以上技术都是攻击的有效手段，但是通常没有人会使用，因为这些手段太老套了，已经有了相应的防御。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在我经历过这个初步测试的阶段后，我列举了更多的东西，意识到一定有一个弱点能够让我们完全避开两步验证。这个弱点就是语音信箱。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;有些读者可能会知道为什么语音信箱容易出问题，因为他们可能听说过2009年英国某些名人的语音信箱被黑客攻击的丑闻。他们进入语音信箱的方式相当让人担心，分为以下几种：默认的语音信箱PIN，未设置语音信箱PIN以及拨打自己电话的方法—都在中写到过。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在另一起类似的事故中，Cloudflare公司的CEO也是通过语音信箱绕过两步验证的受害者之一。然而，在这一次事件中，攻击更为复杂，要求攻击者设法使得AT&amp;amp;T(美国电话电报公司)的员工将Matthew Prince的语音信箱重定向到一个假的语音信箱处。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;­那些我用来登录到语音信箱账号（仅限于那些已经授权的用于测试的账号）的方法在很久以前我就写过了，并且执行起来并不难。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;虽然进入语音信箱的方法受到越来越多的关注，但是这一方法并不适应部分国家的大多数网络。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;概念及攻击流程&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;作为一个攻击者，你需要知道四件事情，才能进入被攻击者被两步验证保护的账号中。它们包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被攻击者的用户名/邮箱和密码。&lt;/li&gt;
&lt;li&gt;被攻击者关联到两步验证服务的手机号。&lt;/li&gt;
&lt;li&gt;一个手机号欺诈服务。&lt;/li&gt;

&lt;/ul&gt;
&lt;p align=&quot;left&quot;&gt;在现实中，作为一名富有经验的攻击者，以上四点要求并不难达到。获取用户名和密码可以通过任何传统的方法做到，获取关联的手机号码在现在也并不困难。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;手机号欺诈服务，比如（可以显示虚假的手机号码的服务）仅仅花费十美元就可以多次使用并且可以获得手机语音信箱的端点。另外，如果想要避免Spoofcard的登记，他们可以雇佣VoIP服务，打电话人的ID可以是虚假的，作用是一样的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;li&gt;攻击者向被攻击者的手机号拨打电话（只需要20-30秒即可）&lt;/li&gt;

&lt;/ul&gt;
&lt;p align=&quot;left&quot;&gt;由于被攻击者正在跟攻击者通话，两步验证的电话服务就会立即将验证码发送到被攻击者的语音信箱里。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这是第一个漏洞。我是这样认为的，大家或许不同意，但是我想不出别的使验证码发送到语音信箱的方法了。由于这种方法的易用性，这样做的时候有一点危险。根据过去几年的语音信箱黑客的情况来看，通过向语音信箱发送pin，看起来好像不用管下面我将要告诉你们的第二个漏洞，直接就可以绕过两步验证。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当被攻击者没有接两步验证的电话时，两步验证的pin码也会被发送到语音信箱中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;绕过两步验证的第二阶段实际上依赖所谓的语音信箱窃听/电话窃听。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;上图是应用于澳大利亚的和我的整个第二部分的方法，它只是和上述移动服务运营商相对应（在未发现其他的运营商之前）。在图中，我展示了我认为容易受到语音信箱攻击的网络以及其他部分或者完全不易攻击的网络。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;另外，我必须指出，英国的Three 和EE网络也很容易通过电子欺骗受到语音信箱攻击。这一点最近被英国的证实。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Telco公司的自动数字识别(ANI)或者是Caller ID是用来判断呼叫者是否是语音信箱账户的合法拥有者。如果ANI或Caller ID和账户持有者相匹配，在进入语音信箱账户时系统就不会要求输入pin码。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在美国，可以不通过Caller ID来请求pin码，然而在澳大利亚，据我所知除非服务提供商从他们的服务上来解决问题，否则没有可以预防语音信箱受到欺诈攻击的办法。&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;
&lt;li&gt;通过网络语音电话业务运营商或者专门的欺诈服务提供商获得ANI/Caller ID欺诈服务。&lt;/li&gt;
&lt;li&gt;在上文列出的所有的所有易受攻击的服务中，输入目标号码为&lt;/li&gt;
&lt;li&gt;输入被攻击者的手机号作为要显示的Caller ID.&lt;/li&gt;
&lt;li&gt;如果你在使用SpoofCard（可以显示虚假的手机号码的服务），你会收到一个手机号和一个访问码。拨打这个手机号码并输入访问码。&lt;/li&gt;
&lt;li&gt;你会连接到被攻击者的语音信箱服务提供商的终端上。在这里输入被攻击者的手机号并按#键、&lt;/li&gt;

&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;为什么目标号码是&lt;b&gt;+610411000321&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;澳大利亚有三大主要的移动业务运营商：Telstra, Optus和Vodafone。&lt;/li&gt;
&lt;li&gt; Telstra, Optus和Vodafone可以转售他们的服务，因此业务可以拓展到其他的提供商处。&lt;/li&gt;
&lt;li&gt;所有的中间商用和Optus相同的主要服务（例如账号信息热线，语音信箱服务等）。&lt;/li&gt;
&lt;li&gt;因此，如果攻击者能够开发任何三个电信提供商其中的任何一个服务的话，每个下属的服务提供商也很有可能受影响。&lt;/li&gt;
&lt;li&gt; Optus呼叫语音信箱的主号码是“321”。&lt;/li&gt;
&lt;li&gt;然而，当进行欺诈攻击时，由于我们不能呼叫“321”我们需要远程号码去呼叫。&lt;/li&gt;

&lt;/ul&gt;
&lt;p align=&quot;left&quot;&gt;&lt;b&gt;&lt;/b&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;注意：Optus语音信箱中任何易被攻击的端点都已经被固定了,包括我曾经用来绕过他们的端点。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我说过Telstra, Virgin和 Vodafone是部分易受攻击或不易受到攻击的，因为我并没有机会彻底测试攻击语音信箱的能力。然而我的确知道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;b&gt;&lt;/b&gt;不管是什么Caller ID或者是ANI都要求一个pin码，因此对于我上文描述的破解来说是安全的。&lt;/li&gt;
&lt;li&gt;
&lt;b&gt;&lt;/b&gt;在未设置pin码的情况下，如果我通过欺诈服务冒充你的号码拨打，会让我设置pin码或者是进入你的语音信箱。&lt;/li&gt;

&lt;/ul&gt;
&lt;p align=&quot;left&quot;&gt;你如果不确定你现在使用的是哪种网络，或者你想检查一下自己是否是易受攻击的，我的一个朋友（(）写了一段程序通过你的手机号来确定你的在澳大利亚的移动网络。你只需输入你的手机号然后点击check就可以了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;你可以在上找到检测移动网络的代码。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;向谷歌安全团队揭露&lt;/h3&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;谷歌是两步验证的早期使用者，它的全部服务都使用了两步验证。如果你所选择的电话公司在语音信箱安全方面管理非常严格的话，谷歌现在使用的两步验证系统还是非常安全的，但是谷歌所提供的两步验证可以绕过的概率其实是非常高的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;假设你现在已经阅读了上文中提到的破解步骤，使我能够绕过两步验证的Google, Facebook, Yahoo 等其他主要的支持两步验证服务的漏洞是当你不在线时，两步验证会发送两步验证标记到你的语音信箱中。单看这一点，这是个很小的问题，但是站在安全的角度上来看，这个漏洞是非常明显的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;语音信箱并未实现全球统一化，它的安全性也是一样的。每个电话公司都运行他们自己的语音信箱管理服务。&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;
&lt;li&gt;语音信箱服务的安全并不由谷歌管理而是由电话商管理。&lt;/li&gt;

&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;如果你想看我和谷歌对话的全部邮件记录，你可以点击这里。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注意：通过这个绕过两步验证的方法并不能不动声色地来盗取谷歌账户，因为很有可能一旦登录到支持两步验证的谷歌账户中就会自动向用户发送信息。在前面的步骤中你必须选择拨打电话的方式然后继续破解。这样很可能会引起受害者的警觉。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;他们对我最初的破解的回复如下：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;虽然我知道语音信箱系统不够安全这是电话商的错误，我仍然觉得谷歌把两步验证标记发送到语音信箱这一做法有缺陷，这是个很危险的做法，并且大部分2FA提供商都不这样做。因此，我作出了以下回复：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;ul style=&quot;padding-left: 30px;&quot;&gt;
&lt;li style=&quot;padding-left: 30px;&quot;&gt;
&lt;li style=&quot;padding-left: 30px;&quot;&gt;

&lt;/ul&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;谷歌很快回复道：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;假设这个问题不能修正，因此目前解决这个问题的最好方法就是禁用通过短信或者电话的两步验证，启用谷歌的两步验证，如果你绑定到手机就可能容易受到攻击。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这个设置方法可以在下面找到：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;另外，当不确定时，可以通过下面的方法通过两步验证来还原谷歌账户：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;https://support.google.com/accounts/answer/183728&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我自己还原账户时失败了，我的朋友也是一样的。然而一段时间以前，成功地还原了账户。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;状态: &lt;b&gt;&lt;/b&gt;&lt;b&gt;仍然易受攻击&lt;/b&gt;&lt;b&gt;/&lt;/b&gt;&lt;b&gt;并不会修复&lt;/b&gt; | 揭露时间: &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;———————————————————————————————————————————————————–&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;向Facebook安全团队揭露&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;因为我的一个失误，在这次揭露之前我刚刚意识到可以用攻击谷歌的类似方法来攻击Facebook。Facebook称他们的两步验证是一个类似于登录通知的特点，但是有额外的安全步骤。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;用和上述步骤相同的流程来破解，同样可以绕过Facebook的两步验证。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 让Facebook发送验证码到语音信箱的步骤如下：&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;
&lt;li&gt;登录账户。&lt;/li&gt;
&lt;li&gt; 点击“通过短信发送验证码”。&lt;/li&gt;
&lt;li&gt;会显示出拨打电话的选项。&lt;/li&gt;
&lt;li&gt;通过拨打被攻击者电话或其他方法保证被攻击者处于通话状态。&lt;/li&gt;
&lt;li&gt; 点击“电话通知验证码”选项。&lt;/li&gt;

&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;另外，除了上述模式，也可以通过向”“发送表单数据为”method_requested=phone_requested”的请求。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这个方法是通过截取最初发送短信的请求，将”sms_requested”替换为”phone_requested”来实现的，它是最有效地方法。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;你可以在这里找到我向facebook 披露这个漏洞的完整版本.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;然而，他们对此的回复如下：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; Facebook在我绕过两步验证之后迅速的禁用了部分功能，他们非常迅速地采取了措施，至少是临时的措施。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;状态: 不再会受攻击| 揭露日期: &lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;向 LinkedIn安全团队揭露&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;正如谷歌和Facebook一样，当被攻击者没有接到系统自动来电或者占线时LinkedIn就会将两步验证码发送到被攻击者的语音信箱中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;LinkedIn处理地很好，他们关闭了通过电话发送两步验证码这个功能，直到他们可以和第三方的两步验证提供商来修复这个问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;你可以在这里看到我和LinkedIn发送的所有邮件.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;他们对这一问题的主要回复如下：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot; align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;状态: 不再会受攻击| 揭露日期: &lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;向雅虎团队揭露 (通过HackerOne)&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;雅虎支持两步验证的主要服务也容易受到我上文中所说的攻击。事实上，对支持两步验证的雅虎账号的攻击会更严重因为攻击者并不用担心被攻击者知道他的账号已经登录。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;通常支持两步验证的网络应用会在有人登录后发送短信通知。然而，当登录到雅虎账号以后，并不会发送短信，并且可以选择通过短信或者是电话来发送验证码。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;由于攻击者不用冒着被立刻知道的风险，攻击者会更有可能登录更长时间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当我揭示这个问题14天后，雅虎仍然没有回复，因此他们仍然很容易受到攻击。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在这里可以看到我揭示雅虎漏洞的全过程&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot; align=&quot;left&quot;&gt;状态: &lt;b&gt;仍然易受攻击&lt;/b&gt;&lt;b&gt;/&lt;/b&gt;&lt;b&gt;尚未回复&lt;/b&gt; | 揭露日期: &lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;向 Authy &amp;amp; Duosecurity揭露&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;我很快假设那些提供两步验证的服务都一定是易受攻击的。然而，我是错误的—因为他们知道这个事实并且对发送pin码到语音信箱这个问题有着长远考虑。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;你可以阅读我和Authy 及 Duosecurity的来往邮件&lt;a href=&quot;http://static.shubh.am/2fadisclosure/authy.pdf&quot;&gt;&lt;/a&gt; and &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这两个服务提供商都在24小时内给了我回复，并且他们对此都非常热心。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Authy&lt;/b&gt; | 状态：不易受攻击 | 揭露日期: &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Duosecurity&lt;/b&gt; | 状态:不易受攻击 | 揭露日期: &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Authy会发送空白的语音信息，Duosecurity会在验证前要求用户的交互操作。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;感谢&lt;a href=&quot;https://www.authy.com/&quot;&gt;&lt;/a&gt; 和!&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;缓解技术和向电话商 Telco 揭露：&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;广大的读者你们好，我校对了上面的一些信息，包括世界各地各种移动网络的终端。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;由于我不能查对 Telco 的海外电话商，我 知道世界各地的人都关心他们的电话商是否是易受攻击的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;要看你是否可以通过欺诈服务不用pin码就进入语音信箱，仅需要跟着上午所说的流程来，将终端号码改为你的电话商用的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果你的电话商也容易受到攻击请通过邮件或者是评论来告诉我。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;应对这个问题并没有想象中的那么简单，这要求重新构造两步验证的电话通知。这里是一些建议的解决方法（在给那些公司的邮件里都提到过）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要求用户的交互作为验证（推荐）&lt;/li&gt;

&lt;/ul&gt;
&lt;p align=&quot;left&quot;&gt;最后也是最重要的：&lt;/p&gt;
&lt;ul&gt;

&lt;/ul&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;向 Optus揭露&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;我和一起工作很愉快(The Sydney Morning Herald and The Age的编辑)，他帮助我把这些问题反映给Optus并且在此过程中非常热心也很有合作精神。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当我第一次发现Optus是易受攻击的时候，我的研究让我注意到这篇文章&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Optus很严肃认真地对待顾客的隐私。顾客必须设置一个独一无二的PIN码来激活他们的语音信箱系统。当他们的PIN码被用户服务重新设置时，Optus会建议他们重新设置一个只有他们自己知道的PIN码。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;至于欺诈服务，我们正在寻求多种方式来强调这一正在出现的整个工业界的威胁，包括技术上的解决途径以及进行对顾客的教育。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这篇文章的日期是2011年7月22号，距今已经三年了，令人惊讶的是这个问题依然存在并且是一个关于隐私的巨大隐患！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我和Ben在2014年3月2日将这个问题告诉了Optus，从那以后七天左右Optus修复了这个问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;然而，在修复以后几个小时之内，我能够又一次找出不用pin就可以进入任何Optus顾客语音信箱的方法。Optus正在研究这样的绕过方法，但是在没有其他公告之前，如果你使用Optus或者其他使用他们网络的代理商的服务，请假设你的语音信箱是不安全的，比如Vaya, LiveConnected, Amaysim, Exetel, Yatango 等等。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;备注&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;正如同我之前对于&lt;a href=&quot;http://blog.shubh.am/captchajacking-bypass-captchas/&quot;&gt;&lt;/a&gt;, &lt;a href=&quot;http://blog.shubh.am/demonstrating-the-critical-nature-of-ssrf---accessing-paypal%27s-internal-network-2/&quot;&gt;&lt;/a&gt;和 的迷恋一样，我认为语音信箱和移动网络的安全会占用我未来的许多时间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;每个人都知道移动网络的安全性很差，但是都没有做出什么改变，直到我们因此受到侵害才能意识到这件事情的重要性。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果你想要跟进我的语音信箱的研究，我会根据电话商的回复来定期更新我的twitter.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;以下服务可能会受到影响，但是我并没有彻底去检测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Snapchat&lt;/li&gt;
&lt;li&gt; (Uses DuoSecurity 2FA and hence is not vuln until further notice)&lt;/li&gt;
&lt;li&gt;Amazon&lt;/li&gt;
&lt;li&gt;Dynadot&lt;/li&gt;
&lt;li&gt;Airbnb&lt;/li&gt;
&lt;li&gt;Elance&lt;/li&gt;
&lt;li&gt;Chase&lt;/li&gt;
&lt;li&gt;Discover&lt;/li&gt;

&lt;/ul&gt;
&lt;p align=&quot;left&quot;&gt;另外有已确认是易受攻击的：&lt;/p&gt;
&lt;ul&gt;

&lt;/ul&gt;
&lt;p align=&quot;left&quot;&gt;感谢你的阅读，我希望你能够觉得这篇文章有用。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Tue, 05 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-05-74590-9247f11e1.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-05-74590-9247f11e1.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Boolean</title>
        <description>
&lt;p&gt;The boolean &lt;span class=&quot;keyword&quot;&gt;Bool&lt;/span&gt; type in Swift underlies a lot of primitive functionality, making it an interesting demonstration of how to build a simple type. This post walks through the creation of a new &lt;span class=&quot;keyword&quot;&gt;MyBool&lt;/span&gt; type designed and implemented to be very similar to the &lt;span class=&quot;keyword&quot;&gt;Bool&lt;/span&gt; type built into Swift. We hope this walk through the design of a simple Swift type will help you better understand how the language works.&lt;/p&gt; &lt;p&gt;Let’s start with the basic definition. The &lt;span class=&quot;keyword&quot;&gt;MyBool&lt;/span&gt; type models two different cases, perfect for an enum:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;enum&lt;/span&gt; MyBool {
	&lt;span class=&quot;key&quot;&gt;case&lt;/span&gt; myTrue, myFalse
}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;To reduce confusion in this post, we’ve named the cases &lt;span class=&quot;keyword&quot;&gt;myTrue&lt;/span&gt; and &lt;span class=&quot;keyword&quot;&gt;myFalse&lt;/span&gt;. We want &lt;span class=&quot;keyword&quot;&gt;MyBool()&lt;/span&gt; to produce a false value, and can do so by providing an &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt; method:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;init&lt;/span&gt;() { &lt;span class=&quot;key&quot;&gt;self&lt;/span&gt; = .&lt;span class=&quot;enum&quot;&gt;myFalse&lt;/span&gt; }
}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Swift enum declarations implicitly scope their enumerators within their body, allowing us to refer to &lt;span class=&quot;keyword&quot;&gt;MyBool.myFalse&lt;/span&gt; and even &lt;span class=&quot;keyword&quot;&gt;.myFalse&lt;/span&gt; when a contextual type is available.  However, we want our type to work with the primitive &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt; and &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt; literal keywords. To make this work, we can make &lt;span class=&quot;keyword&quot;&gt;MyBool&lt;/span&gt; conform to the &lt;span class=&quot;keyword&quot;&gt;BooleanLiteralConvertible&lt;/span&gt; protocol like this:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;BooleanLiteralConvertible&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;static func&lt;/span&gt; convertFromBooleanLiteral(value: &lt;span class=&quot;title&quot;&gt;Bool&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt; {
		&lt;span class=&quot;key&quot;&gt;return&lt;/span&gt; value ? &lt;span class=&quot;enum&quot;&gt;myTrue&lt;/span&gt; : &lt;span class=&quot;enum&quot;&gt;myFalse&lt;/span&gt;
	}
}

&lt;span class=&quot;comment&quot;&gt;// We can now assign &#39;true&#39; and &#39;false&#39; to MyBool.&lt;/span&gt;
&lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; a : &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt; = &lt;span class=&quot;key&quot;&gt;true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;With this set up, we have our basic type, but we still can’t do much with it.  Booleans need to be testable within an &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; condition.  Swift models this with the &lt;span class=&quot;keyword&quot;&gt;BooleanType&lt;/span&gt; protocol, which allows any type to be used as a logical condition:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;BooleanType&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; boolValue: &lt;span class=&quot;title&quot;&gt;Bool&lt;/span&gt; {
		&lt;span class=&quot;key&quot;&gt;switch self&lt;/span&gt; {
		&lt;span class=&quot;key&quot;&gt;case&lt;/span&gt; .myTrue: &lt;span class=&quot;key&quot;&gt;return true&lt;/span&gt;
		&lt;span class=&quot;key&quot;&gt;case&lt;/span&gt; .myFalse: &lt;span class=&quot;key&quot;&gt;return false&lt;/span&gt;
		}
	}
}

&lt;span class=&quot;comment&quot;&gt;// Can now test MyBool in &#39;if&#39; and &#39;while&#39; statement conditions.&lt;/span&gt;
&lt;span class=&quot;key&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pointer&quot;&gt;a&lt;/span&gt; {}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;We also want anything that conforms to &lt;span class=&quot;keyword&quot;&gt;BooleanType&lt;/span&gt; to be castable to &lt;span class=&quot;keyword&quot;&gt;MyBool&lt;/span&gt;, so we add:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt; {
	&lt;span class=&quot;comment&quot;&gt;// MyBool can be constructed from BooleanType&lt;/span&gt;
	&lt;span class=&quot;key&quot;&gt;init&lt;/span&gt;(&lt;span class=&quot;key&quot;&gt;_&lt;/span&gt; v : &lt;span class=&quot;title&quot;&gt;BooleanType&lt;/span&gt;) {
		&lt;span class=&quot;key&quot;&gt;if&lt;/span&gt; v.&lt;span class=&quot;title&quot;&gt;boolValue&lt;/span&gt; {
			&lt;span class=&quot;key&quot;&gt;self&lt;/span&gt; = .&lt;span class=&quot;enum&quot;&gt;myTrue&lt;/span&gt;
		} &lt;span class=&quot;key&quot;&gt;else&lt;/span&gt; {
			&lt;span class=&quot;key&quot;&gt;self&lt;/span&gt; = .&lt;span class=&quot;enum&quot;&gt;myFalse&lt;/span&gt;
		}
	}
}

&lt;span class=&quot;comment&quot;&gt;// Can now convert from other boolean-like types.&lt;/span&gt;
&lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; basicBool : &lt;span class=&quot;title&quot;&gt;Bool&lt;/span&gt; = &lt;span class=&quot;key&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;pointer&quot;&gt;a&lt;/span&gt; = &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;(&lt;span class=&quot;pointer&quot;&gt;basicBool&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Note that the use of &lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; in the initializer argument list disables the keyword argument, which allows the &lt;span class=&quot;keyword&quot;&gt;MyBool(x)&lt;/span&gt; syntax to be used instead of requiring &lt;span class=&quot;keyword&quot;&gt;MyBool(v: x)&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Now that we have basic functionality, let’s define some operators to work with it, starting with the &lt;span class=&quot;keyword&quot;&gt;==&lt;/span&gt; operator.  Simple enums that have no associated data (like &lt;span class=&quot;keyword&quot;&gt;MyBool&lt;/span&gt;) are automatically made &lt;span class=&quot;keyword&quot;&gt;Equatable&lt;/span&gt; by the compiler, so no additional code is required. However, you can make arbitrary types equatable by conforming to the &lt;span class=&quot;keyword&quot;&gt;Equatable&lt;/span&gt; protocol and implementing the &lt;span class=&quot;keyword&quot;&gt;==&lt;/span&gt; operator. If &lt;span class=&quot;keyword&quot;&gt;MyBool&lt;/span&gt; weren’t already &lt;span class=&quot;keyword&quot;&gt;Equatable&lt;/span&gt;, this would look like this:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Equatable&lt;/span&gt; {
}

&lt;span class=&quot;key&quot;&gt;func&lt;/span&gt; ==(lhs: &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;, rhs: &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;title&quot;&gt;Bool&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;switch&lt;/span&gt; (lhs, rhs) {
	&lt;span class=&quot;key&quot;&gt;case&lt;/span&gt; (.myTrue,.myTrue), (.myFalse,.myFalse):
		&lt;span class=&quot;key&quot;&gt;return true
	default&lt;/span&gt;:
		&lt;span class=&quot;key&quot;&gt;return false&lt;/span&gt;
	}
}

&lt;span class=&quot;comment&quot;&gt;// Can now compare with == and !=&lt;/span&gt;
&lt;span class=&quot;key&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pointer&quot;&gt;a&lt;/span&gt; == &lt;span class=&quot;pointer&quot;&gt;a&lt;/span&gt; {}
&lt;span class=&quot;key&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pointer&quot;&gt;a&lt;/span&gt; != &lt;span class=&quot;pointer&quot;&gt;a&lt;/span&gt; {}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Here we’re using some simple pattern matching in the &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; statement to handle this. Since &lt;span class=&quot;keyword&quot;&gt;MyBool&lt;/span&gt; is now &lt;span class=&quot;keyword&quot;&gt;Equatable&lt;/span&gt;, we get a free implementation of the &lt;span class=&quot;keyword&quot;&gt;!=&lt;/span&gt; operator.  Lets add binary operations:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;func&lt;/span&gt; &amp;amp;(lhs: &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;, rhs: &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;if&lt;/span&gt; lhs {
		&lt;span class=&quot;key&quot;&gt;return&lt;/span&gt; rhs
	}
	&lt;span class=&quot;key&quot;&gt;return false&lt;/span&gt;
}

&lt;span class=&quot;key&quot;&gt;func&lt;/span&gt; |(lhs: &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;, rhs: &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;if&lt;/span&gt; lhs {
		&lt;span class=&quot;key&quot;&gt;return true&lt;/span&gt;
	}
	&lt;span class=&quot;key&quot;&gt;return&lt;/span&gt; rhs
}

&lt;span class=&quot;key&quot;&gt;func&lt;/span&gt; ^(lhs: &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;, rhs: &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;(lhs != rhs)
}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;With the basic operators in place, we can implement a variety of helpful unary and compound assignment operators as well, for example:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;prefix func&lt;/span&gt; !(a: &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;enum&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;key&quot;&gt;true&lt;/span&gt;
}

&lt;span class=&quot;comment&quot;&gt;// Compound assignment (with bitwise and)&lt;/span&gt;
&lt;span class=&quot;key&quot;&gt;func&lt;/span&gt; &amp;amp;=(&lt;span class=&quot;key&quot;&gt;inout&lt;/span&gt; lhs: &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;, rhs: &lt;span class=&quot;pointer&quot;&gt;MyBool&lt;/span&gt;) {
	lhs = lhs &lt;span class=&quot;enum&quot;&gt;&amp;amp;&lt;/span&gt; rhs
}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;span class=&quot;keyword&quot;&gt;&amp;amp;=&lt;/span&gt; operator takes the left operand as &lt;span class=&quot;keyword&quot;&gt;inout&lt;/span&gt; because it reads and writes to it, and the effect must be visible to the user of the operator.  Swift gives you complete control over mutability of operations on value types like &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; and &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;With this, the simple &lt;span class=&quot;keyword&quot;&gt;MyBool&lt;/span&gt; type has all of the basic operations and operators.  Hopefully this post gives you a few tips that you can apply to your own code when defining higher-level types.&lt;/p&gt;

</description>
        <pubDate>Tue, 05 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-05--id=8-1cf8664dd.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-05--id=8-1cf8664dd.html</guid>
        
        
        <category>apple_swift</category>
        
      </item>
    
      <item>
        <title>对TCP/IP网络协议的深入浅出归纳</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;前段时间做了一个开发，涉及到网络编程，开发过程比较顺利，但任务完成后始终觉得有一些疑惑。主要是因为对网络协议不太熟悉，对一些概念也没弄清楚。后来 我花了一些时间去了解这些网络协议，现在对TCP/IP网络协议有了初步的认识，在这里总结出来，可以梳理一下我对网络协议的理解，加深印象.&lt;/p&gt;
&lt;p&gt;话说两台电脑要通讯就必须遵守共同的规则，就好比两个人要沟通就必须使用共同的语言一样。一个只懂英语的人，和一个只懂中文的人由于没有共同的语言（规则）就没办法沟通。两台电脑之间进行通讯所共同遵守的规则，就是网络协议。&lt;/p&gt;
&lt;p&gt;那么谁来制定这个网络协议？&lt;/p&gt;
&lt;p&gt;国际标准化组织(ISO)定义了网络协议的基本框架，被称为OSI模型。要制定通讯规则，内容会很多，比如要考虑A电脑如何找到B电脑，A电脑在发送信息 给B电脑时是否需要B电脑进行反馈，A电脑传送给B电脑的数据的格式又是怎样的？内容太多太杂，所以OSI模型将这些通讯标准进行层次划分，每一层次解决 一个类别的问题，这样就使得标准的制定没那么复杂。OSI模型制定的七层标准模型，分别是：应用层，表示层，会话层，传输层，网络层，数据链路层，物理 层。&lt;/p&gt;
&lt;p&gt;虽然国际标准化组织制定了这样一个网络协议的模型，但是实际上互联网通讯使用的网络协议是TCP/IP网络协议。&lt;/p&gt;
&lt;p&gt;TCP/IP 是一个协议族，也是按照层次划分。共四层：应用层，传输层，互连网络层，网络接口层。 那么TCP/IP协议和OSI模型有什么区别呢？OSI网络协议模型，是一个参考模型，而TCP/IP协议是事实上的标准。TCP/IP协议参考了OSI 模型，但是并没有严格按照OSI规定的七层去划分标准，而只划分了四层，个人觉得这样会更简单点，当划分太多层次时，你很难区分某个协议是属于哪个层次 的。TCP/IP协议和OSI模型也并不冲突，TCP/IP协议中的应用层协议，就对应于OSI中的应用层，表示层，会话层。就像以前有工业部和信息产业 部，现在实行大部制后只有工业和信息化部一个部门，但是这个部门还是要做以前两个部门一样多的事情，本质上没有多大的差别。TCP/IP中有两个重要的协 议，传输层的TCP协议和互连网络层的IP协议，因此就拿这两个协议做代表，来命名整个协议族了，在说TCP/IP协议时，是指整个协议族。&lt;/p&gt;
&lt;p&gt;TCP/IP协议分为四个层次，但我们并不需要了解所有层次的协议，我觉得主要关注应用层和传输层的协议就可以了。拿寄送邮件举例， A寄邮件给B，A关心的是用什么格式写什么内容给B（应用层内容），是寄挂号信还是寄平信（传输层内容），但是A是不会去关注邮件传送过程中采用了那条路 线，邮递员是如何把信件递送到B手里的（互连网络层，网络接口层）。&lt;/p&gt;
&lt;p&gt;先说传输层，传输层有多个协议，但最主要的是TCP和UDP协议。两则的区别在于TCP协议需要接收方反馈，UDP协议不需要接收方反馈。TCP就像挂号 信，A电脑发信息给B电脑后，需要得到B电脑的反馈，这样A电脑就能知道B电脑是否已经收到信息。UDP就像平信，A电脑发信息给B电脑后，B电脑并不给 A电脑发聩，A电脑发送信息出去后并不知道B电脑是否已经收到。 因此，TCP传输比UDP传送更可靠，但是TCP传输的效率就不如UDP了。至于，在传送过程中具体选择哪种传送方式，需要具体问题具体分析。在不可靠的 网络传送过程中一般选择TCP传送方式。在讲求效率，或者不在乎传送失误的情况下可以选择UDP方式来提高传输速率。&lt;/p&gt;
&lt;p&gt;应用层的协议有很多，每一个协议代表一种类型的服务。HTTP协议，万维网服务。FTP协议，文件传送服务。POP3，邮件服务，SOAP协议webService服务。&lt;/p&gt;
&lt;p&gt;在理解TCP/IP协议的过程中，我遇到了三个困惑。&lt;/p&gt;
&lt;p&gt;1.什么是socket?&lt;/p&gt;
&lt;p&gt;以前有听说过socket编程这种说法，也有的说套接字编程。我在搜索关于socket的资料时，发现有的说socket是指一个连接，有的说 socket是一指一个端点。拿打电话做比喻，A电话机和B电话机正在通话，那么socket是指的A和B之间的连接线呢，还是指电话机（端点）？&lt;/p&gt;
&lt;p&gt;我现在的理解是，socket就是一个连接中的一个端点，一次通讯（连接）a,b端都会有一个socket。一个socket对应一个连接。&lt;/p&gt;
&lt;p&gt;2.http协议属于应用层还是传输层？&lt;/p&gt;
&lt;p&gt;http 超文本传送协议，听上去像是传输层的协议一样。但事实上大家都知道http和ftp一样都是属于应用层的协议，我先前很纳闷的是，既然是应用层的协议，怎 么就取这样一个误导人的名称啊。在对TCP/IP协议还不熟悉的时候，这很容易让人误解和纳闷的。后来，我在wiki上发现这么一段话：&lt;/p&gt;
&lt;p&gt;http中文译名问题
HTTP 在中国大陆被翻译为“超文本传输协议”，因为“transfer”在中文里有“传输”的含意。但依据 HTTP 定制者之一的 Roy Fielding博士的论文[1]（6.5.3节），作者专门强调“transfer”表示的是“（表述状态的）转移” （Representational State Transfer），而不是“传输”（transport）。故其中文译名“超文本传输协议”恰恰引种反映了这种误解。更符合原义的译名应该为“超文本转 移协议”。&lt;/p&gt;
&lt;p&gt;这段话解除了我的疑惑。那么http协议当然是应用层的协议。&lt;/p&gt;
&lt;p&gt;3.SOAP可以使用HTTP协议进行传输吗？&lt;/p&gt;
&lt;p&gt;在了解SOAP协议的过程中，看到介绍说soap可以通过tcp,udp,http协议来传送。这也是让人困惑的描述。一看这句话，就会感觉http怎么 和tcp,udp协议并列了呢？难道http还是属于传输层的协议？再加上http中文译名的问题，名字听上去像传输层，初学者又要开始头大了。&lt;/p&gt;
&lt;p&gt;事实上，http是应用层的协议，这一点可以毫无怀疑。那么现在新的问题来了。soap和http都是应用层协议，怎么说soap能用http协议来传输呢？应用层的协议可以用应用层的协议传送吗？&lt;/p&gt;
&lt;p&gt;我查阅了资料，是这样一回事情，soap将信息进行XML的序列化后，再用http协议的方式再打包进行传送，传送的方式还是tcp或者udp。做个比喻 就好理解了。tcp 和 udp 都是公路，暂且把tcp认为是一般公路，udp高速公路，soap和http就都是汽车，那么soap和http都可以在tcp和udp上跑。说soap 可以通过http来传送，实际就是说soap是小轿车，http是装轿车的卡车，把soap的信息装到http里面，然后再运输，当然走的道路还是tcp 或udp。&lt;/p&gt;
&lt;p&gt;说soap可以通过http协议来传输，这句话不太准确，比较准确第说法是：soap信息可以通过http协议包装后通过tcp或udp传输。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 04 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-04-74795-7a8fff1f3.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-04-74795-7a8fff1f3.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>你或许想要用到的三个新的Javascript API</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;如果你是一个SitePoint的老读者并且是我的粉丝的话，那么你已经知道我写了很多关于HTML5以及JS API的文章。到目前为止，我已经发布了一些介绍你现在就可以马上使用的API，尽管可能会用到polyfill的方式。（译注：不知道什么是polyfill请。）&lt;/p&gt;
&lt;p&gt;但是今天我可能要打破这个常规来给大家介绍一些仍然还处在初期阶段的API。大家必须知道这些API是非常新的，在这三个里面有两个都是在几天之前刚刚发布的。正因如此，这些API现目前都还无法使用。但是如果你有兴趣了解它们具体是用来做什么的，你可以继续阅读下面关于它们的详细介绍，同时也欢迎留下你的看法和回应。&lt;/p&gt;
&lt;p&gt;废话不多说，现在开始！&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;Web Alarms API&lt;/h2&gt;
&lt;p&gt;让你可以配置设备的闹铃设置，从而能够安排通知消息或让某个特定的应用在指定的时间点启动。这个API最典型的用法会涉及到像闹钟，日历，或其他任何需要在特定时间进行特定操作的程序。&lt;/p&gt;
&lt;p&gt;自从去年开始，这个API刚刚成为了一个W3C的设计草案。因此所有有待成为W3C官方推荐的相关细节都还在初期阶段。这个API需要通过&lt;span style=&quot;color: #008000;&quot;&gt;window.navigator&lt;/span&gt;对象下的&lt;span style=&quot;color: #008000;&quot;&gt;alarms&lt;/span&gt;属性来使用。属性会提供三个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;span style=&quot;color: #008000;&quot;&gt;&lt;/span&gt;从设备获取全部已有的闹铃并以包含对象的数组形式返回。&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color: #008000;&quot;&gt;&lt;/span&gt;注册一个基于&lt;span style=&quot;color: #008000;&quot;&gt;Date&lt;/span&gt;对象的闹铃并返回一个对象。&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;为了向大家演示理想情况下这些函数应当如何使用，这里有一个添加闹铃的例子（请记住现目前任何浏览器都不支持这段代码）&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;var alarmId;
var request = navigator.alarms.add(
    new Date(&quot;June 29, 2012 07:30:00&quot;),
    &quot;respectTimezone&quot;,
);

request.onsuccess = function (e) {
    alarmId = e.target.result;
};

request.onerror = function (e) {
    alert(e.target.error.name);
};&lt;/pre&gt;
&lt;p&gt;然后，如果你想要移除之前添加的闹铃，可以这样写：&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;var request = navigator.alarms.remove(alarmId);

request.onsuccess = function (e) {
    alert(&quot;alarm removed&quot;);
};

request.onerror = function (e) {
    alert(e.target.error.name);
};&lt;/pre&gt;
&lt;p&gt;如果你想要了解更多关于Web Alarms API，请参阅。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;Presentation API&lt;/h2&gt;
&lt;p&gt;的目标就是让投影仪或TV这样的第二显示设备能够被Web使用，包括所有通过有线（HDMI，DVI等）连接以及通过无线（MiraCast, Chromecast, DLNA, AirPlay等）的设备。这个API所做的就是在请求页面与第二显示设备上的演示页面之间实现消息互通。&lt;/p&gt;
&lt;p&gt;请注意该API细节并不属于W3C标准，也不在W3C标准计划当中。这个API需要通过&lt;span style=&quot;color: #008000;&quot;&gt;window.navigator&lt;/span&gt;对象下的&lt;span style=&quot;color: #008000;&quot;&gt;presentation&lt;/span&gt;属性来使用。该属性提供了一个叫&lt;span style=&quot;color: #008000;&quot;&gt;requestSession()&lt;/span&gt;函数，以及&lt;span style=&quot;color: #008000;&quot;&gt;present&lt;/span&gt;和&lt;span style=&quot;color: #008000;&quot;&gt;availablechange&lt;/span&gt;两个事件。&lt;span style=&quot;color: #008000;&quot;&gt;requestSession()&lt;/span&gt;函数可以用来启动或恢复第二显示设备上的演示。它会返回一个&lt;span style=&quot;color: #008000;&quot;&gt;session&lt;/span&gt;对象指代当前的演示。当通过&lt;span style=&quot;color: #008000;&quot;&gt;requestSession()&lt;/span&gt;传入的url里面的演示内容被加载完成后，演示屏幕的页面会收到&lt;span style=&quot;color: #008000;&quot;&gt;present&lt;/span&gt;事件。最后，在第一张演示出现后或者最后一张演示完成后会发出事件。&lt;/p&gt;
&lt;p&gt;举个例子，来自细节文档，该API的用法如下所示：&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;&amp;lt;button disabled&amp;gt;Show&amp;lt;/button&amp;gt;

&amp;lt;script&amp;gt;
var presentation = navigator.presentation,
    showButton = document.querySelector(&#39;button&#39;);

presentation.onavailablechange = function(e) {
  showButton.disabled = !e.available;
  showButton.onclick = show;
};

function show() {
  var session = presentation.requestSession(&#39;http://example.org/&#39;);

  session.onstatechange = function() {
    switch (session.state) {
      case &#39;connected&#39;:
        session.postMessage(/*...*/);
        session.onmessage = function() { /*...*/ };
        break;
      case &#39;disconnected&#39;:
        console.log(&#39;Disconnected.&#39;);
        break;
    }
  };
}
&amp;lt;/script&amp;gt;&lt;/pre&gt;
&lt;p&gt;如果你想要了解更多关于Presentation API的消息，可以看看。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;Standby API&lt;/h2&gt;
&lt;p&gt;让你可以在顶层浏览器页面中请求屏幕持续显示锁。这可以防止设备进入省电状态（例如屏幕自动关闭）。这个功能对有些web应用来说至关重要。例如，想像一下你正在驾车并在手机上使用基于web的导航软件（非本地应用）。如果你不去触碰屏幕的话，你的手机的屏幕会自动关闭，除非你事前在手机上进行过相关的设置。在这样的情况下，通常你是想要让屏幕保持显示状态的。这恰恰是这个API适用的地方。&lt;/p&gt;
&lt;p&gt;这个API需要通过&lt;span style=&quot;color: #008000;&quot;&gt;window.navigator&lt;/span&gt;对象下的属性来使用。它会提供两个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 使当前应用能让屏幕保持显示状态。&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;这两个函数都只接受一个参数，其只能是&lt;span style=&quot;color: #008000;&quot;&gt;“screen”&lt;/span&gt;或。前者表示操作针对的是设备屏幕，而后者针对的是除屏幕之外如CPU或广播之类的其他设备资源。&lt;/p&gt;
&lt;p&gt;以下例子会演示如何适用该API让设备屏幕保持显示状态：&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;navigator.wakeLock.request(&quot;display&quot;).then(
    function successFunction() {
        // do something
    },
    function errorFunction() {
        // do something else
    }
);&lt;/pre&gt;
&lt;p&gt;要让设备允许屏幕关闭，我们可以用以下方法：&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;navigator.wakeLock.release(&quot;display&quot;);&lt;/pre&gt;
&lt;p&gt;如果你想要了解关于Standby API的更多信息，可以参考这个。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇文章里我给大家介绍了一些崭新的JS API。我要再次强调因为它们都还处在非常早期的阶段，所以目前没有浏览器支持。因此我们也没法实际地操作它们。然而正因为它们如此之新大家现在都有机会跟进它们接下来的发展甚至参与帮助它们的细节设计的完善。&lt;/p&gt;
&lt;p&gt;Web开发的未来一片光明，加入进来吧！&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 04 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-04-74773-b877a4741.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-04-74773-b877a4741.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈服务化架构</title>
        <description>
&lt;pre&gt;&lt;code&gt;这两年来，在服务化架构设计上的实践比较多，在此对关于服务化设计一些经验稍作总结，
知识经验水平有限，如有欠缺和不准确的地方，还请指出修正！     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我在&lt;a href=&quot;http://sharecore.net/blog/2014/07/05/ke-kuo-zhan-jia-gou-de-san-ge-wei-du/&quot;&gt;《可扩展架构设计的三个维度》&lt;/a&gt;一文里，谈到服务化架构（SOA）在保证系统扩展性上，是一个比较好的架构设计实践。也谈到了通过服务网关的形式来进行多服务的注册与管理等。但困于篇幅，并未展开讲关于服务化架构实现层面上的具体细节。本文就结合我这两年来，在服务化架构设计上的一些实践经验，谈谈一个服务化框架其应该具备的一些功能以及其基本实现方式。&lt;/p&gt;

&lt;p&gt;这里说到的“服务”，本质上来说，就是指“RPC”。单纯的RPC功能实现，其实很简单，无非就是client发起调用，中间某个组件（甚至就是client本身）拦截调用信息，序列化后将信息传输到server端，server端收到调用请求后反序列化，根据请求详细发起实际调用后返回响应传输回给client端。这样的RPC很常见，比如常见的存储过程调用就是一例。但是在一个复杂的业务环境，如何管理和协同这些大量的RPC才是最麻烦的事情。所以，在此谈的“服务化”更多指的是对RPC的管理。&lt;/p&gt;

&lt;p&gt;一个复杂业务环境下的大量RPC究竟会遇到哪些问题呢？换句话说，一个服务化管理框架究竟应该具备哪些功能特性才算基本完备呢？以下是我的一些看法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.协议选型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据序列化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为整个环境里的服务采用统一的数据序列化协议，其益处是显而易见的，能大大降低服务提供者和服务调用者之间的沟通成本，同时也可以为服务提供者减少应对不同数据协议需求而带来的代码复杂性。所以，在开始设计一个服务化框架时，第一件重要的事情就是选定一个标准的数据序列化协议。如何选择合适的序列化协议重点需要从&lt;strong&gt;扩展性，传输性能以及业界通用性（换句话说就是不同技术/语言的支持程度）&lt;/strong&gt;三个因素里来协调选择。当前看来，在这三个方面都做的比较好，也是使用最广泛的就是&lt;strong&gt;Json&lt;/strong&gt;和&lt;strong&gt;Protobuf&lt;/strong&gt;了，基于文本的Json在可读性和灵活性上占优，而基于二进制的Protobuf在传输性能生更胜一筹。而如果整个环境开发的技术栈比较统一，比如全是Java/.NET，也可以选择对这一技术更加友好的序列化协议。我这一次选择的就是Json，因为从面对的业务情况来看，传输性能不是根本矛盾，而灵活性要求较高，同时服务使用者使用的技术也较为多样化。&lt;/p&gt;

&lt;p&gt;在序列化协议的选定上&lt;strong&gt;要避免的一个误区就是采用自定义协议而不是业界通用协议&lt;/strong&gt;,自定义协议将很容易面临扩展性和使用推广方面的问题，同时，当有新的开发人员加入进来，其需要花费时间来学习与了解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通讯协议选择&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通讯协议上的选择上灵活性比较大，有多种选择，可以在基于HTTP或TCP链接上建立自己的通讯协议。比如可以设计一个简单的header（定长）+body（序列化的请求/响应）。如果采取json作序列化协议的情况下，可以跟我本次的选择一样，采取一个类似&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON-RPC&quot;&gt;json-rpc&lt;/a&gt;, 完全基于json的通讯协议：&lt;/p&gt;

&lt;p&gt;Resust:&lt;/p&gt;

&lt;figure class=&quot;code&quot;&gt;&lt;figcaption&gt;&lt;span&gt;&lt;/span&gt;&lt;/figcaption&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;
&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;nt&quot;&gt;&quot;ActionName&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Do&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;nt&quot;&gt;&quot;AppId&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xxxxxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;nt&quot;&gt;&quot;RequestContent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;


&lt;p&gt;Response:&lt;/p&gt;

&lt;figure class=&quot;code&quot;&gt;&lt;figcaption&gt;&lt;span&gt;&lt;/span&gt;&lt;/figcaption&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;
&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;err&quot;&gt;“RequestId”:“xxxxxxxxx”，&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;err&quot;&gt;“HasError”:false,&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;nt&quot;&gt;&quot;ResponseContent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;


&lt;p&gt;对于服务访问对象主要为企业内部的情况，不太建议采取与http完全绑定的restful协议，这将牺牲链接层选择的灵活性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.注册与授权管理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注册管理是解决系统交互复杂性的必备良药，我建议多余三个系统以上的系统交互，都应该具备注册管理功能。对于服务化架构来说，注册管理也是最为核心的一项功能。当服务数量和服务使用者数量爆发性增长时，最难回答的问题就是“服务被谁使用了？”以及“有哪些服务可供使用？”，注册管理就是解决这两个问题的最佳方式与实践。&lt;/p&gt;

&lt;p&gt;注册管理的实现上其实也很简单，提供一个Config Server（配置中心），收集服务提供者的注册信息（包括服务名称，服务地址（可以多个），版本，超时时间控制等），我们称为&lt;strong&gt;服务的元信息&lt;/strong&gt;。而当服务使用者需要调用相应的服务时，就可以利用这些元信息来查找和调用相应的服务了。&lt;/p&gt;

&lt;p&gt;不过，在元信息的使用上，存在两者架构方式&lt;/p&gt;

&lt;p&gt;1.服务使用者访问统一的服务中转器，由服务中转器按照注册信息以及负载情况将请求转发到相应的服务地址上。服务执行后，响应信息返回到服务中心，服务中心将响应回送给调用方。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sharecore.net/256cb7f23c557856f23ab45f558e68dc.jpg&quot; alt=&quot;service_2&quot;&gt;&lt;/p&gt;

&lt;p&gt;这种方式的优点是能比较好的控制所有请求的调度。当服务元信息发生变化时，能及时地调整请求转发（负载）与超时控制等。缺点是请求和响应均需要由中转中心负责转发，性能耗费较大。同时，中转中心的可用性也容易产生问题，必须通过集群的方式来解决。&lt;/p&gt;

&lt;p&gt;2.服务使用者负责从配置中心获取服务地址等信息，然后有由服务使用者直接向相对应地址上的服务发送请求，请求也直接由服务提供者返回给服务调用者。同时，服务使用者本身可以缓存一定的服务元信息，防止每次访问都要从配置中心获取，以降低配置中心的负载，增强整个系统的可用性。当配置中心的服务元信息发生变化时，通过通知的方式告知服务使用者更新本地缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sharecore.net/36ba0cc57c1e0c0a7b8e534de7be7c60.jpg&quot; alt=&quot;service_1&quot;&gt;&lt;/p&gt;

&lt;p&gt;这种架构方式与第一种架构相比，能显著降低性能的损耗，以及服务使用者对中心节点的直接依赖。但代价是需要彻底改造服务使用者的调用方式，框架的代码必须侵入到客户端的开发中去。一般会针对不同的客户端提供clientLib，但当客户端实现方式多样化时，这种代价是非常大的。&lt;/p&gt;

&lt;p&gt;由于我这次面对的客户端多样性，客户端开发也不在控制范围内，所以选择就是第一种方式。&lt;/p&gt;

&lt;p&gt;关于授权，可以与注册管理相互结合，将授权信息同一保存到配置中心。对于企业内部访问的服务，做到通过IP+AppId授权应该就够了。这里有个经验是可以将授权和服务版本确认两者结合起来，即在&lt;strong&gt;授权的同时完成服务版本的确定&lt;/strong&gt;，而不采取由客户端发起访问时指定版本的方式，这样做的好处是框架和服务提供者对于服务版本变更和灰度发布具有更高的可控制性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.路由与过载保护&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;http://sharecore.net/blog/2014/07/05/ke-kuo-zhan-jia-gou-de-san-ge-wei-du/&quot;&gt;《可扩展架构设计的三个维度》&lt;/a&gt;一文里谈到通过单元化架构以满足Z轴扩展，以满足差异性的需求或者做到安全隔离。而&lt;strong&gt;服务路由是实现这种单元化架构的基本保障&lt;/strong&gt;，以保证能将来自不同访问者请求或者不同的请求内容，分发到不同的服务提供区域去，形成单元化架构的闭环。当然，路由功能并不一定需要框架来独立实现，业界许多通用的（软）负载均衡器可以协助实现，如Nginx/HAProxy/LVS这些。但是这类通用的负载均衡软件的问题是路由算法比较通用，当需要扩展到与业务逻辑相关的路由绑定时，比较麻烦，比如需要用户ID按权重分配路由。在此建议，&lt;strong&gt;可以采取通用的负载均衡软件当第一层接入，而在服务节点之间采取自己实现路由模块的方式。&lt;/strong&gt;而在实现路由模块时，需要将扩展性上的考虑放在第一位。&lt;/p&gt;

&lt;p&gt;对于服务化架构，保障提供服务提供者的业务系统不受“恶意”调用或突发性激增调用的破坏，过载保护功能至关重要，它能起到系统“保险丝”的效果。前文提到可用于接入的Nginx/HAProxy/LVS这些软件，也多少提供了过载保护的功能。如果自己实现过载保护模块，具体可参见我的&lt;a href=&quot;http://sharecore.net/blog/2014/06/21/guo-zai-bao-hu-suan-fa-qian-xi/&quot;&gt;《过载保护算法浅析》&lt;/a&gt;一文。对于过载保护的一个经验是：&lt;strong&gt;过载保护越靠近服务访问前端越好。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.服务拆分与组合化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;传统的SOA概念，指的是不同的应用系统之间相互通过大粒度服务的方式进行集成。而当今的服务化架构已经摆脱了这一概念的束缚，更多讲的是系统内部模块级甚至是功能级的服务化模式。也就是说服务实现的粒度更小了。这当然为应用和服务的实现带来了更强的灵活性，服务交付周期也大大缩短了。但这样的细粒度拆分服务，带来的问题是项功能的实现需要访问的服务数量成倍的增加。如下图所示：一个客户下订单的功能实现需要分别访问：客户信息服务，产品类别服务，库存服务，订单管理服务等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sharecore.net/e310fe10a83859029875682319ae4959.jpg&quot; alt=&quot;service_3&quot;&gt;&lt;/p&gt;

&lt;p&gt;这将显著增加功能实现的复杂性。为了解决这一问题，我们只能再次使用那条永远有效的“中间层定律”：&lt;strong&gt;任何计算机问题都可以通过中间加一层来解决。&lt;/strong&gt; 我们可以将相应的服务组合成一个新的服务提供出去，比如上面的例子，我们可以按以下方式组合：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sharecore.net/f8ede80d4eaaaa4ab773f3d973a34a46.jpg&quot; alt=&quot;service_4&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.基于配置的服务运行时提供&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前文已经概述了一个服务化框架应该具有的一些基本功能以及一些基本的架构实现方式。但这个服务框架究竟如何与业务开发相结合呢？也就是说业务逻辑代码与框架代码之间如何隔离,而不是让框架的功能代码侵入到业务逻辑代码的开发中来?这里通用的做法就是&lt;strong&gt;通过基于配置，由框架提供运行时，动态加载业务代码的方式&lt;/strong&gt;。做到这点，只需要约束业务逻辑代码实现相应的接口/基类，然后打包成相应的组件（如jar/dll/so等）提供给框架加载运行即可，类似于java servlet的开发，业务开发完全不用关心服务化框架任何功能，专注开发业务逻辑即可。同时，对于既有代码的服务化也将变得简单，只需要稍加重构封装出实现相应的接口即可。&lt;/p&gt;

&lt;p&gt;配置类似于：&lt;/p&gt;

&lt;figure class=&quot;code&quot;&gt;&lt;figcaption&gt;&lt;span&gt;&lt;/span&gt;&lt;/figcaption&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;
&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;service&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;serviceName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Customer.GetCustomer&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;biz&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;imp=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.customer.getCustomer&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;biz&amp;gt;&lt;/span&gt; 
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;service&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;


&lt;p&gt;同时，这种基于组件配置的服务实现，对于组合组件实现服务也非常简单。只需要将上面的配置改为嵌套的方式既可以实现组合。比如对于订单生成服务只要组合如下：&lt;/p&gt;

&lt;figure class=&quot;code&quot;&gt;&lt;figcaption&gt;&lt;span&gt;&lt;/span&gt;&lt;/figcaption&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;
&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;service&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;serviceName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Order.CreateOrder&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;biz&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;imp=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.inventory.checkInventory&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;nt&quot;&gt;&amp;lt;biz&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;imp=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.order.createOrder&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;nt&quot;&gt;&amp;lt;biz&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;imp=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.inventory.updateInventory&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;nt&quot;&gt;&amp;lt;/biz&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/biz&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;biz&amp;gt;&lt;/span&gt; 
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;service&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;


&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基本来看，服务化架构已经在业界完成了落地，尤其是互联网公司，更是基于这一架构的领先者，有许多经验值得借鉴。当然，这个落地的服务化架构，与当年被各大商业公司用WS-*和ESB玩坏的SOA概念相去甚远。也再一次证明，那些被鼓吹出来的技术概念，只有当那些商业公司不再炒作之时，方是其真正落地之日（SOA如此，当今热炒的“大数据”，“云计算”这些概念又何尝不会是如此呢？）。在技术被鼓吹得风头正劲时，千万要保持冷静，别被那些商业公司所忽悠,你完全可以自己实现更轻量级更具有扩展性的架构。不信的话，可以去问问，那些当年花大价钱去买SOA商业组件的公司，他们还好吗？&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;如果您觉得这篇文字有意思，欢迎转发！欢迎更多的朋友们关注我的微信公众号：&lt;strong&gt;JustinNotes&lt;/strong&gt;&lt;/p&gt;

&lt;hr&gt;

</description>
        <pubDate>Sat, 02 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-02-qian-tan-fu-wu-hua-kuang-jia-de-ji-ben-gong-neng-25b061573.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-02-qian-tan-fu-wu-hua-kuang-jia-de-ji-ben-gong-neng-25b061573.html</guid>
        
        
        <category>sharecore</category>
        
      </item>
    
      <item>
        <title>机器学习算法基础概念学习总结</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;h2&gt;1.基础概念：&lt;/h2&gt;
&lt;p&gt;(1) 10折交叉验证：英文名是10-fold cross-validation，用来测试算法的准确性。是常用的测试方法。将数据集分成10份。轮流将其中的9份作为训练数据，1分作为测试数据，进行试验。每次试验都会得出相应的正确率（或差错率）。10次的结果的正确率（或差错率）的平均值作为对算法精度的估计，一般还需要进行多次10折交叉验证，在求其平均值，对算法的准确性进行估计。&lt;/p&gt;
&lt;p&gt;(2) 极大似然估计：极大似然估计，只是一种概率论在统计学中的应用，它是参数评估的方法之一。说的 已知某个随机样本满足某种概率分布，但是其中具体的参数不清楚，参数估计通过若干次实验，观察其结果，利用结果推出参数的大概值。极大似然估计是建立在这样的思想上的：已知某个参数能使这个样本出现的概率最大。我们当然不会再去选择其他其他小概率的样本，所以干脆就把这个参数作为估计的真实值。&lt;/p&gt;
&lt;p&gt;(3) 在信息论中，熵表示的是不确定性的量度。信息论的创始人香农在其著作《通信的数学理论》中提出了建立在概率统计模型上的信息度量。他把信息定义为”用来消除不确定性的东西“。熵的定义为信息的期望值。&lt;/p&gt;
&lt;p&gt;ps:熵指的是体系的混乱程度，它在控制论，概率论，数论，天体物理，生命科学等领域都有重要的应用，在不同的学科中也有引申出更为具体的定义，是各个领域十分重要的参量。熵由鲁道夫.克劳修斯提出，并应用在热力学中。后来在，克劳德.埃尔伍德.香农 第一次将熵的概念引入到信息论中来。&lt;/p&gt;
&lt;p&gt;(4) 后验概率是信息论的基本概念之一。在一个通信系统中，在收到某个消息之后，接收端所了解到的该消息发送的概率称为后验证概率。后验概率是指在得到”结果“的信息后重新修正的概率，如贝叶斯公式中的。是执果寻因的问题。后验概率和先验概率有着不可分割的联系，后验的计算要以先验概率为基础，其实说白了后验概率其实就是条件概率。&lt;/p&gt;
&lt;p&gt;(5) PCA 主成分分析:&lt;br&gt;
优点：降低数据的复杂性，识别最重要的多个特征。&lt;br&gt;
缺点：不一定需要，且可能损失有用信息。&lt;br&gt;
适用适用类型：数值型数据。
技术类型：降维技术。&lt;/p&gt;
&lt;p&gt;简述：在PCA中，数据从原来的坐标系转换到了新的坐标系，新坐标系的选择是由数据本身决定的。第一个新坐标轴选择时原始数据中方差最大的方向，第二个新坐标轴的选择和第一个坐标轴正交且具有最大方差的方向。该过程一直重复，重复次数为原始数据中特征的数目。会发现大部分方差都包含在最前面的几个新坐标轴中。因此，可以忽略余下的坐标轴，即对数据进行了降维处理。除了PCA主成分分析技术，其他降维技术还有ICA(独立成分分析)，因子分析等。&lt;/p&gt;
&lt;p&gt;(6) 将不同的分类器组合起来，而这种组合结果则被称为集成方法（ensemble method）或者元算法（meta-algorithm）。&lt;/p&gt;
&lt;p&gt;(7) 回归算法和分类算法很像，不过回归算法和分类算法输出标称型类别值不同的是，回归方法会预测出一个连续的值，即回归会预测出具体的数据，而分类只能预测类别。&lt;/p&gt;
&lt;p&gt;(8) SVD(singular value decomposition) 奇异值分解:&lt;br&gt;
优点：简化数据，去除噪声，提高算法的结果。&lt;br&gt;
缺点：数据转换可能难以理解。&lt;br&gt;
适用数据类型：数值型数据。
ps:SVD是矩阵分解的一种类型。&lt;/p&gt;
&lt;p&gt;总结：SVD是一种强大的降维工具，我们可以利用SVD来逼近矩阵并从中提取重要特征。通过保留矩阵80%~90%的能量，就可以得到重要的特征并去掉噪声。SVD已经运用到多个应用中，其中一个成功的应用案例就是推荐引擎。推荐引擎将物品推荐给用户，协同过滤则是一种基于用户喜好和行为数据的推荐和实现方法。协同过滤的核心是相似度计算方法，有很多相似度计算方法都可以用于计算物品或用户之间的相似度。通过在低维空间下计算相似度，SVD提高了推荐引擎的效果。&lt;/p&gt;
&lt;p&gt;(9)共线性：是指线性回归模型中的解释变量之间由于存在精确的相关关系或高度相关关系而使模型估计失真或难以估计。&lt;/p&gt;
&lt;h2&gt;2.基本算法&lt;/h2&gt;
&lt;p&gt;2.1 Logistic回归：&lt;br&gt;
优点：计算代价不高，易于理解和实现。&lt;br&gt;
缺点：容易欠拟合，分类精度可能不高。&lt;br&gt;
适用数据类型：数值型和标称型数据。&lt;br&gt;
类别：分类算法。
试用场景：解决二分类问题。&lt;/p&gt;
&lt;p&gt;简述：Logistic回归算法基于Sigmoid函数，或者说Sigmoid就是逻辑回归函数。Sigmoid函数定义如下：1/（1+exp（-z))。函数值域范围(0,1)。可以用来做分类器。
Sigmoid函数的函数曲线如下：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;逻辑回归模型分解如下： (1)首先将不同维度的属性值和对应的一组权重加和:&lt;br&gt;
公式如下： z = w0+w1x1+w2x2+…+wm*xm。（其中x1,x2,…,xm是某样本数据的各个特征，维度为m）&lt;br&gt;
ps：这里就是一个线性回归。W权重值就是需要经过训练学习到的数值，具体W向量的求解，就需要用到极大似然估计和将似然估计函数代入到 优化算法来求解。最常用的最后化算法有 梯度上升算法。
由上面可见：逻辑回归函数虽然是一个非线性的函数，但其实其去除Sigmoid映射函数之后，其他步骤都和线性回归一致。&lt;/p&gt;
&lt;p&gt;(2)然后将上述的线性目标函数 z 代入到sigmond逻辑回归函数，可以得到值域为（0,0.5)和（0.5,1）两类值，等于0.5的怎么处理还以自己定。这样其实就得到了2类数据，也就体现了二分类的概念。&lt;/p&gt;
&lt;p&gt;总结：Logistic回归的目的是寻找一个非线性函数Sigmoid的最佳拟合参数，参数的求解过程可以由最优化算法来完成。在最优化算法中，最常用的就是梯度上升算法，而梯度上升算法有可以简化为随机梯度上升算法。&lt;/p&gt;
&lt;p&gt;2.2 SVM(Support Vector Machines) 支持向量机：&lt;/p&gt;
&lt;p&gt;优点：泛化错误率低，计算开销不大，结果易解释。&lt;br&gt;
缺点：对参数调节和核函数的选择敏感，原始分类器不加修改仅适用于处理二分类问题。&lt;br&gt;
适用数据类型：数值型和标称型数据。&lt;br&gt;
类别：分类算法。
试用场景：解决二分类问题。&lt;/p&gt;
&lt;p&gt;简述：通俗的讲，SVM是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，即支持向量机的学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。或者简单的可以理解为就是在高维空间中寻找一个合理的超平面将数据点分隔开来，其中涉及到非线性数据到高维的映射以达到数据线性可分的目的。&lt;/p&gt;
&lt;p&gt;支持向量概念：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;上面样本图是一个特殊的二维情况，真实情况当然可能是很多维。先从低纬度简单理解一下什么是支持向量。从图中可以看到3条线，中间那条红色的线到其他两条先的距离相等。这条红色的就是SVM在二维情况下要寻找的超平面，用于二分类数据。而支撑另外两条线上的点就是所谓的支持向量。从图中可以看到，中间的超平面和另外两条线中间是没有样本的。找到这个超平面后，利用超平面的数据数学表示来对样本数据进行二分类，就是SVM的机制了。&lt;/p&gt;
&lt;p&gt;ps： 《机器学习实战》书中有这么几个概念：&lt;/p&gt;
&lt;p&gt;(1)如果能找到一个直线（或多维的面）将样本点分开，那么这组数据就是线性可分的。将上述数据集分隔开来的直线(或多维的面)称为分隔超平面。分布在超平面一侧的数据属于一个类别，分布在超平面另一侧的数据属于另一个类别&lt;br&gt;
(2)支持向量（Support vector）就是分离超平面最近的那些点。
(3)几乎所有分类问题都可以使用SVM，值得一提的是，SVM本身是一个二分类分类器，对多类问题应用SVM需要对代码做一些修改。&lt;/p&gt;
&lt;p&gt;公式：&lt;br&gt;
SVM有很多实现，但是本章值关注其中最流行的一种实现，及序列最小优化（Sequential Minimal Optimization，SMO）算法。
其公式如下：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;SMO算法的目标是求出一些列的alpha，一旦求出了alpha，就很容易计算出权重向量w并得到分隔超平面。&lt;/p&gt;
&lt;p&gt;SMO算法的工作原理是：每次循环中选择两个alpha进行优化处理。一旦找到一对合适的alpha，那么就增大其中一个同时减小另一个。这里所谓的“合适”就是指两个alpha必须符合一定的条件，条件之一就是这两个alpha必须要在间隔边界之外，而其第二个条件则是这两个alpha还没有进行过区间化处理或者不在边界上。&lt;/p&gt;
&lt;p&gt;核函数将数据从低维度映射到高维：
SVM是通过寻找超平面将数据进行分类的，但是当数据不是线性可分的时候就需要利用核函数将数据从低维映射到高维使其线性可分后，在应用SVM理论。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;这个二维数据分布不是线性可分的，其方程为：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;但是通过核函数维度映射后，其变为：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;对应的方程为：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;这样映射后的数据就变成了线性可分的，就可以应用SVM理论了。&lt;/p&gt;
&lt;p&gt;总结：支持向量机是一种分类器。之所以成为“机”是因为他会产生一个二值决策结果，即它是一种‘决策’机。核方法或者说核技巧会将数据（有时是非线性数据）从一个低维空间映射到一个高维空间，可以将一个在低维空间中的非线性问题转换为高维空间下的线性问题来求解。&lt;/p&gt;
&lt;p&gt;2.3 决策树&lt;br&gt;
： 优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据。&lt;br&gt;
缺点：可能会产生匹配过度问题。&lt;br&gt;
适用数据类型：数值型和标称型。&lt;br&gt;
算法类型：分类算法。
数据要求：树的构造只适用于标称型的数据，因此数值型数据必须离散化。&lt;/p&gt;
&lt;p&gt;简述：在构造决策树时，我们需要解决的第一个问题就是，当前数据集上哪个特征在划分数据分类时起决定性作用。为了找到决定性特征，划分出最好的结果，我们必须评估每个特征。完成测试后，原始数据就被划分为几个数据子集。这些数据的子集分布在第一个决策点的所有分支上，如果某个分支下的数据属于同一个类型，则无需进一步对数据集进行切割。反之则需要进一步切割。&lt;/p&gt;
&lt;p&gt;创建分支的伪代码如下：&lt;/p&gt;
&lt;pre&gt;     检测数据集中的每个子项是否属于同一分类：
        if so return 类标签；
        else
            寻找数据集的最好特征
            划分数据集
            创建分支结点
                for 每个划分的子集
                    调用函数createBranch并增加返回结果到分支结点中
                return 分支结点&lt;/pre&gt;
&lt;p&gt;在可以评测哪种数据划分方式是最好的数据划分之前，我们必须学习如何计算信息增益。集合的信息度量方式称为香农熵或者简称为熵。熵在信息论中定义为信息的期望值。&lt;br&gt;
信息熵的计算公式为：
H(信息熵) = -∑ P（xi） log2P（xi） ps:其中p（xi）表示选择该分类的概率。&lt;/p&gt;
&lt;p&gt;下面简述一下生成决策树的步骤：&lt;br&gt;
(1) 根据给定的训练数据，根据熵最大原则根据每一个维度来划分数据集，找到最关键的维度。&lt;br&gt;
(2) 当某个分支下所有的数据都数据同一分类则终止划分并返回类标签，否则在此分支上重复实施(1)过程。&lt;br&gt;
(3) 依次计算就将类标签构建成了一棵抉择树。&lt;br&gt;
(4) 依靠训练数据构造了决策树之后，我们就可以将它用于实际数据的分类。
ps:当然生成决策树的算法不止这一个，还有其他一些生成决策树的方法，比如：C4.5和CART。&lt;/p&gt;
&lt;p&gt;总结：
决策树分类器就像带有终止块的流程图，终止块表示分类结果。开始处理数据集时，我们首先需要测量集合中数据的不一致性，也就是熵，然后寻找最优的方案划分数据集，直到数据集中的所有数据属于同一个分类。&lt;/p&gt;
&lt;p&gt;2.4 朴素贝叶斯：&lt;br&gt;
优点：在数据较少的情况下仍然有效，可以处理多类别问题。&lt;br&gt;
缺点：对于输入数据的准备方式较为敏感。&lt;br&gt;
适用的数据类型：标称型数据。
算法类型：分类算法&lt;/p&gt;
&lt;p&gt;简述：朴素贝叶斯是贝叶斯理论的一部分，贝叶斯决策理论的核心思想，即选择具有高概率的决策。朴素贝叶斯之所以冠以朴素开头，是因为其在贝叶斯理论的基础上做出了两点假设：&lt;br&gt;
(1)每个特征之间相互独立。&lt;br&gt;
(2)每个特征同等重要。
贝叶斯准则是构建在条件概率的基础之上的，其公式如下：&lt;/p&gt;
&lt;p&gt;P（H|X）=P（X|H)P（H)/P(X)&lt;/p&gt;
&lt;p&gt;ps：P（H|X）是根据X参数值判断其属于类别H的概率，称为后验概率。P（H)是直接判断某个样本属于H的概率，称为先验概率。P（X|H)是在类别H中观测到X的概率（后验概率），P(X)是在数据库中观测到X的概率。可见贝叶斯准则是基于条件概率并且和观测到样本的先验概率和后验概率是分不开的。&lt;/p&gt;
&lt;p&gt;总结：对于分类而言，使用概率有事要比使用硬规则更为有效。贝叶斯概率及贝叶斯准则提供了一种利用已知值来估计未知概率的有效方法。可以通过特征之间的条件独立性假设，降低对数据量的需求。尽管条件独立性的假设并不正确，但是朴素贝叶斯仍然是一种有效的分类器。&lt;/p&gt;
&lt;p&gt;2.5 K-近邻算法（KNN）:&lt;br&gt;
优点：精度高、对异常值不敏感、无数据输入假定。&lt;br&gt;
缺点：计算复杂度高，空间复杂度搞。&lt;br&gt;
适用数据范围：数值型和标称型。
算法类型：分类算法。&lt;/p&gt;
&lt;p&gt;简述：算法原理，存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征和样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。最后选择k个最相似数据中出现次数最多的分类，作为新数据的分类。&lt;/p&gt;
&lt;p&gt;2.6 线性回归(Linear Regression)：&lt;br&gt;
优点：结果易于理解，计算上不复杂。&lt;br&gt;
缺点：对非线性数据拟合不好。&lt;br&gt;
适用数据类型：数值型和标称型数据。&lt;br&gt;
算法类型：回归算法。
ps:回归于分类的不同，就在于其目标变量时连续数值型。&lt;/p&gt;
&lt;p&gt;简述：在统计学中，线性回归（Linear Regression）是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合（自变量都是一次方）。只有一个自变量的情况称为简单回归，大于一个自变量情况的叫做多元回归。&lt;/p&gt;
&lt;p&gt;线性方程的模型函数的向量表示形式为：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;通过训练数据集寻找向量系数的最优解，即为求解模型参数。其中求解模型系数的优化器方法可以用“最小二乘法”、“梯度下降”算法，来求解损失函数：&lt;/p&gt;
&lt;p&gt;的最优值。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;附加：岭回归（ridge regression）:
岭回归是一种专用于共线性数据分析的有偏估计回归方法，实质上是一种改良的最小二乘估计法，通过放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价，获得回归系数更为符合实际、更可靠的回归方法，对病态数据的耐受性远远强于最小二乘法。&lt;/p&gt;
&lt;p&gt;岭回归分析法是从根本上消除复共线性影响的统计方法。岭回归模型通过在相关矩阵中引入一个很小的岭参数K（1&amp;gt;K&amp;gt;0），并将它加到主对角线元素上，从而降低参数的最小二乘估计中复共线特征向量的影响，减小复共线变量系数最小二乘估计的方法，以保证参数估计更接近真实情况。岭回归分析将所有的变量引入模型中，比逐步回归分析提供更多的信息。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;总结：与分类一样，回归也是预测目标值的过程。回归与分类的不同点在于，前者预测连续型的变量，而后者预测离散型的变量。回归是统计学中最有力的工具之一。在回归方程里，求得特征对应的最佳回归系统的方法是最小化误差的平方和。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;2.7 树回归:&lt;br&gt;
优点：可以对复杂和非线性的数据建模。&lt;br&gt;
缺点：结果不易理解。&lt;br&gt;
适用数据类型：数值型和标称型数据。
算法类型：回归算法。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;简述：线性回归方法可以有效的拟合所有样本点(局部加权线性回归除外）。当数据拥有众多特征并且特征之间关系十分复杂时，构建全局模型的回归算法是比较困难的。此外，实际中很多问题为非线性的，例如常见的分段函数，不可能用全局线性模型类进行拟合。树回归将数据集切分成多份易建模的数据，然后利用线性回归进行建模和拟合。较为经典的树回归算法为CART（classification and regreesion trees 分类回归树）。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;CART算法的详细描述可以看这篇文章：http://box.cloud.taobao.com/file/downloadFile.htm?shareLink=1GIQrknG （说实话，大体了解，看的不太懂,谁了解的比较透彻可以分享下）。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;2.8 K-Means(K 均值算法)：&lt;br&gt;
优点：容易实现。&lt;br&gt;
缺点：可能收敛到局部最小值，在大规模数据集上收敛较慢。&lt;br&gt;
适用数据类型：数值型数据。&lt;br&gt;
算法类型：聚类算法。
ps:K-Means和上面的分类和回归算法不同，它属于非监督学习算法。类似分类和回归中的目标变量事先并不存在。与前面“对于数据变量X能预测变量Y”不同的是，非监督学习算法要回答的问题是：“从数据X中能发现什么？“，这里需要回答的X方面可能的问题是：”构成X的最佳6个数据簇都是哪些“或者”X中哪三个特征最频繁共现？“。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;K-Means的基本步骤：&lt;br&gt;
(1) 从数据对象中随机的初始化K个初始点作为质心。然后将数据集中的每个点分配到一个簇中，具体来讲每个点找到距其最近的质心，并将其分配给该质心所对应的簇。&lt;br&gt;
(2) 计算每个簇中样本点的均值，然后用均值更新掉该簇的质心。然后划分簇结点。&lt;br&gt;
(3) 迭代重复（2）过程，当簇对象不再发生变化时，或者误差在评测函数预估的范围时，停止迭代。&lt;br&gt;
算法的时间复杂度上界为O(nkt), 其中t是迭代次数。&lt;br&gt;
ps:初始的K个质心的选取以及距离计算公式的好坏，将影响到算法的整体性能。&lt;br&gt;
附加：
二分K-均值算法:为克服K-均值算法收敛于局部最小值的问题，有人提出了另一个称为二分K-均值（bisecting K-Means）的算法。该算法首先将所有点作为一个簇，然后将簇一分为二。之后选择其中一个簇继续划分，选择哪个一簇进行划分取决于对其划分是否可以最大程度降低SSE(Sum of Squared Error，两个簇的总误差平方和)的值。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;2.9 算法关联分析:&lt;br&gt;
首先了两个概念：&lt;br&gt;
频繁项集（frequent item sets）:经常出现在一块的物品的集合。&lt;br&gt;
关联规则（association rules）：暗示两种物品间可能存在很强的关系。&lt;br&gt;
项集的支持度（support）：数据集中包含该项集记录所占的比例。
关联分析的目标包括两项：发现频繁项集合发现关联规则。首先找到频繁项集，然后才能获得关联规则。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;Apriori算法：&lt;br&gt;
优点：易编码实现。&lt;br&gt;
缺点：在大型数据集上可能较慢。&lt;br&gt;
适用数据类型：数值型或标称型数据。&lt;br&gt;
原理：如果某个项集时频繁的，那么他的所有子集也是频繁的。&lt;br&gt;
Apriori运用的DEMO示例参见博客：http://blog.csdn.net/lantian0802/article/details/38331463&lt;br&gt;
简述：
Apriori算法是发现频繁项集的一种方法。Apriori算法的两个输入参数分别是最小支持度和数据集。该算法首先会生成所有单个item的项集列表。然后扫描列表计算每个item的项集支持度，将低于最小支持度的item排除掉，然后将每个item两两组合，然后重新计算整合后的item列表的支持度并且和最小支持度比较。重复这一过程，直至所有项集都被去掉。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;总结：
关联分析是用于发现大数据集中元素间有趣关系的一个工具集，可以采用两种方式来量化这些有趣的关系。发现元素间不同的组合是个十分耗时的任务，不可避免需要大量昂贵的计算资源，这就需要一些更智能的方法在合理的时间范围内找到频繁项集。能够实现这一目标的一个方法是Apriori算法，它使用Apriori原理来减少在数据库上进行检查的集合的数目。Apriori原理是说如果一个元素是不频繁的，那么那些包含该元素的超集也是不频繁的。Apriori算法从单元素项集开始，通过组合满足最小支持度要求的项集来形成更大的集合。支持度用来度量一个集合在原始数据中出现的频率。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;2.10 FP-growth算法：
简述：FP-growth也是用于发现频繁项集的算法，他以FP树的结构存储构建元素，其他Apriori算法的性能要好很多。通常性能要好2个数量级以上。其发现频繁项集的过程如下：(1)构建FP树。(2)从FP树中挖掘频繁项集。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;优点：一般要快于Apriori。&lt;br&gt;
缺点：实现比较困难，在某些数据集上性能会下降。
适用数据类型：标称型数据。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;总结：FP-growth算法是一种用于发现数据集中频繁模式的有效方法。FP-growth算法利用Apriori原则，执行更快。Apriori算法产生候选项集，然后扫描数据集来检查他们是否频繁。由于只对数据集扫描两次，因此FP-growth算法执行更快。在FP-growth算法中，数据集存储在一个称为FP树的结构中。FP树构建完成后，可以通过查找元素项的条件及FP树来发现频繁项集。该过程不断以更多元素作为条件重复进行，直到FP树只包含一个元素为止。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Sat, 02 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-02-74716-e47d709de.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-02-74716-e47d709de.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>算法系列：计数排序</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Counting_sort&quot;&gt;计数排序&lt;/a&gt;可能是最简单的一种排序，它可以被用来对一个列表进行排序，并且是&lt;a href=&quot;https://en.wikipedia.org/wiki/Radix_sort&quot;&gt;基数排序&lt;/a&gt;的一个关键部分。这两者都是被发明的，这篇文章我将解释计数排序并且用C写出来。&lt;/p&gt;
&lt;ul&gt;

&lt;/ul&gt;
&lt;p&gt;计数排序非常基础，他的主要目的是对整数排序并且会比普通的排序算法性能更好。例如，输入{1, 3, 5, 2, 1, 4}给计数排序，会输出{1, 1, 2, 3, 4, 5}。这个算法由以下步骤组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;li&gt;遍历输入数组，遇到一个数就在计数数组对应的位置上加一。例如：遇到5，就将计数数组第五个位置的数加一。&lt;/li&gt;

&lt;/ol&gt;
&lt;ul&gt;

&lt;/ul&gt;
&lt;p&gt;输入{3, 4, 3, 2, 1}，最大是4，数组长度是5。&lt;/p&gt;
&lt;p&gt;建立计数数组{0, 0, 0, 0}。&lt;/p&gt;
&lt;p&gt;遍历输入数组：&lt;/p&gt;
&lt;p&gt;{&lt;strong&gt;3&lt;/strong&gt;, 4, 3, 2, 1} -&amp;gt; {0, 0, &lt;strong&gt;1&lt;/strong&gt;, 0}&lt;br&gt;
{3, &lt;strong&gt;4&lt;/strong&gt;, 3, 2, 1} -&amp;gt; {0, 0, 1, &lt;strong&gt;1&lt;/strong&gt;}&lt;br&gt;
{3, 4, &lt;strong&gt;3&lt;/strong&gt;, 2, 1} -&amp;gt; {0, 0, &lt;strong&gt;2&lt;/strong&gt;, 1}&lt;br&gt;
{3, 4, 3, &lt;strong&gt;2&lt;/strong&gt;, 1} -&amp;gt; {0, &lt;strong&gt;1&lt;/strong&gt;, 2, 1}&lt;br&gt;
{3, 4, 3, 2, &lt;strong&gt;1&lt;/strong&gt;} -&amp;gt; {, 1, 2, 1}&lt;/p&gt;
&lt;p&gt;计数数组现在是{1, 1, 2, 1}，我们现在把它写回到输入数组里：&lt;/p&gt;
&lt;p&gt;{&lt;strong&gt;0&lt;/strong&gt;, 1, 2, 1} -&amp;gt; {&lt;strong&gt;1&lt;/strong&gt;, 4, 3, 2, 1}&lt;br&gt;
{o, &lt;strong&gt;o&lt;/strong&gt;, 2, 1} -&amp;gt; {1, &lt;strong&gt;2&lt;/strong&gt;, 3, 2, 1}&lt;br&gt;
{o, o, &lt;strong&gt;1&lt;/strong&gt;, 1} -&amp;gt; {1, 2, &lt;strong&gt;3&lt;/strong&gt;, 2, 1}&lt;br&gt;
{o, o, &lt;strong&gt;o&lt;/strong&gt;, 1} -&amp;gt; {1, 2, 3, &lt;strong&gt;3&lt;/strong&gt;, 1}&lt;br&gt;
{o, o, o, &lt;strong&gt;o&lt;/strong&gt;} -&amp;gt; {1, 2, 3, 3, }&lt;/p&gt;
&lt;p&gt;这样就排好序了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;

&lt;/ul&gt;
&lt;ul&gt;

&lt;/ul&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void printArray(int * array, int size){

  int curr;
  for(curr = 0; curr &amp;lt; size; curr++){
    printf(&quot;%d, &quot;, array[curr]);
  }
  printf(&quot;\n&quot;);
}

int maximum(int * array, int size){

  int curr = 0;
  int max = 0;

  for(curr = 0; curr &amp;lt; size; curr++){
    if(array[curr] &amp;gt; max){ max = array[curr]; }
  }

  return max;
}

void countingSort(int * array, int size){

  int curr = 0;
  int max = maximum(array, size);
  int * counting_array = calloc(max, sizeof(int)); // Zeros out the array

  for(curr = 0; curr &amp;lt; size; curr ++){
    counting_array[array[curr]]++;
  }

  int num = 0;
  curr = 0;

  while(curr &amp;lt;= size){
    while(counting_array[num] &amp;gt; 0){
      array[curr] = num;
      counting_array[num]--;
      curr++;
      if(curr &amp;gt; size){ break; }
    }
    num++;
  }
  printArray(array, size);
}

int main(){

  int test1[] = {2, 6, 4, 3, 2, 3, 4, 6, 3, 4, 3, 5, 2, 6};
  int size1 = 14;

  countingSort(test1, size1);

  int test2[] = {5, 6, 7, 8, 5};
  int size2 = 5;

  countingSort(test2, size2);

  int test3[] = {8, 1, 2, 3, 3, 4};
  int size3 = 6;

  countingSort(test3, size3);

  return 0;
}&lt;/pre&gt;
&lt;p&gt;插播一句：如果你编程有困难，无妨看看。&lt;/p&gt;
&lt;ul&gt;

&lt;/ul&gt;
&lt;p&gt;不幸的是，这个算法的简洁性同时也是它的弱点。很多程序员不需要对整数排序，至少他们觉得他们不需要。其实通常非整数都可以被规约为整数，然后再用计数排序或者基数排序（基数排序就是多加了一层，这样会快一些）。谷歌一下可以有不少结果，比如。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Fri, 01 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-08-01-74574-360ecc2bb.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-08-01-74574-360ecc2bb.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
  </channel>
</rss>
