<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IT技术干货</title>
    <description>[IT技术干货iftti.com] @KernelHacks</description>
    <link>http://iftti.com/</link>
    <atom:link href="http://iftti.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 14 Jun 2015 21:59:49 +0800</pubDate>
    <lastBuildDate>Sun, 14 Jun 2015 21:59:49 +0800</lastBuildDate>
    <generator>Jekyll v2.2.0</generator>
    
      <item>
        <title>Linux运维工程师入门须掌握的10个技术点</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt; 本人是linux运维工程师，对这方面有点心得，现在我说说要掌握哪方面的工具吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;说到工具，在行外可以说是技能，在行内我们一般称为工具，就是运维必须要掌握的工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;我就大概列出这几方面，这样入门就基本没问题了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;linux系统如果是学习可以选用redhat或centos，特别是centos在企业中用得最多，当然还会有其它版本的，但学习者还是以这2个版本学习就行，因为这两个版本都是兄弟，没区别的，有空可以再研究一下SUSE，有些公司也喜欢用，例如我公司 。。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;工具如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;1、linux系统基础，这个不用说了，是基础中的基础，连这个都不会就别干了，参考书籍，可以看鸟哥linux基础篇，至少要掌握这书60%内容，没必须全部掌握，但基本命令总得会吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;2、网络服务，服务有很多种，每间公司都会用到不同的，但基础的服务肯定要掌握，如FTP, DNS,SAMBA, 邮件, 这几个大概学一下就行，LAMP和LNMP是必须要熟练，我所指的不是光光会搭建，而是要很熟悉里面的相当配置才行，因为公司最关键的绝对是WEB服务器，所以nginx和apache要熟悉，特别是nginx一定要很熟悉才行，至少有些公司还会用tomcat，这个也最好学一下。其实网络服务方面不用太担心，一般公司的环境都已经搭建好，就算有新服务器或让你整改，公司会有相应的文档让你参照来弄，不会让你乱来的，但至少相关的配置一定要学熟，而且肯定是编译安装多，那些模块要熟悉一下他的作用，特别是PHP那些模块。&lt;/span&gt;&lt;br&gt;
&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;这面2点只是基础，也是必要条件，不能说是工具，下以才是真正的要掌握的工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;3、shell脚本和另一个脚本语言，shell是运维人员必须具备的，不懂这个连入职都不行，至少也要写出一些系统管理脚本，最简单也得写个监控CPU，内存比率的脚本吧，这是最最最基本了，别以为会写那些猜数字和计算什么数的，这些没什么作用，只作学习意义，写系统脚本才是最有意义，而另一个脚本语言是可选的，一般是3P，即python, perl和php，php就不需要考虑了，除非你要做开发，我个人建议学python会比较好，难实现自动化运维，perl是文本处理很强大，反正这两个学一个就行了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;4、sed和awk工具，必须要掌握，在掌握这两个工具同时，还要掌握正则表达式，这个就痛苦了，正则是最难学的表达式，但结合到sed和awk中会很强大，在处理文本内容和过滤WEB内容时十分有用，不过在学shell的同时一般会经常结合用到的，所以学第3点就会顺便学第4点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;5、文本处理命令，sort , tr , cut, paste, uniq, tee等，必学，也是结合第3点时一并学习的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;6、数据库，首选mysql，别问我为什么不学sqlserver和oracle，因为linux用得最多绝对是mysql，增删改查必学，特别要学熟查，其它方面可能不太需要，因为运维人员使用最多还是查，哪些优化和开发语句不会让你弄的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;7、防火墙，不学不行，防火墙也算是个难点，说难不难，说易不易，最重要弄懂规则，如果学过CCNA的朋友可能会比较好学，因为iptables也有NAT表，原理是一样的，而FILTER表用得最多，反正不学就肯定不合格。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;8、监控工具，十分十分重要，我个人建议，最好学这3个，cacti，nagios，zibbix，企业用得最多应该是nagios和 zibbix，反正都学吧，但nagios会有点难，因为会涉及到用脚本写自动监控，那个地方很难。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;9、集群和热备，这个很重要，肯定要懂的，但到了公司就不会让你去弄，因为新手基本不让你碰，集群工具有很多，最好学是LVS，这是必学，最好也学学nginx集群，反向代理，还有热备，这个就更多工具能实现了，像我公司是自己开发热备工具的，mysql热备也要学，就是主从复制，这个别告诉我容易，其实不容易的，要学懂整个流程一点也不容易，只照着做根本没意思。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;10、数据备份，不学不行，工具有很多，但至少要把RAID的原理弄懂，特别是企业最常用的1+0或0+1，自己做实验也要弄出来，备份工具有很多，如tar, dump, rsync等，最好多了解一下。&lt;/span&gt;&lt;br&gt;
&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;算了，说到这10点已经够你受了，应该可以入门了，因为有些技术会比较难学，例如apache和nginx中还有些很重要的技术，如系统调优和服务优化，还有程序优化，这些在没接触工作前很难学习到的，所以先把这10点学了吧，估计要学熟至少3个月不止，就脚本那部分已经让你很吃力了，我建议是先学熟shell，等工作后再学另一门脚本语言，这样会比较好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Arial, 宋体&quot;&gt;以上就是踏入linux运维工程师需要掌握的工具，其实还有很多工具要掌握的，但你在学习环境中是很难学到，最后我再提醒一下，这里所指的工具相当于技能，而不是像windows或ubuntu那些图形化工具，那些工具没用的，还有，学linux就别装图形界面，这样虚拟机就不用吃太多内存，而且绝对不建议在真机上装linux，&lt;/span&gt;根本达不到学习效果。&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87542&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87542votetotal&quot;&gt;3&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87542&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt; 1 收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sun, 14 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-14-87542-8e2d214cf.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-14-87542-8e2d214cf.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Nginx 服务器安装及配置文件详解</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;Nginx 在工作中已经有好几个环境在使用了，每次都是重新去网上找博客，各种编译配置，今天自己也整理一份安装文档和 nginx.conf 配置选项的说明，留作以后参考。&lt;/p&gt;
&lt;h1 id=&quot;1-_安装nginx&quot;&gt;1. 安装nginx&lt;/h1&gt;
&lt;h2 id=&quot;1-1_选择稳定版本&quot;&gt;1.1 选择稳定版本&lt;/h2&gt;
&lt;p&gt;我们编译安装nginx来定制自己的模块，机器CentOS 6.2 x86_64。首先安装缺少的依赖包：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;# yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel&lt;/pre&gt;
&lt;p&gt;这些软件包如果yum上没有的话可以下载源码来编译安装，只是要注意编译时默认安装的目录，确保下面在安装nginx时能够找到这些动态库文件（ldconfig）。&lt;/p&gt;
&lt;p&gt;从 &lt;a href=&quot;http://nginx.org/en/download.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nginx.org/en/download.html&lt;/a&gt; 下载稳定版&lt;code&gt;nginx-1.6.3.tar.gz&lt;/code&gt;到&lt;code&gt;/usr/local/src&lt;/code&gt;下解压。&lt;/p&gt;
&lt;p&gt;为了后续准备我们另外下载2个插件模块：&lt;a href=&quot;https://github.com/yaoweibin/nginx_upstream_check_module/releases&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nginx_upstream_check_module-0.3.0.tar.gz&lt;/a&gt; —— 检查后端服务器的状态，&lt;a href=&quot;https://bitbucket.org/nginx-goodies/nginx-sticky-module-ng/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nginx-goodies-nginx-sticky-module-ng-bd312d586752.tar.gz&lt;/a&gt;（建议在/usr/local/src下解压后将目录重命名为&lt;code&gt;nginx-sticky-module-ng-1.2.5&lt;/code&gt;） —— 后端做负载均衡解决session sticky问题（与upstream_check模块结合使用需要另外打补丁，请参考&lt;a href=&quot;http://seanlook.com/2015/06/02/nginx-cache-check/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nginx负载均衡配置实战&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;请注意插件与nginx的版本兼容问题，一般插件越新越好，nginx不用追新，稳定第一。nginx-1.4.7，nginx-sticky-module-1.1，nginx_upstream_check_module-0.2.0，这个搭配也没问题。sticky-1.1与nginx-1.6版本由于更新没跟上编译出错。（可以直接使用Tengine，默认就包括了这些模块）&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;[root@cachets nginx-1.6.3]# pwd
/usr/local/src/nginx-1.6.3
[root@cachets nginx-1.6.3]# ./configure --prefix=/usr/local/nginx-1.6 --with-pcre \
&amp;gt; --with-http_stub_status_module --with-http_ssl_module \
&amp;gt; --with-http_gzip_static_module --with-http_realip_module \
&amp;gt; --add-module=../nginx_upstream_check_module-0.3.0
 
[root@cachets nginx-1.6.3]# make &amp;amp;&amp;amp; make install&lt;/pre&gt;
&lt;h2 id=&quot;1-2_常用编译选项说明&quot;&gt;1.2 常用编译选项说明&lt;/h2&gt;
&lt;p&gt;nginx大部分常用模块，编译时&lt;code&gt;./configure --help&lt;/code&gt;以&lt;code&gt;--without&lt;/code&gt;开头的都默认安装。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;--prefix=PATH&lt;/code&gt; ： 指定nginx的安装目录。默认 &lt;code&gt;/usr/local/nginx&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--conf-path=PATH&lt;/code&gt; ： 设置nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的-c选项。默认为&lt;em&gt;prefix/conf/nginx.conf&lt;/em&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--user=name&lt;/code&gt;： 设置nginx工作进程的用户。安装完成后，可以随时在nginx.conf配置文件更改user指令。默认的用户名是nobody。&lt;code&gt;--group=name&lt;/code&gt;类似&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--with-pcre&lt;/code&gt; ： 设置PCRE库的源码路径，如果已通过yum方式安装，使用&lt;code&gt;--with-pcre&lt;/code&gt;自动找到库文件。使用&lt;code&gt;--with-pcre=PATH&lt;/code&gt;时，需要从PCRE网站下载pcre库的源码（版本4.4 – 8.30）并解压，剩下的就交给Nginx的&lt;code&gt;./configure&lt;/code&gt;和&lt;code&gt;make&lt;/code&gt;来完成。perl正则表达式使用在&lt;code&gt;location&lt;/code&gt;指令和 &lt;code&gt;ngx_http_rewrite_module&lt;/code&gt;模块中。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--with-zlib=PATH&lt;/code&gt; ： 指定 zlib（版本1.1.3 – 1.2.5）的源码解压目录。在默认就启用的网络传输压缩模块&lt;code&gt;ngx_http_gzip_module&lt;/code&gt;时需要使用zlib 。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--with-http_ssl_module&lt;/code&gt; ： 使用https协议模块。默认情况下，该模块没有被构建。前提是openssl与openssl-devel已安装&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--with-http_stub_status_module&lt;/code&gt; ： 用来监控 Nginx 的当前状态&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--with-http_realip_module&lt;/code&gt; ： 通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如X-Real-IP 或 X-Forwarded-For)，意义在于能够使得后台服务器记录原始客户端的IP地址&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--add-module=PATH&lt;/code&gt; ： 添加第三方外部模块，如nginx-sticky-module-ng或缓存模块。每次添加新的模块都要重新编译（Tengine可以在新加入module时无需重新编译）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;再提供一种编译方案&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;./configure \
&amp;gt; --prefix=/usr \
&amp;gt; --sbin-path=/usr/sbin/nginx \
&amp;gt; --conf-path=/etc/nginx/nginx.conf \
&amp;gt; --error-log-path=/var/log/nginx/error.log \
&amp;gt; --http-log-path=/var/log/nginx/access.log \
&amp;gt; --pid-path=/var/run/nginx/nginx.pid \
&amp;gt; --lock-path=/var/lock/nginx.lock \
&amp;gt; --user=nginx \
&amp;gt; --group=nginx \
&amp;gt; --with-http_ssl_module \
&amp;gt; --with-http_stub_status_module \
&amp;gt; --with-http_gzip_static_module \
&amp;gt; --http-client-body-temp-path=/var/tmp/nginx/client/ \
&amp;gt; --http-proxy-temp-path=/var/tmp/nginx/proxy/ \
&amp;gt; --http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \
&amp;gt; --http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \
&amp;gt; --with-pcre=../pcre-7.8
&amp;gt; --with-zlib=../zlib-1.2.3&lt;/pre&gt;
&lt;h2 id=&quot;1-3_启动关闭nginx&quot;&gt;1.3 启动关闭nginx&lt;/h2&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;## 检查配置文件是否正确
# /usr/local/nginx-1.6/sbin/nginx -t
# ./sbin/nginx -V # 可以看到编译选项
 
## 启动、关闭
# ./sbin/nginx # 默认配置文件 conf/nginx.conf，-c 指定
# ./sbin/nginx -s stop
或 pkill nginx
 
## 重启，不会改变启动时指定的配置文件
# ./sbin/nginx -s reload
或 kill -HUP `cat /usr/local/nginx-1.6/logs/nginx.pid`&lt;/pre&gt;
&lt;p&gt;当然也可以将 nginx 作为系统服务管理，下载 &lt;a href=&quot;http://sean-images.qiniudn.com/nginx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nginx&lt;/a&gt; 到&lt;code&gt;/etc/init.d/&lt;/code&gt;，修改里面的路径然后赋予可执行权限。&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;# service nginx {start|stop|status|restart|reload|configtest}&lt;/pre&gt;
&lt;h2 id=&quot;1-4_yum安装&quot;&gt;1.4 yum安装&lt;/h2&gt;
&lt;p&gt;—— 2015-05-22更新&lt;br&gt;
yum安装rpm包会比编译安装简单很多，默认会安装许多模块，但缺点是如果你想以后安装第三方模块那就没办法了。&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;# vi /etc/yum.repo.d/nginx.repo
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=0
enabled=1&lt;/pre&gt;
&lt;p&gt;剩下的就&lt;code&gt;yum install nginx&lt;/code&gt;搞定，也可以&lt;code&gt;yum install nginx-1.6.3&lt;/code&gt;安装指定版本（前提是你去packages里看到有对应的版本，默认是最新版稳定版）。&lt;/p&gt;
&lt;h1 id=&quot;2-_nginx-conf配置文件&quot;&gt;2. nginx.conf配置文件&lt;/h1&gt;
&lt;p&gt;Nginx配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置），每部分包含若干个指令。main部分设置的指令将影响其它所有部分的设置；server部分的指令主要用于指定虚拟主机域名、IP和端口；upstream的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。他们之间的关系式：server继承main，location继承server；upstream既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。&lt;/p&gt;
&lt;p&gt;当前nginx支持的几个指令上下文：&lt;/p&gt;
&lt;h2 id=&quot;2-1_通用&quot;&gt;2.1 通用&lt;/h2&gt;
&lt;p&gt;下面的&lt;code&gt;nginx.conf&lt;/code&gt;简单的实现nginx在前端做反向代理服务器的例子，处理js、png等静态文件，jsp等动态请求转发到其它服务器tomcat：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;user www www;
worker_processes 2;
 
error_log logs/error.log;
#error_log logs/error.log notice;
#error_log logs/error.log info;
 
pid logs/nginx.pid;
 
 
events {
use epoll;
worker_connections 2048;
}
 
 
http {
include mime.types;
default_type application/octet-stream;
 
#log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
# &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
# &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
 
#access_log logs/access.log main;
 
sendfile on;
# tcp_nopush on;
 
keepalive_timeout 65;
 
# gzip压缩功能设置
gzip on;
gzip_min_length 1k;
gzip_buffers 4 16k;
gzip_http_version 1.0;
gzip_comp_level 6;
gzip_types text/html text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;
gzip_vary on;
 
# http_proxy 设置
client_max_body_size 10m;
client_body_buffer_size 128k;
proxy_connect_timeout 75;
proxy_send_timeout 75;
proxy_read_timeout 75;
proxy_buffer_size 4k;
proxy_buffers 4 32k;
proxy_busy_buffers_size 64k;
proxy_temp_file_write_size 64k;
proxy_temp_path /usr/local/nginx/proxy_temp 1 2;
 
# 设定负载均衡后台服务器列表
upstream backend {
#ip_hash;
server 192.168.10.100:8080 max_fails=2 fail_timeout=30s ;
server 192.168.10.101:8080 max_fails=2 fail_timeout=30s ;
}
 
# 很重要的虚拟主机配置
server {
listen 80;
server_name itoatest.example.com;
root /apps/oaapp;
 
charset utf-8;
access_log logs/host.access.log main;
 
#对 / 所有做负载均衡+反向代理
location / {
root /apps/oaapp;
index index.jsp index.html index.htm;
 
proxy_pass http://backend;
proxy_redirect off;
# 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
 
}
 
#静态文件，nginx自己处理，不去backend请求tomcat
location ~* /download/ {
root /apps/oa/fs;
 
}
location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$
{
root /apps/oaapp;
expires 7d;
}
location /nginx_status {
stub_status on;
access_log off;
allow 192.168.10.0/24;
deny all;
}
 
location ~ ^/(WEB-INF)/ {
deny all;
}
#error_page 404 /404.html;
 
# redirect server error pages to the static page /50x.html
#
error_page 500 502 503 504 /50x.html;
location = /50x.html {
root html;
}
}
 
## 其它虚拟主机，server 指令开始
}&lt;/pre&gt;
&lt;h2 id=&quot;2-2_常用指令说明&quot;&gt;2.2 常用指令说明&lt;/h2&gt;
&lt;h3 id=&quot;2-2-1_main全局配置&quot;&gt;2.2.1 main全局配置&lt;/h3&gt;
&lt;p&gt;nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;woker_processes 2&lt;/code&gt;&lt;br&gt;
在配置文件的顶级&lt;em&gt;main&lt;/em&gt;部分，worker角色的工作进程的个数，master进程是接收并分配请求给worker处理。这个数值简单一点可以设置为cpu的核数&lt;code&gt;grep ^processor /proc/cpuinfo | wc -l&lt;/code&gt;，也是 auto 值，如果开启了ssl和gzip更应该设置成与逻辑CPU数量一样甚至为2倍，可以减少I/O操作。如果nginx服务器还有其它服务，可以考虑适当减少。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;worker_cpu_affinity&lt;/code&gt;&lt;br&gt;
也是写在&lt;em&gt;main&lt;/em&gt;部分。在高并发情况下，通过设置cpu粘性来降低由于多CPU核切换造成的寄存器等现场重建带来的性能损耗。如&lt;code&gt;worker_cpu_affinity 0001 0010 0100 1000;&lt;/code&gt; （四核）。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;worker_connections 2048&lt;/code&gt;&lt;br&gt;
写在&lt;em&gt;events&lt;/em&gt;部分。每一个worker进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。nginx作为反向代理服务器，计算公式 &lt;code&gt;最大连接数 = worker_processes * worker_connections/4&lt;/code&gt;，所以这里客户端最大连接数是1024，这个可以增到到8192都没关系，看情况而定，但不能超过后面的&lt;code&gt;worker_rlimit_nofile&lt;/code&gt;。当nginx作为http服务器时，计算公式里面是除以2。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;worker_rlimit_nofile 10240&lt;/code&gt;&lt;br&gt;
写在&lt;em&gt;main&lt;/em&gt;部分。默认是没有设置，可以限制为操作系统最大的限制65535。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;use epoll&lt;/code&gt;&lt;br&gt;
写在&lt;code&gt;events&lt;/code&gt;部分。在Linux操作系统下，nginx默认使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。在操作系统不支持这些高效模型时才使用select。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-2_http服务器&quot;&gt;2.2.2 http服务器&lt;/h3&gt;
&lt;p&gt;与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;sendfile on&lt;/code&gt;&lt;br&gt;
开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，减少用户空间到内核空间的上下文切换。对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;keepalive_timeout 65&lt;/code&gt; : 长连接超时时间，单位是秒，这个参数很敏感，涉及浏览器的种类、后端服务器的超时设置、操作系统的设置，可以另外起一片文章了。长连接请求大量小文件的时候，可以减少重建连接的开销，但假如有大文件上传，65s内没上传完成会导致失败。如果设置时间过长，用户又多，长时间保持连接会占用大量资源。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;send_timeout&lt;/code&gt; : 用于指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx将会关闭连接。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;client_max_body_size 10m&lt;/code&gt;&lt;br&gt;
允许客户端请求的最大单文件字节数。如果有上传较大文件，请设置它的限制值&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;client_body_buffer_size 128k&lt;/code&gt;&lt;br&gt;
缓冲区代理缓冲用户端请求的最大字节数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;模块http_proxy：&lt;/strong&gt;&lt;br&gt;
这个模块实现的是nginx作为反向代理服务器的功能，包括缓存功能（另见&lt;a href=&quot;http://seanlook.com/2015/06/02/nginx-cache-check/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文章&lt;/a&gt;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;proxy_connect_timeout 60&lt;/code&gt;&lt;br&gt;
nginx跟后端服务器连接超时时间(代理连接超时)&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;proxy_read_timeout 60&lt;/code&gt;&lt;br&gt;
连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时)&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;proxy_buffer_size 4k&lt;/code&gt;&lt;br&gt;
设置代理服务器（nginx）从后端realserver读取并保存用户&lt;strong&gt;头&lt;/strong&gt;信息的缓冲区大小，默认与proxy_buffers大小相同，其实可以将这个指令值设的小一点&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;proxy_buffers 4 32k&lt;/code&gt;&lt;br&gt;
proxy_buffers缓冲区，nginx针对单个连接缓存来自后端realserver的&lt;strong&gt;响应&lt;/strong&gt;，网页平均在32k以下的话，这样设置&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;proxy_busy_buffers_size 64k&lt;/code&gt;&lt;br&gt;
高负荷下缓冲大小（proxy_buffers*2）&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;proxy_max_temp_file_size&lt;/code&gt;&lt;br&gt;
当 proxy_buffers 放不下后端服务器的响应内容时，会将一部分保存到硬盘的临时文件中，这个值用来设置最大临时文件大小，默认1024M，它与 proxy_cache 没有关系。大于这个值，将从upstream服务器传回。设置为0禁用。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;proxy_temp_file_write_size 64k&lt;/code&gt;&lt;br&gt;
当缓存被代理的服务器响应到临时文件时，这个选项限制每次写临时文件的大小。&lt;code&gt;proxy_temp_path&lt;/code&gt;（可以在编译的时候）指定写到哪那个目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;proxy_pass，proxy_redirect见 location 部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块http_gzip：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;gzip on&lt;/code&gt; : 开启gzip压缩输出，减少网络传输。
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;gzip_min_length 1k&lt;/code&gt; ： 设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是20。建议设置成大于1k的字节数，小于1k可能会越压越大。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;gzip_buffers 4 16k&lt;/code&gt; ： 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;gzip_http_version 1.0&lt;/code&gt; ： 用于识别 http 协议的版本，早期的浏览器不支持 Gzip 压缩，用户就会看到乱码，所以为了支持前期版本加上了这个选项，如果你用了 Nginx 的反向代理并期望也启用 Gzip 压缩的话，由于末端通信是 http/1.0，故请设置为 1.0。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;gzip_comp_level 6&lt;/code&gt; ： gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu)&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;gzip_types&lt;/code&gt; ：匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;gzip_proxied any&lt;/code&gt; ： Nginx作为反向代理的时候启用，决定开启或者关闭后端服务器返回的结果是否压缩，匹配的前提是后端服务器必须要返回包含”Via”的 header头。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;gzip_vary on&lt;/code&gt; ： 和http头有关系，会在响应头加个 Vary: Accept-Encoding ，可以让前端的缓存服务器缓存经过gzip压缩的页面，例如，用Squid缓存经过Nginx压缩的数据。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-3_server虚拟主机&quot;&gt;2.2.3 server虚拟主机&lt;/h3&gt;
&lt;p&gt;http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server。每个server通过监听地址或端口来区分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;listen&lt;/code&gt;&lt;br&gt;
监听端口，默认80，小于1024的要以root启动。可以为&lt;code&gt;listen *:80&lt;/code&gt;、&lt;code&gt;listen 127.0.0.1:80&lt;/code&gt;等形式。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;server_name&lt;/code&gt;&lt;br&gt;
服务器名，如&lt;code&gt;localhost&lt;/code&gt;、&lt;code&gt;www.example.com&lt;/code&gt;，可以通过正则匹配。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;模块http_stream&lt;/strong&gt;&lt;br&gt;
这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡，&lt;code&gt;upstream&lt;/code&gt;后接负载均衡器的名字，后端realserver以 &lt;code&gt;host:port options;&lt;/code&gt; 方式组织在 {} 中。如果后端被代理的只有一台，也可以直接写在 proxy_pass 。&lt;/p&gt;
&lt;h3 id=&quot;2-2-4_location&quot;&gt;2.2.4 location&lt;/h3&gt;
&lt;p&gt;http服务中，某些特定的URL对应的一系列配置项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;root /var/www/html&lt;/code&gt;&lt;br&gt;
定义服务器的默认网站根目录位置。如果&lt;code&gt;location&lt;/code&gt;URL匹配的是子目录或文件，&lt;code&gt;root&lt;/code&gt;没什么作用，一般放在&lt;code&gt;server&lt;/code&gt;指令里面或&lt;code&gt;/&lt;/code&gt;下。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;index index.jsp index.html index.htm&lt;/code&gt;&lt;br&gt;
定义路径下默认访问的文件名，一般跟着&lt;code&gt;root&lt;/code&gt;放&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;proxy_pass http:/backend&lt;/code&gt;&lt;br&gt;
请求转向backend定义的服务器列表，即反向代理，对应&lt;code&gt;upstream&lt;/code&gt;负载均衡器。也可以&lt;code&gt;proxy_pass http://ip:port&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;proxy_redirect off;&lt;/code&gt;&lt;br&gt;
&lt;code&gt;proxy_set_header Host $host;&lt;/code&gt;&lt;br&gt;
&lt;code&gt;proxy_set_header X-Real-IP $remote_addr;&lt;/code&gt;&lt;br&gt;
&lt;code&gt;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&lt;/code&gt;&lt;br&gt;
这四个暂且这样设，如果深究的话，每一个都涉及到很复杂的内容，也将通过另一篇文章来解读。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于location匹配规则的写法，可以说尤为关键且基础的，参考文章 &lt;a href=&quot;http://seanlook.com/2015/05/17/nginx-location-rewrite/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nginx配置location总结及rewrite规则写法&lt;/a&gt;;&lt;/p&gt;
&lt;h2 id=&quot;2-3_其它&quot;&gt;2.3 其它&lt;/h2&gt;
&lt;h3 id=&quot;2-3-1_访问控制_allow/deny&quot;&gt;2.3.1 访问控制 allow/deny&lt;/h3&gt;
&lt;p&gt;Nginx 的访问控制模块默认就会安装，而且写法也非常简单，可以分别有多个allow,deny，允许或禁止某个ip或ip段访问，依次满足任何一个规则就停止往下匹配。如：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;location /nginx-status {
stub_status on;
access_log off;
# auth_basic &quot;NginxStatus&quot;;
# auth_basic_user_file /usr/local/nginx-1.6/htpasswd;
 
allow 192.168.10.100;
allow 172.29.73.0/24;
deny all;
}&lt;/pre&gt;
&lt;p&gt;我们也常用 httpd-devel 工具的 htpasswd 来为访问的路径设置登录密码：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;# htpasswd -c htpasswd admin
New passwd:
Re-type new password:
Adding password for user admin
 
# htpasswd htpasswd admin //修改admin密码
# htpasswd htpasswd sean //多添加一个认证用户&lt;/pre&gt;
&lt;p&gt;这样就生成了默认使用CRYPT加密的密码文件。打开上面nginx-status的两行注释，重启nginx生效。&lt;/p&gt;
&lt;h3 id=&quot;2-3-2_列出目录_autoindex&quot;&gt;2.3.2 列出目录 autoindex&lt;/h3&gt;
&lt;p&gt;Nginx默认是不允许列出整个目录的。如需此功能，打开nginx.conf文件，在location，server 或 http段中加入&lt;code&gt;autoindex on;&lt;/code&gt;，另外两个参数最好也加上去:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;autoindex_exact_size off;&lt;/code&gt; 默认为on，显示出文件的确切大小，单位是bytes。改为off后，显示出文件的大概大小，单位是kB或者MB或者GB&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;autoindex_localtime on;&lt;/code&gt;&lt;br&gt;
默认为off，显示的文件时间为GMT时间。改为on后，显示的文件时间为文件的服务器时间&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;location /images {
root /var/www/nginx-default/images;
autoindex on;
autoindex_exact_size off;
autoindex_localtime on;
}&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://liuqunying.blog.51cto.com/3984207/1420556&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://liuqunying.blog.51cto.com/3984207/1420556&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_cpu_affinity&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nginx.org/en/docs/ngx_core_module.html#worker_cpu_affinity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.nginx.org/HttpCoreModule#sendfile&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wiki.nginx.org/HttpCoreModule#sendfile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87538&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87538votetotal&quot;&gt;2&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87538&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sat, 13 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-13-87538-a692c55fe.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-13-87538-a692c55fe.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>比较全面的MySQL优化参考</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;本文整理了一些MySQL的通用优化方法，做个简单的总结分享，旨在帮助那些没有专职MySQL DBA的企业做好基本的优化工作，至于具体的SQL优化，大部分通过加适当的索引即可达到效果，更复杂的就需要具体分析了，&lt;/p&gt;
&lt;h1&gt;1、硬件层相关优化&lt;/h1&gt;
&lt;h2&gt;1.1、CPU相关&lt;/h2&gt;
&lt;p&gt;在服务器的BIOS设置中，可调整下面的几个配置，目的是发挥CPU最大性能，或者避免经典的NUMA问题：&lt;/p&gt;
&lt;p&gt;1、选择Performance Per Watt Optimized(DAPC)模式，发挥CPU最大性能，跑DB这种通常需要高运算量的服务就不要考虑节电了；&lt;/p&gt;
&lt;p&gt;2、关闭C1E和C States等选项，目的也是为了提升CPU效率；&lt;/p&gt;
&lt;p&gt;3、Memory Frequency（内存频率）选择Maximum Performance（最佳性能）；&lt;/p&gt;
&lt;p&gt;4、内存设置菜单中，启用Node Interleaving，避免NUMA问题；&lt;/p&gt;
&lt;h2&gt;1.2、磁盘I/O相关&lt;/h2&gt;
&lt;p&gt;下面几个是按照IOPS性能提升的幅度排序，对于磁盘I/O可优化的一些措施：&lt;/p&gt;
&lt;p&gt;1、使用SSD或者PCIe SSD设备，至少获得数百倍甚至万倍的IOPS提升；&lt;/p&gt;
&lt;p&gt;2、购置阵列卡同时配备CACHE及BBU模块，可明显提升IOPS（主要是指机械盘，SSD或PCIe SSD除外。同时需要定期检查CACHE及BBU模块的健康状况，确保意外时不至于丢失数据）；&lt;/p&gt;
&lt;p&gt;3、有阵列卡时，设置阵列写策略为WB，甚至FORCE WB（若有双电保护，或对数据安全性要求不是特别高的话），严禁使用WT策略。并且闭阵列预读策略，基本上是鸡肋，用处不大；&lt;/p&gt;
&lt;p&gt;4、尽可能选用RAID-10，而非RAID-5；&lt;/p&gt;
&lt;p&gt;5、使用机械盘的话，尽可能选择高转速的，例如选用15KRPM，而不是7.2KRPM的盘，不差几个钱的；&lt;/p&gt;
&lt;h1&gt;2、系统层相关优化&lt;/h1&gt;
&lt;h2&gt;2.1、文件系统层优化&lt;/h2&gt;
&lt;p&gt;在文件系统层，下面几个措施可明显提升IOPS性能：&lt;/p&gt;
&lt;p&gt;1、使用deadline/noop这两种I/O调度器，千万别用cfq（它不适合跑DB类服务）；&lt;/p&gt;
&lt;p&gt;2、使用xfs文件系统，千万别用ext3；ext4勉强可用，但业务量很大的话，则一定要用xfs；&lt;/p&gt;
&lt;p&gt;3、文件系统mount参数中增加：noatime, nodiratime, nobarrier几个选项（nobarrier是xfs文件系统特有的）；&lt;/p&gt;
&lt;h2&gt;2.2、其他内核参数优化&lt;/h2&gt;
&lt;p&gt;针对关键内核参数设定合适的值，目的是为了减少swap的倾向，并且让内存和磁盘I/O不会出现大幅波动，导致瞬间波峰负载：&lt;/p&gt;
&lt;p&gt;1、将vm.swappiness设置为5-10左右即可，甚至设置为0（RHEL 7以上则慎重设置为0，除非你允许OOM kill发生），以降低使用SWAP的机会；&lt;/p&gt;
&lt;p&gt;2、将vm.dirty_background_ratio设置为5-10，将vm.dirty_ratio设置为它的两倍左右，以确保能持续将脏数据刷新到磁盘，避免瞬间I/O写，产生严重等待（和MySQL中的innodb_max_dirty_pages_pct类似）；&lt;/p&gt;
&lt;p&gt;3、将net.ipv4.tcp_tw_recycle、net.ipv4.tcp_tw_reuse都设置为1，减少TIME_WAIT，提高TCP效率；&lt;/p&gt;
&lt;p&gt;4、至于网传的read_ahead_kb、nr_requests这两个参数，我经过测试后，发现对读写混合为主的OLTP环境影响并不大（应该是对读敏感的场景更有效果），不过没准是我测试方法有问题，可自行斟酌是否调整；&lt;/p&gt;
&lt;h1&gt;3、MySQL层相关优化&lt;/h1&gt;
&lt;h2&gt;3.1、关于版本选择&lt;/h2&gt;
&lt;p&gt;官方版本我们称为ORACLE MySQL，这个没什么好说的，相信绝大多数人会选择它。&lt;/p&gt;
&lt;p&gt;我个人强烈建议选择Percona分支版本，它是一个相对比较成熟的、优秀的MySQL分支版本，在性能提升、可靠性、管理型方面做了不少改善。它和官方ORACLE MySQL版本基本完全兼容，并且性能大约有20%以上的提升，因此我优先推荐它，我自己也从2008年一直以它为主。&lt;/p&gt;
&lt;p&gt;另一个重要的分支版本是MariaDB，说MariaDB是分支版本其实已经不太合适了，因为它的目标是取代ORACLE MySQL。它主要在原来的MySQL Server层做了大量的源码级改进，也是一个非常可靠的、优秀的分支版本。但也由此产生了以GTID为代表的和官方版本无法兼容的新特性（MySQL 5.7开始，也支持GTID模式在线动态开启或关闭了），也考虑到绝大多数人还是会跟着官方版本走，因此没优先推荐MariaDB。&lt;/p&gt;
&lt;h2&gt;3.2、关于最重要的参数选项调整建议&lt;/h2&gt;
&lt;p&gt;建议调整下面几个关键参数以获得较好的性能（可使用本站提供的&lt;a href=&quot;http://imysql.com/my_cnf_generator&quot; target=&quot;_blank&quot;&gt;my.cnf生成器&lt;/a&gt;生成配置文件模板）：&lt;/p&gt;
&lt;p&gt;1、选择Percona或MariaDB版本的话，强烈建议启用thread pool特性，可使得在高并发的情况下，性能不会发生大幅下降。此外，还有extra_port功能，非常实用， 关键时刻能救命的。还有另外一个重要特色是 QUERY_RESPONSE_TIME 功能，也能使我们对整体的SQL响应时间分布有直观感受；&lt;/p&gt;
&lt;p&gt;2、设置default-storage-engine=InnoDB，也就是默认采用InnoDB引擎，强烈建议不要再使用MyISAM引擎了，InnoDB引擎绝对可以满足99%以上的业务场景；&lt;/p&gt;
&lt;p&gt;3、调整innodb_buffer_pool_size大小，如果是单实例且绝大多数是InnoDB引擎表的话，可考虑设置为物理内存的50% ~ 70%左右；&lt;/p&gt;
&lt;p&gt;4、根据实际需要设置innodb_flush_log_at_trx_commit、sync_binlog的值。如果要求数据不能丢失，那么两个都设为1。如果允许丢失一点数据，则可分别设为2和10。而如果完全不用care数据是否丢失的话（例如在slave上，反正大不了重做一次），则可都设为0。这三种设置值导致数据库的性能受到影响程度分别是：高、中、低，也就是第一个会另数据库最慢，最后一个则相反；&lt;/p&gt;
&lt;p&gt;5、设置innodb_file_per_table = 1，使用独立表空间，我实在是想不出来用共享表空间有什么好处了；&lt;/p&gt;
&lt;p&gt;6、设置innodb_data_file_path = ibdata1:1G:autoextend，千万不要用默认的10M，否则在有高并发事务时，会受到不小的影响；&lt;/p&gt;
&lt;p&gt;7、设置innodb_log_file_size=256M，设置innodb_log_files_in_group=2，基本可满足90%以上的场景；&lt;/p&gt;
&lt;p&gt;8、设置long_query_time = 1，而在5.5版本以上，已经可以设置为小于1了，建议设置为0.05（50毫秒），记录那些执行较慢的SQL，用于后续的分析排查；&lt;/p&gt;
&lt;p&gt;9、根据业务实际需要，适当调整max_connection（最大连接数）、max_connection_error（最大错误数，建议设置为10万以上，而open_files_limit、innodb_open_files、table_open_cache、table_definition_cache这几个参数则可设为约10倍于max_connection的大小；&lt;/p&gt;
&lt;p&gt;10、常见的误区是把tmp_table_size和max_heap_table_size设置的比较大，曾经见过设置为1G的，这2个选项是每个连接会话都会分配的，因此不要设置过大，否则容易导致OOM发生；其他的一些连接会话级选项例如：sort_buffer_size、join_buffer_size、read_buffer_size、read_rnd_buffer_size等，也需要注意不能设置过大；&lt;/p&gt;
&lt;p&gt;11、由于已经建议不再使用MyISAM引擎了，因此可以把key_buffer_size设置为32M左右，并且强烈建议关闭query cache功能；&lt;/p&gt;
&lt;h2&gt;3.3、关于Schema设计规范及SQL使用建议&lt;/h2&gt;
&lt;p&gt;下面列举了几个常见有助于提升MySQL效率的Schema设计规范及SQL使用建议：&lt;/p&gt;
&lt;p&gt;1、所有的InnoDB表都设计一个无业务用途的自增列做主键，对于绝大多数场景都是如此，真正纯只读用InnoDB表的并不多，真如此的话还不如用TokuDB来得划算；&lt;/p&gt;
&lt;p&gt;2、字段长度满足需求前提下，尽可能选择长度小的。此外，字段属性尽量都加上NOT NULL约束，可一定程度提高性能；&lt;/p&gt;
&lt;p&gt;3、尽可能不使用TEXT/BLOB类型，确实需要的话，建议拆分到子表中，不要和主表放在一起，避免SELECT * 的时候读性能太差。&lt;/p&gt;
&lt;p&gt;4、读取数据时，只选取所需要的列，不要每次都SELECT *，避免产生严重的随机读问题，尤其是读到一些TEXT/BLOB列；&lt;/p&gt;
&lt;p&gt;5、对一个VARCHAR(N)列创建索引时，通常取其50%（甚至更小）左右长度创建前缀索引就足以满足80%以上的查询需求了，没必要创建整列的全长度索引；&lt;/p&gt;
&lt;p&gt;6、通常情况下，子查询的性能比较差，建议改造成JOIN写法；&lt;/p&gt;
&lt;p&gt;7、多表联接查询时，关联字段类型尽量一致，并且都要有索引；&lt;/p&gt;
&lt;p&gt;8、多表连接查询时，把结果集小的表（注意，这里是指过滤后的结果集，不一定是全表数据量小的）作为驱动表；&lt;/p&gt;
&lt;p&gt;9、多表联接并且有排序时，排序字段必须是驱动表里的，否则排序列无法用到索引；&lt;/p&gt;
&lt;p&gt;10、多用复合索引，少用多个独立索引，尤其是一些基数（Cardinality）太小（比如说，该列的唯一值总数少于255）的列就不要创建独立索引了；&lt;/p&gt;
&lt;p&gt;11、类似分页功能的SQL，建议先用主键关联，然后返回结果集，效率会高很多；&lt;/p&gt;
&lt;h2&gt;3.3、其他建议&lt;/h2&gt;
&lt;p&gt;关于MySQL的管理维护的其他建议有：&lt;/p&gt;
&lt;p&gt;1、通常地，单表物理大小不超过10GB，单表行数不超过1亿条，行平均长度不超过8KB，如果机器性能足够，这些数据量MySQL是完全能处理的过来的，不用担心性能问题，这么建议主要是考虑ONLINE DDL的代价较高；&lt;/p&gt;
&lt;p&gt;2、不用太担心mysqld进程占用太多内存，只要不发生OOM kill和用到大量的SWAP都还好；&lt;/p&gt;
&lt;p&gt;3、在以往，单机上跑多实例的目的是能最大化利用计算资源，如果单实例已经能耗尽大部分计算资源的话，就没必要再跑多实例了；&lt;/p&gt;
&lt;p&gt;4、定期使用pt-duplicate-key-checker检查并删除重复的索引。定期使用pt-index-usage工具检查并删除使用频率很低的索引；&lt;/p&gt;
&lt;p&gt;5、定期采集slow query log，用pt-query-digest工具进行分析，可结合Anemometer系统进行slow query管理以便分析slow query并进行后续优化工作；&lt;/p&gt;
&lt;p&gt;6、可使用pt-kill杀掉超长时间的SQL请求，Percona版本中有个选项 innodb_kill_idle_transaction 也可实现该功能；&lt;/p&gt;
&lt;p&gt;7、使用pt-online-schema-change来完成大表的ONLINE DDL需求；&lt;/p&gt;
&lt;p&gt;8、定期使用pt-table-checksum、pt-table-sync来检查并修复mysql主从复制的数据差异；&lt;/p&gt;
&lt;p&gt;后记：本文根据个人多年经验总结，个别建议可能有不完善之处，欢迎留言或者加我 微信公众号：&lt;strong&gt;&lt;a title=&quot;MySQL中文网微信公众号&quot; href=&quot;http://weixin.sogou.com/weixin?query=MySQL%E4%B8%AD%E6%96%87%E7%BD%91&amp;amp;_asf=www.sogou.com&amp;amp;_ast=1412034599&amp;amp;w=01019900&amp;amp;p=40040100&amp;amp;ie=utf8&amp;amp;type=2&amp;amp;sut=3805&amp;amp;sst0=1412034598512&amp;amp;lkt=5%2C1412034594859%2C1412034595433&quot;&gt;MySQL中文网&lt;/a&gt;&lt;/strong&gt;、QQ：&lt;strong&gt;&lt;a href=&quot;//message/?uin=4700963&amp;amp;Site=%E5%8F%B6%E9%87%91%E8%8D%A3&amp;amp;Menu=yes&quot;&gt;4700963&lt;/a&gt; &lt;/strong&gt;相互探讨交流。&lt;/p&gt;
&lt;p&gt;写在最后：这次的优化参考，大部分情况下我都介绍了适用的场景，如果你的应用场景和本文描述的不太一样，那么建议根据实际情况进行调整，而不是生搬硬套。欢迎质疑拍砖，但拒绝不经过大脑的习惯性抵制。&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87520&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87520votetotal&quot;&gt;5&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87520&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Fri, 12 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-12-87520-0d5054dd0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-12-87520-0d5054dd0.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>提高 Vim 使用效率的 12 个技巧</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;h3&gt;1. 使用空格键做为Leader（热键）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Leader&lt;/code&gt;是个非常有创意的设计，通过不同按键的顺序操作可以执行各种命令，而不需要通过组合键的方式，自从使用&lt;code&gt;Leader&lt;/code&gt;之后我就很少使用&lt;code&gt;ctrl-xxx&lt;/code&gt;的这种组合键。&lt;/p&gt;
&lt;p&gt;长久以来我都是使用 &lt;code&gt;, &lt;/code&gt;做为&lt;code&gt;Leader&lt;/code&gt;，直到我意识到我可以使用键盘上更加好用的捷按键：空格键（&amp;lt;Space&amp;gt;）。&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;let mapleader = &quot;\&amp;lt;Space&amp;gt;&quot;&lt;/pre&gt;
&lt;p&gt;这个完全颠覆了我的 Vim 操作效率，我现在可以使用双手任何一个大拇指进行操作，同时其它手指可以保持在键盘的主键区。因为 &lt;code&gt;Leader&lt;/code&gt; 相当容易使用，所以我就将各种常用的操作进行了 &lt;code&gt;Leader&lt;/code&gt; 映射。&lt;/p&gt;
&lt;h3&gt;2. 将最常用的操作映射到 Leader 操作&lt;/h3&gt;
&lt;p&gt;我首先识别出最经常使用的操作，并将它们映射到 Leader 操作，我经常是这么使用的：&lt;/p&gt;
&lt;p&gt;使用 &amp;lt;Space&amp;gt;o 创建一个新文件:&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;nnoremap &amp;lt;Leader&amp;gt;o :CtrlP&amp;lt;CR&amp;gt;&lt;/pre&gt;
&lt;p&gt;使用 &amp;lt;Space&amp;gt;w 文件（比 :w&amp;lt;Enter&amp;gt; 明显快得多）：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;nnoremap &amp;lt;Leader&amp;gt;w :w&amp;lt;CR&amp;gt;&lt;/pre&gt;
&lt;p&gt;使用 &amp;lt;Space&amp;gt;p 与 &amp;lt;Space&amp;gt;y 进行剪切板拷贝、粘贴：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;vmap &amp;lt;Leader&amp;gt;y &quot;+y
vmap &amp;lt;Leader&amp;gt;d &quot;+d
nmap &amp;lt;Leader&amp;gt;p &quot;+p
nmap &amp;lt;Leader&amp;gt;P &quot;+P
vmap &amp;lt;Leader&amp;gt;p &quot;+p
vmap &amp;lt;Leader&amp;gt;P &quot;+P&lt;/pre&gt;
&lt;p&gt;使用 &amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt; 进入 Vim 编辑模式：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;nmap &amp;lt;Leader&amp;gt;&amp;lt;Leader&amp;gt; V&lt;/pre&gt;
&lt;p&gt;我强烈建议你找到最常用的操作并将其映射到 Leader 。&lt;/p&gt;
&lt;h3&gt;3. 使用区域扩展功能&lt;/h3&gt;
&lt;p&gt;为插件 &lt;a href=&quot;https://github.com/terryma/vim-expand-region&quot;&gt;terryma/vim-expand-region&lt;/a&gt; 做按键映射：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;vmap v &amp;lt;Plug&amp;gt;(expand_region_expand)
vmap &amp;lt;C-v&amp;gt; &amp;lt;Plug&amp;gt;(expand_region_shrink)&lt;/pre&gt;
&lt;p&gt;这样我就可以:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按一次 &lt;code&gt;v&lt;/code&gt; 选择一个字符。&lt;/li&gt;
&lt;li&gt;再按一次 &lt;code&gt;v&lt;/code&gt; 自动扩展选择一个单词。&lt;/li&gt;
&lt;li&gt;再按一次 &lt;code&gt;v&lt;/code&gt; 自动扩展选择一段代码。&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;li&gt;以此类推…&lt;/li&gt;
&lt;li&gt;按&amp;lt;&lt;code&gt;C-v&amp;gt;&lt;/code&gt; 回退上一次的选择操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然 vvv 貌似比 vp 的操作更慢，但使用这种方式时，我压根就不需要考虑当前要选择哪些以及应该使用哪个组合键进行操作。&lt;/p&gt;
&lt;p&gt;这么一来 &lt;code&gt;v&lt;/code&gt; 把诸如 &lt;code&gt;viw&lt;/code&gt;, &lt;code&gt;vaw&lt;/code&gt;, &lt;code&gt;vi&quot;&lt;/code&gt;, &lt;code&gt;va&quot;&lt;/code&gt;, &lt;code&gt;vi(&lt;/code&gt;, &lt;code&gt;va(&lt;/code&gt;, &lt;code&gt;vi[&lt;/code&gt;, &lt;code&gt;va[&lt;/code&gt;, &lt;code&gt;vi{&lt;/code&gt;, &lt;code&gt;va{&lt;/code&gt;, &lt;code&gt;vip&lt;/code&gt;, &lt;code&gt;vap&lt;/code&gt;, &lt;code&gt;vit&lt;/code&gt;, &lt;code&gt;vat&lt;/code&gt;, ... 这些操作都给替代了，这下你懂了吧。&lt;/p&gt;
&lt;h3&gt;4. 找到文本查找操作工具&lt;/h3&gt;
&lt;p&gt;我一直都不喜欢 Vim 中的查找和替换操作，直到我在 &lt;a href=&quot;http://vim.wikia.com/wiki/Copy_or_change_search_hit&quot;&gt;Vim wiki&lt;/a&gt; 找到了以下的配置：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;vnoremap &amp;lt;silent&amp;gt; s //e&amp;lt;C-r&amp;gt;=&amp;amp;selection==&#39;exclusive&#39;?&#39;+1&#39;:&#39;&#39;&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;
    :&amp;lt;C-u&amp;gt;call histdel(&#39;search&#39;,-1)&amp;lt;Bar&amp;gt;let @/=histget(&#39;search&#39;,-1)&amp;lt;CR&amp;gt;gv
omap s :normal vs&amp;lt;CR&amp;gt;&lt;/pre&gt;
&lt;p&gt;这个直接替代了我常用的操作序列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;/something&lt;/code&gt; 查找&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;cs&lt;/code&gt; 替换第一个，然后按 &lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt; 键&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;n.n.n.n.n.&lt;/code&gt; 查找以及替换余下匹配项。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PS: 也可以考虑使用 Vim 7.4 提供的 &lt;a href=&quot;http://vimcasts.org/episodes/operating-on-search-matches-using-gn/&quot;&gt;&lt;code&gt;cgn&lt;/code&gt;&lt;/a&gt; 命令。&lt;/p&gt;
&lt;h3&gt;5. 尝试更多更棒的键盘映射&lt;/h3&gt;
&lt;p&gt;我每天都在使用这几个快捷操作键，估计这已经帮我省出了几个月时间。&lt;/p&gt;
&lt;h4&gt;自动跳转到粘贴文本的最后&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;ppppp&lt;/code&gt; 进行多行多次粘贴操作&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;vnoremap &amp;lt;silent&amp;gt; y y`]
vnoremap &amp;lt;silent&amp;gt; p p`]
nnoremap &amp;lt;silent&amp;gt; p p`]&lt;/pre&gt;
&lt;h5&gt;避免缓冲区的内容在粘贴后被覆盖&lt;/h5&gt;
&lt;p&gt;通过以下的配置可以避免缓冲区的内容被删除的文本内容所覆盖（放到&lt;code&gt;~/.vimrc&lt;/code&gt;文件的最后）&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;&quot; vp doesn&#39;t replace paste buffer
function! RestoreRegister()
  let @&quot; = s:restore_reg
  return &#39;&#39;
endfunction
function! s:Repl()
  let s:restore_reg = @&quot;
  return &quot;p@=RestoreRegister()&amp;lt;cr&amp;gt;&quot;
endfunction
vmap &amp;lt;silent&amp;gt; &amp;lt;expr&amp;gt; p &amp;lt;sid&amp;gt;Repl()&lt;/pre&gt;
&lt;h5&gt;&lt;span style=&quot;color: #ff0000&quot;&gt;译注：这里没有Title，估计是作者漏了，加了个。&lt;/span&gt;&lt;/h5&gt;
&lt;h5&gt;在文件中快速跳转&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;12&amp;lt;Enter&amp;gt;&lt;/code&gt; 跳转到第 12 行 （&lt;code&gt;12G&lt;/code&gt; 我觉得不称手）&lt;/li&gt;
&lt;li&gt;按 &amp;lt;Enter&amp;gt; 跳到行文件末尾。&lt;/li&gt;
&lt;li&gt;按 &amp;lt;Backspace&amp;gt; 回到文件开始。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;nnoremap &amp;lt;CR&amp;gt; G
nnoremap &amp;lt;BS&amp;gt; gg&lt;/pre&gt;
&lt;h5&gt;快速选择粘贴的文本&lt;/h5&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;noremap gV `[v`]&lt;/pre&gt;
&lt;h5&gt;关闭无聊的窗口提示&lt;/h5&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;map q: :q&lt;/pre&gt;
&lt;h4&gt;6. 提高单元测试执行效率&lt;/h4&gt;
&lt;p&gt;我用 &lt;a href=&quot;https://github.com/skalnik/vim-vroom&quot;&gt;vim-vroom&lt;/a&gt; 插件以及相应的 tmux 配置来进行我的测试。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim-room&lt;/code&gt; 缺省使用 &lt;code&gt;&amp;lt;Leader&amp;gt;r&lt;/code&gt; 执行测试，由于我已将 Leader 映射为 &lt;code&gt;&amp;lt;Space&amp;gt;&lt;/code&gt; ，因此我通过 &lt;code&gt;&amp;lt;Space&amp;gt;r&lt;/code&gt; 来运行测试工具。&lt;/p&gt;
&lt;p&gt;由于测试在 tmux 的单独窗口运行，因此我可以边看测试进展共修订我的代码。&lt;/p&gt;
&lt;h4&gt;7. 使用 Ctrl-Z 返回 Vim&lt;/h4&gt;
&lt;p&gt;我经常要在shell下执行一些命令，我通过 &lt;code&gt;Ctrl-Z&lt;/code&gt; 挂起 Vim ，在完成 shell 命令执行之后，通过 &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; 重新回到 Vim 。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;fg&lt;/code&gt; 退回 Vim 让我觉得难受，我只想通过 &lt;code&gt;Ctrl-Z&lt;/code&gt; 在 Vim 与 Shell 之间切换，不过我没有找到解决方法，因此我写了个在 ZSH 下完美运行的脚本：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;fancy-ctrl-z () {
  if [[ $#BUFFER -eq 0 ]]; then
    BUFFER=&quot;fg&quot;
    zle accept-line
  else
    zle push-input
    zle clear-screen
  fi
}
zle -N fancy-ctrl-z
bindkey &#39;^Z&#39; fancy-ctrl-z&lt;/pre&gt;
&lt;p&gt;如果你将上述代码放到 &lt;code&gt;~/.zshrc&lt;/code&gt; 文件中，你就可以在 shell 与 Vim 之间快速切换，你真值得去试试看。&lt;/p&gt;
&lt;h4&gt;8. 正确地配置 Tmux&lt;/h4&gt;
&lt;p&gt;在 OS X 下使用 Tmux 和 Vim 工具非常不方便，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统的剪切板处理功能很弱&lt;/li&gt;
&lt;li&gt;Vim 与 Tmux 的窗口切换操作不同&lt;/li&gt;
&lt;li&gt;Tmux 下执行命令的热键不同 ( 使用 &lt;code&gt;C-b&lt;/code&gt; )&lt;/li&gt;
&lt;li&gt;在 Tmux 中拷贝模式超难用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我花了非常多的时间去修正上述配置，具体可以见以下：&lt;/p&gt;
&lt;h5&gt;配置使用 &lt;code&gt;&amp;lt;C-Space&amp;gt;&lt;/code&gt; 作为 tmux 的热键&lt;/h5&gt;
&lt;p&gt;有些人习惯使用 &lt;code&gt;&amp;lt;C-a&amp;gt;&lt;/code&gt; 作为热键，不过我是用这个热键回到行首，所以我这里就不细说了。使用 &lt;code&gt;&amp;lt;C-Space&amp;gt;&lt;/code&gt; 的方式会更好用，原因我一会再说：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;unbind C-b
set -g prefix C-Space
bind Space send-prefix&lt;/pre&gt;
&lt;h5&gt;使用 &lt;code&gt;&amp;lt;Space&amp;gt;&lt;/code&gt; 进入拷贝模式&lt;/h5&gt;
&lt;p&gt;设想一下，使用 &amp;lt;C-Space&amp;gt;&amp;lt;Space&amp;gt; 就可以直接进入 Tmux 的拷贝模式有多方便。&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;bind Space copy-mode
bind C-Space copy-mode&lt;/pre&gt;
&lt;h5&gt;使用 &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;reattach-to-user-namespace&lt;/code&gt; (基于 OSX)&lt;/h5&gt;
&lt;p&gt;在使用系统的剪切板之前，你需要先执行 &lt;code&gt;brew install reattach-to-user-namespace&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;bind-key -t vi-copy y 
  copy-pipe &quot;reattach-to-user-namespace pbcopy&quot;&lt;/pre&gt;
&lt;h5&gt;使用 &lt;a href=&quot;https://github.com/christoomey/vim-tmux-navigator&quot;&gt;vim-tmux-navigator&lt;/a&gt;
&lt;/h5&gt;
&lt;p&gt;你要使用 &lt;code&gt;&amp;lt;C-h&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;C-j&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;C-k&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;C-l&amp;gt;&lt;/code&gt; 这几个快捷键在 vim 和 tmux 的各种窗口内快速切换。&lt;/p&gt;
&lt;p&gt;同时我建议使用 &lt;code&gt;&amp;lt;C-Space&amp;gt;l&lt;/code&gt; 和 &lt;code&gt;&amp;lt;C-Space&amp;gt;j &lt;/code&gt;的映射配置来进行 Tmux 窗口分割操作，这个绝对比用 &lt;code&gt;&amp;lt;C-Space&amp;gt;%&lt;/code&gt; 和 &lt;code&gt;&amp;lt;C-Space&amp;gt;|&lt;/code&gt; 来得快：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;bind j split-window -v
bind C-j split-window -v

bind l split-window -h
bind C-l split-window -h&lt;/pre&gt;
&lt;p&gt;参看我的 &lt;a href=&quot;https://github.com/sheerun/dotfiles/blob/master/tmux.conf&quot;&gt;tmux.conf&lt;/a&gt; 文件，这里有更多的干货。&lt;/p&gt;
&lt;h4&gt;9. 提高 Git 工程中 &lt;code&gt;Ctrl-P&lt;/code&gt; 的执行效率&lt;/h4&gt;
&lt;p&gt;将下面的内容添加到你的 &lt;code&gt;.vimrc&lt;/code&gt; 文件中（配置使用 &amp;lt;Ctrl-P&amp;gt; 来使用 git 或 silver 查找工具来自动补全）：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;let g:ctrlp_use_caching = 0
if executable(&#39;ag&#39;)
    set grepprg=ag --nogroup --nocolor

    let g:ctrlp_user_command = &#39;ag %s -l --nocolor -g &quot;&quot;&#39;
else
  let g:ctrlp_user_command = [&#39;.git&#39;, &#39;cd %s &amp;amp;&amp;amp; git ls-files . -co --exclude-standard&#39;, &#39;find %s -type f&#39;]
  let g:ctrlp_prompt_mappings = {
     &#39;AcceptSelection(&quot;e&quot;)&#39;: [&#39;&amp;lt;space&amp;gt;&#39;, &#39;&amp;lt;cr&amp;gt;&#39;, &#39;&amp;lt;2-LeftMouse&amp;gt;&#39;],
     }
endif&lt;/pre&gt;
&lt;p&gt;我建议使用 &lt;a href=&quot;https://github.com/vim-scripts/gitignore&quot;&gt;vim-scripts/gitignore&lt;/a&gt; 插件。&lt;/p&gt;
&lt;h4&gt;10. 使用包管理器&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Shougo/neobundle.vim&quot;&gt;neobundle.vim&lt;/a&gt; 是一个强大的管理 Vim 插件的工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你不需要手工管理 git 的子库（submodules）&lt;/li&gt;
&lt;li&gt;能够&lt;strong&gt;并行地&lt;/strong&gt;安装以及更新插件&lt;/li&gt;
&lt;li&gt;它支持 &lt;a href=&quot;https://github.com/Valloric/YouCompleteMe&quot;&gt;YouCompleteMe&lt;/a&gt; 这类需要&lt;b&gt; build &lt;/b&gt;的插件
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;NeoBundle &#39;Valloric/YouCompleteMe&#39;, {
       &#39;build&#39; : {
           &#39;mac&#39; : &#39;./install.sh&#39;,
          },
       }&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;出同样支持 &lt;a href=&quot;https://github.com/Valloric/YouCompleteMe&quot;&gt;pry&lt;/a&gt; 这类支持打补丁的插件：
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;NeoBundle &#39;rking/pry-de&#39;, {&#39;rtp&#39;: &#39;vim/&#39;}&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;11. 充分使用 Vim 的插件的优点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Valloric/YouCompleteMe&quot;&gt;YouCompleteMe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mileszs/ack.vim&quot;&gt;ack.vim&lt;/a&gt;（ag.vim 也不错）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tpope/vim-commentary&quot;&gt;tpope/vim-commentary&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tpope/vim-rsi&quot;&gt;tpope/vim-rsi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tpope/vim-endwise&quot;&gt;tpope/vim-endwise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tpope/vim-fugitive&quot;&gt;tpope/vim-fugitive&lt;/a&gt; 主要使用 &lt;code&gt;:Gblame&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tpope/vim-repeat&quot;&gt;tpope/vim-repeat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tpope/vim-sleuth&quot;&gt;tpope/vim-sleuth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mmozuras/vim-github-comment&quot;&gt;mmozuras/vim-github-comment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/bling/vim-airline&quot;&gt;vim-airline&lt;/a&gt; 并加上以下配置：
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;NeoBundle &#39;bling/vim-airline&#39;
let g:airline_theme=&#39;powerlineish&#39;
let g:airline_left_sep=&#39;&#39;
let g:airline_right_sep=&#39;&#39;
let g:airline_section_z=&#39;&#39;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我是个 Ruby 程序员，所以我还使用一些 Ruby 的插件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tpope/vim-rails&quot;&gt;tpope/vim-rails&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nelstrom/vim-textobj-rubyblock&quot;&gt;vim-textobj-rubyblock&lt;/a&gt; (使用 &lt;code&gt;var&lt;/code&gt;，&lt;code&gt;vir&lt;/code&gt; 查找 ruby 代码块）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rking/pry-de/blob/master/vim/ftplugin/ruby_pry.vim&quot;&gt;ruby_pry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/AndrewRadev/splitjoin.vim&quot;&gt;AndrewRadev/splitjoin.vim&lt;/a&gt; 配置以下映射 nmap sj :SplitjoinSplit&amp;lt;cr&amp;gt; nmap sk :SplitjoinJoin&amp;lt;cr&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;12. 在服务器上快速配置 Vim&lt;/h4&gt;
&lt;p&gt;我经常需要服务上使用 Vim 进行配置，不幸的是 Vim 的缺省配置相当不合理。&lt;/p&gt;
&lt;p&gt;一种方案是使用 &lt;a href=&quot;https://github.com/tpope/vim-sensible&quot;&gt;vim-sensible&lt;/a&gt; 插件来生成压缩包，不过这个对我来说不够好用。我写 &lt;a href=&quot;https://github.com/sheerun/vimrc&quot;&gt;vimrc&lt;/a&gt; 的插件来对 Vim 做合理的初始化（特别是对 Ruby 开发者），这个插件配置 Vim 只使用 &lt;code&gt;~/.vimrc&lt;/code&gt; 作为配置文件，同时它还包含了优化的配色、包管理工具以及多种开发语言的语法着色。&lt;/p&gt;
&lt;p&gt;这意味着我不需要手工配置服务器上的 &lt;code&gt;~/.vim&lt;/code&gt; 目录，而是通过以下操作就可以方便地在服务器上配置 Vim 环境：&lt;/p&gt;
&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;git clone --recursive https://github.com/sheerun/vimrc.git ~/.vim&lt;/pre&gt;
&lt;p&gt;我还写了个 &lt;a href=&quot;https://github.com/sheerun/dotfiles&quot;&gt;dotfiles&lt;/a&gt; ，用于快速配置我的开发环境。&lt;/p&gt;
&lt;h4&gt;思考&lt;/h4&gt;
&lt;p&gt;用好 Vim 的关键在于，你要在软件开发过程中不断发现你所遇到的 Vim 问题，并积极处理它们。&lt;/p&gt;
&lt;p&gt;处理方法可以是在 &lt;code&gt;.vimrc&lt;/code&gt; 中添加键盘映射，或是在 google 上查找解决方案，要不就在 IRC 上提问，或者其他方法。&lt;/p&gt;
&lt;p&gt;你用什么方法提高了 Vim 的使用效率？&lt;/p&gt;
&lt;h4&gt;想了解更多？&lt;/h4&gt;
&lt;p&gt;哈，雇我做你的 Vim 顾问吧，给我&lt;a href=&quot;mailto:sheerun@sher.pl&quot;&gt;写个邮件&lt;/a&gt;吧。&lt;/p&gt;
&lt;hr&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87481&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87481votetotal&quot;&gt;9&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87481&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt; 3 收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt; 3 评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者：&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/a1ickgu0&quot;&gt;Alick&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/a1ickgu0&quot;&gt;
			&lt;img src=&quot;/images/jobbole.com/1e11ece2fa370b1d09b13792336ee69d.jpg&quot;&gt;
		&lt;/a&gt;
	&lt;/div&gt;

    &lt;div class=&quot;author-bio-info&quot;&gt;

        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            这个码农很懒，啥也没有留下.        &lt;/span&gt;
        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            &lt;a href=&quot;http://www.jobbole.com/members/a1ickgu0&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 个人主页&lt;/a&gt; · 
            &lt;a href=&quot;http://blog.jobbole.com/author/a1ickgu0/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;/i&gt; 我的文章&lt;/a&gt;

             · &lt;a title=&quot;声望值&quot; target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/a1ickgu0/reputation/&quot;&gt;&lt;i class=&quot;fa fa-graduation-cap&quot;&gt;&lt;/i&gt; 10&lt;/a&gt; · &lt;a title=&quot;微博主页&quot; target=&quot;_blank&quot; href=&quot;http://weibo.com/1798547731/&quot;&gt;&lt;i class=&quot;fa fa-weibo&quot;&gt;&lt;/i&gt;&lt;/a&gt;         &lt;/span&gt;
    &lt;/div&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Fri, 12 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-12-87481-4030188f8.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-12-87481-4030188f8.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Shell脚本编程初体验</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1451d9c8e4597640a3289fcd404b4c2b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;通常，当人们提到“shell脚本语言”时，浮现在他们脑海中是bash，ksh，sh或者其它相类似的linux/unix脚本语言。脚本语言是与计算机交流的另外一种途径。使用图形化窗口界面（不管是windows还是linux都无所谓）用户可以移动鼠标并点击各种对象，比如按钮、列表、选框等等。但这种方式在每次用户想要计算机/服务器完成相同任务时（比如说批量转换照片，或者下载新的电影、mp3等）却是十分不方便。要想让所有这些事情变得简单并且自动化，我们可以使用shell脚本。&lt;/p&gt;
&lt;p&gt;某些编程语言，像pascal、foxpro、C、java之类，在执行前需要先进行编译。它们需要合适的编译器来让我们的代码完成某个任务。&lt;/p&gt;
&lt;p&gt;而其它一些编程语言，像php、javascript、visualbasic之类，则不需要编译器，因此它们需要解释器，而我们不需要编译代码就可以运行程序。&lt;/p&gt;
&lt;p&gt;shell脚本也像解释器一样，但它通常用于调用外部已编译的程序。然后，它会捕获输出结果、退出代码并根据情况进行处理。&lt;/p&gt;
&lt;p&gt;Linux世界中最为流行的shell脚本语言之一，就是bash。而我认为（这是我自己的看法）原因在于，默认情况下bash shell可以让用户便捷地通过历史命令（先前执行过的）导航，与之相反的是，ksh则要求对.profile进行一些调整，或者记住一些“魔术”组合键来查阅历史并修正命令。&lt;/p&gt;
&lt;p&gt;好了，我想这些介绍已经足够了，剩下来哪个环境最适合你，就留给你自己去判断吧。从现在开始，我将只讲bash及其脚本。在下面的例子中，我将使用CentOS 6.6和bash-4.1.2。请确保你有相同版本，或者更高版本。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Shell脚本流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;shell脚本语言就跟和几个人聊天类似。你只需把所有命令想象成能帮你做事的那些人，只要你用正确的方式来请求他们去做。比如说，你想要写文档。首先，你需要纸。然后，你需要把内容说给某个人听，让他帮你写。最后，你想要把它存放到某个地方。或者说，你想要造一所房子，因而你需要请合适的人来清空场地。在他们说“事情干完了”，那么另外一些工程师就可以帮你来砌墙。最后，当这些工程师们也告诉你“事情干完了”的时候，你就可以叫油漆工来给房子粉饰了。如果你让油漆工在墙砌好前就来粉饰，会发生什么呢？我想，他们会开始发牢骚了。几乎所有这些像人一样的命令都会说话，如果它们完成了工作而没有发生什么问题，那么它们就会告诉“标准输出”。如果它们不能做你叫它们做的事——它们会告诉“标准错误”。这样，最后，所有的命令都通过“标准输入”来听你的话。&lt;/p&gt;
&lt;p&gt;快速实例——当你打开linux终端并写一些文本时——你正通过“标准输入”和bash说话。那么，让我们来问问bash shell who am i（我是谁？）吧。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;root@localhost ~]# who am i                                &amp;lt;--- 你通过标准输入对 bash shell 说
root     pts/0        2015-04-22 20:17 (192.168.1.123)     &amp;lt;--- bash shell通过标准输出回答你&lt;/pre&gt;
&lt;p&gt;现在，让我们说一些bash听不懂的问题：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# blablabla           &amp;lt;--- 哈，你又在和标准输入说话了
-bash: blablabla: command not found     &amp;lt;--- bash通过标准错误在发牢骚了&lt;/pre&gt;
&lt;p&gt;“:”之前的第一个单词通常是向你发牢骚的命令。实际上，这些流中的每一个都有它们自己的索引号（LCTT 译注：文件句柄号）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准输入（stdin） – 0&lt;/li&gt;
&lt;li&gt;标准输出（stdout） – 1&lt;/li&gt;
&lt;li&gt;标准错误（stderr） – 2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你真的想要知道哪个输出命令说了些什么——你需要将那次发言重定向到（在命令后使用大于号“&amp;gt;”和流索引）文件：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# blablabla 1&amp;gt; output.txt
-bash: blablabla: command not found&lt;/pre&gt;
&lt;p&gt;在本例中，我们试着重定向流1（&lt;strong&gt;stdout&lt;/strong&gt;）到名为output.txt的文件。让我们来看对该文件内容所做的事情吧，使用cat命令可以做这事：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat output.txt
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;看起来似乎是空的。好吧，现在让我们来重定向流2（&lt;strong&gt;stderr&lt;/strong&gt;）：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# blablabla 2&amp;gt; error.txt
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;好吧，我们看到牢骚话没了。让我们检查一下那个文件：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat error.txt
-bash: blablabla: command not found
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;果然如此！我们看到，所有牢骚话都被记录到errors.txt文件里头去了。&lt;/p&gt;
&lt;p&gt;有时候，命令会同时产生&lt;strong&gt;stdout &lt;/strong&gt;和 &lt;strong&gt;stderr&lt;/strong&gt;。要重定向它们到不同的文件，我们可以使用以下语句：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;command 1&amp;gt;out.txt 2&amp;gt;err.txt&lt;/pre&gt;
&lt;p&gt;要缩短一点语句，我们可以忽略“1”，因为默认情况下stdout会被重定向：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;command &amp;gt;out.txt 2&amp;gt;err.txt&lt;/pre&gt;
&lt;p&gt;好吧，让我们试试做些“坏事”。让我们用rm命令把file1和folder1给删了吧：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# rm -vf folder1 file1 &amp;gt; out.txt 2&amp;gt;err.txt&lt;/pre&gt;
&lt;p&gt;现在来检查以下输出文件：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat out.txt
removed `file1&#39;
[root@localhost ~]# cat err.txt
rm: cannot remove `folder1&#39;: Is a directory
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;正如我们所看到的，不同的流被分离到了不同的文件。有时候，这也不是很方便，因为我们想要查看出现错误时，在某些操作前面或后面所连续发生的事情。要实现这一目的，我们可以重定向两个流到同一个文件：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;command &amp;gt;&amp;gt;out_err.txt 2&amp;gt;&amp;gt;out_err.txt&lt;/pre&gt;
&lt;p&gt;注意：请注意，我使用“&amp;gt;&amp;gt;”替代了“&amp;gt;”。它允许我们附加到文件，而不是覆盖文件。&lt;/p&gt;
&lt;p&gt;我们也可以重定向一个流到另一个：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;command &amp;gt;out_err.txt 2&amp;gt;&amp;amp;1&lt;/pre&gt;
&lt;p&gt;让我来解释一下吧。所有命令的标准输出将被重定向到out_err.txt，错误输出将被重定向到流1（上面已经解释过了），而该流会被重定向到同一个文件。让我们看这个实例：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# rm -fv folder2 file2 &amp;gt;out_err.txt 2&amp;gt;&amp;amp;1
[root@localhost ~]# cat out_err.txt
rm: cannot remove `folder2&#39;: Is a directory
removed `file2&#39;
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;看着这些组合的输出，我们可以将其说明为：首先，rm命令试着将folder2删除，而它不会成功，因为linux要求-r键来允许rm命令删除文件夹，而第二个file2会被删除。通过为rm提供-v（详情）键，我们让rm命令告诉我们每个被删除的文件或文件夹。&lt;/p&gt;
&lt;p&gt;这些就是你需要知道的，关于重定向的几乎所有内容了。我是说几乎，因为还有一个更为重要的重定向工具，它称之为“管道”。通过使用|（管道）符号，我们通常重定向stdout流。&lt;/p&gt;
&lt;p&gt;比如说，我们有这样一个文本文件：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat text_file.txt
This line does not contain H e l l o word
This lilne contains Hello
This also containd Hello
This one no due to HELLO all capital
Hello bash world!&lt;/pre&gt;
&lt;p&gt;而我们需要找到其中某些带有“Hello”的行，Linux中有个grep命令可以完成该工作：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# grep Hello text_file.txt
This lilne contains Hello
This also containd Hello
Hello bash world!
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;当我们有个文件，想要在里头搜索的时候，这用起来很不错。当如果我们需要在另一个命令的输出中查找某些东西，这又该怎么办呢？是的，当然，我们可以重定向输出到文件，然后再在文件里头查找：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# fdisk -l&amp;gt;fdisk.out
[root@localhost ~]# grep &quot;Disk /dev&quot; fdisk.out
Disk /dev/sda: 8589 MB, 8589934592 bytes
Disk /dev/mapper/VolGroup-lv_root: 7205 MB, 7205814272 bytes
Disk /dev/mapper/VolGroup-lv_swap: 855 MB, 855638016 bytes
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;如果你打算grep一些双引号引起来带有空格的内容呢！&lt;/p&gt;
&lt;p&gt;注意：fdisk命令显示关于Linux操作系统磁盘驱动器的信息。&lt;/p&gt;
&lt;p&gt;就像我们看到的，这种方式很不方便，因为我们不一会儿就把临时文件空间给搞乱了。要完成该任务，我们可以使用管道。它们允许我们重定向一个命令的stdout到另一个命令的stdin流：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# fdisk -l | grep &quot;Disk /dev&quot;
Disk /dev/sda: 8589 MB, 8589934592 bytes
Disk /dev/mapper/VolGroup-lv_root: 7205 MB, 7205814272 bytes
Disk /dev/mapper/VolGroup-lv_swap: 855 MB, 855638016 bytes
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;如你所见，我们不需要任何临时文件就获得了相同的结果。我们把fdisk stdout重定向到了grep stdin。&lt;/p&gt;
&lt;p&gt;注意 ： 管道重定向总是从左至右的。&lt;/p&gt;
&lt;p&gt;还有几个其它重定向，但是我们将把它们放在后面讲。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在shell中显示自定义信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如我们所知道的，通常，与shell的交流以及shell内的交流是以对话的方式进行的。因此，让我们创建一些真正的脚本吧，这些脚本也会和我们讲话。这会让你学到一些简单的命令，并对脚本的概念有一个更好的理解。&lt;/p&gt;
&lt;p&gt;假设我们是某个公司的总服务台经理，我们想要创建某个shell脚本来注册呼叫信息：电话号码、用户名以及问题的简要描述。我们打算把这些信息存储到普通文本文件data.txt中，以便今后统计。脚本它自己就是以对话的方式工作，这会让总服务台的工作人员的小日子过得轻松点。那么，首先我们需要显示提问。对于显示信息，我们可以用echo和printf命令。这两个都是用来显示信息的，但是printf更为强大，因为我们可以通过它很好地格式化输出，我们可以让它右对齐、左对齐或者为信息留出专门的空间。让我们从一个简单的例子开始吧。要创建文件，请使用你惯用的文本编辑器（kate，nano，vi，……），然后创建名为note.sh的文件，里面写入这些命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;echo &quot;Phone number ?&quot;&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何运行/执行脚本？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在保存文件后，我们可以使用bash命令来运行，把我们的文件作为它的参数：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# bash note.sh
Phone number ?&lt;/pre&gt;
&lt;p&gt;实际上，这样来执行脚本是很不方便的。如果不使用bash命令作为前缀来执行，会更舒服一些。要让脚本可执行，我们可以使用chmod命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# ls -la note.sh
-rw-r--r--. 1 root root 22 Apr 23 20:52 note.sh
[root@localhost ~]# chmod +x note.sh
[root@localhost ~]# ls -la note.sh
-rwxr-xr-x. 1 root root 22 Apr 23 20:52 note.sh
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;注意 ： ls命令显示了当前文件夹内的文件。通过添加-la键，它会显示更多文件信息。&lt;/p&gt;
&lt;p&gt;如我们所见，在chmod命令执行前，脚本只有读（r）和写（w）权限。在执行chmod +x后，它就获得了执行（x）权限。（关于权限的更多细节，我会在下一篇文章中讲述。）现在，我们只需这么来运行：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# ./note.sh
Phone number ?&lt;/pre&gt;
&lt;p&gt;在脚本名前，我添加了 ./ 组合。.(点）在unix世界中意味着当前位置（当前文件夹），/（斜线）是文件夹分隔符。（在Windows系统中，我们使用反斜线 \ 表示同样功能）所以，这整个组合的意思是说：“从当前文件夹执行note.sh脚本”。我想，如果我用完整路径来运行这个脚本的话，你会更加清楚一些：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# /root/note.sh
Phone number ?
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;它也能工作。&lt;/p&gt;
&lt;p&gt;如果所有linux用户都有相同的默认shell，那就万事OK。如果我们只是执行该脚本，默认的用户shell就会用于解析脚本内容并运行命令。不同的shell的语法、内部命令等等有着一丁点不同，所以，为了保证我们的脚本会使用bash，我们应该添加#!/bin/bash到文件首行。这样，默认的用户shell将调用/bin/bash，而只有在那时候，脚本中的命令才会被执行：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat note.sh
#!/bin/bash
echo &quot;Phone number ?&quot;&lt;/pre&gt;
&lt;p&gt;直到现在，我们才100%确信bash会用来解析我们的脚本内容。让我们继续。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取输入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在显示信息后，脚本会等待用户回答。有个read命令用来接收用户的回答：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;#!/bin/bash
echo &quot;Phone number ?&quot;
read phone&lt;/pre&gt;
&lt;p&gt;在执行后，脚本会等待用户输入，直到用户按[ENTER]键结束输入：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# ./note.sh
Phone number ?
12345 &amp;lt;--- 这儿是我输入的内容
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;你输入的所有东西都会被存储到变量phone中，要显示变量的值，我们同样可以使用echo命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat note.sh
#!/bin/bash
echo &quot;Phone number ?&quot;
read phone
echo &quot;You have entered $phone as a phone number&quot;
[root@localhost ~]# ./note.sh
Phone number ?
123456
You have entered 123456 as a phone number
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;在bash shell中，一般我们使用$（美元）符号来表明这是一个变量，除了读入到变量和其它为数不多的时候才不用这个$（将在今后说明）。&lt;/p&gt;
&lt;p&gt;好了，现在我们准备添加剩下的问题了：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;#!/bin/bash
echo &quot;Phone number?&quot;
read phone
echo &quot;Name?&quot;
read name
echo &quot;Issue?&quot;
read issue
[root@localhost ~]# ./note.sh
Phone number?
123
Name?
Jim
Issue?
script is not working.
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用流重定向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;太完美了！剩下来就是重定向所有东西到文件data.txt了。作为字段分隔符，我们将使用/（斜线）符号。&lt;/p&gt;
&lt;p&gt;注意 ： 你可以选择任何你认为是最好的分隔符，但是确保文件内容不会包含这些符号在内，否则它会导致在文本行中产生额外字段。&lt;/p&gt;
&lt;p&gt;别忘了使用“&amp;gt;&amp;gt;”来代替“&amp;gt;”，因为我们想要将输出内容附加到文件末！&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# tail -2 note.sh
read issue
echo &quot;$phone/$name/$issue&quot;&amp;gt;&amp;gt;data.txt
[root@localhost ~]# ./note.sh
Phone number?
987
Name?
Jimmy
Issue?
Keybord issue.
[root@localhost ~]# cat data.txt
987/Jimmy/Keybord issue.
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;注意 ： tail命令显示了文件的最后的n行。&lt;/p&gt;
&lt;p&gt;搞定。让我们再来运行一次看看：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# ./note.sh
Phone number?
556
Name?
Janine
Issue?
Mouse was broken.
[root@localhost ~]# cat data.txt
987/Jimmy/Keybord issue.
556/Janine/Mouse was broken.
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;我们的文件在增长，让我们在每行前面加个日期吧，这对于今后摆弄这些统计数据时会很有用。要实现这功能，我们可以使用date命令，并指定某种格式，因为我不喜欢默认格式：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# date
Thu Apr 23 21:33:14 EEST 2015 &amp;lt;---- date命令的默认输出
[root@localhost ~]# date &quot;+%Y.%m.%d %H:%M:%S&quot;
2015.04.23 21:33:18 &amp;lt;---- 格式化后的输出&lt;/pre&gt;
&lt;p&gt;有几种方式可以读取命令的输出到变量，在这种简单的情况下，我们将使用`（是反引号，不是单引号，和波浪号~在同一个键位）：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat note.sh
#!/bin/bash
now=`date &quot;+%Y.%m.%d %H:%M:%S&quot;`
echo &quot;Phone number?&quot;
read phone
echo &quot;Name?&quot;
read name
echo &quot;Issue?&quot;
read issue
echo &quot;$now/$phone/$name/$issue&quot;&amp;gt;&amp;gt;data.txt
[root@localhost ~]# ./note.sh
Phone number?
123
Name?
Jim
Issue?
Script hanging.
[root@localhost ~]# cat data.txt
2015.04.23 21:38:56/123/Jim/Script hanging.
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;嗯…… 我们的脚本看起来有点丑啊，让我们来美化一下。如果你要手动读取read命令，你会发现read命令也可以显示一些信息。要实现该功能，我们应该使用-p键加上信息：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat note.sh
#!/bin/bash
now=`date &quot;+%Y.%m.%d %H:%M:%S&quot;`
read -p &quot;Phone number: &quot; phone
read -p &quot;Name: &quot; name
read -p &quot;Issue: &quot; issue
echo &quot;$now/$phone/$name/$issue&quot;&amp;gt;&amp;gt;data.txt&lt;/pre&gt;
&lt;p&gt;你可以直接从控制台查找到各个命令的大量有趣的信息，只需输入：man read, man echo, man date, man ……&lt;/p&gt;
&lt;p&gt;同意吗？它看上去是舒服多了！&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# ./note.sh
Phone number: 321
Name: Susane
Issue: Mouse was stolen
[root@localhost ~]# cat data.txt
2015.04.23 21:38:56/123/Jim/Script hanging.
2015.04.23 21:43:50/321/Susane/Mouse was stolen
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;光标在消息的后面（不是在新的一行中），这有点意思。（LCTT 译注：如果用 echo 命令输出显示的话，可以用 -n 参数来避免换行。）&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是时候来改进我们的脚本了。如果用户一整天都在接电话，如果每次都要去运行，这岂不是很麻烦？让我们让这些活动都永无止境地循环去吧：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat note.sh
#!/bin/bash
while true
do
read -p &quot;Phone number: &quot; phone
now=`date &quot;+%Y.%m.%d %H:%M:%S&quot;`
read -p &quot;Name: &quot; name
read -p &quot;Issue: &quot; issue
echo &quot;$now/$phone/$name/$issue&quot;&amp;gt;&amp;gt;data.txt
done&lt;/pre&gt;
&lt;p&gt;我已经交换了read phone和now=date行的位置。这是因为我想要在输入电话号码后再获得时间。如果我把它放在循环的首行，那么循环一次后，变量 now 就会在数据存储到文件中后马上获得时间。而这并不好，因为下一次呼叫可能在20分钟后，甚至更晚。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# ./note.sh
Phone number: 123
Name: Jim
Issue: Script still not works.
Phone number: 777
Name: Daniel
Issue: I broke my monitor
Phone number: ^C
[root@localhost ~]# cat data.txt
2015.04.23 21:38:56/123/Jim/Script hanging.
2015.04.23 21:43:50/321/Susane/Mouse was stolen
2015.04.23 21:47:55/123/Jim/Script still not works.
2015.04.23 21:48:16/777/Daniel/I broke my monitor
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;注意： 要从无限循环中退出，你可以按[Ctrl]+[C]键。Shell会显示^表示 CTRL 键。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用管道重定向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们添加更多功能到我们的“弗兰肯斯坦（Frankenstein）”，我想要脚本在每次呼叫后显示某个统计数据。比如说，我想要查看各个号码呼叫了我几次。对于这个，我们应该cat文件data.txt：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat data.txt
2015.04.23 21:38:56/123/Jim/Script hanging.
2015.04.23 21:43:50/321/Susane/Mouse was stolen
2015.04.23 21:47:55/123/Jim/Script still not works.
2015.04.23 21:48:16/777/Daniel/I broke my monitor
2015.04.23 22:02:14/123/Jimmy/New script also not working!!!
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;现在，所有输出我们都可以重定向到cut命令，让cut来把每行切成一块一块（我们使用分隔符“/”），然后打印第二个字段：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat data.txt | cut -d&quot;/&quot; -f2
123
321
123
777
123
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;现在，我们可以把这个输出重定向打另外一个命令sort：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat data.txt | cut -d&quot;/&quot; -f2|sort
123
123
123
321
777
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;然后只留下唯一的行。要统计唯一条目，只需添加-c键到uniq命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# cat data.txt | cut -d&quot;/&quot; -f2 | sort | uniq -c
3 123
1 321
1 777
[root@localhost ~]#&lt;/pre&gt;
&lt;p&gt;只要把这个添加到我们的循环的最后：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;#!/bin/bash
while true
do
read -p &quot;Phone number: &quot; phone
now=`date &quot;+%Y.%m.%d %H:%M:%S&quot;`
read -p &quot;Name: &quot; name
read -p &quot;Issue: &quot; issue
echo &quot;$now/$phone/$name/$issue&quot;&amp;gt;&amp;gt;data.txt
echo &quot;===== We got calls from =====&quot;
cat data.txt | cut -d&quot;/&quot; -f2 | sort | uniq -c
echo &quot;--------------------------------&quot;
done&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;[root@localhost ~]# ./note.sh
Phone number: 454
Name: Malini
Issue: Windows license expired.
===== We got calls from =====
3 123
1 321
1 454
1 777
--------------------------------
Phone number: ^C&lt;/pre&gt;
&lt;p&gt;当前场景贯穿了几个熟知的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示消息&lt;/li&gt;
&lt;li&gt;获取用户输入&lt;/li&gt;
&lt;li&gt;存储值到文件&lt;/li&gt;
&lt;li&gt;处理存储的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是，如果用户有点责任心，他有时候需要输入数据，有时候需要统计，或者可能要在存储的数据中查找一些东西呢？对于这些事情，我们需要使用switches/cases，并知道怎样来很好地格式化输出。这对于在shell中“画”表格的时候很有用。&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87465&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87465votetotal&quot;&gt;7&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87465&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt; 3 收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt; 1 评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Tue, 09 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-09-87465-919ec613e.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-09-87465-919ec613e.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>数据挖掘历史中的重要里程碑</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;数据挖掘现在随处可见，而它的故事在《点球成金》出版和“棱镜门”事件发生之前就已经开始了。下文叙述的就是数据挖掘的主要里程碑，历史上的第一次，它是怎样发展以及怎样与数据科学和大数据融合。&lt;/p&gt;
&lt;p&gt;数据挖掘是在大数据集（即：大数据）上探索和揭示模式规律的计算过程。它是计算机科学的分支，融合了统计学、数据科学、数据库理论和机器学习等众多技术。&lt;/p&gt;
&lt;p&gt;1763 年，Thomas Bayes 的论文在他死后发表，他所提出的 Bayes 理论将当前概率与先验概率联系起来。因为 Bayes 理论能够帮助理解基于概率估计的复杂现况，所以它成为了数据挖掘和概率论的基础。&lt;/p&gt;
&lt;p&gt;1805 年, Adrien-Marie Legendre 和 Carl Friedrich Gauss 使用回归确定了天体（彗星和行星）绕行太阳的轨道。回归分析的目标是估计变量之间的关系，在这个例子中采用的方法是最小二乘法。自此，回归成为数据挖掘的重要工具之一。&lt;/p&gt;
&lt;p&gt;1936 年，计算机时代即将到来，它让海量数据的收集和处理成为可能。在1936年发表的论文《论可计算数（On  Computable Numbers）》中，Alan Turing 介绍了通用机（通用图灵机）的构想，通用机具有像今天的计算机一般的计算能力。现代计算机就是在图灵这一开创性概念上建立起来的。&lt;/p&gt;
&lt;p&gt;1943 年，Warren McCullon 和 Walter Pitts 首先构建出神经网络的概念模型。在名为 《A logical calculus of the ideas immanent in nervous activity》 的论文中，他们阐述了网络中神经元的概念。每一个神经元可以做三件事情：接受输入，处理输入和生成输出。&lt;/p&gt;
&lt;p&gt;1965 年，Lawrence J. Fogel 成立了一个新的公司，名为 Decision Science, Inc，目的是对进化规划进行应用。这是第一家专门将进化计算应用于解决现实世界问题的公司。&lt;/p&gt;
&lt;p&gt;上世纪 70 年代，随着数据库管理系统趋于成熟，存储和查询百万兆字节甚至千万亿字节成为可能。而且，数据仓库允许用户从面向事物处理的思维方式向更注重数据分析的方式进行转变。然而，从这些多维模型的数据仓库中提取复杂深度信息的能力是非常有限的。&lt;/p&gt;
&lt;p&gt;1975 年，John Henry Holland 所著的《自然与人工系统中的适应》问世，成为遗传算法领域具有开创意义的著作。这本书讲解了遗传算法领域中的基本知识，阐述理论基础，探索其应用。&lt;/p&gt;
&lt;p&gt;到了 80 年代，HNC 对“数据挖掘”这个短语注册了商标。注册这个商标的目的是为了保护名为“数据挖掘工作站”的产品的知识产权。该工作站是一种构建神经网络模型的通用工具，不过现在早已销声匿迹。也正是在这个时期，出现了一些成熟的算法，能够“学习”数据间关系，相关领域的专家能够从中推测出各种数据关系的实际意义。&lt;/p&gt;
&lt;p&gt;1989 年，术语“数据库中的知识发现”（KDD）被Gregory Piatetsky-Shapiro 提出。同样这个时期，他合作建立起第一个同样名为KDD的研讨会。&lt;/p&gt;
&lt;p&gt;到了 90 年代，“数据挖掘”这个术语出现在数据库社区。零售公司和金融团体使用数据挖掘分析数据和观察趋势以扩大客源，预测利率的波动，股票价格以及顾客需求。&lt;/p&gt;
&lt;p&gt;1992 年，Berhard E. Boser, Isabelle M. Guyon 和 Vladimir N. Vanik对原始的支持向量机提出了一种改进办法，新的支持向量机充分考虑到非线性分类器的构建。支持向量机是一种监督学习方法，用分类和回归分析的方法进行数据分析和模式识别式。&lt;/p&gt;
&lt;p&gt;1993 年，Gregory Piatetsky-Shapiro 创立“ Knowledge Discovery Nuggets (KDnuggets) ”通讯。本意是联系参加KDD研讨会的研究者，然而KDnuggets.com的读者群现在似乎广泛得多。&lt;/p&gt;
&lt;p&gt;2001 年，尽管“数据科学”这个术语在六十年代就已存在，但直至 2001 年，William S. Cleveland 才以一个独立的概念介绍它。根据《Building Data Science Teams》所著，DJ Patil 和 Jeff Hammerbacher 随后使用这个术语介绍他们在 LinkedIn 和 Facebook 中承担的角色 。&lt;/p&gt;
&lt;p&gt;2003 年，Micheal Lewis 写的 《点球成金》 出版，同时它也改变了许多主流联赛决策层的工作方式。奥克兰运动家队（美国职业棒球大联盟球队）使用一种统计的，数据驱动的方式针对球员的素质进行筛选，这些球员被低估或者身价更低。以这种方式，他们成功组建了一支打进2002和2003年季后赛的队伍，而他们的薪金总额只有对手的1/3。&lt;/p&gt;
&lt;p&gt;如今（2015年），在 2015 年二月，DJ Patil成为白宫第一位首位数据科学家。今天，数据挖掘已经遍布商业、科学、工程和医药，这还只是一小部分。信用卡交易，股票市场流动，国家安全，基因组测序以及临床试验方面的挖掘，都只是指数据挖掘应用的冰山一角。随着数据收集成本变得越来越低，数据收集设备数目激增，像大数据这样的专有名词现在已经是随处可见。&lt;/p&gt;
&lt;p&gt;数据挖掘的故事就是这样，匆匆而过！我是否错还过了什么值得提及的事情？我是不是对某些事情叙述的还不够准确？请在下面的评论中让我知道，或者直接邮件联系我。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interesting Resources&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a title=&quot;Data Mining Resources (Marcus P. Zillman)&quot; href=&quot;http://www.zillman.us/subject-tracers/data-mining-resources/&quot; target=&quot;_blank&quot;&gt;Data Mining Resources (Marcus P. Zillman)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;From Data Mining to Big Data and Beyond&quot; href=&quot;http://insideanalysis.com/2012/04/data-mining-and-beyond/&quot; target=&quot;_blank&quot;&gt;From Data Mining to Big Data and Beyond&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;Moneyball (Wikipedia)&quot; href=&quot;http://en.wikipedia.org/wiki/Moneyball&quot; target=&quot;_blank&quot;&gt;Moneyball (Wikipedia)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;NeuralWare Professional II/Plus, HNC Database Mining Workstation&quot; href=&quot;http://archive.raabassociatesinc.com/1993/09/neuralware-professional-iiplushnc-database-mining-workstationadvanced-software-applications-modelmax/&quot; target=&quot;_blank&quot;&gt;NeuralWare Professional II/Plus, HNC Database Mining Workstation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;The Nature of Code, Chapter 10. Neural Networks&quot; href=&quot;http://natureofcode.com/book/chapter-10-neural-networks/&quot; target=&quot;_blank&quot;&gt;The Nature of Code, Chapter 10. Neural Networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;The Analytics Big Bang&quot; href=&quot;https://visual.ly/look-history-and-future-predictive-analytics-and-big-data&quot; target=&quot;_blank&quot;&gt;The Analytics Big Bang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;A Very Short History of Data Science (Forbes)&quot; href=&quot;http://www.forbes.com/sites/gilpress/2013/05/28/a-very-short-history-of-data-science/&quot; target=&quot;_blank&quot;&gt;Very Short History of Data Science (Forbes)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;What is the Origin of Data Mining?&quot; href=&quot;http://www.tgc.com/dsstar/00/1031/102347.html&quot; target=&quot;_blank&quot;&gt;What is the Origin of Data Mining?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;History of Data Mining&quot; href=&quot;http://visual.ly/history-data-mining&quot; target=&quot;_blank&quot;&gt;History of Data Mining Infographic (visual.ly)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87420&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87420votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87420&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者：&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/myillusion3852&quot;&gt;myillusion3852&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/myillusion3852&quot;&gt;
			&lt;img src=&quot;/images/jobbole.com/4d8ad0b6e65624d1c18aac0963063eaf.jpg&quot;&gt;
		&lt;/a&gt;
	&lt;/div&gt;

    &lt;div class=&quot;author-bio-info&quot;&gt;

        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            主要兴趣领域为图像处理，模式识别和机器学习方向，希望多与大家交流。        &lt;/span&gt;
        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            &lt;a href=&quot;http://www.jobbole.com/members/myillusion3852&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 个人主页&lt;/a&gt; · 
            &lt;a href=&quot;http://blog.jobbole.com/author/myillusion3852/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;/i&gt; 我的文章&lt;/a&gt;

             · &lt;a title=&quot;声望值&quot; target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/myillusion3852/reputation/&quot;&gt;&lt;i class=&quot;fa fa-graduation-cap&quot;&gt;&lt;/i&gt; 10&lt;/a&gt;        &lt;/span&gt;
    &lt;/div&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Tue, 09 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-09-87420-9e2943f54.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-09-87420-9e2943f54.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>运维角度浅谈MySQL数据库优化</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;一个成熟的数据库架构并不是一开始设计就具备高可用、高伸缩等特性的，它是随着用户量的增加，基础架构才逐渐完善。这篇博文主要谈MySQL数据库发展周期中所面临的问题及优化方案，暂且抛开前端应用不说，大致分为以下五个阶段：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1、数据库表设计&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;项目立项后，开发部根据产品部需求开发项目，开发工程师工作其中一部分就是对表结构设计。对于数据库来说，这点很重要，如果设计不当，会直接影响访问速度和用户体验。影响的因素很多，比如慢查询、低效的查询语句、没有适当建立索引、数据库堵塞（死锁）等。当然，有测试工程师的团队，会做压力测试，找bug。对于没有测试工程师的团队来说，大多数开发工程师初期不会太多考虑数据库设计是否合理，而是尽快完成功能实现和交付，等项目有一定访问量后，隐藏的问题就会暴露，这时再去修改就不是这么容易的事了。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2、数据库部署&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;该运维工程师出场了，项目初期访问量不会很大，所以单台部署足以应对在1500左右的QPS（每秒查询率）。考虑到高可用性，可采用MySQL主从复制+Keepalived做双击热备，常见集群软件有Keepalived、Heartbeat。&lt;br&gt;
双机热备博文：http://lizhenliang.blog.51cto.com/7876557/1362313&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;3、数据库性能优化&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;如果将MySQL部署到普通的X86服务器上，在不经过任何优化情况下，MySQL理论值正常可以处理2000左右QPS，经过优化后，有可能会提升到2500左右QPS，否则，访问量当达到1500左右并发连接时，数据库处理性能就会变慢，而且硬件资源还很富裕，这时就该考虑软件问题了。那么怎样让数据库最大化发挥性能呢？一方面可以单台运行多个MySQL实例让服务器性能发挥到最大化，另一方面是对数据库进行优化，往往操作系统和数据库默认配置都比较保守，会对数据库发挥有一定限制，可对这些配置进行适当的调整，尽可能的处理更多连接数。&lt;br&gt;
具体优化有以下三个层面：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.1 数据库配置优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL常用有两种存储引擎，一个是MyISAM，不支持事务处理，读性能处理快，表级别锁。另一个是InnoDB，支持事务处理（ACID），设计目标是为处理大容量数据发挥最大化性能，行级别锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表锁：开销小，锁定粒度大，发生死锁概率高，相对并发也低。&lt;/li&gt;
&lt;li&gt;行锁：开销大，锁定粒度小，发生死锁概率低，相对并发也高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么会出现表锁和行锁呢？主要是为了保证数据的完整性，举个例子，一个用户在操作一张表，其他用户也想操作这张表，那么就要等第一个用户操作完，其他用户才能操作，表锁和行锁就是这个作用。否则多个用户同时操作一张表，肯定会数据产生冲突或者异常。&lt;br&gt;
根据以上看来，使用InnoDB存储引擎是最好的选择，也是MySQL5.5以后版本中默认存储引擎。每个存储引擎相关联参数比较多，以下列出主要影响数据库性能的参数。&lt;br&gt;
公共参数默认值：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;max_connections = 151
#同时处理最大连接数，推荐设置最大连接数是上限连接数的80%左右
sort_buffer_size = 2M
#查询排序时缓冲区大小，只对order by和group by起作用，可增大此值为16M
query_cache_limit = 1M
#查询缓存限制，只有1M以下查询结果才会被缓存，以免结果数据较大把缓存池覆盖
query_cache_size = 16M
#查看缓冲区大小，用于缓存SELECT查询结果，下一次有同样SELECT查询将直接从缓存池返回结果，可适当成倍增加此值
open_files_limit = 1024
#打开文件数限制，如果show global status like &#39;open_files&#39;查看的值等于或者大于open_files_limit值时，程序会无法连接数据库或卡死&lt;/pre&gt;
&lt;p&gt;MyISAM参数默认值：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;key_buffer_size = 16M
#索引缓存区大小，一般设置物理内存的30-40%
read_buffer_size = 128K
#读操作缓冲区大小，推荐设置16M或32M&lt;/pre&gt;
&lt;p&gt;InnoDB参数默认值：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;innodb_buffer_pool_size = 128M
#索引和数据缓冲区大小，一般设置物理内存的60%-70%
innodb_buffer_pool_instances = 1
#缓冲池实例个数，推荐设置4个或8个
innodb_flush_log_at_trx_commit = 1
#关键参数，0代表大约每秒写入到日志并同步到磁盘，数据库故障会丢失1秒左右事务数据。1为每执行一条SQL后写入到日志并同步到磁盘，I/O开销大，执行完SQL要等待日志读写，效率低。2代表只把日志写入到系统缓存区，再每秒同步到磁盘，效率很高，如果服务器故障，才会丢失事务数据。对数据安全性要求不是很高的推荐设置2，性能高，修改后效果明显。
innodb_file_per_table = OFF
#默认是共享表空间，共享表空间idbdata文件不断增大，影响一定的I/O性能。推荐开启独立表空间模式，每个表的索引和数据都存在自己独立的表空间中，可以实现单表在不同数据库中移动。
innodb_log_buffer_size = 8M
#日志缓冲区大小，由于日志最长每秒钟刷新一次，所以一般不用超过16M&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt; 3.2 系统内核优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数MySQL都部署在linux系统上，所以操作系统的一些参数也会影响到MySQL性能，以下对linux内核进行适当优化。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;net.ipv4.tcp_fin_timeout = 30
#TIME_WAIT超时时间，默认是60s
net.ipv4.tcp_tw_reuse = 1
#1表示开启复用，允许TIME_WAIT socket重新用于新的TCP连接，0表示关闭
net.ipv4.tcp_tw_recycle = 1
#1表示开启TIME_WAIT socket快速回收，0表示关闭
net.ipv4.tcp_max_tw_buckets = 4096
#系统保持TIME_WAIT socket最大数量，如果超出这个数，系统将随机清除一些TIME_WAIT并打印警告信息
net.ipv4.tcp_max_syn_backlog = 4096
#进入SYN队列最大长度，加大队列长度可容纳更多的等待连接&lt;/pre&gt;
&lt;p&gt;在linux系统中，如果进程打开的文件句柄数量超过系统默认值1024，就会提示“too many files open”信息，所以要调整打开文件句柄限制。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;# vi /etc/security/limits.conf #加入以下配置，*代表所有用户，也可以指定用户，重启系统生效
* soft nofile 65535
* hoft nofile 65535
# ulimit -SHn 65535 #立刻生效&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt; 3.3 硬件配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加大物理内存，提高文件系统性能。linux内核会从内存中分配出缓存区（系统缓存和数据缓存）来存放热数据，通过文件系统延迟写入机制，等满足条件时（如缓存区大小到达一定百分比或者执行sync命令）才会同步到磁盘。也就是说物理内存越大，分配缓存区越大，缓存数据越多。当然，服务器故障会丢失一定的缓存数据。&lt;br&gt;
SSD硬盘代替SAS硬盘，将RAID级别调整为RAID1+0，相对于RAID1和RAID5有更好的读写性能（IOPS），毕竟数据库的压力主要来自磁盘I/O方面。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4、数据库架构扩展&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;随着业务量越来越大，单台数据库服务器性能已无法满足业务需求，该考虑加机器了，该做集群了~~~。主要思想是分解单台数据库负载，突破磁盘I/O性能，热数据存放缓存中，降低磁盘I/O访问频率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 4.1 主从复制与读写分离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为生产环境中，数据库大多都是读操作，所以部署一主多从架构，主数据库负责写操作，并做双击热备，多台从数据库做负载均衡，负责读操作，主流的负载均衡器有LVS、HAProxy、Nginx。怎么来实现读写分离呢？大多数企业是在代码层面实现读写分离，效率比较高。另一个种方式通过代理程序实现读写分离，企业中应用较少，常见代理程序有MySQL Proxy、Amoeba。在这样数据库集群架构中，大大增加数据库高并发能力，解决单台性能瓶颈问题。如果从数据库一台从库能处理2000 QPS，那么5台就能处理1w QPS，数据库横向扩展性也很容易。&lt;br&gt;
有时，面对大量写操作的应用时，单台写性能达不到业务需求。如果做双主，就会遇到数据库数据不一致现象，产生这个原因是在应用程序不同的用户会有可能操作两台数据库，同时的更新操作造成两台数据库数据库数据发生冲突或者不一致。在单库时MySQL利用存储引擎机制表锁和行锁来保证数据完整性，怎样在多台主库时解决这个问题呢？有一套基于perl语言开发的主从复制管理工具，叫MySQL-MMM（Master-Master replication managerfor Mysql，Mysql主主复制管理器），这个工具最大的优点是在同一时间只提供一台数据库写操作，有效保证数据一致性。&lt;br&gt;
主从复制博文：http://lizhenliang.blog.51cto.com/7876557/1290431&lt;br&gt;
读写分离博文：http://lizhenliang.blog.51cto.com/7876557/1305083&lt;br&gt;
MySQL-MMM博文：http://lizhenliang.blog.51cto.com/7876557/1354576&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 4.2 增加缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给数据库增加缓存系统，把热数据缓存到内存中，如果内存缓存中有要请求的数据就不再去数据库中返回结果，提高读性能。缓存实现有本地缓存和分布式缓存，本地缓存是将数据缓存到本地服务器内存中或者文件中，速度快。分布式可以缓存海量数据，扩展容易，主流的分布式缓存系统有memcached、redis，memcached性能稳定，数据缓存在内存中，速度很快，QPS可达8w左右。如果想数据持久化那就用redis，性能不低于memcached。&lt;br&gt;
工作过程：&lt;br&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9e725f12ca2b912d6ee41e23682956be.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 4.3 分库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分库是根据业务不同把相关的表切分到不同的数据库中，比如web、bbs、blog等库。如果业务量很大，还可将切分后的库做主从架构，进一步避免单个库压力过大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 4.4 分表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据量的日剧增加，数据库中某个表有几百万条数据，导致查询和插入耗时太长，怎么能解决单表压力呢？你就该考虑是否把这个表拆分成多个小表，来减轻单个表的压力，提高处理效率，此方式称为分表。&lt;br&gt;
分表技术比较麻烦，要修改程序代码里的SQL语句，还要手动去创建其他表，也可以用merge存储引擎实现分表，相对简单许多。分表后，程序是对一个总表进行操作，这个总表不存放数据，只有一些分表的关系，以及更新数据的方式，总表会根据不同的查询，将压力分到不同的小表上，因此提高并发能力和磁盘I/O性能。&lt;br&gt;
分表分为垂直拆分和水平拆分：&lt;br&gt;
垂直拆分：把原来的一个很多字段的表拆分多个表，解决表的宽度问题。你可以把不常用的字段单独放到一个表中，也可以把大字段独立放一个表中，或者把关联密切的字段放一个表中。&lt;br&gt;
水平拆分：把原来一个表拆分成多个表，每个表的结构都一样，解决单表数据量大的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 4.5 分区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分区就是把一张表的数据分成多个区块，这些区块可以在一个磁盘上，也可以在不同的磁盘上，分区后，表面上还是一张表，但数据散列在多个位置，这样一来，多块硬盘同时处理不同的请求，从而提高磁盘I/O读写性能，实现比较简单。&lt;br&gt;
注：增加缓存、分库、分表和分区主要由程序猿来实现。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5、数据库维护&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;数据库维护是运维工程师或者DBA主要工作，包括性能监控、性能分析、性能调优、数据库备份和恢复等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 5.1 性能状态关键指标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;QPS，Queries Per Second：每秒查询数，一台数据库每秒能够处理的查询次数&lt;br&gt;
TPS，Transactions Per Second：每秒处理事务数&lt;br&gt;
通过show status查看运行状态，会有300多条状态信息记录，其中有几个值帮可以我们计算出QPS和TPS，如下：&lt;br&gt;
Uptime：服务器已经运行的实际，单位秒&lt;br&gt;
Questions：已经发送给数据库查询数&lt;br&gt;
Com_select：查询次数，实际操作数据库的&lt;br&gt;
Com_insert：插入次数&lt;br&gt;
Com_delete：删除次数&lt;br&gt;
Com_update：更新次数&lt;br&gt;
Com_commit：事务次数&lt;br&gt;
Com_rollback：回滚次数&lt;br&gt;
那么，计算方法来了，基于Questions计算出QPS：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;mysql&amp;gt; show global status like &#39;Questions&#39;;
mysql&amp;gt; show global status like &#39;Uptime&#39;;&lt;/pre&gt;
&lt;p&gt;QPS = Questions / Uptime&lt;br&gt;
基于Com_commit和Com_rollback计算出TPS：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;mysql&amp;gt; show global status like &#39;Com_commit&#39;;
mysql&amp;gt; show global status like &#39;Com_rollback&#39;;
mysql&amp;gt; show global status like &#39;Uptime&#39;;
TPS = (Com_commit + Com_rollback) / Uptime&lt;/pre&gt;
&lt;p&gt;另一计算方式：基于Com_select、Com_insert、Com_delete、Com_update计算出QPS&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;mysql&amp;gt; show global status where Variable_name in(&#39;com_select&#39;,&#39;com_insert&#39;,&#39;com_delete&#39;,&#39;com_update&#39;);&lt;/pre&gt;
&lt;p&gt;等待1秒再执行，获取间隔差值，第二次每个变量值减去第一次对应的变量值，就是QPS&lt;br&gt;
TPS计算方法：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;mysql&amp;gt; show global status where Variable_name in(&#39;com_insert&#39;,&#39;com_delete&#39;,&#39;com_update&#39;);&lt;/pre&gt;
&lt;p&gt;计算TPS，就不算查询操作了，计算出插入、删除、更新四个值即可。&lt;br&gt;
经网友对这两个计算方式的测试得出，当数据库中myisam表比较多时，使用Questions计算比较准确。当数据库中innodb表比较多时，则以Com_*计算比较准确。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 5.2 开启慢查询日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL开启慢查询日志，分析出哪条SQL语句比较慢，使用set设置变量，重启服务失效，可以在my.cnf添加参数永久生效。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;mysql&amp;gt; set global slow-query-log=on #开启慢查询功能
mysql&amp;gt; set global slow_query_log_file=&#39;/var/log/mysql/mysql-slow.log&#39;; #指定慢查询日志文件位置
mysql&amp;gt; set global log_queries_not_using_indexes=on; #记录没有使用索引的查询
mysql&amp;gt; set global long_query_time=1; #只记录处理时间1s以上的慢查询&lt;/pre&gt;
&lt;p&gt;分析慢查询日志，可以使用MySQL自带的mysqldumpslow工具，分析的日志较为简单。&lt;br&gt;
# mysqldumpslow -t 3 /var/log/mysql/mysql-slow.log #查看最慢的前三个查询&lt;br&gt;
也可以使用percona公司的pt-query-digest工具，日志分析功能全面，可分析slow log、binlog、general log。&lt;br&gt;
分析慢查询日志：pt-query-digest /var/log/mysql/mysql-slow.log&lt;br&gt;
分析binlog日志：mysqlbinlog mysql-bin.000001 &amp;gt;mysql-bin.000001.sql&lt;br&gt;
pt-query-digest –type=binlog mysql-bin.000001.sql&lt;br&gt;
分析普通日志：pt-query-digest –type=genlog localhost.log&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 5.3 数据库备份&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;备份数据库是最基本的工作，也是最重要的，否则后果很严重，你懂得！但由于数据库比较大，上百G，往往备份都很耗费时间，所以就该选择一个效率高的备份策略，对于数据量大的数据库，一般都采用增量备份。常用的备份工具有mysqldump、mysqlhotcopy、xtrabackup等，mysqldump比较适用于小的数据库，因为是逻辑备份，所以备份和恢复耗时都比较长。mysqlhotcopy和xtrabackup是物理备份，备份和恢复速度快，不影响数据库服务情况下进行热拷贝，建议使用xtrabackup，支持增量备份。&lt;br&gt;
Xtrabackup备份工具使用博文：http://lizhenliang.blog.51cto.com/7876557/1612800&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 5.4 数据库修复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候MySQL服务器突然断电、异常关闭，会导致表损坏，无法读取表数据。这时就可以用到MySQL自带的两个工具进行修复，myisamchk和mysqlcheck。&lt;br&gt;
myisamchk：只能修复myisam表，需要停止数据库&lt;br&gt;
常用参数：&lt;br&gt;
-f –force 强制修复，覆盖老的临时文件，一般不使用&lt;br&gt;
-r –recover 恢复模式&lt;br&gt;
-q –quik 快速恢复&lt;br&gt;
-a –analyze 分析表&lt;br&gt;
-o –safe-recover 老的恢复模式，如果-r无法修复，可以使用此参数试试&lt;br&gt;
-F –fast 只检查没有正常关闭的表&lt;br&gt;
快速修复weibo数据库:&lt;br&gt;
# cd /var/lib/mysql/weibo&lt;br&gt;
# myisamchk -r -q *.MYI&lt;br&gt;
mysqlcheck：myisam和innodb表都可以用，不需要停止数据库，如修复单个表，可在数据库后面添加表名，以空格分割&lt;br&gt;
常用参数：&lt;br&gt;
-a –all-databases 检查所有的库&lt;br&gt;
-r –repair 修复表&lt;br&gt;
-c –check 检查表，默认选项&lt;br&gt;
-a –analyze 分析表&lt;br&gt;
-o –optimize 优化表&lt;br&gt;
-q –quik 最快检查或修复表&lt;br&gt;
-F –fast 只检查没有正常关闭的表&lt;br&gt;
快速修复weibo数据库:&lt;br&gt;
mysqlcheck -r -q -uroot -p123 weibo&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 5.5 另外，查看CPU和I/O性能方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#查看CPU性能&lt;br&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b311e17361eac53a1b99e71479a1e6b1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;#参数-P是显示CPU数，ALL为所有，也可以只显示第几颗&lt;br&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/04ed2a4ce7940b586accd8d56c157ec7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;#查看I/O性能&lt;br&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4758059cd4d930927dec740f1106aa3f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;#参数-m是以M单位显示，默认K&lt;br&gt;
#%util：当达到100%时，说明I/O很忙。&lt;br&gt;
#await：请求在队列中等待时间，直接影响read时间。&lt;br&gt;
I/O极限：IOPS（r/s+w/s）,一般在1200左右。（IOPS，每秒进行读写（I/O）操作次数）&lt;br&gt;
I/O带宽：在顺序读写模式下SAS硬盘理论值在300M/s左右，SSD硬盘理论值在600M/s左右。&lt;/p&gt;
&lt;p&gt;以上是本人使用MySQL三年来总结的一些主要优化方案，能力有限，有些不太全面，但这些基本能够满足中小型企业数据库需求。由于关系型数据库初衷设计限制，一些BAT公司海量数据放到关系型数据库中，在海量数据查询和分析方面已经达不到更好的性能。因此NoSQL火起来了，非关系型数据库，大数据量，具有高性能，同时也弥补了关系型数据库某方面不足，渐渐大多数公司已经将部分业务数据库存放到NoSQL中，如MongoDB、HBase等。数据存储方面采用分布式文件系统，如HDFS、GFS等。海量数据计算分析采用Hadoop、Spark、Storm等。这些都是与运维相关的前沿技术，也是在存储方面主要学习对象，小伙伴们共同加油吧！哪位博友有更好的优化方案，欢迎交流哦。&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87450&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87450votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87450&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Mon, 08 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-08-87450-8c0cd12f5.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-08-87450-8c0cd12f5.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>代码覆盖率工具 Istanbul 入门教程</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;测试的时候，我们常常关心，是否所有代码都测试到了。&lt;br&gt;
这个指标就叫做”代码覆盖率”（code coverage）。它有四个测量维度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行覆盖率（line coverage）：是否每一行都执行了？&lt;/li&gt;
&lt;li&gt;函数覆盖率（function coverage）：是否每个函数都调用了？&lt;/li&gt;
&lt;li&gt;分支覆盖率（branch coverage）：是否每个if代码块都执行了？&lt;/li&gt;
&lt;li&gt;语句覆盖率（statement coverage）：是否每个语句都执行了？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istanbul 是 JavaScript 程序的代码覆盖率工具，本文介绍它的用法。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c451b4fdd1ac912fc1d6cf504c9f2b9b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个软件以土耳其最大城市伊斯坦布尔命名，因为土耳其地毯世界闻名，而地毯是用来覆盖的。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;一、安装&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Istanbul 是一个 npm 模块，安装非常简单，就一行命令。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ npm install -g istanbul&lt;/pre&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;二、覆盖率测试&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;来看一个例子，怎么使用 Istanbul 。下面是脚本文件 simple.js 。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;var a = 1;
var b = 1;
if ((a + b) &amp;gt; 2) {
console.log(&#39;more than two&#39;);
}&lt;/pre&gt;
&lt;p&gt;使用 istanbul cover 命令，就能得到覆盖率。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ istanbul cover simple.js

===== Coverage summary =====
Statements : 75% ( 3/4 )
Branches : 50% ( 1/2 )
Functions : 100% ( 0/0 )
Lines : 75% ( 3/4 )
=============================&lt;/pre&gt;
&lt;p&gt;返回结果显示，simple.js 有4个语句（statement），执行了3个；有2个分支（branch），执行了1个；有0个函数，调用了0个；有4行代码，执行了3行。&lt;br&gt;
这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。&lt;br&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f42190942081552a8d7ad5712a91b1b7.jpg&quot;&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;三、覆盖率门槛&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;完美的覆盖率当然是 100%，但是现实中很难达到。需要有一个门槛，衡量覆盖率是否达标。&lt;br&gt;
istanbul check-coverage 命令用来设置门槛，同时检查当前代码是否达标。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ istanbul check-coverage --statement 90

ERROR: Coverage for statements (75%) does not meet global threshold (90%)&lt;/pre&gt;
&lt;p&gt;上面命令设置语句覆盖率的门槛是 90% ，结果就报错了，因为实际覆盖率只有75%。&lt;br&gt;
除了百分比门槛，我们还可以设置绝对值门槛，比如只允许有一个语句没有被覆盖到。&lt;br&gt;
上面命令使用负数，表示绝对值门槛。这样一来，上面的例子就通过了覆盖率测试，不会再报错了。&lt;br&gt;
百分比门槛和绝对值门槛，可以结合使用。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ istanbul check-coverage --statement -5 --branch -3 --function 100&lt;/pre&gt;
&lt;p&gt;上面命令设置了3个覆盖率门槛：5个语句、3个 if 代码块、100%的函数。注意，这三个门槛是”与”（and）的关系，只要有一个没有达标，就会报错。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 四、与测试框架的结合&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;实际开发时，istanbul 总是与测试框架结合使用，下面以常用的 Mocha 框架为例。&lt;br&gt;
sqrt.js 是一个计算平方根的脚本。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;var My = {
sqrt: function(x) {
if (x &amp;lt; 0) throw new Error(&quot;负值没有平方根&quot;);
return Math.exp(Math.log(x)/2);
}
};

module.exports = My;&lt;/pre&gt;
&lt;p&gt;它的测试脚本 test.sqrt.js 放在 test 子目录。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;var chai = require(&#39;chai&#39;);
var expect = chai.expect;
var My = require(&#39;../sqrt.js&#39;);

describe(&quot;sqrt&quot;, function() {

it(&quot;4的平方根应该等于2&quot;, function() {
expect(My.sqrt(4)).to.equal(2);
});

it(&quot;参数为负值时应该报错&quot;, function() {
expect(function(){ My.sqrt(-1); }).to.throw(&quot;负值没有平方根&quot;);
});

});&lt;/pre&gt;
&lt;p&gt;然后，执行下面的命令得到代码覆盖率。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ istanbul cover _mocha
// or
$ istanbul cover _mocha test/test.sqrt.js

sqrt
✓ 4的平方根应该等于2
✓ 参数为负值时应该报错

2 passing (7ms)

===== Coverage summary =====
Statements : 100% ( 5/5 )
Branches : 100% ( 2/2 )
Functions : 100% ( 1/1 )
Lines : 100% ( 4/4 )
=============================&lt;/pre&gt;
&lt;p&gt;上面命令中，istanbul cover 命令后面跟的是 _mocha 命令，前面的下划线是不能省略的。&lt;br&gt;
因为，mocha 和 _mocha 是两个不同的命令，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。&lt;br&gt;
如果要向 mocha 传入参数，可以写成下面的样子。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ istanbul cover _mocha -- tests/test.sqrt.js -R spec&lt;/pre&gt;
&lt;p&gt;上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接1，2）。&lt;br&gt;
如果想在浏览器运行 Istanbul ，可以参考这篇文章。&lt;br&gt;
五、忽略某些代码&lt;br&gt;
istanbul 提供注释语法，允许某些代码不计入覆盖率。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;var object = parameter || /* istanbul ignore next */ {};&lt;/pre&gt;
&lt;p&gt;上面代码是为 object 指定默认值（一个空对象）。如果由于种种原因，没有为 object 为空对象的情况写测试，可以用注释，不将这种情况计入覆盖率。注意，注释要写在”或”运算符的后面。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;/* istanbul ignore if */
if (hardToReproduceError)) {
return callback(hardToReproduceError);
}&lt;/pre&gt;
&lt;p&gt;上面代码的 if 语句块，在计算覆盖率的时候会被忽略。&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87439&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87439votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87439&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Mon, 08 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-08-87439-803dbf52b.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-08-87439-803dbf52b.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Git Rebase</title>
        <description>

	
	

	&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/6918da8ea368cc748bf9097ee81a401d.jpg&quot; title=&quot;Git&quot; alt=&quot;Git&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git rebase&lt;/code&gt;是个非常强大灵活的命令，它可以让你对commit进行修改、调整顺序、合并等操作、并能以线性的方式进行分支的合并与嫁接等。&lt;/p&gt;

&lt;p&gt;简单来说&lt;code&gt;rebase&lt;/code&gt;就是把某个分支上的一部分commit嫁接到另一个commit后面，而在这个过程中这些commit的base（基）变了，所以这个操作叫做『变基』。&lt;/p&gt;

&lt;p&gt;比如我们有如下的提交历史，当前的分支是&lt;code&gt;topic&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     A---B---C topic(HEAD)
    /
D---E---F---G master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们执行了如下任何一个命令之后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase master
$ git rebase master topic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提交历史将会变成如下这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;              A&#39;--B&#39;--C&#39; topic(HEAD)
             /
D---E---F---G master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出git把&lt;code&gt;A---B---C&lt;/code&gt;这段commit嫁接到了&lt;code&gt;G&lt;/code&gt;之后，不过虽然这些新commit的内容是一样的，但是hash值是不同的（&lt;code&gt;A&#39;--B&#39;--C&#39;&lt;/code&gt;），原因将在后面解释。&lt;/p&gt;

&lt;p&gt;命令完整的形式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt;是新的base，如果你提供&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;，那么首先会checkout到这个&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;，然后再进行rebase操作。所以以下两种方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase master topic
$ git rebase master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;的区别是第一种形式会首先checkout到topic分支，然后再执行rebase的操作。&lt;/p&gt;

&lt;p&gt;那么rebase都做了什么事情呢？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先，git会对topic分支和&lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt;做一个差集，把不同的commit找出来，类似于执行&lt;code&gt;git log &amp;lt;upstream&amp;gt;..HEAD&lt;/code&gt;，对于以上例子来说结果就是&lt;code&gt;A---B---C&lt;/code&gt;，然后把这些commit存在一个临时的地方。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其次，git会把当前分支reset到&lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt;上，类似于执行&lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt;命令。对于以上例子来说就是reset到&lt;code&gt;master&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后，git把第一步中暂存的commit，按照顺序一个一个地应用到分支上，相当于一个一个重复提交，这就是为什么rebase之后commit的hash值变了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;如果&lt;upstream&gt;中的一个commit进行了某项修改，而当前分支中也存在一个commit，这两个commit的修改的内容一样，那么当前分支中的commit将会被忽略。比如以下的&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;A&#39;&lt;/code&gt;就是这样两个commit。&lt;/upstream&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          A---B---C topic
         /
    D---E---A&#39;---F master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完git rebase master之后，结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               B&#39;---C&#39; topic
              /
D---E---A&#39;---F master        
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想更灵活的进行commit嫁接，那么你需要&lt;code&gt;rebase --onto&lt;/code&gt;，命令格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase --onto &amp;lt;newbase&amp;gt; &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设你有如下的branch tree：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你想要得到如下的branch tree：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o---o---o---o---o  master
        |            \
        |             o&#39;--o&#39;--o&#39;  topic
         \
          o---o---o---o---o  next
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那我们需要如下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase --onto master next topic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个操作会把从&lt;code&gt;next&lt;/code&gt;开始的commit嫁接到&lt;code&gt;master&lt;/code&gt;上。如果你提供&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;，那么首先会checkout到这个&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;，然后再进行rebase操作。&lt;/p&gt;

&lt;p&gt;我们再看一个例子，比如我们有如下的branch tree：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E---F---G---H---I---J  topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们想要删除&lt;code&gt;F---G&lt;/code&gt;这两个commit，那么通过&lt;code&gt;rebase --onto&lt;/code&gt;就可以实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase --onto topicA~5 topicA~3 topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E---H&#39;---I&#39;---J&#39;  topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，rebase也会产生冲突，当解决完冲突之后你可以继续rebase的进程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase --continue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者取消此次rebase：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase --abort
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于commit修改、顺序调整、合并等操作可以通过&lt;code&gt;rebase -i&lt;/code&gt;来完成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase -i &amp;lt;upstream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chitsaou写的&lt;a href=&quot;http://blog.yorkxin.org/posts/2011/07/29/git-rebase/&quot;&gt;《Git-rebase 小筆記》&lt;/a&gt;中有详细的介绍，可以自行查看。&lt;/p&gt;

&lt;h2&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://git-scm.com/docs/git-rebase&quot;&gt;http://git-scm.com/docs/git-rebase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.yorkxin.org/posts/2011/07/29/git-rebase/&quot;&gt;http://blog.yorkxin.org/posts/2011/07/29/git-rebase/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


	(完)

	&lt;div class=&quot;post-info&quot;&gt;
		07 Jun 2015  
	
		
	
		
	&lt;/div&gt;
	
	&lt;!-- disqus start --&gt;
	
	
	
	
	&lt;!-- disqus end --&gt;

	&lt;!-- related start --&gt;
	
	&lt;!-- related end --&gt;

</description>
        <pubDate>Sun, 07 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-07-git-rebase.html-26805a866.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-07-git-rebase.html-26805a866.html</guid>
        
        
        <category>weizhifeng</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（17） ： 复制</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87340/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（7） ： 查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87345/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（8） ： 插入 更新 删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87348/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（9） ： 索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87351/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（10） ： 自定义存储过程和函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87353/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（11） ： 视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87355/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（12） ： 触发器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87357/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（13） ： 权限管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87363/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（14） ： 备份和恢复&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87365/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（15） ： 日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87367/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（16） ： 优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最近把大学时候的ORACLE教程书本翻出来看，真的是感触良多&lt;/p&gt;
&lt;p&gt;以前在学校的时候，每次ORACLE测验和考试都是不合格的，期末的时候靠补考才勉强过关&lt;/p&gt;
&lt;p&gt;大家看到下图的封面应该知道大学教我们ORACLE课程的老师，没错，他就是李爱武老师&lt;/p&gt;
&lt;p&gt;大家可能对李爱武老师不太熟悉，在ORACLE领域，大家第一时间肯定会想到“盖国强”&lt;/p&gt;
&lt;p&gt;还记得前段时间某个媒体说“盖国强”是中国第一DBA，但是我在百度里面搜索“&lt;strong&gt;中国第一DBA&lt;/strong&gt;”并没有出现“&lt;strong&gt;盖国强&lt;/strong&gt;”三个字o(∩_∩)o&lt;/p&gt;
&lt;p&gt;李爱武老师可能会有一些人认识，他写了几本数据库方面的书，以&lt;strong&gt;SQLSERVER&lt;/strong&gt;和&lt;strong&gt;ORACLE&lt;/strong&gt;为主&lt;/p&gt;
&lt;p&gt;老师的实力是毋容置疑的，老师上课的风格是比较凶的那种，不过老师他很细心，会把ORACLE里面的知识点讲透&lt;/p&gt;
&lt;p&gt;因为比较凶，所以很多时候不是很想上他的课，有时候会选择逃课，但是想不到多年后自己会做了DBA，会研究数据库&lt;/p&gt;
&lt;p&gt;虽然未到教师节，但是还是要&lt;strong&gt;感谢&lt;/strong&gt;李爱武老师和大学里教我计算机知识的其他老师，感谢&lt;/p&gt;
&lt;p&gt;不扯了，马上开始今天的内容。。。&lt;/p&gt;
&lt;p&gt;的&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e4b25982090974677afe663874ce4289.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一篇主要介绍MYSQL的复制&lt;/p&gt;
&lt;p&gt;MYSQL 从3.25.15版本开始提供数据库复制功能（replication）。mysql复制是指从一个mysql主服务器（MASTER）将数据&lt;/p&gt;
&lt;p&gt;复制到另一台或多台mysql从服务器（SLAVE）的过程，将主数据库的DDL和DML操作通过二进制日志传到复制服务器上，&lt;/p&gt;
&lt;p&gt;然后在从服务器上对这些日志重新执行，从而使从服务器的数据保持同步。&lt;/p&gt;
&lt;p&gt;在mysql中，复制操作是异步进行的，slave服务器不需要持续的保持连接接收master服务器的数据&lt;/p&gt;
&lt;p&gt;mysql支持一台主服务器同时向多台从服务器进行复制操作，从服务器同时可以作为其他从服务器的主服务器，如果mysql主服务器&lt;/p&gt;
&lt;p&gt;访问量大，可以通过复制数据，然后在从服务器上进行查询操作，从而降低主服务器的访问压力（读写分离），同时从服务器作为&lt;/p&gt;
&lt;p&gt;主服务器的备份，可以避免主服务器因为故障数据丢失的问题。&lt;/p&gt;
&lt;p&gt;mysql数据库复制操作大致可以分为三个步骤&lt;/p&gt;
&lt;p&gt;1主服务器将数据的改变记录到二进制日志（binlog）中。&lt;/p&gt;
&lt;p&gt;2、从服务器将主服务器的binary log events复制到他的中继日志（relay log）中。&lt;/p&gt;
&lt;p&gt;3、从服务器做中继日志中的事件，将数据的改变与从服务器保持同步。&lt;/p&gt;
&lt;p&gt;首先，主服务器会记录二进制日志，每个事务更新完毕数据之前，主服务器将这些操作的信息记录在二进制日志里面，在事件写入&lt;/p&gt;
&lt;p&gt;二进制日志完成后，主服务器 通知存储引擎提交事务。&lt;/p&gt;
&lt;p&gt;SLAVE上面的I/O进程连接上MASTER，并发出日志请求，MASTER接收到来自SLAVE的I/O进程的请求后，通过负责复制的I/O进程&lt;/p&gt;
&lt;p&gt;根据请求信息读取指定日志位置之后的日志信息，返回给SLAVE的I/O进程。返回信息中除了日志所包含的信息之外，还包括本次&lt;/p&gt;
&lt;p&gt;返回的信息已经到MASTER端的binlog文件的名称以及binlog的位置&lt;/p&gt;
&lt;p&gt;SLAVE的I/O进程接收到信息后，将接收到的日志内容依次添加到SLAVE端的relay-log文件的最末端，并将读取到的MASTER端的&lt;/p&gt;
&lt;p&gt;binlog文件名和位置记录到master-Info文件中&lt;/p&gt;
&lt;p&gt;SLAVE的SQL进程检测到relay-log中新增了内容后，会马上解析relay-log的内容成为在master端真实执行时候的那些可执行内容，&lt;/p&gt;
&lt;p&gt;并在自身执行&lt;/p&gt;
&lt;p&gt;mysql复制环境，90%以上都是一个master带一个或者多个slave的架构模式。如果master和slave压力不是太大的话，异步复制的延时一般&lt;/p&gt;
&lt;p&gt;都很少。尤其是slave端的复制方式改成两个进程处理之后，更是减少了slave端的延时&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示：对于数据实时性要求不是特别严格的应用，只需要通过廉价的电脑服务器来扩展slave的数量，将读压力分散到多台slave的机器上面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即可解决数据库端的读压力瓶颈。这在很大程度上解决了目前很多中小型网站的数据库压力瓶颈问题，甚至有些大型网站也在使用类似方案解决&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Windows环境下的mysql主从复制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制前的准备工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Windows环境下，如果想实现主从复制需要准备的操作环境&lt;/p&gt;
&lt;p&gt;角色          ip                      端口            操作系统          mysql版本&lt;/p&gt;
&lt;p&gt;master   192.168.1.100     3306           Windows7         5.5.20&lt;/p&gt;
&lt;p&gt;slave      192.168.1.102     3306           Windows8         5.5.20&lt;/p&gt;
&lt;p&gt;Windows环境下实现主从复制&lt;/p&gt;
&lt;p&gt;准备好两台安装mysql5.6的计算机，即可实现两台mysql服务器主从复制备份操作。&lt;/p&gt;
&lt;p&gt;具体操作步骤如下：&lt;/p&gt;
&lt;p&gt;1、在Windows下安装好两台mysql服务器，配置好两台主机的ip地址，实现两台计算机可以网络连通&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e4db397c6d1c072cde94cc1586586dc0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/858b47aac78eed02e6c58433b8846436.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、配置master的相关配置信息，在master主机上开启binlog日志，首先，看下datadir的具体路径&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show variables  LIKE &#39;%datadir%&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9081833fb4c378b405291faf1218fb99.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、此时需要打开在D:\Program Files (x86)\MySQL\MySQL Server 5.5路径下的配置文件my.ini，添加如下代码，开启binlog功能&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[mysqld]
log-bin=&quot;D:/MYSQLDataBase/binlog&quot;
expire_logs_days=10
max_binlog_size=100M&lt;/pre&gt;
&lt;p&gt;提示：此事我们需要在D盘下面创建MYSQLDATABASE文件夹，binlog日志记录在该文件夹里面，该配置文件中的其他参数如下所示&lt;/p&gt;
&lt;p&gt;expire_logs_days：表示二进制日志文件删除的天数&lt;/p&gt;
&lt;p&gt;max_binlog_size：表示二进制日志文件最大的大小&lt;/p&gt;
&lt;p&gt;4、登录mysql后，可以执行show VARIABLES LIKE ‘%log_bin%’命令来测试下log_bin是否成功开启&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show VARIABLES LIKE &#39;%log_bin%&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/12ee54d964ed78650ef2b11725d2cd28.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/eb0ae4ce72f561ce82441d0a7899a468.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果log_bin参数是ON的话，那么表示二进制日志文件已经成功开启，如果为OFF的话，那么表示二进制日志文件开启失败&lt;/p&gt;
&lt;p&gt;5、在master上配置复制所需要的账户，这里创建一个repl的用户，%表示任何远程地址的repl用户都可以连接master主机&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;GRANT replication slave ON *.*TO repl@&#39;%&#39; IDENTIFIED BY &#39;123&#39;;

flush privileges;&lt;/pre&gt;
&lt;p&gt;6、在my.ini配置文件里配置master主机的相关信息&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[mysqld]
log-bin=&quot;D:/MYSQLDataBase/binlog&quot;
expire_logs_days=10
max_binlog_size=100M

server-id=1
binlog-do-db=test
binlog-ignore-db=mysql&lt;/pre&gt;
&lt;p&gt;这些配置语句的含义&lt;/p&gt;
&lt;p&gt;server-id：表示服务器表示id号，master和slave主机的server-id不能一样&lt;/p&gt;
&lt;p&gt;binlog-do-db：表示需要复制的数据库，这里以test库为例&lt;/p&gt;
&lt;p&gt;binlog-ignore-db：表示不需要复制的数据库&lt;/p&gt;
&lt;p&gt;7、重启master主机上的mysql服务，然后输入show master status命令查询master主机的信息&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/44682bf477158f259fd1b91cf337562d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;8、将master主机的数据备份出来，然后导入到slave主机中去，具体执行语句如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqldump -u root -p -h 127.0.0.1 test &amp;gt;D:\TEST.TXT&lt;/pre&gt;
&lt;p&gt;TEST库里面的表和数据&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/89d44fb0a3dcc9f2673068c0ff6ae9bb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/843457bddd30b007604527499a35ffe9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;innodb_monitor表是没有数据的&lt;/p&gt;
&lt;p&gt;dump出来的txt文件内容&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;-- MySQL dump 10.13  Distrib 5.5.20, for Win32 (x86)
--
-- Host: 127.0.0.1    Database: test
-- ------------------------------------------------------
-- Server version    5.5.20-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE=&#39;+00:00&#39; */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#39;NO_AUTO_VALUE_ON_ZERO&#39; */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `book`
--

DROP TABLE IF EXISTS `book`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `book` (
  `bookid` int(11) NOT NULL,
  `bookname` varchar(255) NOT NULL,
  `authors` varchar(255) NOT NULL,
  `info` varchar(255) DEFAULT NULL,
  `comment` varchar(255) DEFAULT NULL,
  `year_publication` year(4) NOT NULL,
  KEY `year_publication` (`year_publication`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `book`
--

LOCK TABLES `book` WRITE;
/*!40000 ALTER TABLE `book` DISABLE KEYS */;
INSERT INTO `book` VALUES (12,&#39;dajiahao&#39;,&#39;NIHAO&#39;,&#39;??&#39;,&#39;henhao&#39;,1990);
/*!40000 ALTER TABLE `book` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `innodb_monitor`
--

DROP TABLE IF EXISTS `innodb_monitor`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `innodb_monitor` (
  `a` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `innodb_monitor`
--

LOCK TABLES `innodb_monitor` WRITE;
/*!40000 ALTER TABLE `innodb_monitor` DISABLE KEYS */;
/*!40000 ALTER TABLE `innodb_monitor` ENABLE KEYS */;
UNLOCK TABLES;

/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2014-08-05 22:36:17&lt;/pre&gt;
&lt;p&gt;将D:\TEST.TXT文件复制到slave机器上，然后执行如下操作&lt;/p&gt;
&lt;p&gt;在命令行登录mysql，然后 USE TEST;&lt;/p&gt;
&lt;p&gt;记得一定要USE TEST，切换数据库上下文，否则会报错：NO DATABASE SELECTED 的错误信息&lt;/p&gt;
&lt;p&gt;然后执行source命令导入TEXT.txt文件的内容&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5019edc2fd2c5d675de040a2afc5207b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，数据已经导入到slave上面了&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/48218f869b7a90ec23ff7ab3a4a52967.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;9、配置slave机器（192.168.1.102）的my.ini配置文件&lt;/p&gt;
&lt;p&gt;具体配置信息如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[mysql]

default-character-set=utf8
log_bin=&quot;C:/MYSQLLOG/binlog&quot;
expire_logs_days=10
max_binlog_size=100M

[mysqld]
server-id=2&lt;/pre&gt;
&lt;p&gt;提示：配置slave主机my.ini文件的时候，需要将server-id=2写到[mysqld]后面&lt;/p&gt;
&lt;p&gt;另外如果配置文件中还有log_bin的配置，可以将他注释掉，如下所示&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;#Binary Logging
#log-bin
#log_bin=&quot;xxx&quot;&lt;/pre&gt;
&lt;p&gt;10、重启slave主机（192.168.1.102）的mysql服务，在slave主机（192.168.1.102）的mysql中执行如下命令&lt;/p&gt;
&lt;p&gt;关闭slave服务&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;stop slave;&lt;/pre&gt;
&lt;p&gt;11、设置slave从机实现复制相关的信息，命令如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;change master to
master_host=&#39;192.168.1.100&#39;,
master_user=&#39;repl&#39;,
master_password=&#39;123&#39;,
master_log_file=&#39;binlog。000004&#39;,
master_log_pos=107;

Command(s) completed successfully.&lt;/pre&gt;
&lt;p&gt;各个参数所代表的具体含义如下：&lt;/p&gt;
&lt;p&gt;master_host：表示实现复制的主机ip地址&lt;/p&gt;
&lt;p&gt;master_user：表示实现复制的登录远程主机的用户&lt;/p&gt;
&lt;p&gt;master_password：表示实现复制的登录远程主机的密码&lt;/p&gt;
&lt;p&gt;master_log_file：表示实现复制的binlog日志文件&lt;/p&gt;
&lt;p&gt;master_log_pos：表示实现复制的binlog日志文件的偏移量&lt;/p&gt;
&lt;p&gt;12、继续在从机执行操作，显示slave从机的状况，如下所示&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;start slave;

Command(s) completed successfully.&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; SHOW SLAVE STATUS \G;
*************************** 1. row ***************************
               Slave_IO_State:
                  Master_Host: 192.168.1.100
                  Master_User: repl
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: binlog銆?00004
          Read_Master_Log_Pos: 107
               Relay_Log_File: Steven-PC-relay-bin.000002
                Relay_Log_Pos: 4
        Relay_Master_Log_File: binlog銆?00004
             Slave_IO_Running: No
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 107
              Relay_Log_Space: 107
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: NULL
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 1236
                Last_IO_Error: Got fatal error 1236 from master when reading dat
a from binary log: &#39;Could not find first log file name in binary log index file&#39;

               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Master_Server_Id: 1
1 row in set (0.00 sec)

ERROR:
No query specified&lt;/pre&gt;
&lt;p&gt;在上述执行show slave status \G命令中很显然存在一些问题，问题如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt; Last_IO_Errno: 1236
                Last_IO_Error: Got fatal error 1236 from master when reading dat
a from binary log: &#39;Could not find first log file name in binary log index file&#39;&lt;/pre&gt;
&lt;p&gt;下面的步骤可以解决问题，具体步骤如下&lt;/p&gt;
&lt;p&gt;1、重启master（192.168.1.100）主机的mysql服务，执行show master status \G命令&lt;/p&gt;
&lt;p&gt;记下File和Position的值，后面slave主机会用到，命令执行如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW MASTER STATUS;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/14c9359d96f43d8d8271858b14225031.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、在slave（192.168.1.102）主机上重新设置信息，命令执行如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;stop slave;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;change master to
master_log_file=&#39;binlog.000005&#39;,
master_log_pos=107;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;start slave;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; SHOW SLAVE STATUS \G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.1.100
                  Master_User: repl
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: binlog.000005
          Read_Master_Log_Pos: 107
               Relay_Log_File: Steven-PC-relay-bin.000002
                Relay_Log_Pos: 250
        Relay_Master_Log_File: binlog.000005
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 107
              Relay_Log_Space: 410
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Master_Server_Id: 1
1 row in set (0.00 sec)

ERROR:
No query specified&lt;/pre&gt;
&lt;p&gt;这次正常了，实际上刚才有两个地方是错误的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一个&lt;/strong&gt;：在从机的my.ini里面&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[mysql]
default-character-set=utf8
#log_bin=&quot;C:/MYSQLLOG/binlog&quot;
#expire_logs_days=10
#max_binlog_size=100M&lt;/pre&gt;
&lt;p&gt;在从机的my.ini里面的mysql配置节下面配置了binlog，实际上这样做是错误的，要配置binlog需要在[mysqld]配置节下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个&lt;/strong&gt;：第一次配置从机的同步的时候本人写错了标点符号，.号写成。号&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;master_log_file=&#39;binlog。000004&#39;,&lt;/pre&gt;
&lt;p&gt;这时候，我们可以在从机上面执行show processlist来查询从服务器的进程状态&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; show processlist \G
*************************** 1. row ***************************
     Id: 4
   User: root
   Host: localhost:60968
     db: information_schema
Command: Sleep
   Time: 3613
  State:
   Info: NULL
*************************** 2. row ***************************
     Id: 5
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 3613
  State: Waiting for master to send event
   Info: NULL
*************************** 3. row ***************************
     Id: 6
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 2769
  State: Slave has read all relay log; waiting for the slave I/O thread to update it
   Info: NULL
*************************** 4. row ***************************
     Id: 7
   User: root
   Host: localhost:61007
     db: NULL
Command: Query
   Time: 0
  State: NULL
   Info: show processlist
4 rows in set (0.04 sec)&lt;/pre&gt;
&lt;p&gt;结果表明slave已经连接上master，开始接收并执行日志&lt;/p&gt;
&lt;p&gt;relay-log.info文件里面的内容&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;.\Steven-PC-relay-bin.000002
250
binlog.000005
107
7&lt;/pre&gt;
&lt;p&gt;relay-log.info文件里面记录了slave端的relaylog的当前文件名和位置，还有master端的binlog文件名和位置&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/336d035302a39501b689b12bc47e4cc2.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Windows环境下主从复制测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、在master端的mysql环境下，执行下面命令&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;use test;
create table rep_test(data integer);

insert into rep_test values(2);&lt;/pre&gt;
&lt;p&gt;2、在slave端的mysql环境下，查看主机刚才添加的表和数据是否成功同步到从机上&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;use test;

show tables;

select * FROM REP_TEST;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ec21cc2d0cdfded8c4f44674891b6f2f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4ab2c6589e307985d3fa2e3709641848.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;测试表明，数据已经成功地同步到slave上，实验中只是用到了主从同步，在实际生产环境中MYSQL架构可能会用到一主多从的架构&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;MYSQL主要复制启动选项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）log-slave-updates&lt;/p&gt;
&lt;p&gt;log-slave-updates这个参数主要用来配置从服务器的更新是否写入二进制日志，该选项默认是不打开的，如果这个&lt;/p&gt;
&lt;p&gt;从服务器同时也作为其他服务器的主服务器，搭建一个链式的复制，那么就需要开启这个选项，这样从服务器才能获取他&lt;/p&gt;
&lt;p&gt;的二进制日志进行同步操作&lt;/p&gt;
&lt;p&gt;（2）master-connect-retry&lt;/p&gt;
&lt;p&gt;master-connect-retry这个参数用来设置和主服务器连接丢失的时候进行重试的时间间隔，默认是60秒&lt;/p&gt;
&lt;p&gt;（3）read-only&lt;/p&gt;
&lt;p&gt;read-only是用来限制普通用户对从数据库的更新操作，以确保从数据库的安全性，不过如果是超级用户依然可以对&lt;/p&gt;
&lt;p&gt;从数据库进行更新操作。如果主数据库创建了一个普通用户，在默认情况下，该用户是可以更新从数据库的数据的，如果&lt;/p&gt;
&lt;p&gt;使用read-only选项启动从数据库以后，用户对从数据库进行更新时会提示错误&lt;/p&gt;
&lt;p&gt;在Linux下启动mysql例子&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[root@localhost~]#mysqld_safe -read-only&lt;/pre&gt;
&lt;p&gt;（4）slave-skip-errors&lt;/p&gt;
&lt;p&gt;在复制过程中，从服务器可以会执行BINLOG中的错误SQL语句，此时如果不忽略错误，从服务器会停止复制进程，等待用户处理错误。&lt;/p&gt;
&lt;p&gt;这种错误如果不能及时发现，将会对应用或者备份产生影响。slave-skip-errors的作用就是用来定义复制过程中从服务器可以自动&lt;/p&gt;
&lt;p&gt;跳过的错误号，设置该参数后，mysql会自动跳过所配置的一系列错误，直接执行后面的SQL语句，该参数可以定义多个错误号，如果&lt;/p&gt;
&lt;p&gt;设置成all，则表示跳过所有的错误，在my.ini或者my.cnf里配置如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;slave-skip-errors=1007,1051,1062&lt;/pre&gt;
&lt;p&gt;如果从数据库主要作为主库的备份，那么就不应该使用这个启动参数，因为一旦设置不当很可能造成主从库的数据不同步。&lt;/p&gt;
&lt;p&gt;如果从库仅仅是为了分担主库的查询压力，并且对数据的完整性要求不高，那么这个选项可以减轻DBA维护从库的工作量&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;查看slave的复制进度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多情况下，用户都想知道从服务器复制的进度，从而判断从服务器上复制数据的完整性，同时判断是否需要手工来做&lt;/p&gt;
&lt;p&gt;主从同步工作。&lt;/p&gt;
&lt;p&gt;事实上，用户可以通过show processlist列表中的Slave_SQL_Running线程的Time值得到，他记录了从服务器当前执行的SQL时间戳&lt;/p&gt;
&lt;p&gt;和系统时间之间的差距，例如下面的例子&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;  Id: 6
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 2769
  State: Slave has read all relay log; waiting for the slave I/O thread to update it
   Info: NULL&lt;/pre&gt;
&lt;p&gt;Time时间说明从服务器最后执行的更新操作大概是主服务器&lt;strong&gt;2769秒&lt;/strong&gt;前的更新操作&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;日常管理和维护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;复制配置完成后，DBA需要进行日常的监控和管理维护工作，以便能够及时发现问题和解决问题&lt;/p&gt;
&lt;p&gt;以保证主从数据库能够正常工作。&lt;/p&gt;
&lt;p&gt;1、了解服务器的状态&lt;/p&gt;
&lt;p&gt;一般使用show slave status命令来检查从服务器&lt;/p&gt;
&lt;p&gt;在查看服务器信息中，首先要查看下面的两个进程是否为YES。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Slave_IO_Running: Yes
Slave_SQL_Running: Yes&lt;/pre&gt;
&lt;p&gt;Slave_IO_Running表明此进程是否能够由从服务器到主服务器上正确地读取binlog日志，并写入到从服务器的中继日志中&lt;/p&gt;
&lt;p&gt;Slave_SQL_Running表明此进程能否读取并执行中继日志中的binlog信息&lt;/p&gt;
&lt;p&gt;2、服务器复制出错原因&lt;/p&gt;
&lt;p&gt;问题一：出现“log event entry exceeded max_allowed_pack”错误&lt;/p&gt;
&lt;p&gt;如果在应用中使用大的BLOB列或CLOB列或者长字符串，那么在从服务器上回复时，可能会出现&lt;/p&gt;
&lt;p&gt;“log event entry exceeded max_allowed_pack”的错误，这是因为含有达文本的记录无法通过网络进行传输而导致的&lt;/p&gt;
&lt;p&gt;解决方法是在主服务器和从服务器上添加max_allowed_packet参数，该参数默认设置为1MB&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show variables LIKE &#39;%max_all%&#39;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Variable_name      Value   
------------------ ------- 
max_allowed_packet 1048576 

(1 row(s) affected)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;set @@global.max_allowed_packet=16777216;&lt;/pre&gt;
&lt;p&gt;同时在my.ini或my.cnf文件里设置max_allowed_packet=16M，数据库重启之后该参数将有效&lt;/p&gt;
&lt;p&gt;问题二：多主复制时的自增长变量冲突问题&lt;/p&gt;
&lt;p&gt;大多数情况下使用一台主服务器对一台或者多台从服务器，但是在某些情况下可能会存在多个服务器配置为复制主服务器，&lt;/p&gt;
&lt;p&gt;使用auto_increment时应采取特殊步骤以防止键值冲突，否则插入时多个主服务器会试图使用相同的auto_increment值&lt;/p&gt;
&lt;p&gt;服务器变量auto_increment_increment和auto_increment_offset可以协调多主服务器复制auto_increment列&lt;/p&gt;
&lt;p&gt;在多主服务器复制到从服务器的过程中会发生主键冲突问题，可以将不同的主服务器的这两个参数重新进行设置，将A库&lt;/p&gt;
&lt;p&gt;上设置auto_increment_increment=1，auto_increment_offset=1，此时B库上设置&lt;/p&gt;
&lt;p&gt;auto_increment_increment=1，auto_increment_offset=0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：一般不建议使用双主或多主，因为这样会带来意想不到的冲突状况，就像SQLSERVER的对等复制，虽然有很多冲突检测措施&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是有时候冲突是不可预料的，出现冲突DBA要排查，维护成本较高，我们生产环境里是没有使用双主和多主，主要使用的是一主多从或一主一从&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;切换主从服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实际生产环境，如果主机上的主库发生故障，需要将从机上的从库切换成主库，同时需要修改服务器C的配置文件，使程序连接到从机&lt;/p&gt;
&lt;p&gt;下面介绍主从切换的步骤&lt;/p&gt;
&lt;p&gt;1、首先要确保所有的从库都已经执行了relay log中的全部更新，看从库的状态是否是Has read all relay log，是否更新都已经执行完成&lt;/p&gt;
&lt;p&gt;在从库上执行下面命令&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;STOP SLAVE IO_THREAD;

Command(s) completed successfully.&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; show processlist \G
*************************** 1. row ***************************
     Id: 4
   User: root
   Host: localhost:60968
     db: test
Command: Sleep
   Time: 45
  State:
   Info: NULL
*************************** 2. row ***************************
     Id: 6
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 3949
  State: Slave has read all relay log; waiting for the slave I/O thread to update it
   Info: NULL
*************************** 3. row ***************************
     Id: 7
   User: root
   Host: localhost:61007
     db: NULL
Command: Query
   Time: 0
  State: NULL
   Info: show processlist
3 rows in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;2、在从库上停止slave服务，然后执行reset master重置成为主库&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;STOP SLAVE;

Command(s) completed successfully.

RESET MASTER;
Command(s) completed successfully.&lt;/pre&gt;
&lt;p&gt;注意：如果从库上并未开binlog，那么在执行reset master的时候会报错：ERROR 1186(HY000):BINLOG CLOSED ,CANNOT RESET MASTER&lt;/p&gt;
&lt;p&gt;在切换之后，在从库的数据目录会多出master.info文件&lt;/p&gt;
&lt;p&gt;master.info文件里的内容&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;18
binlog.000005
393
192.168.1.100
repl
123
3306
60
0

0
1800.000

0
0&lt;/pre&gt;
&lt;p&gt;基本上记录了主库的复制用户、密码和binlog文件名和位置等&lt;/p&gt;
&lt;p&gt;3、在从库B（192.168.1.102）上添加具有replication权限的用户repl，查询主库状态，命令如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;GRANT REPLICATION SLAVE ON *.*TO &#39;repl&#39;@&#39;localhost&#39; identified by &#39;123&#39;;

show master status;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c2edd2bb5dab902ce5e281324941792d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、修改主服务器的my.ini文件里的server-id为1，从服务器的server-id为2&lt;/p&gt;
&lt;p&gt;5、在原来的主库（192.168.1.100）上配置复制参数&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;change master TO
master_host=&#39;192.168.1.102&#39;,
master_user=&#39;repl&#39;,
master_password=&#39;123&#39;,
master_port=3306,
master_log_file=&#39;on.000004&#39;,
master_log_pos=107;&lt;/pre&gt;
&lt;p&gt;6、在从库（192.168.1.100）上执行show slave status命令查看从库是否启动成功&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;START SLAVE;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; show slave status \G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.1.102
                  Master_User: repl
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: on.000004
          Read_Master_Log_Pos: 107
               Relay_Log_File: joe-relay-bin.000006
                Relay_Log_Pos: 246
        Relay_Master_Log_File: on.000004
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 107
              Relay_Log_Space: 436
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Master_Server_Id: 1
1 row in set (0.00 sec)

ERROR:
No query specified&lt;/pre&gt;
&lt;p&gt;注意：如果在主库上面（192.168.1.102）的复制用户repl没有允许远程主机从库的访问，那么在执行show slave status的时候就会报错&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt; Last_IO_Errno: 1130
 Last_IO_Error: error connecting to master &#39;repl@192.168.1.102:3360  retries: 8640006&#39; - retry-time: 60  retries: 86400&lt;/pre&gt;
&lt;p&gt;这时候，只需要在主库（192.168.1.102）上面执行下面语句即可&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;use mysql;
select * from user where user=&#39;repl&#39;;
update user set host = &#39;%&#39; where user =&#39;repl&#39;;
flush privileges;&lt;/pre&gt;
&lt;p&gt;7、在主库和从库上面是否成功设置复制功能，首先在主库（192.168.1.102）上查看test库中的表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;use test;
show tables;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5c52f32d39bd879d054b01f883bb08a9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;查询从库中（192.168.1.100）test库里表的情况&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;use test;
show tables;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/14304fa0cadf5b3d09329b4007746de6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;跟主库一样&lt;/p&gt;
&lt;p&gt;8、在主库（192.168.1.102）中增加表rep_t ，并插入数据&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;create table rep_t(data int);

insert into rep_t values(1);&lt;/pre&gt;
&lt;p&gt;9、在从库（192.168.1.100）上查询表是否已经创建并复制数据到从库中&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE test;

show variables like &#39;%server%&#39;;

show tables;

SELECT * FROM rep_t;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/65d6d02c9a49d674feb79e594563629e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;至此，主从库成功切换&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;如果主机和从机server-id一样如何解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常情况下，master和slave的server-id是不会一样的，如果一样的话会出现报错&lt;/p&gt;
&lt;p&gt;出现这种情况，用户可以使用如下命令来查看服务器的server-id，然后手动进行修改，如下所示&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show variables like &#39;%server_id%&#39;;

Variable_name Value 
------------- ----- 
server_id     2     

(1 row(s) affected)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET global server_id=1&lt;/pre&gt;
&lt;p&gt;修改完成后，执行slave start命令，查询slave主机的状态，查看问题可否解决&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;从机状态显示Last_IO_Error错误代码为2013的原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候会遇到这样的情况，在执行show slave status \G 命令中 Slave_IO_Running和Slave_SQL_Running的值都是YES&lt;/p&gt;
&lt;p&gt;但是Last_IO_Error发生2013错误&lt;/p&gt;
&lt;p&gt;发生这种问题主要原因是网络问题，首先要检查下master主机创建的用户是否授予远程连接的权限&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;GRANT replication slave ON *.*TO repl@&#39;%&#39; IDENTIFIED BY &#39;123&#39;;&lt;/pre&gt;
&lt;p&gt;这里%表示任何的repl用户都可以访问master主机，另外需要查看是否有防火墙设置和网络的其他故障&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;MYSQL复制不同步的原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql replication（复制）采用binlog进行网络传输，所以网络延时是产生mysql主从不同步的主要原因，这会给我们进行读写分离带来&lt;/p&gt;
&lt;p&gt;一定困难&lt;/p&gt;
&lt;p&gt;为了避免这种情况，在配置服务器的时候推荐使用INNODB存储引擎的表，在主机上可以设置&lt;strong&gt;sync_binlog&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面内容摘抄自《MYSQL行调优和架构设计》&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“sync_binlog”：这个参数是对于 MySQL 系统来说是至关重要的，他不仅影响到 Binlog 对 MySQL 所&lt;/p&gt;
&lt;p&gt;带来的性能损耗，而且还影响到 MySQL 中数据的完整性。对于“sync_binlog”参数的各种设置的说明如&lt;/p&gt;
&lt;p&gt;下：&lt;/p&gt;
&lt;p&gt;● sync_binlog=0，当事务提交之后，MySQL 不做 fsync 之类的磁盘同步指令刷新 binlog_cache 中&lt;/p&gt;
&lt;p&gt;的信息到磁盘，而让 Filesystem 自行决定什么时候来做同步，或者 cache 满了之后才同步到磁&lt;/p&gt;
&lt;p&gt;盘。&lt;/p&gt;
&lt;p&gt;● sync_binlog=n，当每进行 n 次事务提交之后，MySQL 将进行一次 fsync 之类的磁盘同步指令来&lt;/p&gt;
&lt;p&gt;将 binlog_cache 中的数据强制写入磁盘。&lt;/p&gt;
&lt;p&gt;在 MySQL 中系统默认的设置是 sync_binlog=0，也就是不做任何强制性的磁盘刷新指令，这时候的性&lt;/p&gt;
&lt;p&gt;能是最好的，但是风险也是最大的。因为一旦系统 Crash，在 binlog_cache 中的所有 binlog 信息都会被&lt;/p&gt;
&lt;p&gt;丢失。而当设置为“1”的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使系统&lt;/p&gt;
&lt;p&gt;Crash，也最多丢失 binlog_cache 中未完成的一个事务，对实际数据没有任何实质性影响。从以往经验&lt;/p&gt;
&lt;p&gt;和相关测试来看，对于高并发事务的系统来说，“sync_binlog”设置为 0 和设置为 1 的系统写入性能差&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果master主机上的max_allowed_packet比较大，但是从机上没有配置该值的话，该参数还是使用默认值1MB&lt;/p&gt;
&lt;p&gt;此时很有可能导致同步失败，建议主从两台机器都设为5MB比较合适&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文简单的阐述了MYSQL的复制方面的内容，MYSQL复制是比较重要的技术&lt;/p&gt;
&lt;p&gt;文本的主从切换使用手工的方式，当然在真实生产环境一般使用&lt;strong&gt;自动切换脚本&lt;/strong&gt;和&lt;strong&gt;软件工具&lt;/strong&gt;去做自动主从切换，这里不做介绍了&lt;/p&gt;
&lt;p&gt;希望这篇文章对大家有帮助&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87369&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87369votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87369&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt; 1 收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sun, 07 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-07-87369-741661838.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-07-87369-741661838.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（16） ： 优化</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87340/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（7） ： 查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87345/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（8） ： 插入 更新 删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87348/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（9） ： 索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87351/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（10） ： 自定义存储过程和函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87353/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（11） ： 视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87355/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（12） ： 触发器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87357/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（13） ： 权限管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87363/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（14） ： 备份和恢复&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87365/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（15） ： 日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一步一步走来已经写到了第十六篇了~&lt;/p&gt;
&lt;p&gt;这一篇主要介绍MYSQL的优化，优化MYSQL数据库是DBA和开发人员的必备技能&lt;/p&gt;
&lt;p&gt;MYSQL优化一方面是找出系统瓶颈，提高MYSQL数据库整体性能；另一方面需要合理的结构设计和参数调整，以提高&lt;/p&gt;
&lt;p&gt;用户操作响应的速度；同时还有尽可能节省系统资源，以便系统可以提供更大负荷的服务&lt;/p&gt;
&lt;p&gt;如果大家看过我写的两篇文章，那么学习MYSQL的索引就不会太难，因为是相通的&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/lyhabc/p/3196479.html&quot; href=&quot;http://www.cnblogs.com/lyhabc/p/3196479.html&quot; target=&quot;_blank&quot;&gt;SQLSERVER聚集索引与非聚集索引的再次研究（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/lyhabc/p/3196484.html&quot; href=&quot;http://www.cnblogs.com/lyhabc/p/3196484.html&quot; target=&quot;_blank&quot;&gt;SQLSERVER聚集索引与非聚集索引的再次研究（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实MYSQL也有&lt;strong&gt;SQLSERVER堆表&lt;/strong&gt;的概念&lt;/p&gt;
&lt;p&gt;myisam允许&lt;strong&gt;没有任何索引和主键的表存在，个人觉得没有主键的myisam表都属于堆表，因为MYSQL不支持非主键的聚集索引。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;innodb引擎如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)&lt;/p&gt;
&lt;p&gt;详细参考：&lt;a title=&quot;http://www.searchdatabase.com.cn/showcontent_56283.htm&quot; href=&quot;http://www.searchdatabase.com.cn/showcontent_56283.htm&quot; target=&quot;_blank&quot;&gt;MyISAM vs InnoDB：MySQL存储引擎详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过《MyISAM vs InnoDB：MySQL存储引擎详解》文章也有一点错误，意向共享锁就是表锁，其实是不对的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、优化简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统的反应速度。&lt;/p&gt;
&lt;p&gt;例如，通过优化文件系统，提高磁盘I/O的读写速度；通过优化操作系统调度策略，提高mysql在高负荷情况下&lt;/p&gt;
&lt;p&gt;的负载能力；优化表结构、索引、查询语句等使查询响应更快&lt;/p&gt;
&lt;p&gt;在mysql中，可以使用show status语句查询一些mysql的性能参数&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show status like &#39;value&#39;;&lt;/pre&gt;
&lt;p&gt;其中value是要查询的参数值，一些常用性能参数如下：&lt;/p&gt;
&lt;p&gt;connections：连接mysql服务器的次数&lt;/p&gt;
&lt;p&gt;uptime：mysql服务器的上线时间&lt;/p&gt;
&lt;p&gt;slow_queries：慢查询的次数&lt;/p&gt;
&lt;p&gt;com_select:查询操作次数&lt;/p&gt;
&lt;p&gt;com_insert:插入操作次数&lt;/p&gt;
&lt;p&gt;com_update:更新操作次数&lt;/p&gt;
&lt;p&gt;com_delete:删除操作次数&lt;/p&gt;
&lt;p&gt;如果查询mysql服务器的连接次数，可以执行如下语句&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show status like &#39;connections&#39;;&lt;/pre&gt;
&lt;p&gt;如果查询mysql服务器的慢查询次数，可以执行如下语句&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show status like &#39;slow_queries&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、优化查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询是数据库最频繁的操作，提高查询速度可以有效地提高mysql数据库的性能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）分析查询语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过对查询语句的分析，可以了解查询语句的执行情况找出查询语句执行的瓶颈&lt;/p&gt;
&lt;p&gt;mysql中提供了EXPLAIN语句和DESCRIBE语句，用来分析查询语句&lt;/p&gt;
&lt;p&gt;EXPLAIN语句的基本语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;EXPLAIN [EXTENDED] SELECT SELECT_OPTION&lt;/pre&gt;
&lt;p&gt;使用EXTENDED关键字，EXPLAIN语句将产生附加信息。SELECT_OPTION是SELECT 语句的查询选项，包括FROM WHERE子句等&lt;/p&gt;
&lt;p&gt;执行该语句，可以分析EXPLAIN后面的select语句的执行情况，并且能够分析所查询的表的一些特征&lt;/p&gt;
&lt;p&gt;使用EXPLAIN语句来分析1个查询语句&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE TEST;
EXPLAIN EXTENDED SELECT * FROM PERSON;&lt;/pre&gt;
&lt;p&gt;下面对结果进行解释&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;· id&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SELECT识别符。这是SELECT的查询序列号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;· select_type&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SELECT类型，可以为以下任何一种：&lt;/p&gt;
&lt;p&gt;SIMPLE：简单SELECT(不使用UNION或子查询)&lt;/p&gt;
&lt;p&gt;PRIMARY：表示主查询，或者是最外层的查询语句（多表连接的时候）&lt;/p&gt;
&lt;p&gt;UNION：表示连接查询的第二个或后面的查询语句&lt;/p&gt;
&lt;p&gt;DEPENDENT UNION：UNION连接查询中的第二个或后面的SELECT语句，取决于外面的查询&lt;/p&gt;
&lt;p&gt;UNION RESULT：UNION连接查询的结果&lt;/p&gt;
&lt;p&gt;SUBQUERY：子查询中的第一个SELECT语句&lt;/p&gt;
&lt;p&gt;DEPENDENT SUBQUERY：子查询中的第一个SELECT语句，取决于外面的查询&lt;/p&gt;
&lt;p&gt;DERIVED：导出表的SELECT(FROM子句的子查询)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;· table&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示查询的表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;· type&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示表的联接类型&lt;/p&gt;
&lt;p&gt;下面给出各种联接类型，按照从最佳类型到最坏类型进行排序：&lt;/p&gt;
&lt;p&gt;（1）system&lt;/p&gt;
&lt;p&gt;表仅有一行(=系统表)。这是const联接类型的一个特例。&lt;/p&gt;
&lt;p&gt;（2）const&lt;/p&gt;
&lt;p&gt;表最多只有一个匹配行，它将在查询开始时被读取。余下的查询优化中被作为常量对待。const表查询速度很快，因为它们只读取一次。&lt;/p&gt;
&lt;p&gt;const用于常数值比较PRIMARY KEY或UNIQUE索引的所有部分的场合。&lt;/p&gt;
&lt;p&gt;在下面的查询中，tbl_name可以用于const表：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * from tbl_name WHERE primary_key=1;SELECT * from tbl_name
WHERE primary_key_part1=1和 primary_key_part2=2;&lt;/pre&gt;
&lt;p&gt;（3）eq_ref&lt;/p&gt;
&lt;p&gt;对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。&lt;/p&gt;
&lt;p&gt;它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY时。&lt;/p&gt;
&lt;p&gt;eq_ref可以用于使用“=” 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。&lt;/p&gt;
&lt;p&gt;在下面的例子中，MySQL可以使用eq_ref联接来处理ref_tables：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM ref_table,other_table
WHERE ref_table.key_column=other_table.column;

SELECT * FROM ref_table,other_table
WHERE ref_table.key_column_part1=other_table.column
 AND ref_table.key_column_part2=1;&lt;/pre&gt;
&lt;p&gt;（4）ref&lt;/p&gt;
&lt;p&gt;对于每个来自于前面的表的任意行组合，将从该表中读取所有匹配的行。&lt;/p&gt;
&lt;p&gt;如果联接只使用索引键的最左边的前缀，或如果索引键不是UNIQUE或PRIMARY KEY，则使用ref。&lt;/p&gt;
&lt;p&gt;如果使用的键仅仅匹配少量行，该联接类型是不错的。&lt;/p&gt;
&lt;p&gt;ref可以用于使用=或&amp;lt;=&amp;gt;操作符的带索引的列。&lt;/p&gt;
&lt;p&gt;在下面的例子中，MySQL可以使用ref联接来处理ref_tables：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM ref_table WHERE key_column=expr;

SELECT * FROM ref_table,other_table
WHERE ref_table.key_column=other_table.column;

SELECT * FROM ref_table,other_table
WHERE ref_table.key_column_part1=other_table.column
AND ref_table.key_column_part2=1;&lt;/pre&gt;
&lt;p&gt;（5）ref_or_null&lt;/p&gt;
&lt;p&gt;该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行，在解决子查询中经常使用该联接类型的优化。&lt;/p&gt;
&lt;p&gt;在下面的例子中，MySQL可以使用ref_or_null联接来处理ref_tables：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM ref_table
WHERE key_column=expr OR key_column IS NULL;&lt;/pre&gt;
&lt;p&gt;（6） index_merge&lt;/p&gt;
&lt;p&gt;该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了所用到的索引的清单，key_len列包含了所用到的索引的最长长度。&lt;/p&gt;
&lt;p&gt;（7） unique_subquery&lt;/p&gt;
&lt;p&gt;该类型替换了下面形式的IN子查询的ref：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;value IN (SELECT primary_key FROM single_table WHERE some_expr)&lt;/pre&gt;
&lt;p&gt;unique_subquery是一个索引查找类型，可以完全替换子查询，效率更高。&lt;/p&gt;
&lt;p&gt;（8） index_subquery&lt;/p&gt;
&lt;p&gt;该联接类型类似于unique_subquery，不过索引类型不需要是唯一索引，可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;value IN (SELECT key_column FROM single_table WHERE some_expr)&lt;/pre&gt;
&lt;p&gt;（9） range&lt;/p&gt;
&lt;p&gt;只检索给定范围的行，使用一个索引来检索行数据。key列显示使用了哪个索引，key_len显示所使用索引的长度。&lt;/p&gt;
&lt;p&gt;在该类型中ref列为NULL。&lt;/p&gt;
&lt;p&gt;当使用=、&amp;lt;&amp;gt;、&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=、IS NULL、&amp;lt;=&amp;gt;、BETWEEN或者IN操作符，用常量比较关键字列时，类型为range。&lt;/p&gt;
&lt;p&gt;下面介绍几种检索指定行数据的情况&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM tbl_name
WHERE key_column = 10;

SELECT * FROM tbl_name
WHERE key_column BETWEEN 10 and 20;

SELECT * FROM tbl_name
WHERE key_column IN (10,20,30);

SELECT * FROM tbl_name
WHERE key_part1= 10 AND key_part2 IN (10,20,30);&lt;/pre&gt;
&lt;p&gt;（10）  index&lt;/p&gt;
&lt;p&gt;该联接类型与ALL相同，除了扫描索引树。其他情况都比ALL快，因为索引文件通常比数据文件小。&lt;/p&gt;
&lt;p&gt;当查询只使用作为单索引一部分的列时，MySQL可以使用该联接类型。&lt;/p&gt;
&lt;p&gt;（11）   ALL&lt;/p&gt;
&lt;p&gt;对于每个来自于先前的表的行组合，进行完整的表扫描。&lt;/p&gt;
&lt;p&gt;如果第一个表没标记为const，这样执行计划就不会很好。&lt;/p&gt;
&lt;p&gt;通常可以增加更多的索引来摆脱ALL，使得行能基于前面的表中的常数值或列值被检索出。&lt;/p&gt;
&lt;p&gt;possible_keys&lt;/p&gt;
&lt;p&gt;possible_keys列指出MySQL能供给使用的索引键有哪些。注意，该列完全独立于EXPLAIN输出所示的表的次序。&lt;/p&gt;
&lt;p&gt;这意味着在possible_keys中的某些索引键实际上不能按生成的表次序使用。&lt;/p&gt;
&lt;p&gt;如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句查看是否可以引用某些列或适合的索引列来提高查询性能。&lt;/p&gt;
&lt;p&gt;如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询。&lt;/p&gt;
&lt;p&gt;如果要查询一张表有什么索引，可以使用&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW INDEX FROM tbl_name&lt;/pre&gt;
&lt;p&gt;key&lt;/p&gt;
&lt;p&gt;key列显示MySQL实际决定使用的键（索引）。如果没有选择索引，那么可能列的值是NULL。&lt;/p&gt;
&lt;p&gt;要想强制MySQL使用或忽略possible_keys列中的索引，在查询中可以使用&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;FORCE INDEX  -- 强逼使用某个索引&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE INDEX --使用某个索引&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;IGNORE INDEX -- 忽略某个索引&lt;/pre&gt;
&lt;p&gt;对于MyISAM引擎和BDB引擎的表，运行 ANALYZE TABLE 可以帮助优化器选择更好的索引。&lt;/p&gt;
&lt;p&gt;对于MyISAM表，可以使用myisamchk –analyze。&lt;/p&gt;
&lt;p&gt;key_len&lt;/p&gt;
&lt;p&gt;key_len列显示MySQL决定使用的索引键的长度（按字节计算）。如果键是NULL，则长度为NULL。&lt;/p&gt;
&lt;p&gt;注意通过key_len值我们可以确定MySQL将实际使用一个多索引键索引的几个字段。&lt;/p&gt;
&lt;p&gt;ref&lt;/p&gt;
&lt;p&gt;ref列显示使用哪个列或常数与索引一起查询记录。&lt;/p&gt;
&lt;p&gt;rows&lt;/p&gt;
&lt;p&gt;rows列显示MySQL&lt;strong&gt;预估&lt;/strong&gt;执行查询时必须要检索的行数。&lt;/p&gt;
&lt;p&gt;Extra&lt;/p&gt;
&lt;p&gt;该列包含MySQL处理查询时的详细信息。下面解释了该列可以显示的不同的文本字符串：&lt;/p&gt;
&lt;p&gt;Distinct&lt;/p&gt;
&lt;p&gt;MySQL发现第1个匹配行后，停止为当前的行组合搜索更多的行。&lt;/p&gt;
&lt;p&gt;Not exists&lt;/p&gt;
&lt;p&gt;MySQL能够对查询进行LEFT JOIN优化，发现1个匹配LEFT JOIN标准的行后，不再为前面的的行组合在该表内检查更多的行。&lt;/p&gt;
&lt;p&gt;下面是一个可以这样优化的查询类型的例子：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id
WHERE t2.id IS NULL;&lt;/pre&gt;
&lt;p&gt;假定t2.id定义为NOT NULL。在这种情况下，MySQL使用t1.id的值扫描t1并查找t2中的行。&lt;/p&gt;
&lt;p&gt;如果MySQL在t2中发现一个匹配的行，它知道t2.id绝不会为NULL，并且不再扫描t2内有相同的id值的行。换句话说，对于t1的每个行，MySQL只需要在t2中查找一次，无论t2内实际有多少匹配的行。&lt;/p&gt;
&lt;p&gt;range checked for each record (index map: #)&lt;/p&gt;
&lt;p&gt;MySQL没有发现好的可以使用的索引，但发现如果来自前面的表的列值已知，可能部分索引可以使用。&lt;/p&gt;
&lt;p&gt;对前面的表的每个行组合，MySQL检查是否可以使用range或index_merge访问方法来获取行。&lt;/p&gt;
&lt;p&gt;这并不很快，但比执行没有索引的联接要快得多。&lt;/p&gt;
&lt;p&gt;可以参考一下这篇文章：&lt;a title=&quot;http://blog.rds.aliyun.com/2014/05/23/%e4%b8%80%e4%b8%aa%e7%94%a8%e6%88%b7sql%e6%85%a2%e6%9f%a5%e8%af%a2%e5%88%86%e6%9e%90%ef%bc%8c%e5%8e%9f%e5%9b%a0%e5%8f%8a%e4%bc%98%e5%8c%96/&quot; href=&quot;http://blog.rds.aliyun.com/2014/05/23/%e4%b8%80%e4%b8%aa%e7%94%a8%e6%88%b7sql%e6%85%a2%e6%9f%a5%e8%af%a2%e5%88%86%e6%9e%90%ef%bc%8c%e5%8e%9f%e5%9b%a0%e5%8f%8a%e4%bc%98%e5%8c%96/&quot; target=&quot;_blank&quot;&gt;一个用户SQL慢查询分析，原因及优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面就提到了range checked for each record&lt;/p&gt;
&lt;p&gt;Using filesort&lt;/p&gt;
&lt;p&gt;MySQL需要额外的一次传递，以找出如何按排序顺序检索行。&lt;/p&gt;
&lt;p&gt;通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。&lt;/p&gt;
&lt;p&gt;然后关键字被排序，并按排序顺序检索行&lt;/p&gt;
&lt;p&gt;如果是&lt;strong&gt;order by&lt;/strong&gt;操作就会用到这个Using filesort，当然filesort不是指使用&lt;strong&gt;文件&lt;/strong&gt;来排序，大家不要误会了。。。&lt;/p&gt;
&lt;p&gt;Using index&lt;/p&gt;
&lt;p&gt;从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。当查询只使用作为单一索引一部分的列时，可以使用该策略。&lt;/p&gt;
&lt;p&gt;Using temporary&lt;/p&gt;
&lt;p&gt;为了解决查询，MySQL需要创建一个&lt;strong&gt;临时表&lt;/strong&gt;来容纳结果。&lt;/p&gt;
&lt;p&gt;典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句时。&lt;/p&gt;
&lt;p&gt;一般用到&lt;strong&gt;临时表&lt;/strong&gt;都会看到 &lt;strong&gt;Using temporary&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Using where&lt;/p&gt;
&lt;p&gt;WHERE子句用于限制哪一个行匹配下一个表或发送到客户端。&lt;/p&gt;
&lt;p&gt;除非你专门从表中索取或检查所有行，如果Extra值不为Using where并且表联接类型为ALL或index，查询可能会有一些错误。&lt;/p&gt;
&lt;p&gt;Using index for group-by&lt;/p&gt;
&lt;p&gt;类似于访问表的Using index方式，Using index for group-by表示MySQL发现了一个索引，可以用来查询GROUP BY或DISTINCT查询的所有列，&lt;/p&gt;
&lt;p&gt;而不要额外搜索硬盘访问实际的表。并且，按最有效的方式使用索引，以便对于每个组，只读取少量索引条目。&lt;/p&gt;
&lt;p&gt;DESCIBE语句的使用方法与EXPLAIN语句是一样的，并且分享结果也是一样的DESCIBE语句的语法如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DESCRIBE SELECT select_options&lt;/pre&gt;
&lt;p&gt;DESCIBE可以缩写成DESC&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）索引对查询速度的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql中提高性能的一个最有效的方式就是对数据表设计合理的索引。索引提供了高效访问数据的方法，并且加快查询速度&lt;/p&gt;
&lt;p&gt;因此索引对查询速度有着至关重要的影响。&lt;/p&gt;
&lt;p&gt;如果查询没有索引，查询语句将扫描表中所有记录。在数据量大的情况下，这样查询的速度会很慢。如果使用索引进行查询，&lt;/p&gt;
&lt;p&gt;查询语句可以根据索引快速定位到待查询记录，从而减少查询的记录数，达到提高查询速度的目的。&lt;/p&gt;
&lt;p&gt;下面是查询语句中不使用索引和使用索引的对比，首先分析未使用索引的查询情况，EXPLAIN语句执行如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;EXPLAIN SELECT `ID`,`name` FROM `test`.`emp` WHERE `name` =&#39;nihao&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dc763d004e911af3b939fbaa1c45e95e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，rows列的值是3说“SELECT `ID`,`name` FROM `test`.`emp` WHERE `name` =’nihao’” 语句扫描了表中的3条记录&lt;/p&gt;
&lt;p&gt;然后在emp表加上索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE INDEX ix_emp_name ON emp(name)&lt;/pre&gt;
&lt;p&gt;现在再分析上面的查询语句，执行的EXPLAIN语句结果如下&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f3e1f1dd2f72f350c0b08b6237b8bfac.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;结果显示，rows列的值为1。这表示这个查询语句只扫描了表中的一条记录，其他查询速度自然比扫描3条记录快。&lt;/p&gt;
&lt;p&gt;而且possible_keys 和key的值都是ix_emp_name ，这说明查询时使用了ix_emp_name 索引&lt;/p&gt;
&lt;p&gt;如果表中记录有100条、1000条、10000条优势就显现出来了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; （3）使用索引查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索引可以提高查询速度，但并不是使用带有索引的字段查询时，索引都会起作用。&lt;/p&gt;
&lt;p&gt;下面的几种情况跟跟SQLSERVER一样，有可能用不到索引&lt;/p&gt;
&lt;p&gt;（1）使用like关键字的查询语句&lt;/p&gt;
&lt;p&gt;使用like关键字进行查询的时候，如果匹配字符串的第一个字符为“%”，索引不起作用。只有“%”不在第一个位置，索引&lt;/p&gt;
&lt;p&gt;才会起作用&lt;/p&gt;
&lt;p&gt;使用like关键字，并且匹配字符串中含有“%”字符，EXPLAIN语句如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE test;
EXPLAIN SELECT * FROM `test`.`emp` WHERE `name` LIKE &#39;%x&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ae47b82f485e33d298e93e0f7218d1dd.jpg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE test;
EXPLAIN SELECT * FROM `test`.`emp` WHERE `name` LIKE &#39;x%&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a3eed54f7d8936c00407446347985848.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;name上有索引ix_emp_name&lt;/p&gt;
&lt;p&gt;第一个查询type为ALL，表示要全表扫描&lt;/p&gt;
&lt;p&gt;第二个查询TYPE为index，表示会扫描索引&lt;/p&gt;
&lt;p&gt;like 关键字是否能利用上索引跟SQLSERVER是一样的&lt;/p&gt;
&lt;p&gt;我之前写过一篇文章：&lt;a title=&quot;http://www.cnblogs.com/lyhabc/p/3378753.html&quot; href=&quot;http://www.cnblogs.com/lyhabc/p/3378753.html&quot; target=&quot;_blank&quot;&gt;like语句百分号前置会使用到索引吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（2）使用多列索引的查询语句&lt;/p&gt;
&lt;p&gt;mysql可以为多个字段创建索引。一个索引可以包括&lt;strong&gt;16个字段（跟SQLSERVER一样）&lt;/strong&gt;对于多列索引，只有查询条件中使用了&lt;/p&gt;
&lt;p&gt;这些字段中的第一个字段时，索引才会被使用，这个字段叫：&lt;a title=&quot;http://blog.rds.aliyun.com/2014/06/08/sql常见的可优化点/&quot; href=&quot;http://blog.rds.aliyun.com/2014/06/08/sql%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%AF%E4%BC%98%E5%8C%96%E7%82%B9/&quot; target=&quot;_blank&quot;&gt;前导索引或前导列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在表person中name，age字段创建多列索引，验证多列索引的情况&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE INDEX ix_person_name_age ON `person` (name,age)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;EXPLAIN SELECT ID,Name,Age,job FROM `person` WHERE `Name` =&#39;suse&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d2f8731e4339192af213b4800de88ecc.jpg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;EXPLAIN SELECT ID,Name,Age,job FROM `person` WHERE `age` =12&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1d94608ff6844de0be476095ae56907d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;从第一条查询看出，WHERE `Name` =’suse’的记录有一条，扫描了一条记录并且使用了ix_person_name_age 索引&lt;/p&gt;
&lt;p&gt;从第二条记录可以看出，rows列的值为4，说明共扫描了4条记录，并且key列值为NULL，说明EXPLAIN SELECT ID,Name,Age,job FROM `person` WHERE `age` =12&lt;/p&gt;
&lt;p&gt;语句并没有使用索引。因为age字段是多列索引的第二个字段，只有查询条件中使用了name字段才会使用ix_person_name_age 索引&lt;/p&gt;
&lt;p&gt;这个跟SQLSERVER是一样的，详细请看：&lt;a title=&quot;http://www.cnblogs.com/lyhabc/p/3196484.html&quot; href=&quot;http://www.cnblogs.com/lyhabc/p/3196484.html&quot; target=&quot;_blank&quot;&gt;SQLSERVER聚集索引与非聚集索引的再次研究（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（3）使用OR关键字的查询语句&lt;/p&gt;
&lt;p&gt;查询语句的查询条件中只有OR关键字，而且OR前后的两个条件中的列都是索引时，查询中才使用索引，否则，查询不使用索引&lt;/p&gt;
&lt;p&gt;查询语句使用OR关键字的情况&lt;/p&gt;
&lt;p&gt;我们再创建一个索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE INDEX ix_person_age ON `person` (age)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;EXPLAIN SELECT Name,Age FROM `person`  WHERE `Name` =&#39;SUSE&#39; OR `job`=&#39;SPORTMAN&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/94554bcfff1200e79ad31a3d786b0958.jpg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;EXPLAIN SELECT Name,Age FROM `person`  WHERE   `AGE` =2 OR `Name` =&#39;SUSE&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/69e61c1eee10f5e814cd35aa468615fc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;大家要注意，这里跟刚才不一样，这次我们select的字段只有name和age，而不是select出全部字段&lt;/p&gt;
&lt;p&gt;因为并没有在job这个字段上建立索引，所以第一个查询使用的是全表扫描&lt;/p&gt;
&lt;p&gt;第二个查询因为name字段和age字段都有索引，那么mysql可以利用这两个索引的其中之一，这里是ix_person_name_age索引来查找记录&lt;/p&gt;
&lt;p&gt;利用索引来查找记录会快很多&lt;/p&gt;
&lt;p&gt;（4）优化子查询&lt;/p&gt;
&lt;p&gt;mysql从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结果作为另一个SELECT语句的条件&lt;/p&gt;
&lt;p&gt;子查询可以一次性完成很多逻辑需要多个步骤才能完成的SQL操作。子查询虽然使查询语句灵活，但是执行效率不高。&lt;/p&gt;
&lt;p&gt;执行子查询时，mysql需要为内层查询语句结果建立一个临时表。然后外层查询语句从临时表中查询记录&lt;/p&gt;
&lt;p&gt;查询完毕后，再撤销临时表。因此，子查询的速度会受到一定影响，如果查询的数据量特别大，这种影响就会更大。&lt;/p&gt;
&lt;p&gt;在mysql中，可以使用连接（join）查询来代替子查询。连接查询不需要建立临时表，其速度比子查询快，如果查询中使用索引的话，性能会更好。&lt;/p&gt;
&lt;p&gt;所以很多网上的文章都说尽量使用join来代替子查询，虽然网上也说mysql5.7对于子查询有很大的改进，但是如果不是使用mysql5.7还是需要注意的&lt;/p&gt;
&lt;p&gt;如果系统中join语句特别多还需要注意修改my.ini或my.cnf文件中的&lt;strong&gt;join_buffer_size&lt;/strong&gt;大小，预防性能问题&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;优化数据库结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个好的数据库设计方案对于数据库的性能常常起到事半功倍的效果。&lt;/p&gt;
&lt;p&gt;数据库结构的设计需要考虑数据冗余、查询和更新速度、字段的数据类型是否合理等多方面&lt;/p&gt;
&lt;p&gt;（1）将字段很多的表拆分成多个表&lt;/p&gt;
&lt;p&gt;有时候有些字段使用频率很低或者字段的数据类型比较大，那么可以考虑垂直拆分的方法，把不常用的字段和大字段拆分出去&lt;/p&gt;
&lt;p&gt;（2）增加中间表&lt;/p&gt;
&lt;p&gt;对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，&lt;/p&gt;
&lt;p&gt;然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。&lt;/p&gt;
&lt;p&gt;（3）增加冗余字段&lt;/p&gt;
&lt;p&gt;设计数据库表时应尽量遵循范式理论，尽可能减少冗余字段，但是现今存储硬件越来越便宜，有时候查询数据的时候需要join多个表&lt;/p&gt;
&lt;p&gt;这样在高峰期间会影响查询的效率，我们需要反范式而为之，增加一些必要的冗余字段，以空间换时间&lt;/p&gt;
&lt;p&gt;需要这样做会增加开发的工作量和维护量，但是如果能换来可观的性能提升，这样做也是值得的&lt;/p&gt;
&lt;p&gt;（4）优化插入记录的速度&lt;/p&gt;
&lt;p&gt;插入记录时，影响插入速度的主要是索引、唯一性校验、一次插入记录条数等。&lt;/p&gt;
&lt;p&gt;根据实际情况，可以分别进行优化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于myisam表，常见优化方法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、禁用索引&lt;/p&gt;
&lt;p&gt;对于非空表，插入记录时，mysql会根据表的索引对插入的记录建立索引。如果插入大量数据，建立索引会降低插入记录的速度。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，可以在插入记录之前禁用索引，数据插入完毕后再开启索引&lt;/p&gt;
&lt;p&gt;禁用索引语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE table_name DISABLE KEYS ;&lt;/pre&gt;
&lt;p&gt;其中table_name是禁用索引的表的表名&lt;/p&gt;
&lt;p&gt;重新开启索引语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE table_name ENABLE KEYS ;&lt;/pre&gt;
&lt;p&gt;对于空表批量导入数据，则不需要进行此操作，&lt;strong&gt;因为myisam表是在导入数据之后才建立索引！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、禁用唯一性检查&lt;/p&gt;
&lt;p&gt;插入数据时，mysql会对插入的记录进行唯一性校验。这种唯一性校验也会降低插入记录的速度。&lt;/p&gt;
&lt;p&gt;为了降低这种情况对查询速度的影响，可以在插入记录之前禁用唯一性检查，等到记录插入完毕之后再开启&lt;/p&gt;
&lt;p&gt;禁用唯一性检查的语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET UNIQUE_CHECKS=0;&lt;/pre&gt;
&lt;p&gt;开启唯一性检查的语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET UNIQUE_CHECKS=1;&lt;/pre&gt;
&lt;p&gt;3、使用批量插入&lt;/p&gt;
&lt;p&gt;插入多条记录时，可以使用一条INSERT语句插入一条记录，也可以使用一条INSERT语句插入多条记录。&lt;/p&gt;
&lt;p&gt;第一种情况&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO emp(id,name) VALUES (1,&#39;suse&#39;);
INSERT INTO emp(id,name) VALUES (2,&#39;lily&#39;);
INSERT INTO emp(id,name) VALUES (3,&#39;tom&#39;);&lt;/pre&gt;
&lt;p&gt;第二种情况&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO emp(id,name) VALUES (1,&#39;suse&#39;),(2,&#39;lily&#39;),(3,&#39;tom&#39;)&lt;/pre&gt;
&lt;p&gt;第二种情况要比第一种情况要快&lt;/p&gt;
&lt;p&gt;4、使用LOAD DATA INFILE批量导入&lt;/p&gt;
&lt;p&gt;当需要批量导入数据时，如果能用LOAD DATA INFILE语句，就尽量使用。因为LOAD DATA INFILE语句导入数据的速度比INSERT语句快很多&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于INNODB引擎的表，常见的优化方法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、禁用唯一性检查&lt;/p&gt;
&lt;p&gt;插入数据时，mysql会对插入的记录进行唯一性校验。这种唯一性校验也会降低插入记录的速度。&lt;/p&gt;
&lt;p&gt;为了降低这种情况对查询速度的影响，可以在插入记录之前禁用唯一性检查，等到记录插入完毕之后再开启&lt;/p&gt;
&lt;p&gt;禁用唯一性检查的语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET UNIQUE_CHECKS=0;&lt;/pre&gt;
&lt;p&gt;开启唯一性检查的语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET UNIQUE_CHECKS=1;&lt;/pre&gt;
&lt;p&gt;2、禁用外键约束&lt;/p&gt;
&lt;p&gt;插入数据之前执行禁止对外键的检查，数据插入完成之后再恢复对外键的检查。禁用外键检查的语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET FOREIGN_KEY_CHECKS=0;&lt;/pre&gt;
&lt;p&gt;恢复对外键的检查语句如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET FOREIGN_KEY_CHECKS=1;&lt;/pre&gt;
&lt;p&gt;3、禁止自动提交&lt;/p&gt;
&lt;p&gt;插入数据之前禁止事务的自动提交，数据导入完成之后，执行恢复自动提交操作&lt;/p&gt;
&lt;p&gt;或显式指定事务&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE test;

START TRANSACTION;
INSERT INTO emp(name) VALUES(&#39;ming&#39;);
INSERT INTO emp(name) VALUES(&#39;lily&#39;);
commit;&lt;/pre&gt;
&lt;p&gt;（5）分析表、检查表、优化表、修复表和CHECKSUM表&lt;/p&gt;
&lt;p&gt;mysql提供了分析表、检查表和优化表的语句&lt;/p&gt;
&lt;p&gt;分析表主要是分析关键字的分布；&lt;/p&gt;
&lt;p&gt;检查表主要是检查表是否存在错误；&lt;/p&gt;
&lt;p&gt;优化表主要是消除删除或者更新造成的空间浪费&lt;/p&gt;
&lt;p&gt;修复表主要对myisam表文件进行修复&lt;/p&gt;
&lt;p&gt;CHECKSUM表主要对表数据传输前和传输后进行比较&lt;/p&gt;
&lt;p&gt;1、分析表&lt;/p&gt;
&lt;p&gt;mysql中提供了ANALYZE TABLE 语句分析表，ANALYZE TABLE 语句的基本语法如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ANALYZE [LOCAL|NO_WRITE_TO_BINLOG] TABLE TBL_NAME [,TBL_NAME]...&lt;/pre&gt;
&lt;p&gt;LOCAL关键字是NO_WRITE_TO_BINLOG关键字的别名，二者都是执行过程不写入二进制日志，tbl_name为分析的表的表名&lt;/p&gt;
&lt;p&gt;可以有一个或多个&lt;/p&gt;
&lt;p&gt;使用ANALYZE TABLE 分析表的过程中，数据库系统会自动对表加一个只读锁。在分享期间，只能读取表的记录，不能更新和插入记录&lt;/p&gt;
&lt;p&gt;ANALYZE TABLE 语句能分析INNODB、BDB和MYISAM类型的表&lt;/p&gt;
&lt;p&gt;使用ANALYZE TABLE 来分析emp表，执行语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ANALYZE TABLE emp;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d2422ac7d284a155d3f6ea2d9e7cf3f6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面结果显示说明&lt;/p&gt;
&lt;p&gt;table：表示分析的表名&lt;/p&gt;
&lt;p&gt;op：表示执行的操作，analyze表示进行分析操作&lt;/p&gt;
&lt;p&gt;msg_type：表示信息类型其值通常是状态（status）、信息（info）、注意（note）、警告（warning）和错误（error）之一&lt;/p&gt;
&lt;p&gt;msg_text：显示信息&lt;/p&gt;
&lt;p&gt;实际上分析表跟SQLSERVER里的更新统计信息是差不多的&lt;/p&gt;
&lt;p&gt;主要就是为了索引的基数更加准确，从而使查询优化器能够更加准确的预估行数&lt;/p&gt;
&lt;p&gt;emp表的记录行数是18&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/97612b3f3b786989753771585c214b7e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;分析表之后，Cardinality 基数更加准确了&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2b14d7bf00456a835ada7e2f31a71d50.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、检查表&lt;/p&gt;
&lt;p&gt;mysql中使用check table语句来检查表。check table语句能够检查innodb和myisam类型的表是否存在错误。&lt;/p&gt;
&lt;p&gt;对于myisam类型的表，check table语句还会更新关键字统计数据。而且，check table也可以检查视图是否有错误，&lt;/p&gt;
&lt;p&gt;比如在视图定义中被引用的表已不存在。&lt;/p&gt;
&lt;p&gt;该语句基本语法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CHECK TABLE TBL_NAME [,tbl_name]...[option]...
option={QUICK|FAST|MEDIUM|EXTENDED|CHANGED}&lt;/pre&gt;
&lt;p&gt;其中，tbl_name是表名；option参数有5个取值分别是QUICK、FAST、MEDIUM、EXTENDED、CHANGED&lt;/p&gt;
&lt;p&gt;各个选项的意思分别是&lt;/p&gt;
&lt;p&gt;QUICK：不扫描行，不检查错误的连接&lt;/p&gt;
&lt;p&gt;FAST：只检查没有被正确关闭的表&lt;/p&gt;
&lt;p&gt;MEDIUM：扫描行，以验证被删除的连接是有效的，也可以计算各行的关键字校验和，并使用计算出的校验和验证这一点&lt;/p&gt;
&lt;p&gt;EXTENDED：对每行的所有关键字进行一个全面的关键字查找。这可以确保表是100%一致的，但是花的时间较长&lt;/p&gt;
&lt;p&gt;CHANGED：只检查上次检查后被更改的表和没有被正确关闭的表&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f4cc2a604edcc974a661c52f05030b13.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;option只对myisam表有效，对innodb表无效。check table语句在执行过程中也会给表加上只读锁。&lt;/p&gt;
&lt;p&gt;3、优化表&lt;/p&gt;
&lt;p&gt;mysql中使用OPTIMIZE TABLE语句来优化表。该语句对INNODB和MYISAM表都有效。但是，OPTIMIZE TABLE语句只能优化表中的&lt;/p&gt;
&lt;p&gt;VARCHAR、BLOB、TEXT类型的字段&lt;/p&gt;
&lt;p&gt;OPTIMIZE TABLE语句的基本语法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;OPTIMIZE [LOCAL|NO_WRITE_TO_BINLOG] TABLE TBL_NAME [,TBL_NAME]...&lt;/pre&gt;
&lt;p&gt;LOCAL和NO_WRITE_TO_BINLOG关键字的意义和分析表相同，都是指定不写入二进制日志&lt;/p&gt;
&lt;p&gt;tbl_name是表名&lt;/p&gt;
&lt;p&gt;通过OPTIMIZE TABLE语句可以消除删除和更新造成的文件碎片。&lt;/p&gt;
&lt;p&gt;OPTIMIZE TABLE语句在执行过程中也会给表加上只读锁。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0d3e53161110651fbe43beb2f32ca0c0.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：一个表使用了TEXT或者BLOB这样的数据类型，如果已经删除了表的一大部分，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）&lt;/p&gt;
&lt;p&gt;进行了很多更新，则应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的碎片。在多数设置中，根本不需要运行OPTIMIZE TABLE。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OPTIMIZE TABLE语句类似于SQLSERVER的重建索引和收缩数据文件的功能&lt;/p&gt;
&lt;p&gt;4、修复表&lt;/p&gt;
&lt;p&gt;mysql中使用Repair Table来修复myisam表，只对MyISAM和ARCHIVE类型的表有效。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;REPAIR [LOCAL|NO_WRITE_TO_BINLOG] TABLE TBL_NAME [,tbl_name]...[option]...
option={QUICK|EXTENDED|USE_FRM}&lt;/pre&gt;
&lt;p&gt;选项的意思分别是：&lt;/p&gt;
&lt;p&gt;QUICK：最快的选项，只修复索引树。&lt;br&gt;
EXTENDED：最慢的选项，需要逐行重建索引。&lt;br&gt;
USE_FRM：只有当MYI文件丢失时才使用这个选项，全面重建整个索引。&lt;/p&gt;
&lt;p&gt;与Analyze Table一样，Repair Table也可以使用local来取消写入binlog。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/413abb8be6ddc2dce1ecc0c0b9a47004.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;5、Checksum 表&lt;/p&gt;
&lt;p&gt;数据在传输时，可能会发生变化，也有可能因为其它原因损坏，为了保证数据的一致，我们可以计算checksum（校验值）。&lt;/p&gt;
&lt;p&gt;使用MyISAM引擎的表会把checksum存储起来，称为live checksum，当数据发生变化时，checksum会相应变化。&lt;/p&gt;
&lt;p&gt;语法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CHECKSUM TABLE tbl_name [, tbl_name] ... [ QUICK | EXTENDED ]&lt;/pre&gt;
&lt;p&gt;quick：表示返回存储的checksum值&lt;/p&gt;
&lt;p&gt;extended：表示重新计算checksum&lt;/p&gt;
&lt;p&gt;如果没有指定选项，则默认使用extended。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/676a05ff269b094e5d0f7efc5f5a8c5e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;Checksum 表主要用来对比在传输表数据之前和表数据之后，表的数据是否发生了变化，例如插入了数据或者删除了数据，或者有数据损坏&lt;/p&gt;
&lt;p&gt;CHECKSUM值都会改变。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;优化MYSQL服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;水电费优化mysql服务器主要从两个方面入手，一方面是对硬件进行优化；另一方面是对mysql服务器的参数进行优化&lt;/p&gt;
&lt;p&gt;1、优化服务器硬件&lt;/p&gt;
&lt;p&gt;服务器的硬件性能直接决定着MYSQL数据库的性能。硬件的性能瓶颈直接决定MYSQL数据库的运行速度和效率。&lt;/p&gt;
&lt;p&gt;优化服务器硬件的几种方法&lt;/p&gt;
&lt;p&gt;（1）配置较大的内存。足够大的内存，是提高mysql数据库性能之一。内存速度比磁盘I/O快得多，可以通过增加系统缓冲区容量，使数据库&lt;/p&gt;
&lt;p&gt;在内存停留时间更长，以减少磁盘I/O&lt;/p&gt;
&lt;p&gt;（2）配置高速磁盘系统，以减少读盘等待时间，提高响应速度&lt;/p&gt;
&lt;p&gt;（3）合理分布磁盘I/O，把磁盘I/O分散在多个设备上，以减少资源竞争，提高并行操作能力&lt;/p&gt;
&lt;p&gt;（4）配置多处理器，mysql是多线程的数据库，多处理器可同时执行多个线程&lt;/p&gt;
&lt;p&gt;2、优化MYSQL的参数&lt;/p&gt;
&lt;p&gt;通过优化MYSQL的参数可以提高资源利用率，从而达到提高MYSQL服务器的性能的目的。&lt;/p&gt;
&lt;p&gt;MYSQL服务器的配置参数都在my.cnf或者my.ini文件的[mysqld]组中。&lt;/p&gt;
&lt;p&gt;下面对几个对性能影响较大的参数进行介绍&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;我们先看一下与网络连接的性能配置项及对性能的影响。
● max_conecctions：整个 MySQL 允许的最大连接数；
这个参数主要影响的是整个 MySQL 应用的并发处理能力，当系统中实际需要的连接量大于
max_conecctions 的情况下，由于 MySQL 的设置限制，那么应用中必然会产生连接请求的等待，
从而限制了相应的并发量。所以一般来说，只要 MySQL 主机性能允许，都是将该参数设置的尽
可能大一点。一般来说 500 到 800 左右是一个比较合适的参考值
● max_user_connections：每个用户允许的最大连接数；
上面的参数是限制了整个 MySQL 的连接数，而 max_user_connections 则是针对于单个用户的连
接限制。在一般情况下我们可能都较少使用这个限制，只有在一些专门提供 MySQL 数据存储服
务，或者是提供虚拟主机服务的应用中可能需要用到。除了限制的对象区别之外，其他方面和
max_connections 一样。这个参数的设置完全依赖于应用程序的连接用户数，对于普通的应用来
说，完全没有做太多的限制，可以尽量放开一些。
● net_buffer_length：网络包传输中，传输消息之前的 net buffer 初始化大小；
这个参数主要可能影响的是网络传输的效率，由于该参数所设置的只是消息缓冲区的初始化大
小，所以造成的影响主要是当我们的每次消息都很大的时候 MySQL 总是需要多次申请扩展该缓
冲区大小。系统默认大小为 16KB，一般来说可以满足大多数场景，当然如果我们的查询都是非
常小，每次网络传输量都很少，而且系统内存又比较紧缺的情况下，也可以适当将该值降低到
8KB。
● max_allowed_packet：在网络传输中，一次传消息输量的最大值；
这个参数与 net_buffer_length 相对应，只不过是 net buffer 的最大值。当我们的消息传输量
大于 net_buffer_length 的设置时，MySQL 会自动增大 net buffer 的大小，直到缓冲区大小达
到 max_allowed_packet 所设置的值。系统默认值为 1MB，最大值是 1GB，必须设定为 1024 的倍
数，单位为字节。
● back_log：在 MySQL 的连接请求等待队列中允许存放的最大连接请求数。
连接请求等待队列，实际上是指当某一时刻客户端的连接请求数量过大的时候，MySQL 主线程没
办法及时给每一个新的连接请求分配（或者创建）连接线程的时候，还没有分配到连接线程的
所有请求将存放在一个等待队列中，这个队列就是 MySQL 的连接请求队列。当我们的系统存在
瞬时的大量连接请求的时候，则应该注意 back_log 参数的设置。系统默认值为 50，最大可以设
置为 65535。当我们增大 back_log 的设置的时候，同时还需要主义 OS 级别对网络监听队列的限
制，因为如果 OS 的网络监听设置小于 MySQL 的 back_log 设置的时候，我们加大“back_log”设
置是没有意义的。
上面介绍了网络连接交互相关的主要优化设置，下面我们再来看看与每一个客户端连接想对应的连
接线程。
在 MySQL 中，为了尽可提高客户端请求创建连接这个过程的性能，实现了一个 Thread Cache 池，将
空闲的连接线程存放在其中，而不是完成请求后就销毁。这样，当有新的连接请求的时候，MySQL 首先会
检查 Thread Cache 池中是否存在空闲连接线程，如果存在则取出来直接使用，如果没有空闲连接线程，
才创建新的连接线程。在 MySQL 中与连接线程相关的系统参数及状态变量说明如下：
● thread_cache_size：Thread Cache 池中应该存放的连接线程数。
当系统最初启动的时候，并不会马上就创建 thread_cache_size 所设置数目的连接线程存放在
Thread Cache 池中，而是随着连接线程的创建及使用，慢慢的将用完的连接线程存入其中。当
存放的连接线程达到 thread_cache_size 值之后，MySQL 就不会再续保存用完的连接线程了。
如果我们的应用程序使用的短连接，Thread Cache 池的功效是最明显的。因为在短连接的数据
库应用中，数据库连接的创建和销毁是非常频繁的，如果每次都需要让 MySQL 新建和销毁相应
的连接线程，那么这个资源消耗实际上是非常大的，而当我们使用了 Thread Cache 之后，由于
连接线程大部分都是在创建好了等待取用的状态，既不需要每次都重新创建，又不需要在使用
完 之 后 销 毁 ， 所 以 可 以 节 省 下 大 量 的 系 统 资 源 。 所 以 在 短 连 接 的 应 用 系 统 中 ，
thread_cache_size 的值应该设置的相对大一些，不应该小于应用系统对数据库的实际并发请求
数。
而如果我们使用的是长连接的时候，Thread Cache 的功效可能并没有使用短连接那样的大，但
也并不是完全没有价值。因为应用程序即使是使用了长连接，也很难保证他们所管理的所有连
接都能处于很稳定的状态，仍然会有不少连接关闭和新建的操作出现。在有些并发量较高，应
用服务器数量较大的系统中，每分钟十來次的连接创建与关闭的操作是很常见的。而且如果应
用服务器的连接池管理不是太好，容易产生连接池抖动的话，所产生的连接创建和销毁操作将
会更多。所以即使是在使用长连接的应用环境中，Thread Cache 机制的利用仍然是对性能大有
帮助的。只不过在长连接的环境中我们不需要将 thread_cache_size 参数设置太大，一般来说
可能 50 到 100 之间应该就可以了。
● thread_stack：每个连接线程被创建的时候，MySQL 给他分配的内存大小。
当 MySQL 创建一个新的连接线程的时候，是需要给他分配一定大小的内存堆栈空间，以便存放
客户端的请求 Query 以及自身的各种状态和处理信息。不过一般来说如果不是对 MySQL 的连接线
程处理机制十分熟悉的话，不应该轻易调整该参数的大小，使用系统的默认值（192KB）基本上
可以所有的普通应用环境。如果该值设置太小，会影响 MySQL 连接线程能够处理客户端请求的
Query 内容的大小，以及用户创建的 Procedures 和 Functions 等

计算出系统新建连接连接的 Thread
Cache 命中率，也就是通过 Thread Cache 池中取得连接线程的次数与系统接收的总连接次数的比率，如
下：
Threads_Cache_Hit = (Connections - Threads_created) / Connections * 100%
我们可以通过上面的这个运算公式计算一下上面环境中的 Thread Cache 命中率：Thread_Cache_Hit
= (127 - 12) / 127 * 100% = 90.55%
一般来说，当系统稳定运行一段时间之后，我们的 Thread Cache 命中率应该保持在 90%左右甚至更
高的比率才算正常。可以看出上面环境中的 Thread Cache 命中比率基本还算是正常的。
Table Cache 相关的优化
我们先来看一下 MySQL 打开表的相关机制。由于多线程的实现机制，为了尽可能的提高性能，在
MySQL 中每个线程都是独立的打开自己需要的表的文件描述符，而不是通过共享已经打开的表的文件描述
符的机制来实现。当然，针对于不同的存储引擎可能有不同的处理方式。如 MyISAM 表，每一个客户端线
程打开任何一个 MyISAM 表的数据文件都需要打开一个文件描述符，但如果是索引文件，则可以多个线程
共享同一个索引文件的描述符。对于 Innodb 的存储引擎，如果我们使用的是共享表空间来存储数据，那
么我们需要打开的文件描述符就比较少，而如果我们使用的是独享表空间方式来存储数据，则同样，由
于存储表数据的数据文件较多，则同样会打开很多的表文件描述符。除了数据库的实际表或者索引打开
以外，临时文件同样也需要使用文件描述符，同样会占用系统中 open_files_limit 的设置限额。
为了解决打开表文件描述符太过频繁的问题，MySQL 在系统中实现了一个 Table Cache 的机制，和前
面介绍的 Thread Cache 机制有点类似，主要就是 Cache 打开的所有表文件的描述符，当有新的请求的时
候不需要再重新打开，使用结束的时候也不用立即关闭。通过这样的方式来减少因为频繁打开关闭文件
描述符所带来的资源消耗。我们先看一看 Table Cache 相关的系统参数及状态变量。
在 MySQL 中我们通过 table_cache（从 MySQL5.1.3 开始改为 table_open_cache），来设置系统中为
我们 Cache 的打开表文件描述符的数量。通过 MySQL 官方手册中的介绍，我们设置 table_cache 大小的时
候应该通过 max_connections 参数计算得来，公式如下：
table_cache = max_connections * N；
其中 N 代表单个 Query 语句中所包含的最多 Table 的数量。但是我个人理解这样的计算其实并不是太
准确，分析如下：
首先，max_connections 是系统同时可以接受的最大连接数，但是这些连接并不一定都是 active 状
态的，也就是说可能里面有不少连接都是处于 Sleep 状态。而处于 Sleep 状态的连接是不可能打开任何
Table 的。
其次，这个 N 为执行 Query 中包含最多的 Table 的 Query 所包含的 Table 的个数也并不是太合适，因
为我们不能忽略索引文件的打开。虽然索引文件在各个连接线程之间是可以共享打开的连接描述符的，
但总还是需要的。而且，如果我 Query 中的每个表的访问都是通过现通过索引定位检索的，甚至可能还
是通过多个索引，那么该 Query 的执行所需要打开的文件描述符就更多了，可能是 N 的两倍甚至三倍。
最后，这个计算的公式只能计算出我们同一时刻需要打开的描述符的最大数量，而 table_cache 的
设置也不一定非得根据这个极限值来设定，因为 table_cache 所设定的只是 Cache 打开的描述符的数量的
大小，而不是最多能够打开的量的大小。

join_buffer_size ：当我们的 Join 是 ALL ， index ， rang 或者 index_merge 的时候使用的
Buffer；
实际上这种 Join 被称为 Full Join。实际上参与 Join 的每一个表都需要一个 Join Buffer，所以在
Join 出现的时候，至少是两个。Join Buffer 的设置在 MySQL 5.1.23 版本之前最大为 4GB，但是从
5.1.23 版本开始，在除了 Windows 之外的 64 位的平台上可以超出 4BG 的限制。系统默认是 128KB。
● sort_buffer_size：系统中对数据进行排序的时候使用的 Buffer；
Sort Buffer 同样是针对单个 Thread 的，所以当多个 Thread 同时进行排序的时候，系统中就会出现
多个 Sort Buffer。一般我们可以通过增大 Sort Buffer 的大小来提高 ORDER BY 或者是 GROUP BY
的处理性能。系统默认大小为 2MB，最大限制和 Join Buffer 一样，在 MySQL 5.1.23 版本之前最大
为 4GB，从 5.1.23 版本开始，在除了 Windows 之外的 64 位的平台上可以超出 4GB 的限制。
如果应用系统中很少有 Join 语句出现，则可以不用太在乎 join_buffer_size 参数的大小设置，但是
如果 Join 语句不是很少的话，个人建议可以适当增大 join_buffer_size 的设置到 1MB 左右，如果内存充
足甚至可以设置为 2MB。对于 sort_buffer_size 参数来说，一般设置为 2MB 到 4MB 之间可以满足大多数
应用的需求。当然，如果应用系统中的排序都比较大，内存充足且并发量不是特别的大的时候，也可以
继续增大 sort_buffer_size 的设置。在这两个 Buffer 设置的时候，最需要注意的就是不要忘记是每个
Thread 都会创建自己独立的 Buffer，而不是整个系统共享的 Buffer，不要因为设置过大而造成系统内存
不足。&lt;/pre&gt;
&lt;p&gt;配置完参数之后，需要重启MYSQL服务才能生效&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;如何使用查询缓冲区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询缓冲区可以提高查询的速度，但是这种方式只适合查询语句多、更新较少的情况。默认情况下查询缓冲区的大小为0，也就是不可用&lt;/p&gt;
&lt;p&gt;可以修改query_cache_size以调整查询缓冲区大小；修改 query_cache_type以调整查询缓冲区的类型。&lt;/p&gt;
&lt;p&gt;在my.ini中修改query_cache_size和query_cache_type的值如下所示&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[mysqld]
query_cache_size=512M
query_cache_type=1&lt;/pre&gt;
&lt;p&gt;query_cache_type=1表示开启查询缓冲区。只有在查询语句中包含SQL_NO_CACHE关键字时，才不会使用查询缓冲区。&lt;/p&gt;
&lt;p&gt;可以使用FLUSH QUERY CACHE语句来刷新缓冲区，清理查询缓冲区中的碎片&lt;/p&gt;
&lt;p&gt;注意：开启查询缓冲区是有风险的，如果命中率不高，或者更新修改语句较多，都会使查询缓冲区失效，从而使命中率更加低&lt;/p&gt;
&lt;p&gt;建议使用&lt;strong&gt;memcached&lt;/strong&gt;等软件来做二级缓存，除非系统中修改语句较少，命中率较高，这样才会看到明显的性能提升&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文阐述了MYSQL的性能优化面的内容，虽然网上对于MYSQL优化的资料很多&lt;/p&gt;
&lt;p&gt;但是，MYSQL优化方面需要长期的进行研究探索才能找到适合于自己公司的业务系统最佳参数，否则只是使用网上的介绍只会人云亦云&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87367&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87367votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87367&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sun, 07 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-07-87367-302bea242.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-07-87367-302bea242.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Git版本控制与工作流</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0648714a2bd80a1c9709b2a713e7c5ac.jpg&quot;&gt;&lt;/p&gt;
&lt;div&gt;Git Version Control&lt;/div&gt;
&lt;p&gt;这篇文章是针对git版本控制和工作流的&lt;strong&gt;总结&lt;/strong&gt;，如果有些朋友之前还没使用过git，对git的基本概念和命令不是很熟悉，可以从以下基本教程入手：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/73944/&quot; target=&quot;_blank&quot;&gt;专为设计师而写的GitHub快速入门教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://rogerdudler.github.io/git-guide/index.zh.html&quot; target=&quot;_blank&quot;&gt;git – 简明指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pcottle.github.io/learnGitBranching/&quot; target=&quot;_blank&quot;&gt;学习Git的在线互动教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;基本概念&lt;/h1&gt;
&lt;h3&gt;Git是什么？&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot;&gt;Git&lt;/a&gt;是&lt;strong&gt;分布式&lt;/strong&gt;版本控制系统，与SVN类似的&lt;strong&gt;集中化&lt;/strong&gt;版本控制系统相比，集中化版本控制系统虽然能够令多个团队成员一起协作开发，但有时如果中央服务器宕机的话，谁也无法在宕机期间提交更新和协同开发。甚至有时，中央服务器磁盘故障，恰巧又没有做备份或备份没及时，那就可能有丢失数据的风险。&lt;/p&gt;
&lt;p&gt;但Git是分布式的版本控制系统，客户端不只是提取最新版本的快照，而且将整个代码仓库镜像复制下来。如果任何协同工作用的服务器发生故障了，也可以用任何一个代码仓库来恢复。而且在协作服务器宕机期间，你也可以提交代码到本地仓库，当协作服务器正常工作后，你再将本地仓库同步到远程仓库。&lt;/p&gt;
&lt;h3&gt;为什么要使用Git&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;能够对文件&lt;strong&gt;版本控制&lt;/strong&gt;和&lt;strong&gt;多人协作开发&lt;/strong&gt;
&lt;/li&gt;
&lt;li&gt;拥有强大的&lt;strong&gt;分支特性&lt;/strong&gt;，所以能够灵活地以&lt;strong&gt;不同的工作流&lt;/strong&gt;协同开发&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;分布式版本控制系统&lt;/strong&gt;，即使协作服务器宕机，也能继续提交代码或文件到本地仓库，当协作服务器恢复正常工作时，再将本地仓库同步到远程仓库。&lt;/li&gt;
&lt;li&gt;当团队中某个成员完成某个功能时，通过&lt;strong&gt;pull request&lt;/strong&gt;操作来通知其他团队成员，其他团队成员能够review code后再合并代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Git有哪些特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文件三种状态(modified, staged, committed)&lt;/li&gt;
&lt;li&gt;直接记录快照，而非差异比较&lt;/li&gt;
&lt;li&gt;多数操作仅添加操作&lt;/li&gt;
&lt;li&gt;近乎所有操作都是本地执行&lt;/li&gt;
&lt;li&gt;时刻保持数据完整性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关以上特性的详细解释，请查看Pro git的&lt;a href=&quot;http://iissnan.com/progit/html/zh/ch1_3.html&quot; target=&quot;_blank&quot;&gt;git基础章节&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Git基本工作流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在git版本控制的目录下修改某个文件&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;git add&lt;/code&gt;命令对修改后的文件快照，保存到暂存区域&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;git commit&lt;/code&gt;命令提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Git基本技巧&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;自动补全&lt;/li&gt;
&lt;li&gt;Git 命令别名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于具体如何使用自动补全和命名别名技巧，请查看Pro git的&lt;a href=&quot;http://iissnan.com/progit/html/zh/ch2_7.html&quot; target=&quot;_blank&quot;&gt;技巧和窍门&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Git版本控制&lt;/h1&gt;
&lt;h3&gt;创建仓库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git init&lt;/li&gt;
&lt;li&gt;git clone&lt;/li&gt;
&lt;li&gt;git config&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;保存修改&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git add&lt;/li&gt;
&lt;li&gt;git commit&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;查看仓库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git status&lt;/li&gt;
&lt;li&gt;git log –oneline&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;撤销修改&lt;/h3&gt;
&lt;h5&gt;查看之前的commit&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;git checkout &amp;lt;commit&amp;gt; &amp;lt;file&amp;gt;&lt;/li&gt;
&lt;li&gt;git checkout &amp;lt;commit&amp;gt;&lt;/li&gt;
&lt;li&gt;git checkout &amp;lt;branch&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;撤销公共修改&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;git revert &amp;lt;commit&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;撤销本地修改&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;git reset&lt;/li&gt;
&lt;li&gt;git clean&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;重写Git历史记录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git commit –amend&lt;/li&gt;
&lt;li&gt;git rebase&lt;/li&gt;
&lt;li&gt;git reflog&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Git协作开发&lt;/h1&gt;
&lt;h3&gt;分支&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git branch&lt;/li&gt;
&lt;li&gt;git checkout&lt;/li&gt;
&lt;li&gt;git merge&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;仓库同步&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git remote&lt;/li&gt;
&lt;li&gt;git fetch&lt;/li&gt;
&lt;li&gt;git pull&lt;/li&gt;
&lt;li&gt;git push&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Git工作流&lt;/h1&gt;
&lt;p&gt;由于git拥有强大的&lt;strong&gt;分支特性&lt;/strong&gt;，它的工作流比较灵活而缺乏约束，于是参考&lt;a href=&quot;https://www.atlassian.com/git/tutorials&quot; target=&quot;_blank&quot;&gt;Atlassian Git Tutorial&lt;/a&gt;的&lt;a href=&quot;https://www.atlassian.com/git/tutorials/comparing-workflows&quot; target=&quot;_blank&quot;&gt;Comparing Workflows&lt;/a&gt;章节提供&lt;strong&gt;四种Git工作流&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Centralized Workflow&lt;/li&gt;
&lt;li&gt;Feature Branch Workflow&lt;/li&gt;
&lt;li&gt;Gitflow Workflow&lt;/li&gt;
&lt;li&gt;Forking Workflow&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上工作流只是&lt;strong&gt;参考指南&lt;/strong&gt;，而不是具体规则。你可以根据自己实际情况来选择适合自己的工作流或微调来满足自己的需要。&lt;/p&gt;
&lt;h2&gt;Centralized Workflow&lt;/h2&gt;
&lt;p&gt;过渡到分布式版本控制系统看起来像一个艰巨的任务，但如果你充分利用好git的话，你不必改变你既有的工作流，你的团队可以采用与之前使用SVN一样的方式来开发项目。&lt;/p&gt;
&lt;h4&gt;如何工作&lt;/h4&gt;
&lt;div&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ad8fe4a823dcf8608440bbdaf73f3475.jpg&quot;&gt;
&lt;div&gt;Centralized Workflow&lt;/div&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;从远程仓库(central repository)克隆工程到本地仓库(local repository) — &lt;code&gt;git clone&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;在本地仓库编辑文件和提交更新 — &lt;code&gt;git add&lt;/code&gt;和&lt;code&gt;git commit&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;fetch远程仓库已更新的commit到本地仓库和rebase到已更新的commit的上面 —&lt;code&gt;git fetch&lt;/code&gt;和&lt;code&gt;git rebase&lt;/code&gt; 或 &lt;code&gt;git pull --rebase&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;push本地主分支(master branch)到远程仓库 — &lt;code&gt;git push&lt;/code&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;管理冲突&lt;/h4&gt;
&lt;div&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d7295faaaa91683632e27c47d9f762b3.jpg&quot;&gt;
&lt;div&gt;File Conflicts&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;何时发生冲突：&lt;/strong&gt;在开发者发布它们功能之前，他们需要fetch远程仓库已更新的commit到本地仓库和rebase到已更新的commit的上面。有时，本地提交与远程提交会发生冲突，git会暂停rebase过程来让你手动解决冲突。&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;如何解决冲突：&lt;/strong&gt;你可以使用&lt;code&gt;git status&lt;/code&gt;和&lt;code&gt;git add&lt;/code&gt;来手动解决合并时冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Feature Branch Workflow&lt;/h2&gt;
&lt;p&gt;Feature Branch Workflow的主要思想就是在开发每个功能时都应该创建&lt;strong&gt;一个独立的分支&lt;/strong&gt;而不只是使用主分支。由于每个分支是独立且互不影响，这就意味着主分支不会包含broken code，对持续集成环境是很有帮助的。&lt;/p&gt;
&lt;h4&gt;如何工作&lt;/h4&gt;
&lt;div&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7097389e060b3c59f56c3890e70b02c3.jpg&quot;&gt;
&lt;div&gt;Feature Branch Workflow&lt;/div&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;仍然使用远程仓库(central repository)和主分支(master branch)仍记录官方工程的历史&lt;/li&gt;
&lt;li&gt;开发者每次开发新功能时都创建一个新分支 — &lt;code&gt;git checkout -b&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;Feature branches应该推送到远程仓库(central repository) — &lt;code&gt;git push&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;发送pull request来请求管理员能否合并到主分支(master branch)&lt;/li&gt;
&lt;li&gt;发布新功能到远程仓库(central repository)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Pull Request&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Pull request&lt;/strong&gt;是一种当开发者完成一个新功能后向其他团队成员发送通知的机制。它的使用过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发者可以通过Github或Bitbucket发送pull request&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6ef3c1626a542b771c3aa60ab6b88cc6.jpg&quot;&gt;
&lt;div&gt;Pull request on Github&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;其他的团队成员审查、讨论和修改代码&lt;/li&gt;
&lt;li&gt;项目维护者合并新增功能分支到主分支(master branch)，然后关闭pull request&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Gitflow Workflow&lt;/h2&gt;
&lt;p&gt;Feature Branch Workflow是一种非常灵活的开发方式。对于一些规模比较大的团队，最好就是给特定的分支赋予不同的角色。除了&lt;strong&gt;功能分支(feature branch)&lt;/strong&gt;，Gitflow Workflow还使用独立的分支来&lt;strong&gt;准备发布(preparing)&lt;/strong&gt;，&lt;strong&gt;维护(maintaining)&lt;/strong&gt;, 和&lt;strong&gt;记录版本(recording releases)&lt;/strong&gt;。下面我会逐个介绍这个几个分支：Historical Branches、Feature Branches、Release Branches和Maintenance Branches。&lt;/p&gt;
&lt;h4&gt;Historical Branches&lt;/h4&gt;
&lt;div&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d838c8e7dbd5367dea5857db4330e2a8.jpg&quot;&gt;
&lt;div&gt;Historical Branches&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;master分支&lt;/strong&gt;保存官方发布历史&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;develop分支&lt;/strong&gt;衍生出各个feature分支&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Feature Branches&lt;/h4&gt;
&lt;div&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e352f6c985e3e8f239355a1b3225ba6f.jpg&quot;&gt;
&lt;div&gt;Feature Branches&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;feature分支&lt;/strong&gt;使用develop分支作为它们的父类分支&lt;/li&gt;
&lt;li&gt;当其中一个feature分支完成后，它会合并会develop分支&lt;/li&gt;
&lt;li&gt;feature分支应该从不与master分支直接交互&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Release Branches&lt;/h4&gt;
&lt;div&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/56d0a012b68953688292775fc8797104.jpg&quot;&gt;
&lt;div&gt;Release Branches&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;release分支&lt;/strong&gt;主要用来清理释放、测试和更新文档&lt;/li&gt;
&lt;li&gt;一旦develop分支获得足够的功能来发布时，你可以从develop衍生出一个release分支&lt;/li&gt;
&lt;li&gt;一旦准备好上架，release合并到master分支并且标记一个版本号&lt;/li&gt;
&lt;li&gt;另外，还需要合并回develop分支&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Maintenance Branches&lt;/h4&gt;
&lt;div&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/00a3eaf3efbdb903274e743b6327aea2.jpg&quot;&gt;
&lt;div&gt;Maintenance Branches.png&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;maintenance分支&lt;/strong&gt;用来快速给已发布产品修复bug或微调功能&lt;/li&gt;
&lt;li&gt;它从master分支直接衍生出来&lt;/li&gt;
&lt;li&gt;一旦完成修复bug，它应该合并回master分支和develop分支&lt;/li&gt;
&lt;li&gt;master应该被标记一个新的版本号&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;标记Tags&lt;/h4&gt;
&lt;p&gt;使用两个命令来给master分支标记版本号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git tag -a 0.1 -m &quot;Initial public release&quot; master&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push origin master --tags&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Forking Workflow&lt;/h2&gt;
&lt;p&gt;Forking Workflow与以上讨论的工作流很不同，一个很重要的&lt;strong&gt;区别&lt;/strong&gt;就是它不只是多个开发共享一个远程仓库(central repository)，而是每个开发者都拥有一个独立的服务端仓库。也就是说每个contributor都有两个仓库：本地私有的仓库和远程共享的仓库。&lt;/p&gt;
&lt;div&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/56aa04368a8ff7aba055cf6a8e7bec0f.jpg&quot;&gt;
&lt;div&gt;Forking Workflow&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Forking Workflow这种工作流主要好处就是每个开发者都拥有自己的远程仓库，可以将提交的commits推送到自己的远程仓库，但只有工程维护者才有权限push提交的commits到官方的仓库，其他开发者在没有授权的情况下不能push。Github很多&lt;strong&gt;开源项目&lt;/strong&gt;都是采用Forking Workflow工作流。&lt;/p&gt;
&lt;h4&gt;如何工作&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;在服务器上有一个官方公共的仓库&lt;/li&gt;
&lt;li&gt;开发者fork官方仓库来创建它的拷贝，然后存放在服务器上
&lt;div&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5587006baed28a9955db44d3b693b69d.jpg&quot;&gt;
&lt;div&gt;Fork official repository.png&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;当开发者准备好发布本地的commit时，他们push commit到他们自己的公共仓库&lt;/li&gt;
&lt;li&gt;在自己的公共仓库发送一个pull request到官方仓库&lt;/li&gt;
&lt;li&gt;维护者pull贡献者的commit到他自己的本地仓库&lt;/li&gt;
&lt;li&gt;审查代码确保它不会破坏工程，合并它到本地仓库的master分支&lt;/li&gt;
&lt;li&gt;push master分支到服务器上的官方仓库&lt;/li&gt;
&lt;li&gt;其他开发者应该同步官方仓库。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;扩展阅读&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://iissnan.com/progit/&quot; target=&quot;_blank&quot;&gt;Pro Git 简体中文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.atlassian.com/git/tutorials&quot; target=&quot;_blank&quot;&gt;atlassian Git Tutorials&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87410&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87410votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87410&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt; 2 收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sat, 06 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-06-87410-179f472d7.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-06-87410-179f472d7.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（15） ： 日志</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87340/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（7） ： 查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87345/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（8） ： 插入 更新 删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87348/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（9） ： 索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87351/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（10） ： 自定义存储过程和函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87353/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（11） ： 视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87355/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（12） ： 触发器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87357/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（13） ： 权限管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87363/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（14） ： 备份和恢复&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一篇《我的MYSQL学习心得（十五）》将会讲解MYSQL的日志&lt;/p&gt;
&lt;p&gt;MYSQL里的日志主要分为4类，使用这些日志文件，可以查看MYSQL内部发生的事情。&lt;/p&gt;
&lt;p&gt;分别是&lt;/p&gt;
&lt;p&gt;1、错误日志：记录mysql服务的启动、运行、停止mysql服务时出现的问题&lt;/p&gt;
&lt;p&gt;2、查询日志：记录建立的客户端连接和执行的语句&lt;/p&gt;
&lt;p&gt;3、二进制日志：记录所有更改数据的语句，可以用于数据复制&lt;/p&gt;
&lt;p&gt;4、慢查询日志：记录所有执行时间超过long_query_time的所有查询或不使用索引的查询&lt;/p&gt;
&lt;p&gt;默认情况下，所有日志创建于mysql数据目录中。通过刷新日志，可以强制mysql关闭和重新打开日志文件（或者在某些情况下切换到&lt;/p&gt;
&lt;p&gt;一个新的日志）。当执行一个FLUSH LOGS语句或执行mysqladmin flush-logs 或mysqladmin refresh 时，将刷新日志&lt;/p&gt;
&lt;p&gt;如果使用mysql复制功能，在复制服务器上可以维护更多日志文件，这种日志称为接替日志&lt;/p&gt;
&lt;p&gt;其他日志功能会降低mysql数据库的性能。例如，在查询非常频繁的mysql数据库系统中，如果开启了通用查询日志和慢查询日志，&lt;/p&gt;
&lt;p&gt;mysql数据库会花费很多时间记录日志。同时，日志会占用大量的磁盘空间&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;二进制日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二进制日志就是我们经常说的binlog，主要记录mysql数据库的变化。&lt;/p&gt;
&lt;p&gt;二进制日志以一种有效的格式，并且是事务安全的方式包含更新日志中可用的所有信息。&lt;/p&gt;
&lt;p&gt;二进制日志包含关于每个更新数据库的语句的执行时间信息。他不包含没有修改任何数据的语句，例如select语句&lt;/p&gt;
&lt;p&gt;使用二进制日志的最大目的是最大可能地恢复数据库，因为二进制日志包含备份后进行的所有更新&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、启动和设置二进制日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，二进制日志是关闭的，可以通过修改mysql的配置文件来启动和设置二进制日志&lt;/p&gt;
&lt;p&gt;my.ini中[mysqld]组下面有几个设置是关于二进制日志的：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;log-bin[=PATH/[FILENAME]]
expire_logs_days=10
max_binlog_size=100M&lt;/pre&gt;
&lt;p&gt;log-bin定义开启二进制日志；path表明日志文件所在的目录路径；&lt;/p&gt;
&lt;p&gt;filename指定了日志文件的名称，如文件的全名是filename.0001，filename.0002等&lt;/p&gt;
&lt;p&gt;除了上述文件之外，还有一个成为filename.index的文件，文件内容为所有日志的清单，可以使用记事本打开该文件&lt;/p&gt;
&lt;p&gt;filename.index文件的内容，joe是我的计算机名，当前只有一个binlog文件：.\joe-bin.000001&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;.\joe-bin.000001&lt;/pre&gt;
&lt;p&gt;expire_logs_days定义了mysql清除过期日志的时间，即二进制日志自动删除的天数。&lt;/p&gt;
&lt;p&gt;默认值为0，表示“没有自动删除”。当mysql启动或刷新二进制日志时可能删除该文件&lt;/p&gt;
&lt;p&gt;max_binlog_size定义了单个文件的大小限制，如果二进制日志写入的内容大小超出给定值，日志就会发生滚动&lt;/p&gt;
&lt;p&gt;（关闭当前文件，重新打开一个新的日志文件）。不能将该变量设置为大于1GB或小于4096字节。默认值是1GB&lt;/p&gt;
&lt;p&gt;如果正在使用大事务 ，二进制日志文件大小还可能超过max_binlog_size的定义大小。&lt;/p&gt;
&lt;p&gt;在my.ini配置文件中的[mysqld]组下，添加以下几个参数与参数值&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[mysqld]
log-bin
expire_logs_days=10
max_binlog_size=100M&lt;/pre&gt;
&lt;p&gt;添加完毕之后，关闭并重启mysql服务进程，即可打开二进制日志，然后可以通过SHOW VARIABLES语句来查询日志设置&lt;/p&gt;
&lt;p&gt;使用show VARIABLES  语句查看日志设置&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show VARIABLES  LIKE &#39;%log_%&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4179d0eecc6bfb97936c99177ae00970.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到log_bin为ON，max_binlog_size为104857600字节，换算为MB为100MB&lt;/p&gt;
&lt;p&gt;MYSQL重新启动之后，就可以看到新产生的文件后缀为.000001和.index的两个文件，文件名称默认为主机名称&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/249147b4fe3f444a54e9217188149492.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果想改变日志文件的目录位置，可以修改my.ini中log-bin参数&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[mysqld]
log-bin=&quot;D:\mysql\log\binlog&quot;&lt;/pre&gt;
&lt;p&gt;关闭并重启mysql服务之后，新的二进制日志将出现在”D:\mysql\log\binlog”路径下&lt;/p&gt;
&lt;p&gt;提示：数据库文件最好不要和日志文件放在同一个磁盘上，这样当数据库文件所在磁盘发生损坏的时候，可以使用日志来恢复数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、查看二进制日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql二进制日志是经常用到的。当mysql创建二进制日志文件时，首先创建一个以filename为名称，以index为后缀的文件；&lt;/p&gt;
&lt;p&gt;再创建一个以filename为名称，以“.000001”为后缀的文件。当mysql服务重新启动一次，以“.000001”为后缀的文件会增加一个，&lt;/p&gt;
&lt;p&gt;并且后缀名加1递增；如果日志长度超过了max_binlog_size的上限（默认是1GB）也会创建一个新的日志文件&lt;/p&gt;
&lt;p&gt;show binary logs语句可以查看当前二进制日志文件个数和文件名。mysql二进制日志并不能直接查看，如果要查看日志内容，&lt;/p&gt;
&lt;p&gt;可以通过mysqlbinlog命令查看&lt;/p&gt;
&lt;p&gt;使用show binary logs语句查看二进制日志文件个数和文件名&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW BINARY LOGS;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4043e28d51b045b196870d99409772c6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，当前有两个二进制日志文件，因为我把mysql服务重启了一次，日志文件的个数和mysql服务启动的次数相同。&lt;/p&gt;
&lt;p&gt;每启动一次mysql服务，将会产生一个新的日志文件&lt;/p&gt;
&lt;p&gt;使用mysqlbinlog查看二进制日志&lt;/p&gt;
&lt;p&gt;mysqlbinlog是一个单独的exe，需要在命令行里执行我们把binlog文件里面的内容导出到binlog.txt&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqlbinlog  &quot;D:\Program Files (x86)\MySQL\MySQL Server5.5\data\joe-bin.000002&quot; &amp;gt;c:\binlog.txt&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#140731  7:49:30 server id 1  end_log_pos 107     Start: binlog v 4, server v 5.5.20-log created 140731  7:49:30 at startup
# Warning: this binlog is either in use or was not closed properly.
ROLLBACK/*!*/;
BINLOG &#39;
ioTZUw8BAAAAZwAAAGsAAAABAAQANS41LjIwLWxvZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAACKhNlTEzgNAAgAEgAEBAQEEgAAVAAEGggAAAAICAgCAA==
&#39;/*!*/;
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、删除二进制日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql的二进制日志可以配置自动删除，同时mysql也提供了安全的手动删除二进制日志的方法&lt;/p&gt;
&lt;p&gt;删除所有的二进制日志文件使用RESET MASTER;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;RESET MASTER;&lt;/pre&gt;
&lt;p&gt;执行该语句，所有二进制日志将被删除，mysql 会重新创建二进制日志，新的日志文件扩展名将重新从000001开始编号&lt;/p&gt;
&lt;p&gt;只删除部分二进制日志文件使用PURGE MASTER LOGS;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;PURGE MASTER LOGS;&lt;/pre&gt;
&lt;p&gt;语法如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;PURGE {MASTER | BINARY} LOGS TO &#39;log_name&#39;
PURGE {MASTER | BINARY} LOGS BEFORE &#39;date&#39;&lt;/pre&gt;
&lt;p&gt;第一种方法指定文件名，执行该命令将删除文件名编号比指定文件名编号小的所有日志文件&lt;/p&gt;
&lt;p&gt;第二种方法指定日期，执行该命令将删除指定日期以前的所有日志文件&lt;/p&gt;
&lt;p&gt;使用PURGE MASTER LOGS;删除创建时间比binlog.000003早的所有日志文件&lt;/p&gt;
&lt;p&gt;首先，为了演示语句操作过程，准备多个日志文件，读者可以对mysql服务进行多次重启&lt;/p&gt;
&lt;p&gt;例如这里有10个日志文件&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/be52c53c436f4083edd8057bf2a65bf0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;执行删除命令&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt; PURGE MASTER LOGS TO &quot;joe-bin.000003&quot;;&lt;/pre&gt;
&lt;p&gt;执行完成后，使用 show BINARY logs; 查看二进制日志&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1ed4df49a53a6be8124dc6956db0fc33.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到joe-bin.000001和joe-bin.000002两个日志文件被删除了&lt;/p&gt;
&lt;p&gt;使用 PURGE MASTER LOGS 删除2013年3月30日前创建的所有日志文件，执行命令如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;PURGE MASTER LOGS BEFORE &#39;20130330&#39;&lt;/pre&gt;
&lt;p&gt;执行完毕之后，2013年3月30日前的日志文件都被删除，但2013年3月30日的日志会被保留&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、查看二进制日志里的操作记录&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show binlog events;&lt;/pre&gt;
&lt;p&gt;比如想查看某一个二进制日志里面的记录，但又不想用mysqlbinlog，可以使用show binlog events&lt;/p&gt;
&lt;p&gt;比如我想查看’joe-bin.000006′这个binlog文件的内容，执行如下命令&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show binlog events in &#39;joe-bin.000006&#39;;&lt;/pre&gt;
&lt;p&gt;内容如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Log_name: joe-bin.000006
Pos: 202 
Event_type: Query 
Server_id: 1 
End_log_pos: 304 
Info: use `test`; insert into bin(name) values (&#39;orange&#39;)&lt;/pre&gt;
&lt;p&gt;可以看到’joe-bin.000006′这个binlog文件记录了哪些SQL命令&lt;/p&gt;
&lt;p&gt;如果想知道binlog文件的创建时间，就需要mysqlbinlog工具来查看&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;C:\ProgramData\MySQL\MySQL Server 5.5\data&amp;gt;mysqlbinlog mysql_bin.000001 
/*!40019 SET @@session.max_insert_delayed_threads=0*/; 
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/; 
DELIMITER /*!*/; 
# at 4 
#131015 16:35:56 server id 1  end_log_pos 106&lt;/pre&gt;
&lt;p&gt;其中131015为日志创建时间，即2013年10月15日&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、使用二进制日志还原数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果mysql服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用mysqlbinlog工具从指定的时间点开始&lt;/p&gt;
&lt;p&gt;（例如，最后一次备份）直到现在，或另外一个指定的时间点的日志中恢复数据&lt;/p&gt;
&lt;p&gt;要想从二进制日志恢复数据，需要知道当前二进制日志文件的路径和文件名。一般可以从配置文件（即my.cnf或者my.ini，文件名取决于mysql&lt;/p&gt;
&lt;p&gt;服务器的操作系统）中找到路径&lt;/p&gt;
&lt;p&gt;mysqlbinlog恢复数据的语法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqlbinlog [option] filename |mysql -uuser -ppass&lt;/pre&gt;
&lt;p&gt;option是一些可选项，filename是日志文件名&lt;/p&gt;
&lt;p&gt;比较重要的两对option参数是&lt;/p&gt;
&lt;p&gt;–start-datetime、–stop-datetime&lt;/p&gt;
&lt;p&gt;–start-position、–stop–position&lt;/p&gt;
&lt;p&gt;–start-date、–stop-date可以指定恢复数据库的起始时间点和结束时间点&lt;/p&gt;
&lt;p&gt;–start-position、–stop–position可以指定恢复数据的开始位置和结束位置&lt;/p&gt;
&lt;p&gt;使用mysqlbinlog恢复mysql数据库到2014年7月2日15：27：48时的状态，执行下面命令&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqlbinlog --stop-datetime=&quot;2014-7-2 15:27:48 &quot; D:\mysql\log\binlog\binlog.000008 |mysql -u user -p password&lt;/pre&gt;
&lt;p&gt;该命令执行成功后，会根据binlog.000008日志文件恢复2014年7月2日15：27：48前的所有操作。&lt;/p&gt;
&lt;p&gt;这种方法对误操作的删除数据比较有效&lt;/p&gt;
&lt;p&gt;6、暂时停止二进制日志&lt;/p&gt;
&lt;p&gt;如果在mysql的配置文件配置启动了二进制日志，mysql会一直记录二进制日志，修改配置文件，可以停止二进制日志，&lt;/p&gt;
&lt;p&gt;但是需要重启mysql数据库。mysql提供了暂时停止二进制日志的功能。通过 SET SQL_LOG_BIN 语句可以使mysql暂停或者启动二进制日志&lt;/p&gt;
&lt;p&gt;语法如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET sql_log_bin={0|1}&lt;/pre&gt;
&lt;p&gt;执行下面语句将暂停二进制日志&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET sql_log_bin=0;&lt;/pre&gt;
&lt;p&gt;执行下面语句将恢复记录二进制日志&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET sql_log_bin=1;&lt;/pre&gt;
&lt;p&gt;实际上，binlog文件有点类似于SQLSERVER的ldf文件，大家都保存了数据库的操作日志，都可以根据这个日志来恢复数据库&lt;/p&gt;
&lt;p&gt;但是又有不同，mysql的binlog可用不开启，因为mysql的redo日志放在ib_logfile开头的文件里面，而undo日志跟数据文件是放在一起的&lt;/p&gt;
&lt;p&gt;所以这一点跟SQLSERVER很不一样&lt;/p&gt;
&lt;p&gt;在复制的时候，MYSQL一定要开启binlog功能，slave读取binlog，而SQLSERVER的订阅端读取发布端的ldf文件&lt;/p&gt;
&lt;p&gt;所以刚才说：binlog文件有点类似于SQLSERVER的ldf文件&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;错误日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;错误日志文件包含了当mysqld启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。&lt;/p&gt;
&lt;p&gt;在MYSQL中，错误日志也是非常重要的，mysql将启动和停止数据库信息以及一些错误信息记录到错误日志中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、启动和设置错误日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在默认情况下，错误日志会记录到数据库的数据目录下。如果没有在配置文件中指定文件名，则文件名默认为hostname.err。&lt;/p&gt;
&lt;p&gt;例如：mysql所在服务器主机名为mysql-db，记录错误信息的文件名为mysql-db.err。如果执行了FLUSH LOGS，错误日志文件会重新加载&lt;/p&gt;
&lt;p&gt;错误日志的启动和停止以及日志文件名，都可以通过修改my.ini（或者my.cnf）来配置。错误日志的配置项是log-error。&lt;/p&gt;
&lt;p&gt;在[mysqld]下配置log-error，在启动错误日志。如果需要指定文件名，则配置项如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[mysqld]

log-error=[path/[file_name]]&lt;/pre&gt;
&lt;p&gt;path为日志文件所在的目录路径，filename为日志文件名。修改配置项后，需要重启mysql服务才生效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、查看错误日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过错误日志可以监视系统的运行状态，便于及时发现故障，修复故障。mysql错误日志是以文本文件形式存储的，可以使用文本编辑器直接&lt;/p&gt;
&lt;p&gt;查看mysql错误日志&lt;/p&gt;
&lt;p&gt;如果不知道日志文件的存储路径，可以使用 show variables; 语句查看错误日志的存储路径。&lt;/p&gt;
&lt;p&gt;语句如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show variables LIKE &#39;log_error&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/feb20e7d3af0d0379389d9a3fee32bc6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用记事本查看mysql错误日志&lt;/p&gt;
&lt;p&gt;通过上面 show variables LIKE ’log_error’; 的语句查看到错误日志的路径，然后用记事本打开该文件&lt;/p&gt;
&lt;p&gt;我们可以看到错误日志内容如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;140705 16:41:17 [Note] Plugin &#39;FEDERATED&#39; is disabled.
140705 16:41:17 InnoDB: The InnoDB memory heap is disabled
140705 16:41:17 InnoDB: Mutexes and rw_locks use Windows interlocked functions
140705 16:41:17 InnoDB: Compressed tables use zlib 1.2.3
140705 16:41:17 InnoDB: Initializing buffer pool, size = 2.0G
140705 16:41:18 InnoDB: Completed initialization of buffer pool
InnoDB: The first specified data file E:\MYSQL DataBase\ibdata1 did not exist:
InnoDB: a new database to be created!
140705 16:41:18  InnoDB: Setting file E:\MYSQL DataBase\ibdata1 size to 10 MB
InnoDB: Database physically writes the file full: wait...
140705 16:41:18  InnoDB: Log file .\ib_logfile0 did not exist: new to be created
InnoDB: Setting log file .\ib_logfile0 size to 213 MB
InnoDB: Database physically writes the file full: wait...
InnoDB: Progress in MB: 100 200
140705 16:41:21  InnoDB: Log file .\ib_logfile1 did not exist: new to be created
InnoDB: Setting log file .\ib_logfile1 size to 213 MB
InnoDB: Database physically writes the file full: wait...
InnoDB: Progress in MB: 100 200
InnoDB: Doublewrite buffer not found: creating new
InnoDB: Doublewrite buffer created
InnoDB: 127 rollback segment(s) active.
InnoDB: Creating foreign key constraint system tables
InnoDB: Foreign key constraint system tables created
140705 16:41:23  InnoDB: Waiting for the background threads to start
140705 16:41:24 InnoDB: 1.1.8 started; log sequence number 0
140705 16:41:24 [Note] Event Scheduler: Loaded 0 events
140705 16:41:24 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: ready for connections.
Version: &#39;5.5.19&#39;  socket: &#39;&#39;  port: 3306  MySQL Community Server (GPL)
140705 23:44:14 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Normal shutdown

140705 23:44:14 [Note] Event Scheduler: Purging the queue. 0 events
140705 23:44:14  InnoDB: Starting shutdown...
140705 23:44:15  InnoDB: Shutdown completed; log sequence number 1595675
140705 23:44:15 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Shutdown complete

140706  8:17:09 [Note] Plugin &#39;FEDERATED&#39; is disabled.
140706  8:17:09 InnoDB: The InnoDB memory heap is disabled
140706  8:17:09 InnoDB: Mutexes and rw_locks use Windows interlocked functions
140706  8:17:09 InnoDB: Compressed tables use zlib 1.2.3
140706  8:17:09 InnoDB: Initializing buffer pool, size = 2.0G
140706  8:17:10 InnoDB: Completed initialization of buffer pool
140706  8:17:10 InnoDB: highest supported file format is Barracuda.
140706  8:17:14  InnoDB: Waiting for the background threads to start
140706  8:17:15 InnoDB: 1.1.8 started; log sequence number 1595675
140706  8:17:16 [Note] Event Scheduler: Loaded 0 events
140706  8:17:16 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: ready for connections.
Version: &#39;5.5.19&#39;  socket: &#39;&#39;  port: 3306  MySQL Community Server (GPL)
140706 14:05:35 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Normal shutdown

140706 14:05:35 [Note] Event Scheduler: Purging the queue. 0 events
140706 14:05:35  InnoDB: Starting shutdown...
140706 14:05:36  InnoDB: Shutdown completed; log sequence number 1603322
140706 14:05:37 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Shutdown complete

140718 21:47:03 [Note] Plugin &#39;FEDERATED&#39; is disabled.
140718 21:47:03 InnoDB: The InnoDB memory heap is disabled
140718 21:47:03 InnoDB: Mutexes and rw_locks use Windows interlocked functions
140718 21:47:03 InnoDB: Compressed tables use zlib 1.2.3
140718 21:47:03 InnoDB: Initializing buffer pool, size = 2.0G
140718 21:47:03 InnoDB: Completed initialization of buffer pool
140718 21:47:03 InnoDB: highest supported file format is Barracuda.
140718 21:47:04  InnoDB: Waiting for the background threads to start
140718 21:47:05 InnoDB: 1.1.8 started; log sequence number 1603322
140718 21:47:06 [Note] Event Scheduler: Loaded 0 events
140718 21:47:06 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: ready for connections.
Version: &#39;5.5.19&#39;  socket: &#39;&#39;  port: 3306  MySQL Community Server (GPL)
140719 20:02:45 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Normal shutdown

140719 20:02:45 [Note] Event Scheduler: Purging the queue. 0 events
140719 20:02:46  InnoDB: Starting shutdown...
140719 20:02:47  InnoDB: Shutdown completed; log sequence number 1603332
140719 20:02:48 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Shutdown complete

140719 20:04:20 [Note] Plugin &#39;FEDERATED&#39; is disabled.
140719 20:04:20 InnoDB: The InnoDB memory heap is disabled
140719 20:04:20 InnoDB: Mutexes and rw_locks use Windows interlocked functions
140719 20:04:20 InnoDB: Compressed tables use zlib 1.2.3
140719 20:04:20 InnoDB: Initializing buffer pool, size = 2.0G
140719 20:04:20 InnoDB: Completed initialization of buffer pool
140719 20:04:20 InnoDB: highest supported file format is Barracuda.
140719 20:04:21  InnoDB: Waiting for the background threads to start
140719 20:04:22 InnoDB: 1.1.8 started; log sequence number 1603332
140719 20:04:23 [Note] Event Scheduler: Loaded 0 events
140719 20:04:23 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: ready for connections.
Version: &#39;5.5.19&#39;  socket: &#39;&#39;  port: 3306  MySQL Community Server (GPL)
140720  1:39:36 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Normal shutdown

140720  1:39:37 [Note] Event Scheduler: Purging the queue. 0 events
140720  1:39:40  InnoDB: Starting shutdown...
140720 11:17:29 [Note] Plugin &#39;FEDERATED&#39; is disabled.
140720 11:17:29 InnoDB: The InnoDB memory heap is disabled
140720 11:17:29 InnoDB: Mutexes and rw_locks use Windows interlocked functions
140720 11:17:29 InnoDB: Compressed tables use zlib 1.2.3
140720 11:17:29 InnoDB: Initializing buffer pool, size = 2.0G
140720 11:17:29 InnoDB: Completed initialization of buffer pool
140720 11:17:29 InnoDB: highest supported file format is Barracuda.
140720 11:17:37  InnoDB: Waiting for the background threads to start
140720 11:17:38 InnoDB: 1.1.8 started; log sequence number 1603332
140720 11:17:39 [Note] Event Scheduler: Loaded 0 events
140720 11:17:39 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: ready for connections.
Version: &#39;5.5.19&#39;  socket: &#39;&#39;  port: 3306  MySQL Community Server (GPL)
140720 13:40:21 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Normal shutdown

140720 13:40:21 [Note] Event Scheduler: Purging the queue. 0 events
140720 13:40:22  InnoDB: Starting shutdown...
140720 13:40:23  InnoDB: Shutdown completed; log sequence number 1603332
140720 13:40:24 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Shutdown complete

140726 11:12:58 [Note] Plugin &#39;FEDERATED&#39; is disabled.
140726 11:12:59 InnoDB: The InnoDB memory heap is disabled
140726 11:12:59 InnoDB: Mutexes and rw_locks use Windows interlocked functions
140726 11:12:59 InnoDB: Compressed tables use zlib 1.2.3
140726 11:12:59 InnoDB: Initializing buffer pool, size = 2.0G
140726 11:12:59 InnoDB: Completed initialization of buffer pool
140726 11:12:59 InnoDB: highest supported file format is Barracuda.
140726 11:13:06  InnoDB: Waiting for the background threads to start
140726 11:13:07 InnoDB: 1.1.8 started; log sequence number 1603332
140726 11:13:10 [Note] Event Scheduler: Loaded 0 events
140726 11:13:10 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: ready for connections.
Version: &#39;5.5.19&#39;  socket: &#39;&#39;  port: 3306  MySQL Community Server (GPL)
140727  0:34:19 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Normal shutdown

140727  0:34:20 [Note] Event Scheduler: Purging the queue. 0 events
140727  0:34:24  InnoDB: Starting shutdown...
140727 10:03:47 [Note] Plugin &#39;FEDERATED&#39; is disabled.
140727 10:03:49 InnoDB: The InnoDB memory heap is disabled
140727 10:03:49 InnoDB: Mutexes and rw_locks use Windows interlocked functions
140727 10:03:49 InnoDB: Compressed tables use zlib 1.2.3
140727 10:03:49 InnoDB: Initializing buffer pool, size = 2.0G
140727 10:03:49 InnoDB: Completed initialization of buffer pool
140727 10:03:50 InnoDB: highest supported file format is Barracuda.
140727 10:03:50  InnoDB: Waiting for the background threads to start
140727 10:03:51 InnoDB: 1.1.8 started; log sequence number 1603332
140727 10:03:52 [Note] Event Scheduler: Loaded 0 events
140727 10:03:52 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: ready for connections.
Version: &#39;5.5.19&#39;  socket: &#39;&#39;  port: 3306  MySQL Community Server (GPL)
140727 14:29:56 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Normal shutdown

140727 14:29:56 [Note] Event Scheduler: Purging the queue. 0 events
140727 14:29:58  InnoDB: Starting shutdown...
140727 14:30:00  InnoDB: Shutdown completed; log sequence number 1643538
140727 14:30:00 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Shutdown complete

140801 21:10:05 [Note] Plugin &#39;FEDERATED&#39; is disabled.
140801 21:10:05 InnoDB: The InnoDB memory heap is disabled
140801 21:10:05 InnoDB: Mutexes and rw_locks use Windows interlocked functions
140801 21:10:05 InnoDB: Compressed tables use zlib 1.2.3
140801 21:10:06 InnoDB: Initializing buffer pool, size = 2.0G
140801 21:10:06 InnoDB: Completed initialization of buffer pool
140801 21:10:06 InnoDB: highest supported file format is Barracuda.
140801 21:10:09  InnoDB: Waiting for the background threads to start
140801 21:10:10 InnoDB: 1.1.8 started; log sequence number 1643538
140801 21:10:10 [Note] Event Scheduler: Loaded 0 events
140801 21:10:10 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: ready for connections.
Version: &#39;5.5.19&#39;  socket: &#39;&#39;  port: 3306  MySQL Community Server (GPL)
140801 22:59:19 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Normal shutdown

140801 22:59:19 [Note] Event Scheduler: Purging the queue. 0 events
140801 22:59:21 [Warning] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Forcing close of thread 2  user: &#39;root&#39;

140801 22:59:21  InnoDB: Starting shutdown...
140801 22:59:23  InnoDB: Shutdown completed; log sequence number 1643538
140801 22:59:23 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: Shutdown complete

140801 22:59:24 [Warning] No argument was provided to --log-bin, and --log-bin-index was not used; so replication may break when this MySQL server acts as a master and has his hostname changed!! Please use &#39;--log-bin=WIN7U-20130414Z-bin&#39; to avoid this problem.
140801 22:59:24 [Note] Plugin &#39;FEDERATED&#39; is disabled.
140801 22:59:24 InnoDB: The InnoDB memory heap is disabled
140801 22:59:24 InnoDB: Mutexes and rw_locks use Windows interlocked functions
140801 22:59:24 InnoDB: Compressed tables use zlib 1.2.3
140801 22:59:24 InnoDB: Initializing buffer pool, size = 2.0G
140801 22:59:24 InnoDB: Completed initialization of buffer pool
140801 22:59:24 InnoDB: highest supported file format is Barracuda.
140801 22:59:24  InnoDB: Waiting for the background threads to start
140801 22:59:25 InnoDB: 1.1.8 started; log sequence number 1643538
140801 22:59:26 [Note] Event Scheduler: Loaded 0 events
140801 22:59:26 [Note] E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld: ready for connections.
Version: &#39;5.5.19-log&#39;  socket: &#39;&#39;  port: 3306  MySQL Community Server (GPL)&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、删除错误日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql的错误日志以文本文件的形式存储在文件系统中，可以直接删除&lt;/p&gt;
&lt;p&gt;对于mysql5.5.7以前的版本，flush logs可以将错误日志文件重命名为filename.err_old，&lt;/p&gt;
&lt;p&gt;并创建新的日志文件。但是从mysql5.5.7开始，flush logs只是重新打开日志文件，并不做日志备份和创建的操作。&lt;/p&gt;
&lt;p&gt;如果日志文件不存在，mysql启动或者执行flush logs时会创建新的日志文件&lt;/p&gt;
&lt;p&gt;在运行状态下删除错误日志文件后，mysql并不会自动创建日志文件。flush logs在重新加载日志的时候，如果文件不存在，&lt;/p&gt;
&lt;p&gt;则会自动创建。所以在删除错误日志之后，如果需要重建日志文件需要在服务器端执行以下命令：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqladmin -u root -p flush-logs&lt;/pre&gt;
&lt;p&gt;或者在客户端登录mysql数据库，执行flush logs语句&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;flush logs;&lt;/pre&gt;
&lt;p&gt;删除err文件，并用flush logs语句重建log-error文件&lt;/p&gt;
&lt;p&gt;手动删除文件&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6e2012288e81b1b48e4c1830870a16ed.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;手动执行 flush logs; ，err文件恢复了&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/76e8fc20c41f54b1f58aa2a2cae7b1b9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;打开err文件，里面什么都没有&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/96392b25aff7787489441b252cd306de.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;通用查询日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通用查询日志记录了mysql的所有用户操作，包括启动和关闭服务、执行查询和更新语句等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、启动和设置通用查询日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql服务器默认情况下并没有开启通用查询日志。如果需要通用查询日志，可以通过修改my.ini或my.cnf配置文件来&lt;/p&gt;
&lt;p&gt;开启。在my.ini或my.cnf的[mysqld]组下加入log选项&lt;/p&gt;
&lt;p&gt;形式如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[mysqld]

log[=path/[filename]]&lt;/pre&gt;
&lt;p&gt;path为日志文件所在目录路径，filename为日志文件名。如果不指定目录和文件名，通用查询日志将默认存储在mysql数据目录中的&lt;/p&gt;
&lt;p&gt;hostname.log文件中。hostname是mysql数据库的主机名&lt;/p&gt;
&lt;p&gt;这里在[mysqld]下面增加选项log，后面不指定参数值&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[mysqld]
log&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、查看通用查询日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通用查询日志中记录了用的所有操作。通过查看通用查询日志，可以了解用户对mysql进行的操作。通用查询日志是&lt;/p&gt;
&lt;p&gt;以文本文件形式存储在文件系统中的，可以使用文本编辑器直接打开通用日志文件进行查看，Windows下可以使用记事本&lt;/p&gt;
&lt;p&gt;Linux下可以使用vim、gedit等&lt;/p&gt;
&lt;p&gt;使用记事本查看mysql通用查询日志&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d31364be24eda92993e938000a69e74f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;文件内容如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld, Version: 5.5.19-log (MySQL Community Server (GPL)). started with:
TCP Port: 3306, Named Pipe: (null)
Time                 Id Command    Argument
140801 23:39:33        1 Connect    root@localhost on 
            1 Query    SHOW VARIABLES
            1 Query    SHOW WARNINGS
            1 Query    select timediff( curtime(), utc_time() )
            1 Query    SHOW COLLATION
            1 Query    SET NAMES utf8
            1 Query    SET character_set_results=NULL
            1 Query    SELECT * FROM `emp`
140801 23:39:44        1 Query    SELECT * FROM `emp`
            1 Query    SELECT * FROM `emp`
140801 23:39:55        1 Query    USE test;

SELECT * FROM `emp`
            1 Init DB    test&lt;/pre&gt;
&lt;p&gt;可以看到mysql启动信息和用户root连接服务器与执行查询语句的记录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、删除通用查询日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通用查询日志是以文本文件的形式存储在文件系统中的。通用查询日志记录用户的所有操作&lt;/p&gt;
&lt;p&gt;因此在用户查询、更新频繁的情况下，通用查询日志会增长得很快。DBA可以定期删除比较早的通用日志，以节省磁盘空间&lt;/p&gt;
&lt;p&gt;可以用直接删除日志文件的方式删除通用查询日志。要重新建立新的日志文件，可使用语句&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqladmin -flush logs&lt;/pre&gt;
&lt;p&gt;直接删除log文件&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8e1460271120926eae903891c188bed4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;执行 flush logs&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f3eeda99f80a6b6ef0bfc597348e9e64.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;log文件重新生成了&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dc29fee06d48e9217e5940589774cf7a.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;慢查询日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;慢查询日志是记录查询时长超过指定时间的日。慢查询日志主要用来记录执行时间较长的查询语句&lt;/p&gt;
&lt;p&gt;通过慢查询日志，可以找出执行时间较长、执行效率较低的语句，然后进行优化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、启动和设置慢查询日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql中慢查询日志默认是关闭的，可以通过配置文件my.ini或my.cnf中的log-slow-queries选项打开，也可以在mysql服务&lt;/p&gt;
&lt;p&gt;启动的时候使用–log–slow-queries[=file_name]启动慢查询日志。启动慢查询日志时，需要在my.ini或者my.cnf文件中&lt;/p&gt;
&lt;p&gt;配置long_query_time选项指定记录阀值，如果某条查询语句的查询时间超过了这个值，这个查询过程将被记录到慢查询日志&lt;/p&gt;
&lt;p&gt;文件中。&lt;/p&gt;
&lt;p&gt;在my.ini或者my.cnf文件中开启慢查询日志的配置如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[mysqld]

log-slow-queries[=path/[filename]]
long_query_time=n&lt;/pre&gt;
&lt;p&gt;path为日志文件所在目录路径，filename为日志文件名。如果不指定目录和文件名称，默认存储在数据目录中&lt;/p&gt;
&lt;p&gt;文件名为hostname-slow.log，hostname是mysql服务器的主机名。参数n是时间值，单位是秒。&lt;/p&gt;
&lt;p&gt;如果没有设置long-query_time选项，默认时间为10秒&lt;/p&gt;
&lt;p&gt;开启慢查询日志&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[mysqld]
log-slow-queries
long_query_time=1&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、查看慢查询日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql的慢查询日志是以文本形式存储的，可以直接使用文本编辑器查看。在慢查询日志中，记录着执行时间较长的查询语句，&lt;/p&gt;
&lt;p&gt;用户可以从慢查询日志中获取执行效率较低的查询语句，为查询优化提供重要的依据&lt;/p&gt;
&lt;p&gt;查看慢查询日志的一些参数&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show variables like &#39;%slow%&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/33f34540c2b465eb2d9ab964301b1f1a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;查看慢查询日志文件里的内容，使用文本编辑器打开数据目录下的WIN7U-20130414Z-slow.log文件&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7548e3f831f5875cbbea200d986497fe.jpg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;E:\Program Files\MySQL\MySQL Server 5.5\bin\mysqld, Version: 5.5.19-log (MySQL Community Server (GPL)). started with:
TCP Port: 3306, Named Pipe: (null)
Time                 Id Command    Argument
# Time: 140802  0:02:29
# User@Host: root[root] @ localhost [::1]
# Query_time: 7.578125  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 0
use test;
SET timestamp=1406908949;
SELECT BENCHMARK (10000000,PASSWORD (&#39;newpwd&#39;));&lt;/pre&gt;
&lt;p&gt;可以看到这里记录了一条慢查询日志。执行该条语句的帐户是root @ localhost&lt;/p&gt;
&lt;p&gt;查询时间是Query_time: 7.578125秒&lt;/p&gt;
&lt;p&gt;查询语句是 SELECT BENCHMARK (10000000,PASSWORD (‘newpwd’));&lt;/p&gt;
&lt;p&gt;该语句查询时间大大超过了设置值1秒，因此被记录在慢查询日志文件中&lt;/p&gt;
&lt;p&gt;BENCHMARK函数简介：&lt;a title=&quot;http://database.51cto.com/art/201010/229366.htm &quot; href=&quot;http://database.51cto.com/art/201010/229366.htm%20&quot; target=&quot;_blank&quot;&gt;http://database.51cto.com/art/201010/229366.htm &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、删除慢查询日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和通用查询日志一样，慢查询日志也可以直接删除。删除后在不重启服务器的情况下，需要执行&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqladmin -u root -p flush logs&lt;/pre&gt;
&lt;p&gt;重新生成日志文件，或者在客户端登录到服务器执行 flush logs; 语句重建日志文件&lt;/p&gt;
&lt;p&gt;官方mysql的慢查询日志在这里有一个缺陷，就是查询阀值只能是1秒或以上，如果要设置一秒以下就无能为力了&lt;/p&gt;
&lt;p&gt;这时候如果想找出1秒以下的慢查询SQL，可以使用&lt;strong&gt;percona&lt;/strong&gt;提供的&lt;strong&gt;microslow-patch&lt;/strong&gt;来突破限制，将慢查询时间阀值减小到毫秒级别&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;平时应打开哪些日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;日志既会影响mysql的性能，又会占用大量磁盘空间。因此，如果不必要，应尽可能少地开启日志。&lt;/p&gt;
&lt;p&gt;根据不同的使用环境，考虑开启不同的日志。&lt;/p&gt;
&lt;p&gt;例如开发环境中优化查询效率低的语句，可以开启&lt;strong&gt;慢查询日志&lt;/strong&gt;，或者生产环境中发现某些SQL执行特别慢也可以开启&lt;/p&gt;
&lt;p&gt;如果磁盘空间不是特充足可以在高峰期间开启，在捕获到查询慢的SQL之后再关闭慢查询日志&lt;/p&gt;
&lt;p&gt;如果需要搭建复制环境，那么就一定要开启&lt;strong&gt;二进制日志&lt;/strong&gt;，如果数据特别重要也建议开启二进制日志，以便数据库损坏的时候也可以通过二进制日志&lt;/p&gt;
&lt;p&gt;挽救一部分数据&lt;/p&gt;
&lt;p&gt;通用日志无论在哪种情况下，一般不建议开启&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文简单的阐述了MYSQL的日志面的内容，MYSQL的日志系统还是比较完善的，希望这篇文章对大家有帮助&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2014-11-27补充 写事务日志流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/cb7df7e51e0534c668280e0336600a05.jpg&quot;&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87365&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87365votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87365&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sat, 06 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-06-87365-92f010d92.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-06-87365-92f010d92.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（14） ： 备份和恢复</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87345/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（7） ： 查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87345/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（8） ： 插入 更新 删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87348/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（9） ： 索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87351/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（10） ： 自定义存储过程和函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87353/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（11） ： 视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87355/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（12） ： 触发器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87357/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（13） ： 权限管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一篇《我的MYSQL学习心得（十四）》将会讲解MYSQL的备份和恢复&lt;/p&gt;
&lt;p&gt;MYSQL里的备份分为逻辑备份和物理备份，还原的时候同样分逻辑还原和物理还原&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备份&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑备份方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用MYSQLDUMP命令备份&lt;/p&gt;
&lt;p&gt;MYSQLDUMP是MYSQL提供的一个非常有用的数据库备份工具。mysqldump命令执行时将数据库备份成一个文本文件，&lt;/p&gt;
&lt;p&gt;该文件中实际上包含了多个CREATE 和INSERT语句，使用这些语句可以重新创建表和插入数据&lt;/p&gt;
&lt;p&gt;MYSQLDUMP的语法和选项&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqldump -u user -p pwd -h host dbname[tbname,[tbname...]]&amp;gt;filename.sql

选项/Option 作用/Action Performed
--add-drop-table
这个选项将会在每一个表的前面加上DROP TABLE IF EXISTS语句，这样可以保证导回MySQL数据库的时候不会出错，因为每次导回的时候，都会首先检查表是否存在，存在就删除
--add-locks
这个选项会在INSERT语句中捆上一个LOCK TABLE和UNLOCK TABLE语句。这就防止在这些记录被再次导入数据库时其他用户对表进行的操作
-c or - complete_insert
这个选项使得mysqldump命令给每一个产生INSERT语句加上列（field）的名字。当把数据导出导另外一个数据库时这个选项很有用。
--delayed-insert 在INSERT命令中加入DELAY选项
-F or -flush-logs 使用这个选项，在执行导出之前将会刷新MySQL服务器的log.
-f or -force 使用这个选项，即使有错误发生，仍然继续导出
--full 这个选项把附加信息也加到CREATE TABLE的语句中
-l or -lock-tables 使用这个选项，导出表的时候服务器将会给表加锁。
-t or -no-create- info
这个选项使的mysqldump命令不创建CREATE TABLE语句，这个选项在您只需要数据而不需要DDL（数据库定义语句）时很方便。
-d or -no-data 这个选项使的mysqldump命令不创建INSERT语句。
在您只需要DDL语句时，可以使用这个选项。
--opt 此选项将打开所有会提高文件导出速度和创造一个可以更快导入的文件的选项。
-q or -quick 这个选项使得MySQL不会把整个导出的内容读入内存再执行导出，而是在读到的时候就写入导文件中。
-T path or -tab = path 这个选项将会创建两个文件，一个文件包含DDL语句或者表创建语句，另一个文件包含数据。DDL文件被命名为table_name.sql,数据文件被命名为table_name.txt.路径名是存放这两个文件的目录。目录必须已经存在，并且命令的使用者有对文件的特权。
-w &quot;WHERE Clause&quot; or -where = &quot;Where clause &quot;
如前面所讲的，您可以使用这一选项来过筛选将要放到 导出文件的数据。
假定您需要为一个表单中要用到的帐号建立一个文件，经理要看今年（2004年）所有的订单（Orders），它们并不对DDL感兴趣，并且需要文件有逗号分隔，因为这样就很容易导入到Excel中。 为了完成这个任务，您可以使用下面的句子：
bin/mysqldump –p –where &quot;Order_Date &amp;gt;=&#39;2000-01-01&#39;&quot;
–tab = /home/mark –no-create-info –fields-terminated-by=, Meet_A_Geek Orders
这将会得到您想要的结果。
schema：模式
The set of statements, expressed in data definition language, that completely describe the structure of a data base.
一组以数据定义语言来表达的语句集,该语句集完整地描述了数据库的结构。
SELECT INTO OUTFILE ：&lt;/pre&gt;
&lt;p&gt;mysqldump提供了很多选项，包括调试和压缩的，在这里只是列举最有用的。&lt;/p&gt;
&lt;p&gt;运行帮助命令mysqldump –help可以获得特定版本的完整选项列表&lt;/p&gt;
&lt;p&gt;user表示用户名称；&lt;/p&gt;
&lt;p&gt;host表示登录用户的主机名称；&lt;/p&gt;
&lt;p&gt;pwd为登录密码；&lt;/p&gt;
&lt;p&gt;dbname为需要备份的数据库名称；&lt;/p&gt;
&lt;p&gt;tbname为dbname数据库中需要备份的数据表，可以指定多个需要备份的表；&lt;/p&gt;
&lt;p&gt;右箭头“&amp;gt;”告诉mysqldump将备份数据库表定义和数据写入备份文件；&lt;/p&gt;
&lt;p&gt;filename为备份文件的名称&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1、使用mysqldump备份单个数据库中的所有表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库的记录是这样的&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/098b3cb7f5722bdd31ea0cdd1be4f493.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;打开cmd，然后执行下面的命令&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d46250f91627f33d82a23880c1cc85e4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到C盘下面已经生成了school_2014-7-10.sql文件&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/95fd598fc997959b0f0556e154725c8c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用editplus来打开这个sql文件&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;-- MySQL dump 10.13  Distrib 5.5.20, for Win32 (x86)
--
-- Host: 127.0.0.1    Database: school
-- ------------------------------------------------------
-- Server version    5.5.20-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE=&#39;+00:00&#39; */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#39;NO_AUTO_VALUE_ON_ZERO&#39; */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `book`
--

DROP TABLE IF EXISTS `book`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `book` (
  `bookid` int(11) NOT NULL,
  `bookname` varchar(255) NOT NULL,
  `authors` varchar(255) NOT NULL,
  `info` varchar(255) DEFAULT NULL,
  `comment` varchar(255) DEFAULT NULL,
  `year_publication` year(4) NOT NULL,
  KEY `BkNameIdx` (`bookname`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `book`
--

LOCK TABLES `book` WRITE;
/*!40000 ALTER TABLE `book` DISABLE KEYS */;
INSERT INTO `book` VALUES (1,&#39;鍓戝湥&#39;,&#39;灏忔槑&#39;,&#39;13&#39;,&#39;hao&#39;,2013);
/*!40000 ALTER TABLE `book` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `student`
--

DROP TABLE IF EXISTS `student`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `student` (
  `stuno` int(11) DEFAULT NULL,
  `stuname` varchar(60) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `student`
--

LOCK TABLES `student` WRITE;
/*!40000 ALTER TABLE `student` DISABLE KEYS */;
INSERT INTO `student` VALUES (2,&#39;xiaofang&#39;),(3,&#39;zhanghai&#39;),(6,&#39;haojie&#39;);
/*!40000 ALTER TABLE `student` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `stuinfo`
--

DROP TABLE IF EXISTS `stuinfo`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `stuinfo` (
  `stuno` int(11) DEFAULT NULL,
  `class` varchar(60) DEFAULT NULL,
  `city` varchar(60) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `stuinfo`
--

LOCK TABLES `stuinfo` WRITE;
/*!40000 ALTER TABLE `stuinfo` DISABLE KEYS */;
INSERT INTO `stuinfo` VALUES (1,&#39;wuban&#39;,&#39;henan&#39;),(2,&#39;liuban&#39;,&#39;hebei&#39;),(3,&#39;qiban&#39;,&#39;shandong&#39;);
/*!40000 ALTER TABLE `stuinfo` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2014-07-23 22:04:16&lt;/pre&gt;
&lt;p&gt;可以看到，备份文件包含了一些信息，文件开头首先写明了mysqldump工具的版本号；&lt;/p&gt;
&lt;p&gt;然后是主机信息，以及备份的数据库名称，最后是mysql服务器的版本号5.5.20&lt;/p&gt;
&lt;p&gt;备份文件接下来的部分是一些SET语句，这些语句将一些系统变量赋值给用户定义变量，以确保被恢复的数据库的系统变量和原来&lt;/p&gt;
&lt;p&gt;备份时的变量相同&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;&lt;/pre&gt;
&lt;p&gt;该set语句将当前系统变量character_set_client的值赋值给用户变量@OLD_CHARACTER_SET_CLIENT&lt;/p&gt;
&lt;p&gt;备份文件的最后几行mysql使用set语句恢复服务器系统变量原来的值，例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;&lt;/pre&gt;
&lt;p&gt;该语句将用户定义变量@OLD_CHARACTER_SET_CLIENT 中保存的值赋值给实际的系统变量OLD_CHARACTER_SET_CLIENT&lt;/p&gt;
&lt;p&gt;备份文件中的“–”字符开头的行为注释语句；以“/*!”开头、以“*/”结尾的语句为可执行的mysql注释，这些语句可以被mysql执行&lt;/p&gt;
&lt;p&gt;但在其他数据库管理系统将被作为注释忽略，这可以提高数据库的可移植性&lt;/p&gt;
&lt;p&gt;另外注意到，备份文件开始的一些语句以数字开头，这些数字代表了mysql版本号，该数字告诉我们这些语句只有在指定的mysql版本&lt;/p&gt;
&lt;p&gt;或者比该版本高的情况下才能执行。&lt;/p&gt;
&lt;p&gt;例如：40101，表明这些语句只有在mysql版本为4.01.01或者更高版本的条件下才可以执行&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;2、使用mysqldump备份数据库中的某个表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;备份school数据库里面的book表&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/94cdf968ee1566f604aec0e7959094a0.jpg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;-- MySQL dump 10.13  Distrib 5.5.20, for Win32 (x86)
--
-- Host: 127.0.0.1    Database: school
-- ------------------------------------------------------
-- Server version    5.5.20-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE=&#39;+00:00&#39; */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#39;NO_AUTO_VALUE_ON_ZERO&#39; */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `book`
--

DROP TABLE IF EXISTS `book`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `book` (
  `bookid` int(11) NOT NULL,
  `bookname` varchar(255) NOT NULL,
  `authors` varchar(255) NOT NULL,
  `info` varchar(255) DEFAULT NULL,
  `comment` varchar(255) DEFAULT NULL,
  `year_publication` year(4) NOT NULL,
  KEY `BkNameIdx` (`bookname`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `book`
--

LOCK TABLES `book` WRITE;
/*!40000 ALTER TABLE `book` DISABLE KEYS */;
INSERT INTO `book` VALUES (1,&#39;剑圣&#39;,&#39;小明&#39;,&#39;13&#39;,&#39;hao&#39;,2013);
/*!40000 ALTER TABLE `book` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2014-07-23 22:24:29&lt;/pre&gt;
&lt;p&gt;备份文件中的内容跟前面的介绍是一样的，唯一不同的是只包含了book表的CREATE语句和INSERT语句&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;3、使用mysqldump备份多个数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果要使用mysqldump备份多个数据库，需要使用–databases参数。&lt;/p&gt;
&lt;p&gt;使用–databases参数之后，必须指定至少一个数据库的名称，多个数据库名称之间用空格隔开&lt;/p&gt;
&lt;p&gt;使用mysqldump备份school库和test库&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/71e0df558b03f1eb1af17d3aaad0ca0b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;备份文件里的内容，基本上跟第一个例子一样，但是指明了里面的内容那一部分属于test库，哪一部分属于school库&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;-- MySQL dump 10.13  Distrib 5.5.20, for Win32 (x86)
--
-- Host: 127.0.0.1    Database: school
-- ------------------------------------------------------
-- Server version    5.5.20-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE=&#39;+00:00&#39; */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#39;NO_AUTO_VALUE_ON_ZERO&#39; */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `school`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `school` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `school`;

--
-- Table structure for table `book`
--

DROP TABLE IF EXISTS `book`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `book` (
  `bookid` int(11) NOT NULL,
  `bookname` varchar(255) NOT NULL,
  `authors` varchar(255) NOT NULL,
  `info` varchar(255) DEFAULT NULL,
  `comment` varchar(255) DEFAULT NULL,
  `year_publication` year(4) NOT NULL,
  KEY `BkNameIdx` (`bookname`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `book`
--

LOCK TABLES `book` WRITE;
/*!40000 ALTER TABLE `book` DISABLE KEYS */;
INSERT INTO `book` VALUES (1,&#39;剑圣&#39;,&#39;小明&#39;,&#39;13&#39;,&#39;hao&#39;,2013);
/*!40000 ALTER TABLE `book` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `student`
--

DROP TABLE IF EXISTS `student`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `student` (
  `stuno` int(11) DEFAULT NULL,
  `stuname` varchar(60) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `student`
--

LOCK TABLES `student` WRITE;
/*!40000 ALTER TABLE `student` DISABLE KEYS */;
INSERT INTO `student` VALUES (2,&#39;xiaofang&#39;),(3,&#39;zhanghai&#39;),(6,&#39;haojie&#39;);
/*!40000 ALTER TABLE `student` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `stuinfo`
--

DROP TABLE IF EXISTS `stuinfo`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `stuinfo` (
  `stuno` int(11) DEFAULT NULL,
  `class` varchar(60) DEFAULT NULL,
  `city` varchar(60) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `stuinfo`
--

LOCK TABLES `stuinfo` WRITE;
/*!40000 ALTER TABLE `stuinfo` DISABLE KEYS */;
INSERT INTO `stuinfo` VALUES (1,&#39;wuban&#39;,&#39;henan&#39;),(2,&#39;liuban&#39;,&#39;hebei&#39;),(3,&#39;qiban&#39;,&#39;shandong&#39;);
/*!40000 ALTER TABLE `stuinfo` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Current Database: `test`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `test` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `test`;

--
-- Table structure for table `book`
--

DROP TABLE IF EXISTS `book`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `book` (
  `bookid` int(11) NOT NULL,
  `bookname` varchar(255) NOT NULL,
  `authors` varchar(255) NOT NULL,
  `info` varchar(255) DEFAULT NULL,
  `comment` varchar(255) DEFAULT NULL,
  `year_publication` year(4) NOT NULL,
  KEY `year_publication` (`year_publication`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `book`
--

LOCK TABLES `book` WRITE;
/*!40000 ALTER TABLE `book` DISABLE KEYS */;
INSERT INTO `book` VALUES (12,&#39;dajiahao&#39;,&#39;NIHAO&#39;,&#39;??&#39;,&#39;henhao&#39;,1990);
/*!40000 ALTER TABLE `book` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `innodb_monitor`
--

DROP TABLE IF EXISTS `innodb_monitor`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `innodb_monitor` (
  `a` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `innodb_monitor`
--

LOCK TABLES `innodb_monitor` WRITE;
/*!40000 ALTER TABLE `innodb_monitor` DISABLE KEYS */;
/*!40000 ALTER TABLE `innodb_monitor` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `test_innodb_lock`
--

DROP TABLE IF EXISTS `test_innodb_lock`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `test_innodb_lock` (
  `A` int(11) DEFAULT NULL,
  `B` varchar(16) DEFAULT NULL,
  KEY `TEST_INNODB_A_IND` (`A`),
  KEY `TEST_INNODB_B_IND` (`B`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `test_innodb_lock`
--

LOCK TABLES `test_innodb_lock` WRITE;
/*!40000 ALTER TABLE `test_innodb_lock` DISABLE KEYS */;
/*!40000 ALTER TABLE `test_innodb_lock` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2014-07-23 22:32:59&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;4、使用–all-databases参数备份系统中所有的数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用–all-databases不需要指定数据库名称&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/260b7b70821bbff9cc773f01e5394f3d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;执行完毕之后会产生all_2014-7-10.sql的备份文件，里面会包含了所有数据库的备份信息&lt;/p&gt;
&lt;p&gt;提示：如果在服务器上进行备份，并且表均为myisam，应考虑使用mysqlhotcopy&lt;/p&gt;
&lt;p&gt;因为可以更快地进行备份和恢复&lt;/p&gt;
&lt;p&gt;使用mysqlhotcopy，如果是Windows操作系统，需要先安装perl脚本组件才能使用，因为mysqlhotcopy是使用perl来编写的&lt;/p&gt;
&lt;p&gt;提示&lt;br&gt;
(1)如果你未使用–quick或者–opt选项，那么&lt;a href=&quot;http://baike.baidu.com/view/4275909.htm&quot; target=&quot;_blank&quot;&gt;mysqldump&lt;/a&gt;将在转储结果之前把全部内容载入到&lt;a href=&quot;http://baike.baidu.com/view/1082.htm&quot; target=&quot;_blank&quot;&gt;内存&lt;/a&gt;中。这在你转储大数据量的数据库时将会有些问题。该选项默认是打开的，但可以使用–skip-opt来关闭它。&lt;br&gt;
(2)使用–skip-comments可以去掉导出文件中的注释语句&lt;br&gt;
(3)使用–compact选项可以只输出最重要的语句，而不输出注释及删除表语句等等&lt;br&gt;
(4)使用–database或-B选项，可以转储多个数据库，在这个选项名后的参数都被认定为数据库名&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;SQLSERVER逻辑备份&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我发现SQLSERVER的备份概念并没有ORACLE和MYSQL那么多&lt;/p&gt;
&lt;p&gt;我们通常都会使用下面的两个SQL语句来备份SQLSERVER数据库，例如备份test库&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;BACKUP DATABASE test TO DISK=&#39;c:\test.bak&#39; 
BACKUP LOG test  TO DISK=&#39;c:\test_log.bak&#39;&lt;/pre&gt;
&lt;p&gt;第一个SQL是完整备份test库，如果加上WITH DIFFERENTIAL就是差异备份&lt;/p&gt;
&lt;p&gt;第二个SQL是备份test库的日志&lt;/p&gt;
&lt;p&gt;实际上从我眼中的理解，SQLSERVER就是将数据文件和必要的日志信息放入一个压缩包里面，类似于MYSQL的&lt;strong&gt;物理备份&lt;/strong&gt;，直接复制文件，只是MYSQL并没有进行打包压缩&lt;/p&gt;
&lt;p&gt;SQLSERVER的逻辑备份&lt;/p&gt;
&lt;p&gt;逻辑备份就是生成表定义脚本和数据插入脚本，SQLSERVER2008开始支持生成数据脚本，在SQLSERVER2008之前只支持生成表定义脚本&lt;/p&gt;
&lt;p&gt;我所用的数据库是&lt;strong&gt;SQLSERVER2012 SP1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选中需要生成脚本的数据库&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ecbb037c97838d5784dc38ad1ae8d48b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;比如我要导出test表的数据和表定义&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c218ffc2f3033ca53f6f74044a095643.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;要选择架构和数据，并且要选择索引，这样就会生成表的数据、定义、索引&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4e5d6507899219f34da2dff8d3c0a7d3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bf6e499b512c23f81c247a07b6e4d333.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a3f1e4d00fcac0320966ea204c224a06.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;生成的脚本如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE [sss]
GO
/****** Object:  Table [dbo].[test]    Script Date: 2014/7/24 11:27:44 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[test](
    [a] [int] NULL
) ON [PRIMARY]

GO
INSERT [dbo].[test] ([a]) VALUES (10)
GO&lt;/pre&gt;
&lt;p&gt;由于test表是没有任何索引的，所以脚本里看不到CREATE INDEX语句&lt;/p&gt;
&lt;p&gt;实际上各种数据库的备份恢复方法都是大同小异的&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/oracle-dba/p/3754202.html&quot; href=&quot;http://www.cnblogs.com/oracle-dba/p/3754202.html&quot; target=&quot;_blank&quot;&gt;ORACLE冷备份与恢复&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;逻辑备份和物理备份&lt;/p&gt;
&lt;p&gt;1、导出create table 、create index、insert into 表等语句（逻辑备份）&lt;/p&gt;
&lt;p&gt;mysql：mysqldump、load data infile、select into outfile&lt;/p&gt;
&lt;p&gt;sqlserver：生成脚本、导入导出向导&lt;/p&gt;
&lt;p&gt;oracle：（exp/imp）&lt;/p&gt;
&lt;p&gt;2、直接复制文件（物理备份）&lt;/p&gt;
&lt;p&gt;sqlserver：backup database语句、backup log语句、停SQLSERVER服务直接拷贝数据文件&lt;/p&gt;
&lt;p&gt;mysql：mysqlhotcopy、innobackupex&lt;/p&gt;
&lt;p&gt;oracle：rman、直接将关键性文件拷贝到另外的位置、（exp/imp）、（expdp/impdp）&lt;/p&gt;
&lt;p&gt;相似点：上面的各种数据库的各种备份还原方法，每一种&lt;strong&gt;基本&lt;/strong&gt;上都会有一个单独的工具来做&lt;/p&gt;
&lt;p&gt;例如sqlserver导入导出向导就是一个单独的exe来做&lt;/p&gt;
&lt;p&gt;oracle的rman也是一个单独的工具&lt;/p&gt;
&lt;p&gt;冷备份和热备份：无论oracle、sqlserver、mysql都有冷备份和热备份的概念&lt;/p&gt;
&lt;p&gt;冷备份其实可以简单理解为：停止服务进行备份&lt;/p&gt;
&lt;p&gt;热备份其实可以简单理解为：不停止服务进行备份（在线）&lt;/p&gt;
&lt;p&gt;上面的停止服务，正确的来讲应该是停止&lt;strong&gt;数据库的写入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么mysql的myisam引擎只支持冷备份呢？&lt;/p&gt;
&lt;p&gt;大家可以先想一下innodb引擎，innodb引擎是事务性存储引擎，每一条语句都会写日志，并且每一条语句在日志里面都有时间点&lt;/p&gt;
&lt;p&gt;那么在备份的时候，mysql可以根据这个日志来进行redo和undo，将备份的时候没有提交的事务进行回滚，已经提交了的进行重做&lt;/p&gt;
&lt;p&gt;但是myisam不行，myisam是没有日志的，为了保证一致性，只能停机或者锁表进行备份&lt;/p&gt;
&lt;p&gt;在书《&lt;strong&gt;MYSQL性能调优和架构设计&lt;/strong&gt;》里面说到了事务的作用&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/91bbb2b1a7e2eac0c40ff9c54bb5327a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;大家可以想一想，为什么sqlserver支持从某一个lsn或者时刻进行恢复数据库，他也是从日志里面读取日志的lsn号来进行恢复到某一个lsn时刻的数据或者某一个时刻的数据&lt;/p&gt;
&lt;p&gt;假如没有事务日志，那么sqlserver是做不到时点还原的&lt;/p&gt;
&lt;p&gt;热备份、冷备份&lt;/p&gt;
&lt;p&gt;为什么SQLSERVER需要停止SQLSERVER服务才可以拷贝物理数据文件，为的都是保证数据一致性&lt;/p&gt;
&lt;p&gt;我之前写的一篇文章《&lt;a title=&quot;http://www.cnblogs.com/lyhabc/p/3788709.html&quot; href=&quot;http://www.cnblogs.com/lyhabc/p/3788709.html&quot; target=&quot;_blank&quot;&gt;达梦7的试用 与SQLSERVER的简单技术对比&lt;/a&gt;》，达梦数据库支持脱机还原，实际上脱机备份的时候数据库也是需要停止写入数据的&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6544780e6917a9274d133eb824e3bd90.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;物理备份方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、直接复制整个数据库目录&lt;/p&gt;
&lt;p&gt;因为MYSQL表保存为文件方式，所以可以直接复制MYSQL数据库的存储目录以及文件进行备份。&lt;/p&gt;
&lt;p&gt;MYSQL的数据库目录位置不一定相同，在Windows平台下，MYSQL5.6存放数据库的目录通常默认为&lt;/p&gt;
&lt;p&gt;C:\Documents and Settings\All User\Application Data\MySQL\MYSQL Server 5.6\data&lt;/p&gt;
&lt;p&gt;或者其他用户自定义的目录；&lt;/p&gt;
&lt;p&gt;在Linux平台下，数据库目录位置通常为/var/lib/mysql/，不同Linux版本下目录会有不同&lt;/p&gt;
&lt;p&gt;这是一种简单、快速、有效的备份方式。要想保持备份一致，备份前需要对相关表执行LOCK TABLES操作，然后对表执行&lt;/p&gt;
&lt;p&gt;FLUSH TABLES。这样当复制数据库目录中的文件时，允许其他客户继续查询表。需要FLUSH TABLES语句来确保开始&lt;/p&gt;
&lt;p&gt;备份前将所有激活的索引页写入磁盘。&lt;/p&gt;
&lt;p&gt;当然，也可以停止MYSQL服务再进行备份操作&lt;/p&gt;
&lt;p&gt;这种方法虽然简单，但并不是最好的方法。因为这种方法对&lt;strong&gt;INNODB存储引擎&lt;/strong&gt;的表不适用。使用这种方法备份的数据最好还原&lt;/p&gt;
&lt;p&gt;到相同版本的服务器中，不同的版本可能不兼容。&lt;/p&gt;
&lt;p&gt;注意：在mysql版本中，第一个数字表示主版本号，主版本号相同的MYSQL数据库文件格式相同&lt;/p&gt;
&lt;p&gt;2、使用mysqlhotcopy工具快速备份&lt;/p&gt;
&lt;p&gt;mysqlhotcopy是一个perl脚本，最初由Tim Bunce编写并提供。他使用LOCK TABLES 、FLUSH TABLES和cp或scp&lt;/p&gt;
&lt;p&gt;来快速备份数据库。他是备份数据库或单个表的最快途径，但他只能运行在数据库目录所在机器上，并且只能备份myisam类型的表。&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqlhotcopy db_name_1,...db_name_n /path/to/new_directory&lt;/pre&gt;
&lt;p&gt;db_name_1…n代表要备份的数据库的名称；&lt;/p&gt;
&lt;p&gt;path/to/new_directory指定备份文件目录&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;p&gt;在Linux下面使用mysqlhotcopy备份test库到/usr/backup&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqlhotcopy -u root -p test /usr/backup&lt;/pre&gt;
&lt;p&gt;要想执行mysqlhotcopy，必须可以访问备份的表文件，具有那些表的SELECT权限、RELOAD权限（以便能够执行FLUSH TABLES）&lt;/p&gt;
&lt;p&gt;和LOCK TABLES权限&lt;/p&gt;
&lt;p&gt;提示：mysqlhotcopy只是将表所在目录复制到另一个位置，只能用于备份myisam和archive表。备份innodb表会出现错误信息&lt;/p&gt;
&lt;p&gt;由于他复制本地格式的文件，故也不能移植到其他硬件或操作系统下&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;还原&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;逻辑还原&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、使用mysql命令进行还原&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于已经备份的包含CREATE、INSERT语句的文本文件，可以使用myslq命令导入数据库中&lt;/p&gt;
&lt;p&gt;备份的sql文件中包含CREATE、INSERT语句（有时也会有DROP语句）。mysql命令可以直接执行文件中的这些语句&lt;/p&gt;
&lt;p&gt;其语法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql -u user -p [dbname]&amp;lt;filename.sql&lt;/pre&gt;
&lt;p&gt;user是执行backup.sql中语句的用户名；-p表示输入用户密码；dbname是数据库名&lt;/p&gt;
&lt;p&gt;如果filename.sql文件为mysqldump工具创建的包含创建数据库语句的文件，执行的时候不需要指定数据库名&lt;/p&gt;
&lt;p&gt;用mysql命令将school_2014-7-10.sql文件中的备份导入到数据库中&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql -u root -h 127.0.0.1 -p school&amp;lt;c:\school_2014-7-10.sql&lt;/pre&gt;
&lt;p&gt;执行语句之前我们必须建好school数据库，如果不存在恢复过程将会出错。&lt;/p&gt;
&lt;p&gt;可以看到表数据都已经导入到数据库了&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b2021eb966dac00e0c0ecac2dcd4dc6c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果已经登录mysql，那么可以使用source命令导入备份文件&lt;/p&gt;
&lt;p&gt;使用source命令导入备份文件school_2014-7-10.sql&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/188fba3c8d24ab4df4bbada08648e719.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;执行source命令前必须使用use 语句选择好数据库，不然会出现ERROR 1046(3D000):NO DATABASE SELECTED 的错误&lt;/p&gt;
&lt;p&gt;还有一点要注意的是只能在cmd界面下执行，不能在mysql工具里面执行source命令，否则会报错&lt;/p&gt;
&lt;p&gt;因为cmd是直接调用mysql.exe来执行命令的&lt;/p&gt;
&lt;p&gt;而这些mysql 编辑工具只是利用mysql connector连接mysql，来管理mysql并不是直接调用mysql.exe，所以执行source会报错&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/74c0ca966909e41bc9d026f59d183602.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;物理还原&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、直接复制到数据库目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果数据库通过复制数据库文件备份，可以直接复制备份文件到MYSQL数据目录下实现还原。通过这种方式还原时，&lt;/p&gt;
&lt;p&gt;必须保证备份数据的数据库和待还原的数据库服务器的主版本号相同。&lt;/p&gt;
&lt;p&gt;而且这种方式只对MYISAM引擎有效，对于innodb引擎的表不可用&lt;/p&gt;
&lt;p&gt;执行还原以前关闭mysql服务，将备份的文件或目录覆盖mysql的data目录，启动mysql服务。&lt;/p&gt;
&lt;p&gt;对于Linux操作系统来说，复制完文件需要将文件的用户和组更改为mysql运行的用户和组，通常用户是mysql，组也是mysql&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;3、mysqlhotcopy快速恢复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysqlhotcopy备份后的文件也可以用来恢复数据库，在mysql服务器停止运行时，将备份的数据库文件复制到mysql存放数据的位置&lt;/p&gt;
&lt;p&gt;（mysql的data文件夹），重新启动mysql服务即可。&lt;/p&gt;
&lt;p&gt;如果根用户执行该操作，必须指定数据库文件的所有者，输入语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;chown -R mysql.mysql /var/lib/mysql/dbname&lt;/pre&gt;
&lt;p&gt;从mysqlhotcopy复制的备份恢复数据库&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;cp -R /usr/backup/test  usr/local/mysql/data&lt;/pre&gt;
&lt;p&gt;执行完该语句，重启服务器，mysql将恢复到备份状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：如果需要恢复的数据库已经存在，则在使用DROP语句删除已经存在的数据库之后，恢复才能成功。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外mysql不同版本之间必须兼容，恢复之后的数据才可以使用！！&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;数据库迁移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库迁移就是把数据从一个系统移动到另一个系统上。&lt;/p&gt;
&lt;p&gt;迁移的一般原因：&lt;/p&gt;
&lt;p&gt;1、需要安装新的数据库服务器&lt;/p&gt;
&lt;p&gt;2、mysql版本更新&lt;/p&gt;
&lt;p&gt;3、数据库管理系统变更（从SQLSERVER迁移到mysql）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相同版本的MYSQL数据库之间迁移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相同版本mysql数据库间的迁移就是主版本号相同的mysql数据库直接进行数据库移动。&lt;/p&gt;
&lt;p&gt;前面讲解备份和还原的时候，知道最简单的方法就是复制数据库文件目录，但是这种方法只适合于myisam表&lt;/p&gt;
&lt;p&gt;对于innodb表，不能直接复制文件来备份数据库&lt;/p&gt;
&lt;p&gt;最常用的方法是使用mysqldump导出数据，然后在目标数据库服务器使用mysql命令导入&lt;/p&gt;
&lt;p&gt;将www.abc.com主机上的mysql数据库全部迁移到www.bcd.com主机上。&lt;/p&gt;
&lt;p&gt;在www.abc.com主机上执行以下命令：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqldump -h www.abc.com -u root -p dbname |
mysql -h www.bcd.com -u root -p&lt;/pre&gt;
&lt;p&gt;mysqldump导入的数据直接通过管道符|，传给mysql命令导入到主机www.bcd.com数据库中，dbname为需要迁移的数据库名称&lt;/p&gt;
&lt;p&gt;如果要迁移全部数据库，可以使用–all -databases参数&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;不同版本的mysql数据库之间的迁移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为数据库升级，需要将旧版本mysql数据库中的数据迁移到新版本数据库中。&lt;/p&gt;
&lt;p&gt;mysql服务器升级，需要先停止服务，然后卸载旧版本，并安装新版本的mysql，这种更新方法很简单。&lt;/p&gt;
&lt;p&gt;如果想保留旧版本中的用户访问控制信息，则需要备份mysql的mysql库，&lt;/p&gt;
&lt;p&gt;在新版本mysql安装完成后，重新读入mysql备份文件中的信息&lt;/p&gt;
&lt;p&gt;旧版本和新版本的mysql可能使用不同的默认字符集，例如mysql.4.x中大多数使用latin1作为默认字符集，&lt;/p&gt;
&lt;p&gt;而mysql5.x的默认字符集为utf8。如果数据库中有中文数据，迁移过程中需要对默认字符集进行修改，不然可能无法正常显示结果&lt;/p&gt;
&lt;p&gt;新版本对旧版本有一定兼容性。从旧版本的mysql向新版本mysql迁移时，对于myisam引擎的表，可以直接复制数据库文件，&lt;/p&gt;
&lt;p&gt;也可以用mysqlhotcopy工具、mysqldump工具。&lt;/p&gt;
&lt;p&gt;对于innodb引擎的表一般只能使用mysqldump将数据导出。然后使用mysql命令导入目标服务器。&lt;/p&gt;
&lt;p&gt;从新版本向旧版本mysql迁移数据时要小心，最好使用mysqldump命令导出，然后导入目标数据库中。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;不同数据库之间的迁移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同类型的数据库之间的迁移，是指把mysql数据库迁移到其他的数据库，例如从mysql迁移到oracle，从oracle迁移到mysql&lt;/p&gt;
&lt;p&gt;从mysql迁移到SQLSERVER等。&lt;/p&gt;
&lt;p&gt;迁移之前，需要了解不同数据库的结构，比较他们的差异。不同数据库定义相同类型的数据的关键字可能不同。&lt;/p&gt;
&lt;p&gt;例如：mysql中日期字段分为DATE 和TIME两种，而ORACLE的日期字段只有DATE。&lt;/p&gt;
&lt;p&gt;数据库迁移可以使用一些工具，例如，在Windows系统下，可以使用MyODBC实现mysql和SQLSERVER之间的迁移（使用SQLSERVER导入导出向导）&lt;/p&gt;
&lt;p&gt;mysql官方提供的工具：MYSQL Migration Toolkit也可以在不同数据库间进行数据迁移。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;表的导入导出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MYSQL数据库可以将数据导出成sql文本文件、xml文件、html文件。同样这些导出文件也可以导入到MYSQL数据库中&lt;/p&gt;
&lt;p&gt;一般异构数据库迁移都是采用文本文件的方式来导数据&lt;/p&gt;
&lt;p&gt;导出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、用SELECT…INTO OUTFILE导出文本文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql导出数据时，允许使用包含表定义的select语句进行数据的导出操作&lt;/p&gt;
&lt;p&gt;该文件被创建在服务器主机上，因此必须有文件写入权限(FILE权限)，才能使用此语法&lt;/p&gt;
&lt;p&gt;SELECT INTO…OUTFILE语法：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;select columnlist  from Table WHERE condition  into outfile &#39;filename&#39; [OPTIONS]
fields terminated by &#39;VALUE&#39;
fields [OPTIONALLY]  ENCLOSED BY &#39;VALUE&#39;
fields ESCAPED BY &#39;VALUE&#39;
lines STARTING by &#39;VALUE&#39;
lines terminated by &#39;VALUE&#39;&lt;/pre&gt;
&lt;p&gt;into outfile语句的作用就是把前面select语句查询出来的结果导出到名称为“filename”的外部文件中&lt;/p&gt;
&lt;p&gt;[OPTIONS]部分为可选参数，[OPTIONS]部分的语法包括FILED和LINES子句，其可能取值为：&lt;/p&gt;
&lt;p&gt;● fields子句：在FIELDS子句中有三个子句：TERMINATED BY、 [OPTIONALLY] ENCLOSED BY和ESCAPED BY。&lt;/p&gt;
&lt;p&gt;如果指定了FIELDS子句，则这三个子句中至少要指定一个。&lt;br&gt;
（1）TERMINATED BY用来指定字段值之间的符号，例如，“TERMINATED BY ‘,’”指定了逗号作为两个字段值之间的标志，默认为“\t”制表符。&lt;br&gt;
（2）ENCLOSED BY子句用来指定包裹文件中字符值的符号，例如，“ENCLOSED BY ‘ ” ‘”表示文件中字符值放在双引号之间，&lt;/p&gt;
&lt;p&gt;若加上关键字OPTIONALLY表示所有的值都放在双引号之间，则只有CHAR和VARCHAR等字符数据字段被包括。&lt;/p&gt;
&lt;p&gt;（3）ESCAPED BY子句用来指定转义字符，例如，“ESCAPED BY ‘*’”将“*”指定为转义字符，取代“\”，如空格将表示为“*N”。&lt;br&gt;
● LINES子句：在LINES子句中使用TERMINATED BY指定一行结束的标志，如“LINES TERMINATED BY ‘?’”表示一行以“?”作为结束标志，默认值为“\n”。&lt;/p&gt;
&lt;p&gt;TERMINATED BY也是同样的原理&lt;/p&gt;
&lt;p&gt;FIELDS子句和LINES子句都是自选的，但是如果两个都被指定了，FIELDS子句必须位于LINES子句的前面&lt;/p&gt;
&lt;p&gt;SELECT INTO…OUTFILE只能在本机执行，如果要在其他服务器上导出数据，则需要使用下面命令来生成文件&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql -e &quot;select ...&quot;&amp;gt;filename&lt;/pre&gt;
&lt;p&gt;-e, –execute=name  Execute command and quit. (Disables –force and history&lt;/p&gt;
&lt;p&gt;SELECT INTO…OUTFILE是LOAD DATA INFILE的补语。用于语句的OPTIONS部分的语法包括部分FIELDS子句和LINES子句&lt;/p&gt;
&lt;p&gt;这些子句与LOAD DATA INFILE语句同时使用&lt;/p&gt;
&lt;p&gt;使用SELECT INTO…OUTFILE将test数据库中的person表的记录导出到文本文件&lt;/p&gt;
&lt;p&gt;建表脚本&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE test;

create table person
(
ID INT  PRIMARY KEY AUTO_INCREMENT,
Name varchar(20) not null,
Age INT UNSIGNED,
job varchar(90) not null
)engine=innodb default charset=utf8  ; 

INSERT INTO person(name,age,job) VALUES (&#39;green&#39;,29,&#39;lawer&#39;),(&#39;suse&#39;,26,&#39;dancer&#39;),(&#39;evans&#39;,27,&#39;sports man&#39;),(&#39;mary&#39;,26,&#39;singer&#39;);

SELECT * FROM `person` ;&lt;/pre&gt;
&lt;p&gt;输入命令如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM test.person  INTO  OUTFILE  &quot;C:\person0.txt&quot; ;&lt;/pre&gt;
&lt;p&gt;由于指定了INTO OUTFILE 子句，SELECT将查询出来的3个字段的值保存到C:\person0.txt文件，打开文件内容如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;1    green    29    lawer
2    suse    26    dancer
3    evans    27    sports man
4    mary    26    singer&lt;/pre&gt;
&lt;p&gt;可以看到默认情况下，MYSQL使用制表符“\t”分隔不同的字段，字段没有被其他字符括起来&lt;/p&gt;
&lt;p&gt;另外在Windows平台下，使用记事本打开该文件，显示的格式与这里并不相同，这是因为Windows系统下回车换行为“\r\n”&lt;/p&gt;
&lt;p&gt;默认换行符为“\n”,因此会在person.txt中可能看到类似黑色方块的字符，所有的记录也会在同一行显示&lt;/p&gt;
&lt;p&gt;默认情况下，NULL值会显示为“\N”,转义字符会显示为“\”&lt;/p&gt;
&lt;p&gt;使用SELECT ..INTO OUTFILE将test库中的person表中的记录导出到文本文件，使用FIELDS选项和LINES选项，要求字段之间&lt;/p&gt;
&lt;p&gt;使用逗号“，”间隔，所有字段值用双引号括起来，定义转移字符为单引号“\’”&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM test.person  INTO  OUTFILE  &quot;C:\person1.txt&quot; 
FIELDS
TERMINATED BY &#39;,&#39;
ENCLOSED BY &#39;\&#39;&#39;
ESCAPED BY &#39;\&#39;&#39;
LINES
TERMINATED BY &#39;\r\n&#39;;&lt;/pre&gt;
&lt;p&gt;在C盘下生成的person1文件内容&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;&#39;1&#39;,&#39;green&#39;,&#39;29&#39;,&#39;lawer&#39;
&#39;2&#39;,&#39;suse&#39;,&#39;26&#39;,&#39;dancer&#39;
&#39;3&#39;,&#39;evans&#39;,&#39;27&#39;,&#39;sports man&#39;
&#39;4&#39;,&#39;mary&#39;,&#39;26&#39;,&#39;singer&#39;&lt;/pre&gt;
&lt;p&gt;FIELDS  TERMINATED BY ‘,’表示字段之间用逗号分隔&lt;/p&gt;
&lt;p&gt;ENCLOSED BY ‘\”表示每个字段用双引号括起来&lt;/p&gt;
&lt;p&gt;ESCAPED BY ‘\”表示将系统默认的转移字符替换为单引号&lt;/p&gt;
&lt;p&gt;LINES TERMINATED BY ‘\r\n’表示每行以回车换行符结尾，保证每一条记录占一行&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;2、用mysqldump命令导出文本文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了使用SELECT…INTO OUTFILE导出文本文件之外，也可以使用mysqldump&lt;/p&gt;
&lt;p&gt;mysqldump不仅可以将数据导出包含CREATE、INSERT的sql文件，也可以导出为纯文本文件&lt;/p&gt;
&lt;p&gt;mysqldump创建一个包含创建表的CREATE TABLE语句的tablename.sql文件，和一个包含其数据&lt;/p&gt;
&lt;p&gt;的tablename.txt文件。mysqldump导出文本文件的基本语法如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqldump -T path -u root -p dbname [tables][OPTIONS]

--fields-terminated-by=
--fields-enclosed-by=
--fields-optionally-enclosed-by=
--fields-escaped-by=
--lines-terminated-by=&lt;/pre&gt;
&lt;p&gt;只有指定了-T参数才可以导出纯文本文件；path表示导出数据的目录&lt;/p&gt;
&lt;p&gt;tables为指定要导出的表名称，如果不指定，将导出dbname的所有表&lt;/p&gt;
&lt;p&gt;基本上每个选项跟SELECT ..INTO OUTFILE语句中的OPTIONS各个参数设置相同&lt;/p&gt;
&lt;p&gt;不同的是，等号后面的value值不要用引号括起来&lt;/p&gt;
&lt;p&gt;使用mysqldump将test库的person表的记录导出到文本文件，执行的命令如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqldump -T C:\ -u root -h 127.0.0.1  -p test person&lt;/pre&gt;
&lt;p&gt;这里要注意的是，路径这里不能先创建好person.txt文件，否则会报错，跟SELECT ..INTO OUTFILE语句是一样的&lt;/p&gt;
&lt;p&gt;在C盘会生成一个person.txt文件和person.sql文件，内容如下&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3192224a497a29340a5e6b13b479b4e3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;person.sql&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;-- MySQL dump 10.13  Distrib 5.5.28, for Win32 (x86)
--
-- Host: 127.0.0.1    Database: test
-- ------------------------------------------------------
-- Server version    5.5.28-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE=&#39;+00:00&#39; */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#39;&#39; */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `person`
--

DROP TABLE IF EXISTS `person`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `person` (
  `ID` int(11) NOT NULL AUTO_INCREMENT,
  `Name` varchar(20) NOT NULL,
  `Age` int(10) unsigned DEFAULT NULL,
  `job` varchar(90) NOT NULL,
  PRIMARY KEY (`ID`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2014-07-27 23:56:01&lt;/pre&gt;
&lt;p&gt;person.sql的内容跟之前解释的是一样的&lt;/p&gt;
&lt;p&gt;person.txt&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;1    green    29    lawer
2    suse    26    dancer
3    evans    27    sports man
4    mary    26    singer&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;3、使用mysql命令导出文本文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql是一个功能丰富的工具命令，使用mysql还可以在命令行模式下执行SQL指令，将查询结果导入到文本文件中。&lt;/p&gt;
&lt;p&gt;相比mysqldump，mysql工具导出的结果可读性更强&lt;/p&gt;
&lt;p&gt;如果mysql服务器是单独的机器，用户是在一个client上进行操作，用户要把数据结果导入到client机器上，可以使用mysql -e语句&lt;/p&gt;
&lt;p&gt;基本格式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql -u root -p --execute=&quot;SELECT 语句&quot; dbname &amp;gt;filename.txt&lt;/pre&gt;
&lt;p&gt;该命令使用–execute 选项，表示执行该选项后面的语句并退出，后面的语句必须用双引号括起来&lt;/p&gt;
&lt;p&gt;dbname为要导出的数据库名称，导出的文件中不同列之间使用制表符分隔，第一行包含了字段名称&lt;/p&gt;
&lt;p&gt;使用mysql命令，导出test库的person表记录到文本文件，输入语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql -u root -p --execute=&quot;SELECT * FROM person;&quot; test&amp;gt;C:\person3.txt&lt;/pre&gt;
&lt;p&gt;person3.txt的内容如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ID    Name    Age    job
1    green    29    lawer
2    suse    26    dancer
3    evans    27    sports man
4    mary    26    singer&lt;/pre&gt;
&lt;p&gt;可以看到，person3.txt文件中包含了每个字段的名称和各条记录，如果某行记录字段很多，可能一行不能完全显示，可以使用&lt;/p&gt;
&lt;p&gt;–vertical参数，将每条记录分为多行显示&lt;/p&gt;
&lt;p&gt;使用mysql命令导出test库的person表使用–vertical参数显示&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql -u root -p  --vertical --execute=&quot;SELECT * FROM person;&quot; test&amp;gt;C:\person4.txt&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;*************************** 1. row ***************************
  ID: 1
Name: green
 Age: 29
 job: lawer
*************************** 2. row ***************************
  ID: 2
Name: suse
 Age: 26
 job: dancer
*************************** 3. row ***************************
  ID: 3
Name: evans
 Age: 27
 job: sports man
*************************** 4. row ***************************
  ID: 4
Name: mary
 Age: 26
 job: singer&lt;/pre&gt;
&lt;p&gt;如果person表中记录内容太长，这样显示将会更加容易阅读&lt;/p&gt;
&lt;p&gt;使用mysql命令导出test库的person表记录到html文件，输入语句如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql -u root -p --html --execute=&quot;SELECT * FROM PERSON;&quot;test &amp;gt;C:\person5.html&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/45ac00df486d7880fc98db92dbfeed3f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果要导出为xml文件，那么使用–xml选项&lt;/p&gt;
&lt;p&gt;使用mysql命令导出test库的person表的中记录到xml文件&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql -u root -p --xml --execute=&quot;SELECT * FROM PERSON;&quot; test &amp;gt;C:\person6.xml&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;

&amp;lt;resultset statement=&quot;SELECT * FROM PERSON&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&amp;gt;
  &amp;lt;row&amp;gt;
    &amp;lt;field name=&quot;ID&quot;&amp;gt;1&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;Name&quot;&amp;gt;green&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;Age&quot;&amp;gt;29&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;job&quot;&amp;gt;lawer&amp;lt;/field&amp;gt;
  &amp;lt;/row&amp;gt;

  &amp;lt;row&amp;gt;
    &amp;lt;field name=&quot;ID&quot;&amp;gt;2&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;Name&quot;&amp;gt;suse&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;Age&quot;&amp;gt;26&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;job&quot;&amp;gt;dancer&amp;lt;/field&amp;gt;
  &amp;lt;/row&amp;gt;

  &amp;lt;row&amp;gt;
    &amp;lt;field name=&quot;ID&quot;&amp;gt;3&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;Name&quot;&amp;gt;evans&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;Age&quot;&amp;gt;27&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;job&quot;&amp;gt;sports man&amp;lt;/field&amp;gt;
  &amp;lt;/row&amp;gt;

  &amp;lt;row&amp;gt;
    &amp;lt;field name=&quot;ID&quot;&amp;gt;4&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;Name&quot;&amp;gt;mary&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;Age&quot;&amp;gt;26&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;job&quot;&amp;gt;singer&amp;lt;/field&amp;gt;
  &amp;lt;/row&amp;gt;
&amp;lt;/resultset&amp;gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;导入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、使用LOAD DATA INFILE 方式导入文本文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql允许将数据导出到外部文件，也可以从外部文件导入数据。&lt;/p&gt;
&lt;p&gt;MYSQL提供了一些导入数据的工具，这些工具有：LOAD DATA语句、source命令、mysql命令&lt;/p&gt;
&lt;p&gt;LOAD DATA INFILE语句用于高速地从一个文本文件中读取行，并装入一个表中。文件名称必须为文字字符串&lt;/p&gt;
&lt;p&gt;语法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE &#39;file_name.txt&#39; 
[REPLACE | IGNORE] 
INTO TABLE tbl_name 
[FIELDS 
[TERMINATED BY &#39;string&#39;] 
[[OPTIONALLY] ENCLOSED BY &#39;char&#39;] 
[ESCAPED BY &#39;char&#39; ] 
] 
[LINES 
[STARTING BY &#39;string&#39;] 
[TERMINATED BY &#39;string&#39;] 
] 
[IGNORE number LINES] 
[(col_name_or_user_var,...)] 
[SET col_name = expr,...]]&lt;/pre&gt;
&lt;p&gt;load data infile语句从一个文本文件中以很高的速度读入一个表中。&lt;br&gt;
使用这个命令之前，mysqld进程（服务） 必须已经在运行。&lt;br&gt;
当读取的文本文件不在本机，而是位于服务器上的文本文件时，使用load data infile语句，在服务器主机上你必须有file的权限。&lt;/p&gt;
&lt;p&gt;1 、如果你指定关键词low_priority，那么MySQL将会等到没有其他人读取这个表的时候，&lt;br&gt;
才插入数据。例如如下的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;load data low_priority infile &quot;/home/mark/data.sql&quot; into table Orders;&lt;/pre&gt;
&lt;p&gt;2 、如果指定local关键词，则表明读取的文件在本机，那么必须指定local参数。&lt;/p&gt;
&lt;p&gt;3 、replace和ignore参数控制对现有表的唯一键记录重复的处理。&lt;/p&gt;
&lt;p&gt;如果你指定replace，新行将代替有相同的唯一键值的现有行。&lt;/p&gt;
&lt;p&gt;（1）如果你指定ignore，跳过有唯一键的现有行的重复行的输入。&lt;/p&gt;
&lt;p&gt;（2）如果你不指定任何一个选项，当找到重复键时，出现一个错误，并且文本文件的余下部分被忽略。&lt;/p&gt;
&lt;p&gt;FIELDS  TERMINATED BY ‘,’表示字段之间用逗号分隔&lt;/p&gt;
&lt;p&gt;ENCLOSED BY ‘\”表示每个字段用双引号括起来&lt;/p&gt;
&lt;p&gt;ESCAPED BY ‘\”表示将系统默认的转移字符替换为单引号&lt;/p&gt;
&lt;p&gt;LINES STARTING BY ”表示每行数据开头的字符，可以为单个或多个，默认不是有任何字符&lt;/p&gt;
&lt;p&gt;LINES TERMINATED BY ‘\r\n’表示每行以回车换行符结尾，保证每一条记录占一行&lt;/p&gt;
&lt;p&gt;[IGNORE number LINES] 选项表示忽略文件开始处的行数，number表示忽略的行数。&lt;/p&gt;
&lt;p&gt;基本上格式上的参数跟SELECT…INTO OUTFILE是一样的&lt;/p&gt;
&lt;p&gt;使用LOAD DATA命令将C:\person0。txt文件中的数据导入到test库中的test表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;LOAD DATA INFILE &#39;C:\person0.txt&#39; INTO TABLE test.person&lt;/pre&gt;
&lt;p&gt;先删除person表里的数据，然后执行LOAD DATA命令&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3d9699539ed107410621efbd8e780fac.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用mysqlimport命令导入文本文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、使用mysqlimport命令导入文本文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysqlimport是一个单独的exe，他提供了许多与LOAD DATA INFILE语句相同的功能&lt;/p&gt;
&lt;p&gt;大多数选项直接对应LOAD DATA INFILE子句&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/91947340fca8e21069f59eecdec783eb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;mysqlimport的语法如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqlimport -u root -p dbname filename.txt  [OPTIONS]

--[OPTIONS] 选项
FIELDS  TERMINATED BY &#39;value&#39;
ENCLOSED BY &#39;value&#39;
ESCAPED BY &#39;value&#39;
LINES TERMINATED BY &#39;value&#39;
IGNORE LINES&lt;/pre&gt;
&lt;p&gt;[OPTIONS] 选项基本上与LOAD DATA INFILE 语句是一样的，这里不做介绍了&lt;/p&gt;
&lt;p&gt;mysqlimport不能指定导入的表名称，表名称由导入文件名称确定，即文件名作为表名，导入数据之前该表必须存在&lt;/p&gt;
&lt;p&gt;使用mysqlimport命令将C:\目录下person.txt文件内容导入到test库&lt;/p&gt;
&lt;p&gt;先删除test库的person表的数据&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DELETE FROM `person`;&lt;/pre&gt;
&lt;p&gt;person.txt文件内容&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;1    green    29    lawer
2    suse    26    dancer
3    evans    27    sports man
4    mary    26    singer&lt;/pre&gt;
&lt;p&gt;命令如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqlimport -u root -p  test C:\person.txt&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c667309fdbb45695a82c6ad33ce873f5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;导入成功&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e3c28369763c7b0d4c703cde48c295ad.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;mysqlimport的常见选项：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;显示帮助消息并退出。

·         --columns=column_list, -c column_list

该选项采用用逗号分隔的列名作为其值。列名的顺序指示如何匹配数据文件列和表列。

·         --compress，-C

压缩在客户端和服务器之间发送的所有信息（如果二者均支持压缩）。

·         ---debug[=debug_options]，-# [debug_options]

写调试日志。debug_options字符串通常是&#39;d:t:o,file_name&#39;。

·         --delete，-D

导入文本文件前清空表。

·         --fields-terminated-by=...，--fields-enclosed-by=...，--fields-optionally-enclosed-by=...，--fields-escaped-by=...，--lines-terminated-by=...

这些选项与LOAD DATA INFILE相应子句的含义相同。参见13.2.5节，“LOAD DATA INFILE语法”。

·         --force，-f

忽视错误。例如，如果某个文本文件的表不存在，继续处理其它文件。不使用--force，如果表不存在则mysqlimport退出。

·         --host=host_name，-h host_name

将数据导入给定主机上的MySQL服务器。默认主机是localhost。

·         --ignore，-i

参见--replace选项的描述。

·         --ignore-lines=n

忽视数据文件的前n行。

·         --local，-L

从本地客户端读入输入文件。

·         --lock-tables，-l

处理文本文件前锁定所有表以便写入。这样可以确保所有表在服务器上保持同步。

·         --password[=password]，-p[password]

当连接服务器时使用的密码。如果使用短选项形式(-p)，选项和 密码之间不能有空格。如果在命令行中--password或-p选项后面没有 密码值，则提示输入一个密码。

·         --port=port_num，-P port_num

用于连接的TCP/IP端口号。

·         --protocol={TCP | SOCKET | PIPE | MEMORY}

使用的连接协议。

·         --replace，-r

--replace和--ignore选项控制复制唯一键值已有记录的输入记录的处理。如果指定--replace，新行替换有相同的唯一键值的已有行。如果指定--ignore，复制已有的唯一键值的输入行被跳过。如果不指定这两个选项，当发现一个复制键值时会出现一个错误，并且忽视文本文件的剩余部分。

·         --silent，-s

沉默模式。只有出现错误时才输出。

·         --socket=path，-S path

当连接localhost时使用的套接字文件(为默认主机)。

·         --user=user_name，-u user_name

当连接服务器时MySQL使用的用户名。

·         --verbose，-v

冗长模式。打印出程序操作的详细信息。

·         --version，-V

显示版本信息并退出。&lt;/pre&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;LOAD DATA INFILE语句中有一个mysqlimport工具中没有特点：&lt;/p&gt;
&lt;p&gt;LOAD DATA INFILE 可以按指定的字段把文件导入到数据库中。&lt;/p&gt;
&lt;p&gt;当我们要把数据的一部分内容导入的时候，这个特点就很重要。&lt;/p&gt;
&lt;p&gt;比方说，我们要从Access数据库升级到MySQL数据库的时候，需要加入一些字段（列/字 段/field）到MySQL数据库中，以适应一些额外的需要。&lt;/p&gt;
&lt;p&gt;这个时候，我们的Access数据库中的数据仍然是可用的，但是因为这些数据的字段(field)与MySQL中的不再匹配，因此而无法再使用mysqlimport工具。&lt;/p&gt;
&lt;p&gt;尽管如此，我们仍然可以使用LOAD DATA INFILE，下面的例子显示了如何向指定的字段(field)中导入数据：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;LOAD DATA INFILE &quot;/home/Order.txt&quot; INTO TABLE Orders(Order_Number, Order_Date, Customer_ID);&lt;/pre&gt;
&lt;p&gt;如您所见，我们可以指定需要的字段（fields）。这些指定的字段依然是以括号括起，由逗号分隔的，如果您遗漏了其中任何一个，MySQL将会提醒您^_^&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;如何选择备份工具？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接复制数据文件是最为直接、快速的备份方法，但缺点是基本上不能实现增量备份。&lt;/p&gt;
&lt;p&gt;备份时必须确保没有使用这些表。如果在复制一个表的物理数据文件的同时服务器正在修改他，则复制无效。&lt;/p&gt;
&lt;p&gt;备份文件时，最好关闭服务器，然后重新启动服务器，为了保证数据的一致性，需要在备份文件前执行以下SQL&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;FLUSH TABLES WITH READ LOCK;&lt;/pre&gt;
&lt;p&gt;也就是把内存中的数据刷新到磁盘中，同时锁定数据表，以保证复制过程中不会有新的数据写入。&lt;/p&gt;
&lt;p&gt;这种方法备份出来的数据恢复很简单，直接复制回原来的数据库目录下即可&lt;/p&gt;
&lt;p&gt;mysqlhotcopy是一个PERL程序，他使用LOCK TABLES、FLUSH TABLES和CP或SCP来快速备份数据库&lt;/p&gt;
&lt;p&gt;他是备份数据库或单个表的最快的途径，但他只能运行在数据库文件所在机器上，并且mysqlhotcopy只能用于备份myisam表&lt;/p&gt;
&lt;p&gt;mysqlhotcopy适合于小型数据库的备份，数据量不大，可以使用mysqlhotcopy程序每天进行一次完全备份&lt;/p&gt;
&lt;p&gt;mysqldump将数据表导出为SQL脚本，在不同的MYSQL版本之间升级时相对比较合适，这也是最常用的备份方法。&lt;/p&gt;
&lt;p&gt;mysqldump比直接复制要慢些。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;使用mysqldump备份整个数据库成功，把表和数据库删除了，但使用备份文件却不能恢复数据库？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;出现这种情况是因为备份的时候没有指定–databases参数。默认情况下，如果只指定数据库名称，mysqldump&lt;/p&gt;
&lt;p&gt;备份的是数据库中的所有表，而不包括数据库的创建语句，如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqldump -u root -p booksdb &amp;gt;c:\booksdb_2014-7-1.sql&lt;/pre&gt;
&lt;p&gt;该语句只备份了booksdb数据库下的所有表，读者打开该文件，可以看到文件中不包含创建booksdb数据库&lt;/p&gt;
&lt;p&gt;的CREATE DATABASE语句，因此如果把booksdb也删除了，使用该sql文件不能还原以前的表，&lt;/p&gt;
&lt;p&gt;还原时会出现ERROR 1046(3D000):NO DATABASE SELECTED 的错误信息&lt;/p&gt;
&lt;p&gt;而下面的语句，数据库删除之后，可以正常还原备份时的状态&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqldump -u root -p --databases booksdb&amp;gt;C:\booksdb_db_2014-7-1.sql&lt;/pre&gt;
&lt;p&gt;该语句不仅备份了所有数据库下的表结构，而且包括创建数据库的语句&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节介绍了MYSQL中的备份和还原，还有数据库的迁移，异构数据库之间的迁移基本上都用导出文件文件的方法&lt;/p&gt;
&lt;p&gt;如果是小数据量尚可以，如果数据量比较大，导出文本文件也会很大，不是太可取&lt;/p&gt;
&lt;p&gt;希望这篇文章对大家有帮助&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87363&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87363votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87363&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt; 3 评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sat, 06 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-06-87363-7da0a07c6.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-06-87363-7da0a07c6.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（13） ： 权限管理</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87345/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（7） ： 查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87345/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（8） ： 插入 更新 删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87348/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（9） ： 索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87351/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（10） ： 自定义存储过程和函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87353/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（11） ： 视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87355/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（12） ： 触发器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一篇《我的MYSQL学习心得（十三）》将会讲解MYSQL的用户管理&lt;/p&gt;
&lt;p&gt;在mysql数据库中，有mysql_install_db脚本初始化权限表，存储权限的表有：&lt;/p&gt;
&lt;p&gt;1、user表&lt;/p&gt;
&lt;p&gt;2、db表&lt;/p&gt;
&lt;p&gt;3、host表&lt;/p&gt;
&lt;p&gt;4、table_priv表&lt;/p&gt;
&lt;p&gt;5、columns_priv表&lt;/p&gt;
&lt;p&gt;6、proc_priv表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL&lt;/strong&gt;存取控制包含2个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;阶段1&lt;/strong&gt;：服务器检查你是否允许连接。&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;阶段2&lt;/strong&gt;：假定你能连接，服务器检查你发出的每个请求。看你是否有足够的权限实施它。例如，如果你从数据库中一个表精选(select)行或从数据库抛弃一个表，服务器确定你对表有&lt;strong&gt;select&lt;/strong&gt;权限或对数据库有&lt;strong&gt;drop&lt;/strong&gt;权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务器在存取控制的两个阶段使用在&lt;code&gt;mysql&lt;/code&gt;的数据库中的&lt;code&gt;user&lt;/code&gt;、&lt;code&gt;db&lt;/code&gt;和&lt;code&gt;host&lt;/code&gt;表，在这些授权表中字段如下：&lt;/p&gt;
&lt;table border=&quot;Privileges&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;表名称&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;user&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;db&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;host&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;范围字段&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;User&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Db&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Db&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Password&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;User&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;权限字段&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Select_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Select_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Select_priv&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Insert_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Insert_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Insert_priv&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Update_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Update_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Update_priv&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Delete_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Delete_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Delete_priv&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Index_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Index_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Index_priv&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Alter_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Alter_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Alter_priv&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Create_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Create_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Create_priv&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Drop_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Drop_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Drop_priv&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Grant_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Grant_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Grant_priv&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Reload_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Shutdown_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Process_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;File_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对存取控制的第二阶段(请求证实)，如果请求涉及表，服务器可以另外参考&lt;code&gt;tables_priv&lt;/code&gt;和&lt;code&gt;columns_priv&lt;/code&gt;表。这些表的字段如下：&lt;/p&gt;
&lt;table border=&quot;Privileges&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;表名称&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;tables_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;columns_priv&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;范围字段&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Db&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Db&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;User&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;User&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Table_name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Table_name&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Column_name&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;权限字段&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Table_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Column_priv&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Column_priv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;其他字段&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Timestamp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Timestamp&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Grantor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每个授权表包含范围字段和权限字段。&lt;/p&gt;
&lt;p&gt;user表主要分为：用户列、权限列、安全列、资源控制列&lt;/p&gt;
&lt;p&gt;host表主要分为：用户列、权限列&lt;/p&gt;
&lt;p&gt;这里美中不足的是&lt;strong&gt;mysql.user 没有一个列是保存用户创建时间的&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;有时候排查用户问题的时候，比如某个客户在某个时间说连接不上数据库，我们在user表里只能查到是否存在那个用户&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;帐户管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MYSQL提供许多语句用来管理用户帐号，这些语句可以用来包括登录和退出MYSQL服务器、创建用户、删除用户、密码管理、权限管理&lt;/p&gt;
&lt;p&gt;MYSQL数据库的安全性，需要通过帐户管理来保证&lt;/p&gt;
&lt;p&gt;登录和退出MYSQL&lt;/p&gt;
&lt;p&gt;mysql命令的常用参数&lt;/p&gt;
&lt;p&gt;-h：主机名或ip，默认是localhost，最好指定-h参数&lt;/p&gt;
&lt;p&gt;-u：用户名&lt;/p&gt;
&lt;p&gt;-p：密码，注意：该参数后面的字符串和-p不能有空格&lt;/p&gt;
&lt;p&gt;-P：端口号，默认为3306&lt;/p&gt;
&lt;p&gt;数据库名：可以在命令最后指定数据库名&lt;/p&gt;
&lt;p&gt;-e：执行SQL语句，如果指定该参数，将在登录后执行-e后面的命令或sql语句并退出&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/39cdb37ec7ae448c4bb4870eea3e208f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;命令执行完之后返回book表的结构，查询返回之后会自动退出MYSQL&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;用户&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE USER user [IDENTIFIED BY [PASSWORD] &#39;password&#39;]
    [, user [IDENTIFIED BY [PASSWORD] &#39;password&#39;]]&lt;/pre&gt;
&lt;p&gt;新建普通用户&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE USER &#39;jeffrey&#39;@&#39;localhost&#39; identified BY &#39;mypass&#39;;&lt;/pre&gt;
&lt;p&gt;用户名部分为“jeffrey”，主机名默认为“%”（即对所有主机开放权限）&lt;/p&gt;
&lt;p&gt;如果指定用户登录不需要密码，则可以省略identified BY部分&lt;/p&gt;
&lt;p&gt;对于使用插件认证连接的用户，服务器调用指定名称的插件，客户端需要提供验证方法所需要的凭据。&lt;/p&gt;
&lt;p&gt;如果创建用户时或者连接服务器时，服务器找不到对应的插件，将返回一个错误&lt;/p&gt;
&lt;p&gt;identified with语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE user &#39;jeffrey&#39;@&#39;localhost&#39; identified with my_auth_plugin;&lt;/pre&gt;
&lt;p&gt;identified with只能在MYSQL5.5.7及以上版本使用。&lt;/p&gt;
&lt;p&gt;identified with和identified by是互斥的，所以对一个帐户来说只能使用一个验证方法。&lt;/p&gt;
&lt;p&gt;CREATE USER语句的操作会被记录到服务器日志文件或者操作历史文件中&lt;/p&gt;
&lt;p&gt;例如 ~/.mysql_history。这意味着对这些文件有读取权限的人，都可以读取到新添加用户的明文密码&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d8a93dc6fa9210d0fe9726bc0ac05b20.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;一个办法就是新建用户的时候使用password关键字&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE user &#39;tom&#39;@&#39;localhost&#39; identified BY password&#39;*6C8989366EAF75BB670AD8EA7A7FC1176A95CEF4&#39;;

SELECT password(&#39;mypass&#39;);

SELECT * FROM `mysql`.`user` WHERE `User` =&#39;tom&#39;;&lt;/pre&gt;
&lt;p&gt;先查出你的密码的哈希值，然后在新建用户的时候输入哈希值&lt;/p&gt;
&lt;p&gt;那么在日志里面就只能看到哈希值&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9dc3c5e3f9365eb4bba0d3524a19967c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/69627e332de721e310aa1f32972367ec.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;使用GRANT语句创建新用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GRANT USER语句可以用来创建帐户，通过该语句可以在user表中添加一条新记录&lt;/p&gt;
&lt;p&gt;比起CREATE USER语句创建的新用户，还需要使用GRANT语句赋予用户权限&lt;/p&gt;
&lt;p&gt;使用GRANT语句创建新用户时必须有GRANT权限。&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;GRANT priv_type [(column_list)] [, priv_type [(column_list)]] ...
    ON [object_type] {tbl_name | * | *.* | db_name.*}
    TO user [IDENTIFIED BY [PASSWORD] &#39;password&#39;]
        [, user [IDENTIFIED BY [PASSWORD] &#39;password&#39;]] ...
    [REQUIRE
        NONE |
        [{SSL| X509}]
        [CIPHER &#39;cipher&#39; [AND]]
        [ISSUER &#39;issuer&#39; [AND]]
        [SUBJECT &#39;subject&#39;]]
    [WITH with_option [with_option] ...]&lt;/pre&gt;
&lt;p&gt;使用GRANT语句创建一个新用户testUser，密码为testpwd，并授予用户对所有数据表的SELECT和UPDATE权限&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;GRANT SELECT ,UPDATE ON *.* TO &#39;testUser&#39;@&#39;localhost&#39; identified BY &#39;testpwd&#39;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT `Host` ,`User` ,`Select_priv` ,`Update_priv`  FROM mysql.user WHERE `User` =&#39;testUser&#39;;&lt;/pre&gt;
&lt;p&gt;执行结果显示执行成功，使用SELECT语句查询用户testUser的权限&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/02166aa1523c59d3133c78767a2cc206.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;查询结果显示SELECT和UPDATE权限字段均为Y&lt;/p&gt;
&lt;p&gt;注意：User表中的user和host字段区分大小写，在查询的时候要指定正确的用户名或主机名&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;直接操作MYSQL用户表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不管是CREATE USER还是GRANT USER，在创建用户时，实际上都是在user表中添加一条新记录。&lt;/p&gt;
&lt;p&gt;使用INSERT语句向mysql.user表INSERT一条记录来创建一个新用户&lt;/p&gt;
&lt;p&gt;插入的时候必须要有INSERT权限&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO mysql.user(host,user,password,[privilegelist])
VALUES (&#39;host&#39;,&#39;username&#39;,password(&#39;password&#39;),privilegevaluelist)&lt;/pre&gt;
&lt;p&gt;使用INSERT创建一个新用户，其用户名称为customer1，主机名为localhost，密码为customer1&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO mysql.user(host,user,password)
VALUES (&#39;localhost&#39;,&#39;customer1&#39;,password(&#39;customer1&#39;))&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dc602a69eac29943d306c71864480fd7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;语句执行失败，查看警告信息如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show WARNINGS ;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/843da6a361c460138d5ae434411f9ba3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为ssl_cipher这个字段在user表中没有定义默认值，所以在这里提示错误信息。&lt;/p&gt;
&lt;p&gt;影响insert语句的执行，使用SELECT语句查看user表中的记录&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5c692447bf149b66650234635bb653a7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，插入失败&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;删除普通用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用DROP USER语句删除用户，也可以直接通过DELETE从mysql.user表中删除对应的记录来删除用户&lt;/p&gt;
&lt;p&gt;DROP USER语句用于删除一个或多个MYSQL帐户。要使用DROP USER，必须拥有MYSQL数据库的全局&lt;/p&gt;
&lt;p&gt;CREATE USER 权限或DELETE权限。&lt;/p&gt;
&lt;p&gt;删除testUser这个用户&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP user &#39;testUser&#39;@&#39;localhost&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ab19bdc3347b462d21d694f9b0ac43cc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/eae772ebeac034f69ab73811d2d4b314.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以发现testUser这个用户已经删除了&lt;/p&gt;
&lt;p&gt;使用delete语句删除用户&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DELETE FROM mysql.user WHERE `Host`=&#39;localhost&#39; and `User`=&#39;testUser&#39;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;root用户修改自己的密码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改root密码的方式有多种&lt;/p&gt;
&lt;p&gt;1、使用mysqladmin命令在命令行指定新密码&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqladmin -u root -p password&quot;rootpwd&quot;&lt;/pre&gt;
&lt;p&gt;2、修改mysql数据库的user表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;UPDATE mysql.user SET `Password` =password(&#39;rootpwd&#39;) WHERE `User`=&#39;root&#39; and `Host`=&#39;localhost&#39;&lt;/pre&gt;
&lt;p&gt;password(”)函数用来加密用户密码。执行update之后需要执行flush privileges语句重新加载用户权限&lt;/p&gt;
&lt;p&gt;3、使用SET语句修改root用户的密码&lt;/p&gt;
&lt;p&gt;SET PASSWORD语句可以用来重新设置其他用户的登录密码或者自己使用的帐户密码&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET PASSWORD=PASSWORD(&quot;ROOTPWD&quot;)&lt;/pre&gt;
&lt;p&gt;新密码必须用PASSWORD函数加密&lt;/p&gt;
&lt;p&gt;使用root用户登录到mysql之后执行下面语句&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET password=password(&#39;123456&#39;)&lt;/pre&gt;
&lt;p&gt;执行之后需要使用执行flush privileges语句或者重启MYSQL重新加载用户权限&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;root用户修改普通用户密码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、使用SET语句修改普通用户的密码&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET PASSWORD FOR &#39;USER&#39;@&#39;HOST&#39; =PASSWORD(&quot;ROOTPWD&quot;)&lt;/pre&gt;
&lt;p&gt;2、使用update语句修改普通用户的密码&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;UPDATE mysql.user SET `Password` =password(&#39;rootpwd&#39;) WHERE `User`=&#39;root&#39; and `Host`=&#39;localhost&#39;&lt;/pre&gt;
&lt;p&gt;执行完毕之后需要使用flush privileges语句或者重启MYSQL重新加载用户权限&lt;/p&gt;
&lt;p&gt;3、使用GRANT语句修改普通用户密码&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;GRANT USAGE ON *.* TO &#39;someuser&#39;@&#39;%&#39;  IDENTIFIED BY &#39;somepwd&#39;&lt;/pre&gt;
&lt;p&gt;使用下面语句把testUser用户的密码改为123456&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;grant USAGE ON *testUser*TO &#39;localhost&#39; identified BY &#39;123456&#39;;&lt;/pre&gt;
&lt;p&gt;注意：使用GRANT语句和MYSQLADMIN设置密码，他们均会加密密码，这种情况下，不需要使用PASSWORD()函数&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;普通用户修改密码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用SET语句修改自己的密码&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET password=password(&#39;newpassword&#39;);&lt;/pre&gt;
&lt;p&gt;比如修改testUser这个用户的密码，需要使用testUser这个用户登录到mysql，然后执行&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET password=password(&#39;123456&#39;);&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;root用户密码丢失的解决办法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用–skip-grant-tables选项启动MYSQL服务&lt;/p&gt;
&lt;p&gt;使用–skip-grant-tables选项启动MYSQL时，服务器将不加载权限判断，任何用户都能访问数据库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LINUX下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用mysqld_safe来启动MYSQL服务，也可以使用/etc/init.d/mysql命令来启动mysql&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysqld_safe --skip-grant-tables user=mysql&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;/etc/init.d/mysql start-mysqld --skip-grant-tables&lt;/pre&gt;
&lt;p&gt;启动MYSQL服务后，就可以使用root用户登录了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Windows下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;详细可以看一下这篇文章&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/MYSQLZOUQI/p/3539912.html&quot; href=&quot;http://www.cnblogs.com/MYSQLZOUQI/p/3539912.html&quot; target=&quot;_blank&quot;&gt;Windows mysql提示：1045 access denied for user ‘root’@&#39;localhost’ using password yes&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;权限管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MYSQL中的各种权限&lt;/p&gt;
&lt;p&gt;对于GRANT和REVOKE语句，priv_type可以被指定为以下任何一种：&lt;/p&gt;
&lt;table id=&quot;table7&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;权限&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;意义&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ALL [PRIVILEGES]&lt;/td&gt;
&lt;td&gt;设置除GRANT OPTION之外的所有简单权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ALTER&lt;/td&gt;
&lt;td&gt;允许使用ALTER TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ALTER ROUTINE&lt;/td&gt;
&lt;td&gt;更改或取消已存储的子程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE&lt;/td&gt;
&lt;td&gt;允许使用CREATE TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE ROUTINE&lt;/td&gt;
&lt;td&gt;创建已存储的子程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE TEMPORARY TABLES&lt;/td&gt;
&lt;td&gt;允许使用CREATE TEMPORARY TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE USER&lt;/td&gt;
&lt;td&gt;允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE VIEW&lt;/td&gt;
&lt;td&gt;允许使用CREATE VIEW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;允许使用DELETE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DROP&lt;/td&gt;
&lt;td&gt;允许使用DROP TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXECUTE&lt;/td&gt;
&lt;td&gt;允许用户运行已存储的子程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FILE&lt;/td&gt;
&lt;td&gt;允许使用SELECT…INTO OUTFILE和LOAD DATA INFILE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INDEX&lt;/td&gt;
&lt;td&gt;允许使用CREATE INDEX和DROP INDEX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INSERT&lt;/td&gt;
&lt;td&gt;允许使用INSERT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LOCK TABLES&lt;/td&gt;
&lt;td&gt;允许对您拥有SELECT权限的表使用LOCK TABLES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROCESS&lt;/td&gt;
&lt;td&gt;允许使用SHOW FULL PROCESSLIST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REFERENCES&lt;/td&gt;
&lt;td&gt;未被实施&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RELOAD&lt;/td&gt;
&lt;td&gt;允许使用FLUSH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REPLICATION CLIENT&lt;/td&gt;
&lt;td&gt;允许用户询问从属服务器或主服务器的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REPLICATION SLAVE&lt;/td&gt;
&lt;td&gt;用于复制型从属服务器（从主服务器中读取二进制日志事件）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SELECT&lt;/td&gt;
&lt;td&gt;允许使用SELECT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SHOW DATABASES&lt;/td&gt;
&lt;td&gt;SHOW DATABASES显示所有数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SHOW VIEW&lt;/td&gt;
&lt;td&gt;允许使用SHOW CREATE VIEW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SHUTDOWN&lt;/td&gt;
&lt;td&gt;允许使用&lt;strong&gt;mysqladmin shutdown&lt;/strong&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SUPER&lt;/td&gt;
&lt;td&gt;允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，&lt;strong&gt;mysqladmin debug&lt;/strong&gt;命令；允许您连接（一次），即使已达到max_connections。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UPDATE&lt;/td&gt;
&lt;td&gt;允许使用UPDATE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USAGE&lt;/td&gt;
&lt;td&gt;“无权限”的同义词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GRANT OPTION&lt;/td&gt;
&lt;td&gt;允许授予权限&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;当从旧版本的MySQL升级时，要使用EXECUTE, CREATE VIEW, SHOW VIEW, CREATE USER, CREATE ROUTINE和ALTER ROUTINE权限&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;授权&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;授权就是为某个用户授予权限&lt;/p&gt;
&lt;p&gt;授予的权限可以分为多个层级：&lt;/p&gt;
&lt;p&gt;·         &lt;strong&gt;全局层级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全局权限适用于一个给定服务器中的所有数据库。这些权限存储在mysql.user表中。GRANT ALL ON *.*和REVOKE ALL ON *.*只授予和撤销全局权限。&lt;/p&gt;
&lt;p&gt;·         &lt;strong&gt;数据库层级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库权限适用于一个给定数据库中的所有目标。这些权限存储在mysql.db和mysql.host表中。GRANT ALL ON&lt;em&gt;db_name&lt;/em&gt;.*和REVOKE ALL ON &lt;em&gt;db_name&lt;/em&gt;.*只授予和撤销数据库权限。&lt;/p&gt;
&lt;p&gt;·         &lt;strong&gt;表层级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表权限适用于一个给定表中的所有列。这些权限存储在mysql.talbes_priv表中。GRANT ALL ON &lt;em&gt;db_name.tbl_name&lt;/em&gt;和REVOKE ALL ON &lt;em&gt;db_name.tbl_name&lt;/em&gt;只授予和撤销表权限。&lt;/p&gt;
&lt;p&gt;·         &lt;strong&gt;列层级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;列权限适用于一个给定表中的单一列。这些权限存储在mysql.columns_priv表中。当使用REVOKE时，您必须指定与被授权列相同的列。&lt;/p&gt;
&lt;p&gt;·         &lt;strong&gt;子程序层级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CREATE ROUTINE, ALTER ROUTINE, EXECUTE和GRANT权限适用于已存储的子程序。这些权限可以被授予为全局层级和数据库层级。而且，除了CREATE ROUTINE外，这些权限可以被授予为子程序层级，并存储在mysql.procs_priv表中。&lt;/p&gt;
&lt;p&gt;当后续目标是一个表、一个已存储的函数或一个已存储的过程时，&lt;em&gt;object_type&lt;/em&gt;子句应被指定为TABLE、FUNCTION或PROCEDURE。当从旧版本的MySQL升级时，要使用本子句，您必须升级您的授权表&lt;/p&gt;
&lt;p&gt;使用GRANT语句创建一个新用户grantUser，密码为“grantpwd”&lt;/p&gt;
&lt;p&gt;用户对所有的数据有查询、插入权限，并授予GRANT权限&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;GRANT SELECT ,INSERT ON *.*TO &#39;grantUser&#39;@&#39;localhost&#39; identified BY &#39;123456&#39; WITH GRANT OPTION ;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/52d17ad152ac7939ee00f118ca7d42fc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;查询显示grantUser被创建成功，并赋予了SELECT、INSERT、GRANT权限，其相应字段值为Y&lt;/p&gt;
&lt;p&gt;被授予GRANT权限的用户可以登录MYSQL并创建其他用户帐户，在这里是grantUser的用户&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;收回权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;收回权限就是取消已经赋予用户的某些权限。收回用户不必要的权限可以在一定程度上保证系统的安全性。&lt;/p&gt;
&lt;p&gt;使用REVOKE收回权限之后，用户帐户的记录将从db、host、tables_priv、columns_priv表中删除，但是用户帐号记录依然&lt;/p&gt;
&lt;p&gt;在user表中保存。&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;REVOKE priv_type [(column_list)] [, priv_type [(column_list)]] ...
    ON [object_type] {tbl_name | * | *.* | db_name.*}
    FROM user [, user] ...

REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] ...&lt;/pre&gt;
&lt;p&gt;使用REVOKE语句，必须拥有mysql数据库的全局CREATE权限或UPDATE权限&lt;/p&gt;
&lt;p&gt;使用REVOKE语句取消用户grantUser的INSERT权限&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;REVOKE INSERT ON *.* FROM &#39;grantUser&#39;@&#39;localhost&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/52722f7a1f8d4b7d4786570d926426c1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到grantUser用户的INSERT权限已经被收回了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：当从旧版本的MYSQL升级时，如果要使用EXECUTE、CREATE VIEW、SHOW VIEW、CREATE USER、CREATE ROUTINE、ALTER ROUTINE&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;查看权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SHOW GRANT语句可以显示用户的权限信息&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show grants FOR &#39;user&#39;@&#39;host&#39;;&lt;/pre&gt;
&lt;p&gt;使用SHOW GRANT语句查询用户grantUser的权限信息&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;show grants FOR &#39;grantUser&#39;@&#39;localhost&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fa07f4a5ebedb03de9eda35da8846190.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;返回结果显示了user表中的帐户信息；接下来以为GRANT SELECT ON关键字开头，表示用户被授予了SELECT权限；&lt;/p&gt;
&lt;p&gt;*.*表示SELECT权限作用于所有数据库的所有数据表；&lt;/p&gt;
&lt;p&gt;IDENTIFIED BY 后面的为用户加密后的密码&lt;/p&gt;
&lt;p&gt;在这里，只是定义了个别的用户权限，GRANT可以显示更加详细的权限信息，包括全局级的和非全局级的权限&lt;/p&gt;
&lt;p&gt;如果表层级或者列层级的权限被授予用户的话，他们也能在结果中显示出来。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;查看MYSQL里面匿名用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果有匿名用户，那么客户端就可以不用密码登录MYSQL数据库，这样就会存在安全隐患&lt;/p&gt;
&lt;p&gt;检查匿名用户的方法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM mysql.user WHERE `User`=&#39;&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/cd7e2cf488b2bde78295436346cbb0ad.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果查找到user字段值为空的那条记录，说明存在匿名用户，需要把这条记录删除&lt;/p&gt;
&lt;p&gt;如果用匿名用户登录MYSQL就可以看到用户名是空的&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5b4e4d6734d7a4247920f79c559b8807.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;删除语句&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DELETE FROM mysql.user WHERE `User`=&#39;&#39;;

SELECT * FROM mysql.user WHERE `User`=&#39;&#39;;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文简单的阐述了MYSQL的用户管理和权限方面的内容，希望对大家有帮助&lt;/p&gt;
&lt;p&gt;如果大家想更深入学习MYSQL访问控制方面的知识&lt;/p&gt;
&lt;p&gt;可以参考这篇文章：&lt;a title=&quot;http://www.searchdatabase.com.cn/showcontent_50461.htm&quot; href=&quot;http://www.searchdatabase.com.cn/showcontent_50461.htm&quot; target=&quot;_blank&quot;&gt;MySQL权限的架构体系&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;核心就是&lt;strong&gt;两个图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、客户端连接请求认证阶段&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7a4a298ec2d0f78562d03f74348a771c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、客户端操作请求认证阶段&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1e306800866cda91407b66397cc8273f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;最最后说一下，我开了一个MYSQL走起的微博，希望大家支持一下o(∩_∩)o&lt;/p&gt;
&lt;p&gt;欢迎关注&lt;strong&gt;MYSQL官方微博&lt;/strong&gt;：&lt;a title=&quot;http://weibo.com/MYSQLZOUQI/home?topnav=1&amp;amp;wvr=5#_rnd1405248126528&quot; href=&quot;http://weibo.com/MYSQLZOUQI/home?topnav=1&amp;amp;wvr=5#_rnd1405248126528&quot; target=&quot;_blank&quot;&gt;MYSQL走起&lt;/a&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87357&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87357votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87357&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sat, 06 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-06-87357-2d1c00f74.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-06-87357-2d1c00f74.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>写一个支持键盘输入和屏幕输出的内核</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;在我之前的文章&lt;a href=&quot;http://arjunsreedharan.org/post/82710718100/kernel-101-lets-write-a-kernel&quot;&gt;让我们编写一个内核&lt;/a&gt;，讲述了如何搭建一个初级的x86内核，该内核使用GRUB启动，运行于保护模式，能在屏幕上输出字符串。&lt;/p&gt;
&lt;p&gt;今天，我将为该内核添加键盘驱动，这样它能够获取键盘上a-z和0-9字符输入并且输出到屏幕。&lt;/p&gt;
&lt;p&gt;本文使用的源代码可以在我的&lt;a href=&quot;http://github.com/arjun024/mkeykernel&quot;&gt;GirHub仓库-mkeykernel&lt;/a&gt;中获取。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/283d9c999c2132ae1d0dd43cc53f1dde.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们使用I/O端口来与I/O设备交互。这些端口只是x86 I/O总线上的具体地址，仅此而已。对该端口的读/写操作通过处理器内建的特定指令完成。&lt;/p&gt;
&lt;h1&gt;&lt;strong style=&quot;font-style: normal;&quot;&gt;端口读写&lt;/strong&gt;&lt;/h1&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;read_port:
        mov edx, [esp + 4]
        in al, dx      
        ret

write_port:
        mov   edx, [esp + 4]    
        mov   al, [esp + 4 + 4]  
        out   dx, al  
        ret&lt;/pre&gt;
&lt;p&gt;I/O端口的访问使用x86指令集中的in和out指令。&lt;/p&gt;
&lt;p&gt;在read_port中，端口号被视为参数。当编译器调用你的函数时，它将所有的参数压入栈中。参数使用栈指针复制到寄存器edx中。寄存器dx是edx的低16位。这里的in指令读取dx指定端口并将结果输出到al中。寄存器al是eax的低8位。如果你还记得大学课程，函数的返回值存放于eax寄存器中。因此，read_port可以读取I/O端口数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;write_port非常类似。这里有两个参数：端口号和待写入数据。out指令将数据写入端口中。&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong style=&quot;font-style: normal;&quot;&gt;中断&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;在我们开始编写任何设备驱动前，我们需要了解处理器是如何知道设备执行了一个事件。&lt;/p&gt;
&lt;p&gt;最简单的方法是&lt;strong&gt;轮询&lt;/strong&gt;—始终保持对设备状态的监测。这样显然效率太低且不实用。因此&lt;strong&gt;中断&lt;/strong&gt;机制被引入。中断是硬件或软件发送给处理器的一个信号，代表一个事件。使用中断，我们可以避免轮询，仅当我们关注的指定中断触发时才响应。&lt;/p&gt;
&lt;p&gt;可编程中断控制器（PIC）器件或芯片确保x86成为支持中断驱动的架构。该器件或芯片负责管理硬件中断并将中断发送至相应系统中断。&lt;/p&gt;
&lt;p&gt;当硬件设备上执行指定操作时，它会向与PIC芯片连接的指定中断引脚上发送一个&lt;strong&gt;中断请求（IRQ）&lt;/strong&gt;脉冲。接着，PIC将接收到的IRQ转换成系统中断，并发送消息中止CPU当前执行的任何工作。接下来，由内核负责处理这些中断。&lt;/p&gt;
&lt;p&gt;如果没有PIC，我们就必须轮询系统中的所有设备来查看它们中是否有事件发生。&lt;/p&gt;
&lt;p&gt;下面以键盘为例。键盘依靠0×60和0×64 I/O端口工作。端口0×60输出数据（按了什么键），端口0×64输出状态。但是，你必须确切知道什么时候去读取这些端口。&lt;/p&gt;
&lt;p&gt;此处使用中断很简单。当按下一个键时，键盘会在IRQ1中断线上发送一个信号给PIC。PIC在初始化期间存储了一个偏移量。该设备将输入线号叠加偏移量就形成&lt;strong&gt;中断号&lt;/strong&gt;。接着，处理器查询称为&lt;strong&gt;中断描述符表(IDT)&lt;/strong&gt;的特定数据结构给出此中断号相对应的中断处理程序入口地址。&lt;/p&gt;
&lt;p&gt;接着，上述地址的事件处理代码会被执行。&lt;/p&gt;
&lt;h1&gt;
&lt;strong style=&quot;font-style: normal;&quot;&gt;建立&lt;/strong&gt;&lt;strong style=&quot;font-style: normal;&quot;&gt;IDT&lt;/strong&gt;&lt;strong style=&quot;font-style: normal;&quot;&gt;表&lt;/strong&gt;
&lt;/h1&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;struct IDT_entry{
	unsigned short int offset_lowerbits;
	unsigned short int selector;
	unsigned char zero;
	unsigned char type_attr;
	unsigned short int offset_higherbits;
};

struct IDT_entry IDT[IDT_SIZE];

void idt_init(void)
{
	unsigned long keyboard_address;
	unsigned long idt_address;
	unsigned long idt_ptr[2];

	/* populate IDT entry of keyboard&#39;s interrupt */
	keyboard_address = (unsigned long)keyboard_handler; 
	IDT[0x21].offset_lowerbits = keyboard_address &amp;amp; 0xffff;
	IDT[0x21].selector = 0x08; /* KERNEL_CODE_SEGMENT_OFFSET */
	IDT[0x21].zero = 0;
	IDT[0x21].type_attr = 0x8e; /* INTERRUPT_GATE */
	IDT[0x21].offset_higherbits = (keyboard_address &amp;amp; 0xffff0000) &amp;gt;&amp;gt; 16;

	/*     Ports
	*	 PIC1	PIC2
	*Command 0x20	0xA0
	*Data	 0x21	0xA1
	*/

	/* ICW1 - begin initialization */
	write_port(0x20 , 0x11);
	write_port(0xA0 , 0x11);

	/* ICW2 - remap offset address of IDT */
	/*
	* In x86 protected mode, we have to remap the PICs beyond 0x20 because
	* Intel have designated the first 32 interrupts as &quot;reserved&quot; for cpu exceptions
	*/
	write_port(0x21 , 0x20);
	write_port(0xA1 , 0x28);

	/* ICW3 - setup cascading */
	write_port(0x21 , 0x00);  
	write_port(0xA1 , 0x00);  

	/* ICW4 - environment info */
	write_port(0x21 , 0x01);
	write_port(0xA1 , 0x01);
	/* Initialization finished */

	/* mask interrupts */
	write_port(0x21 , 0xff);
	write_port(0xA1 , 0xff);

	/* fill the IDT descriptor */
	idt_address = (unsigned long)IDT ;
	idt_ptr[0] = (sizeof (struct IDT_entry) * IDT_SIZE) + ((idt_address &amp;amp; 0xffff) &amp;lt;&amp;lt; 16);
	idt_ptr[1] = idt_address &amp;gt;&amp;gt; 16 ;

	load_idt(idt_ptr);
}&lt;/pre&gt;
&lt;p&gt;IDT依靠IDT_entry组成的结构体数组实现。文章稍后会讨论键盘中断是如何映射到中断处理程序。首先，我们来了解PIC是如何工作的。&lt;/p&gt;
&lt;p&gt;现在的x86系统有2块PIC芯片，每一块有&lt;strong&gt;8条输入线&lt;/strong&gt;。我们称其为PIC1和PIC2。PIC1接收IRQ0到IRQ7，PIC2接收IRQ8至IRQ15。PIC1使用0×20作为命令端口，0×21作为数据。PIC2使用0xA0作为命令端口，0xA1作为数据端口。&lt;/p&gt;
&lt;p&gt;PIC初始化使用8位命令字，该命令字叫做&lt;strong&gt;初始化命令字（ICW）&lt;/strong&gt;。这些命令字的具体每一位语法参考&lt;a href=&quot;http://stanislavs.org/helppc/8259.html&quot;&gt;此链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在保护模式下，你需要发送给这两个PIC的第一条命令是初始化命令&lt;strong&gt;ICW1&lt;/strong&gt;(0×11)。该指令让PIC等待数据端口的其他3条初始化字。&lt;/p&gt;
&lt;p&gt;这些指令告诉PIC以下信息：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;*它的偏移向量。(ICW2)&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;*PIC是如何作为主/从设备的。(ICW3)&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;*给出环境相关的附加信息。(ICW4)&lt;/p&gt;
&lt;p&gt;第二条初始化指令是ICW2，该指令会被写入每一个PIC的数据端口。该指令设置PIC的偏移量。该偏移量和输入线的数据相加可以得到中断号。&lt;/p&gt;
&lt;p&gt;PIC允许彼此之间输出到输入的级联。级联的建立使用ICW3，每一位代表相应IRQ的级联状态。至于现在，我们不使用级联并且所有位均设为0。&lt;/p&gt;
&lt;p&gt;ICW4设置附加环境参数。我们仅设置大部分低位来告诉PIC我们运行于80×86模式。&lt;/p&gt;
&lt;p&gt;Tang ta dang!! PIC初始化完成。&lt;/p&gt;
&lt;p&gt;每一个PIC内部有一个8位寄存器叫做&lt;strong&gt;中断屏蔽寄存器(IMR)&lt;/strong&gt;。该寄存器中存放进入PIC的IRQ线的位图。当一位被置位时，PIC会忽略相应的请求。这意味着我们可以通过设置IMR中的数值的第n位为0或1来启用和禁止第n跳IRQ线。从数据端口读取的数据返回值存放在IMR寄存器中，向其中写入可设置寄存器。此处我们的代码中，在PIC初始化后，我们设置所有位为1，因此所有IRQ线都被禁用。我们稍后会启用键盘中断对应的线。至于现在，我们禁用所有的中断！！&lt;/p&gt;
&lt;p&gt;假设IRQ线开启，PIC可以通过IRQ线接收信号，并叠加偏移量转换成中断号。现在，我们需要填写IDT，这样键盘的中断号才能映射到我们编写的键盘处理程序的地址。&lt;/p&gt;
&lt;p&gt;那么键盘处理函数地址应该与IDT中哪一个中断号映射？&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;键盘使用IRQ1。IRQ1是PIC1的输入线。我们已经将PIC1的偏移量初始化为0×20（参见ICW2）。为查找中断号，将1加上偏移量0×20，即0×21。所以在IDT中，键盘终端处理程序地址必须映射到0×21号中断。&lt;/p&gt;
&lt;p&gt;那么，接下来的任务就是填写IDT中的0×21中断。&lt;/p&gt;
&lt;p&gt;我们要将该中断映射到我们在汇编文件中编写的键盘处理函数。&lt;/p&gt;
&lt;p&gt;每一个IDT条目由64位组成。在IDT中断条目中，我们没有将中断处理程序地址作为一个整体存储。我们把它分成两个16位部分。低16位存储在IDT条目的前16位，高16位存储在IDT条目的最后16位。这样做的目的是为了保持与286兼容。你可以在很多地方看到Intel类似的巧妙设计！！&lt;/p&gt;
&lt;p&gt;在IDT条目中，我们还必须设置类型——这样做是为了捕获中断。我们还需给出内核代码段偏移量。GRUB引导为我们建立一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Global_Descriptor_Table&quot; target=&quot;_blank&quot;&gt;GDT&lt;/a&gt;。每一项GDT条目占8个字节，内核代码描述符是第二个段；所以它的偏移量是0×08（更多相关描述对本文过于冗余）。中断门由0x8e表示。中间剩余8位必须全部填充为0。这样，我们就填充了与键盘中断相对应的IDT条目。&lt;/p&gt;
&lt;p&gt;一旦IDT中需要映射完成，我们需要告诉CPU IDT的位置。&lt;/p&gt;
&lt;p&gt;该操作通过lidt汇编指令完成。lidt指令有一个操作数。该操作数必须是一个指向描述IDT描述符结构的指针。&lt;/p&gt;
&lt;p&gt;该描述符十分简单。它包含了IDT的字节空间和地址。我使用了一个数组来打包该数值。你也可以使用一个结构体来填写该数值。&lt;/p&gt;
&lt;p&gt;我们在变量idt_ptr中存放了指针，然后使用load_idt()函数传递指针给lidt指令。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;load_idt:
	mov edx, [esp + 4]
	lidt [edx]
	sti
	ret&lt;/pre&gt;
&lt;p&gt;此外，load_idt()函数使用sti指令启用中断。&lt;/p&gt;
&lt;p&gt;一旦IDT被建立并加载，我们可以使用前面讨论过的中断屏蔽启用键盘的IRQ线。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;void kb_init(void)
{
	/* 0xFD is 11111101 - enables only IRQ1 (keyboard)*/
	write_port(0x21 , 0xFD);
}&lt;/pre&gt;
&lt;h1&gt;&lt;strong style=&quot;font-style: normal;&quot;&gt;键盘终端处理函数&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;既然我们已经通过IDT的0×21中断条目成功将键盘中断映射到键盘处理函数。&lt;/p&gt;
&lt;p&gt;那么，每次你按下键盘上的一个键，键盘处理函数必定会被调用。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;keyboard_handler:                 
	call    keyboard_handler_main
	iretd&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;键盘处理函数仅仅是调用了另一个C函数并使用iret类指令返回。我们本可以在此处编写整个中断处理程序，但是相对汇编而言编写C代码要更容易——所以这里采用函数调用。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当从中断处理程序返回中断之前的程序时，应该使用iret/iretd替换ret指令。这些指令会将中断调用前入栈的标志寄存器值出栈。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;void keyboard_handler_main(void) {
	unsigned char status;
	char keycode;

	/* write EOI */
	write_port(0x20, 0x20);

	status = read_port(KEYBOARD_STATUS_PORT);
	/* Lowest bit of status will be set if buffer is not empty */
	if (status &amp;amp; 0x01) {
		keycode = read_port(KEYBOARD_DATA_PORT);
		if(keycode &amp;lt; 0)
			return;
		vidptr[current_loc++] = keyboard_map[keycode];
		vidptr[current_loc++] = 0x07;	
	}
}&lt;/pre&gt;
&lt;p&gt;首先，我们通过向PIC通用端口写入指令发送EOI信号。只有这样，PIC才允许更多的中断请求。这里我们必须读取两个端口——0×60数据端口和0×64命令/状态端口。&lt;/p&gt;
&lt;p&gt;我们首先读取0×64端口获取状态。如果状态的最低位是0，这意味着缓冲区是空的，没有可读取数据。否则，我们要读取0×60数据端口。该端口将给出我们按下的键盘键码。每一个键码对应于键盘上的一个按键。keyboard_map.h头中定义了一个简单的字符数组来完成键码到对应字符的映射。该字符在屏幕上的输出与之前那篇文章中使用的技术相同。&lt;/p&gt;
&lt;p&gt;在本篇文章中，为了简洁，我仅仅处理了小写字母a-z和数字0-9。你可以轻松扩展到其他特殊字符，ALT，SHIFT，CAPS LOCK。你可以根据状态端口输出知道按键是否被按下或释放，并执行所需操作。你也可以将任意按键组合映射到特定功能，例如关机等。&lt;/p&gt;
&lt;p&gt;你可以编译内核，在实际机器或虚拟机(QEMU)上运行，和&lt;a href=&quot;http://arjunsreedharan.org/post/82710718100/kernel-101-lets-write-a-kernel&quot;&gt;之前的文章&lt;/a&gt;(&lt;a href=&quot;http://github.com/arjun024/mkernel&quot;&gt;内核仓库&lt;/a&gt;)一样。&lt;/p&gt;
&lt;p&gt;开始输入！！&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/31d00e615655da085bfa71ad66deee79.jpg&quot;&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87399&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87399votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87399&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt; 1 收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者：&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/ashiontang&quot;&gt;ashiontang&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/ashiontang&quot;&gt;
			&lt;img src=&quot;/images/jobbole.com/045abbad0c22fa44fd982fdd09f4a9ca.jpg&quot;&gt;
		&lt;/a&gt;
	&lt;/div&gt;

    &lt;div class=&quot;author-bio-info&quot;&gt;

        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            （新浪微博：@ashiontang）        &lt;/span&gt;
        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            &lt;a href=&quot;http://www.jobbole.com/members/ashiontang&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 个人主页&lt;/a&gt; · 
            &lt;a href=&quot;http://blog.jobbole.com/author/ashiontang/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;/i&gt; 我的文章&lt;/a&gt;

             · &lt;a title=&quot;声望值&quot; target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/ashiontang/reputation/&quot;&gt;&lt;i class=&quot;fa fa-graduation-cap&quot;&gt;&lt;/i&gt; 10&lt;/a&gt;        &lt;/span&gt;
    &lt;/div&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Fri, 05 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-05-87399-101542266.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-05-87399-101542266.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>TCP/IP 完全掌握了么？来看看 CloudFlare 的面试题</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;长期以来，我们都会考察面试者一些有关 TCP/IP 协议族的犄角旮旯的问题。例如：IPv4 协议栈和 IPv6 协议栈的校验和算法有什么不同？ 每个工程师都要证明自己对于网络栈的全面理解。&lt;/p&gt;
&lt;p&gt;本着&lt;a href=&quot;http://valerieaurora.org/tcpip.html&quot;&gt;传统的TCP/IP 酒令&lt;/a&gt;的精神，在这里我想和诸位分享我在 CloudFlare 的自动缓解攻击系统工作的这几个月里，遇到的那些有关 TCP/IP 的奇葩问题。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/18b0cbc49f0ff09837a48d242627d8af.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;small&gt;&lt;a href=&quot;https://creativecommons.org/licenses/by-sa/2.0/&quot;&gt;CC BY-SA 2.0&lt;/a&gt; &lt;a href=&quot;https://www.flickr.com/photos/dbreg2007/4376127852&quot;&gt;image&lt;/a&gt; by &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/2.0/&quot;&gt;Daan Berg&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;如果你不知道正确答案也不用担心，欢迎提出有趣的观点！&lt;/p&gt;
&lt;p&gt;有些问题的答案是显而易见的，而有些问题却没有直接的答案，而且还可能引起激烈的讨论。列出这些问题的目的是鼓励诸位捡起满是灰尘的 RFC 文档，激发起对网络栈内部工作原理的兴趣以及传播、分享我们如此依赖的协议的知识。&lt;/p&gt;
&lt;p&gt;如果你想分享某个问题的答案，别忘了添加一条评论。&lt;/p&gt;
&lt;p&gt;你觉得自己完全了解 TCP/IP 协议族吗？让我们试试看：&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;古老的问题&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1）TCP 最小的端口号是多少?&lt;/p&gt;
&lt;p&gt;2）TCP 帧中有一个叫做 URG Pointer 的字段，什么时候会用到该字段？&lt;/p&gt;
&lt;p&gt;3）RST 包能有荷载么？&lt;/p&gt;
&lt;p&gt;4）什么时候会用到 IPv6 里的“flow”字段？&lt;/p&gt;
&lt;p&gt;5）socket中的 IP_FREEBIND 选项有什么用？&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;被遗忘奇葩问题&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;6）PSH 标志实际上有什么用？&lt;/p&gt;
&lt;p&gt;7）TCP 时间戳和 SYN Cookie 是如何协同工作的？&lt;/p&gt;
&lt;p&gt;8）“UDP” 包可以把校验和字段设置为0么？&lt;/p&gt;
&lt;p&gt;9）TCP 的同时开放连接是如何工作的？真的能工作么？&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;碎片处理和拥塞控制&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;10）什么是愚笨窗口综合征（stupid window syndrome）？&lt;/p&gt;
&lt;p&gt;11）TCP 头里的 CWE 和 ECE 标志有什么用？&lt;/p&gt;
&lt;p&gt;12）IP 头里的 ID 字段是什么？ID 字段必须和 DF 比特位一起完成什么工作？为什么有些 IP 包的 ID 字段不是零并且设置了 DF？&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;新提议&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;13）SYN 包可以有荷载么？（提示：新RFC提案）&lt;/p&gt;
&lt;p&gt;14）SYN+ACK 包可以有荷载么？&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;ICMP Path MTU&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;15）ICMP 包太大（packet-too-big ）的消息会由路由器返回，并且荷载里包含了原始包的一部分。Linux 系统中可接受的最小荷载长度是多少？&lt;/p&gt;
&lt;p&gt;16）当 ICMP包太大（packet-too-big ）的消息被中间路由返回时会包含这个路由的源IP。但在实际操作中，我们经常可以看到 ICMP 消息的源 IP 与原始包的目的 IP 相同。为什么会这样？&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;Linux配置&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;17）Linux 有一个名为 “tcp_no_metrics_save” 的 sysctl 设置。它用于存储什么？存储多久？&lt;/p&gt;
&lt;p&gt;18）Linux 使用了两个队列来处理到达的 TCP 连接：SYN 队列和接收队列。SYN 队列长度是多少？&lt;/p&gt;
&lt;p&gt;19）如果 SYN 队列因变得很大而导致溢出，那么会发生什么？&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;路由相关&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;最后：&lt;/p&gt;
&lt;p&gt;20）BGP bogons 是什么？为什么说它们现在只是个小问题？&lt;/p&gt;
&lt;p&gt;21）TCP 有一个会添加 MD5 校验和到包中的扩展。该扩展什么时候起作用？&lt;/p&gt;
&lt;p&gt;22）IPv4 和 IPv6 的校验和算法有什么区别？&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87398&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87398votetotal&quot;&gt;6&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87398&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt; 7 收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt; 7 评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者：&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/lxtalx&quot;&gt;zer0Black&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/lxtalx&quot;&gt;
			&lt;img src=&quot;/images/jobbole.com/acc7de4f3e21ddea3affb662f132911f.jpg&quot;&gt;
		&lt;/a&gt;
	&lt;/div&gt;

    &lt;div class=&quot;author-bio-info&quot;&gt;

        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            目前工作为移动开发，兴趣广泛，计算机各方面均有强烈兴趣。（新浪微博：&amp;lt;a href=&quot;http://weibo.com/u/...        &lt;/span&gt;
        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            &lt;a href=&quot;http://www.jobbole.com/members/lxtalx&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 个人主页&lt;/a&gt; · 
            &lt;a href=&quot;http://blog.jobbole.com/author/lxtalx/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;/i&gt; 我的文章&lt;/a&gt;

             · &lt;a title=&quot;声望值&quot; target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/lxtalx/reputation/&quot;&gt;&lt;i class=&quot;fa fa-graduation-cap&quot;&gt;&lt;/i&gt; 13&lt;/a&gt;        &lt;/span&gt;
    &lt;/div&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Fri, 05 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-05-87398-e26c53f40.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-05-87398-e26c53f40.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（12） ： 触发器</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87340/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（7） ： 查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87345/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（8） ： 插入 更新 删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87348/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（9） ： 索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87351/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（10） ： 自定义存储过程和函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87353/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（11） ： 视图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一篇《我的MYSQL学习心得（二）》将会讲解MYSQL的触发器&lt;/p&gt;
&lt;p&gt;触发器是一个特殊的存储过程，不同的是存储过程要用CALL来调用，而触发器不需要使用CALL&lt;/p&gt;
&lt;p&gt;也不需要手工启动，只要当一个预定义的事件发生的时候，就会被MYSQL自动调用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;创建触发器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TRIGGER trigger_name trigger_time trigger_event
    ON tbl_name FOR EACH ROW trigger_stmt&lt;/pre&gt;
&lt;p&gt;触发程序是与表有关的命名数据库对象，当表上出现特定事件时，将激活该对象。&lt;/p&gt;
&lt;p&gt;触发程序与命名为tbl_name的表相关。tbl_name必须引用永久性表。不能将触发程序与临时表表或视图关联起来。&lt;/p&gt;
&lt;p&gt;trigger_time是触发程序的动作时间。它可以是BEFORE或AFTER，以指明触发程序是在激活它的语句之前或之后触发。&lt;/p&gt;
&lt;p&gt;trigger_event指明了激活触发程序的语句的类型。trigger_event可以是下述值之一：&lt;/p&gt;
&lt;p&gt;·         INSERT：将新行插入表时激活触发程序，例如，通过INSERT、LOAD DATA和REPLACE语句。&lt;/p&gt;
&lt;p&gt;·         UPDATE：更改某一行时激活触发程序，例如，通过UPDATE语句。&lt;/p&gt;
&lt;p&gt;·         DELETE：从表中删除某一行时激活触发程序，例如，通过DELETE和REPLACE语句。&lt;/p&gt;
&lt;p&gt;请注意，trigger_event与以表操作方式激活触发程序的SQL语句并不很类似，这点很重要。&lt;/p&gt;
&lt;p&gt;例如，关于INSERT的BEFORE触发程序不仅能被INSERT语句激活，也能被&lt;strong&gt;LOAD DATA&lt;/strong&gt;语句激活。&lt;/p&gt;
&lt;p&gt;可能会造成混淆的例子之一是INSERT INTO .. ON DUPLICATE UPDATE …语法：BEFORE INSERT触发程序对于每一行将激活，后跟AFTER INSERT触发程序，或BEFORE UPDATE和AFTER UPDATE触发程序，具体情况取决于行上是否有重复键。&lt;/p&gt;
&lt;p&gt;对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。&lt;/p&gt;
&lt;p&gt;例如，对于某一表，不能有两个&lt;strong&gt;BEFORE UPDATE&lt;/strong&gt;触发程序。&lt;/p&gt;
&lt;p&gt;但可以有1个BEFORE UPDATE触发程序和1个BEFORE INSERT触发程序，或1个BEFORE UPDATE触发程序和1个AFTER UPDATE触发程序。&lt;/p&gt;
&lt;p&gt;trigger_stmt是当触发程序激活时执行的语句。&lt;/p&gt;
&lt;p&gt;如果你打算执行多个语句，可使用BEGIN … END复合语句结构。这样，就能使用存储子程序中允许的相同语句。&lt;/p&gt;
&lt;p&gt;创建一个单执行语句的触发器&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE account(acct_num INT ,amount DECIMAL(10,2));
CREATE TRIGGER ins_sum BEFORE INSERT ON account
FOR EACH ROW SET @SUM=@SUM+new.amount;&lt;/pre&gt;
&lt;p&gt;首先创建一个account表，表中有两个字段，分别为：acct_num字段（定义为int类型）&lt;/p&gt;
&lt;p&gt;amount字段（定义成浮点类型）；其次创建一个名为ins_sum的触发器，触发的条件是向数据表account插入数据之前，&lt;/p&gt;
&lt;p&gt;对新插入的amount字段值进行求和计算&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DECLARE @num INT
SET @num=0
INSERT INTO account VALUES(1,1.00),(2,2.00)
SELECT @num&lt;/pre&gt;
&lt;p&gt;首先创建一个account表，在向表account插入数据之前，计算所有新插入的account表的amount值之和，&lt;/p&gt;
&lt;p&gt;触发器的名称为ins_num，条件是在向表插入数据之前触发。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c9de510134bbb8ea6a40064f33cf7e74.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;创建有多个执行语句的触发器，语法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DELIMITER |

CREATE TRIGGER testref BEFORE INSERT ON test1
  FOR EACH ROW BEGIN
    INSERT INTO test2 SET a2 = NEW.a1;
    DELETE FROM test3 WHERE a3 = NEW.a1;  
    UPDATE test4 SET b4 = b4 + 1 WHERE a4 = NEW.a1;
  END
|&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;查看触发器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看触发器是指数据库中已存在的触发器的定义、状态、语法信息等。&lt;/p&gt;
&lt;p&gt;可以使用SHOW TRIGGERS 和在TRIGGERS 表中查看触发器信息&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW TRIGGERS&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Trigger  Event   Table    Statement                 Timing  Created  sql_mode  Definer         character_set_client  collation_connection  Database Collation
-------  ------  -------  ------------------------  ------  -------  --------  --------------  --------------------  --------------------  ------------------
ins_sum  INSERT  account  set @sum=@sum+new.amount  BEFORE  (NULL)             root@localhost  utf8                  utf8_general_ci       utf8_general_ci&lt;/pre&gt;
&lt;p&gt;EVENT表示激活触发器的事件，这里的触发事件为插入操作INSERT，TABLE表示激活触发器的对象表，这里为account 表&lt;/p&gt;
&lt;p&gt;Timing表示触发器的时间，为插入之前（BEFORE）；Statement 表示触发器执行的操作，还有一些其他信息，比如SQL模式，触发器的定义帐户和字符集等&lt;/p&gt;
&lt;p&gt;在TRIGGERS 表中查看触发器信息&lt;/p&gt;
&lt;p&gt;information_schema数据库的TRIGGERS 表中，可以通过查询查看触发器信息&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM `information_schema`.`TRIGGERS` WHERE `TRIGGER_NAME`=&#39;ins_sum&#39;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;TRIGGER_CATALOG  TRIGGER_SCHEMA  TRIGGER_NAME  EVENT_MANIPULATION  EVENT_OBJECT_CATALOG  EVENT_OBJECT_SCHEMA  EVENT_OBJECT_TABLE  ACTION_ORDER  ACTION_CONDITION  ACTION_STATEMENT          ACTION_ORIENTATION  ACTION_TIMING  ACTION_REFERENCE_OLD_TABLE  ACTION_REFERENCE_NEW_TABLE  ACTION_REFERENCE_OLD_ROW  ACTION_REFERENCE_NEW_ROW  CREATED  SQL_MODE  DEFINER         CHARACTER_SET_CLIENT  COLLATION_CONNECTION  DATABASE_COLLATION
---------------  --------------  ------------  ------------------  --------------------  -------------------  ------------------  ------------  ----------------  ------------------------  ------------------  -------------  --------------------------  --------------------------  ------------------------  ------------------------  -------  --------  --------------  --------------------  --------------------  ------------------
def              school          ins_sum       INSERT              def                   school               account                        0  (NULL)            set @sum=@sum+new.amount  ROW                 BEFORE         (NULL)                      (NULL)                      OLD                       NEW                       (NULL)             root@localhost  utf8                  utf8_general_ci       utf8_general_ci&lt;/pre&gt;
&lt;p&gt;TRIGGER_SCHEMA 表示触发器所在的数据库&lt;/p&gt;
&lt;p&gt;TRIGGER_NAME表示触发器的名称&lt;/p&gt;
&lt;p&gt;EVENT_OBJECT_TABLE表示在哪个表上触发&lt;/p&gt;
&lt;p&gt;ACTION_STATEMENT 表示触发器触发的时候执行的具体操作&lt;/p&gt;
&lt;p&gt;ACTION_ORIENTATION是ROW，表示在每条记录上都触发&lt;/p&gt;
&lt;p&gt;ACTION_TIMING表示触发的时刻是BEFORE&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;删除触发器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用DROP TRIGGER 语句可以删除MYSQL中已经定义的触发器，删除触发器的基本语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP TRIGGER [schema_name.]trigger_name&lt;/pre&gt;
&lt;p&gt;其中（schema_name）是可选的&lt;/p&gt;
&lt;p&gt;如果省略了schema（方案），将从当前方案中舍弃触发程序。&lt;/p&gt;
&lt;p&gt;删除ins_sum触发器&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP TRIGGER `school`.`ins_sum`&lt;/pre&gt;
&lt;p&gt;触发器ins_sum删除成功&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于相同的表，相同的事件只能创建一个触发器，比如对表account创建了BEFORE INSERT触发器&lt;/p&gt;
&lt;p&gt;那么如果对表account再次创建一个BEFORE INSERT触发器，MYSQL就会报错，此时，只可以在表account上&lt;/p&gt;
&lt;p&gt;创建AFTER INSERT或者BEFORE UPDATE类型的触发器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2014-6-23补充&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE account(acct_num INT ,amount DECIMAL(10,2),NUM INT );

CREATE TRIGGER ins_sum BEFORE INSERT 
ON account FOR EACH ROW 
UPDATE 
  `employee` 
SET
  `Age` = new.acct_num + 1 
WHERE `ID` = new.acct_num ;

INSERT INTO account(acct_num,amount) VALUES(1,2.00);

SELECT * FROM `employee`&lt;/pre&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87355&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87355votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87355&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Fri, 05 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-05-87355-c08dd85fd.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-05-87355-c08dd85fd.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（11） ： 视图</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87340/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（7） ： 查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87345/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（8） ： 插入 更新 删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87348/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（9） ： 索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87351/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（10） ： 自定义存储过程和函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一篇《我的MYSQL学习心得（十一）》将会讲解MYSQL的视图&lt;/p&gt;
&lt;p&gt;使用视图的理由是什么？&lt;/p&gt;
&lt;p&gt;1、安全性：一般是这样做的:创建一个视图，定义好该视图所操作的数据。&lt;/p&gt;
&lt;p&gt;之后将用户权限与视图绑定，这样的方式是使用到了一个特性：grant语句可以针对视图进行授予权限。&lt;/p&gt;
&lt;p&gt;2、查询性能提高&lt;/p&gt;
&lt;p&gt;3、有灵活性的功能需求后，需要改动表的结构而导致工作量比较大，那么可以使用虚拟表的形式达到少修改的效果。&lt;/p&gt;
&lt;p&gt;这是在实际开发中比较有用的&lt;/p&gt;
&lt;p&gt;4、复杂的查询需求，可以进行问题分解，然后将创建多个视图获取数据。将视图联合起来就能得到需要的结果了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;创建视图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建视图的语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
    VIEW view_name [(column_list)]
    AS select_statement
    [WITH [CASCADED | LOCAL] CHECK OPTION]&lt;/pre&gt;
&lt;p&gt;其中，CREATE：表示新建视图；&lt;/p&gt;
&lt;p&gt;REPLACE：表示替换已有视图&lt;/p&gt;
&lt;p&gt;ALGORITHM ：表示视图选择算法&lt;/p&gt;
&lt;p&gt;view_name ：视图名&lt;/p&gt;
&lt;p&gt;column_list：属性列&lt;/p&gt;
&lt;p&gt;select_statement：表示select语句&lt;/p&gt;
&lt;p&gt;[WITH [CASCADED | LOCAL] CHECK OPTION]参数表示视图在更新时保证在视图的权限范围之内&lt;/p&gt;
&lt;p&gt;可选的ALGORITHM子句是对标准SQL的MySQL扩展。&lt;/p&gt;
&lt;p&gt;ALGORITHM可取三个值：MERGE、TEMPTABLE或UNDEFINED。&lt;/p&gt;
&lt;p&gt;如果没有ALGORITHM子句，&lt;strong&gt;默认算法是UNDEFINED（未定义的）&lt;/strong&gt;。算法会影响MySQL处理视图的方式。&lt;/p&gt;
&lt;p&gt;对于MERGE，会将引用视图的语句的文本与视图定义合并起来，使得视图定义的某一部分取代语句的对应部分。&lt;/p&gt;
&lt;p&gt;对于TEMPTABLE，视图的结果将被置于临时表中，然后使用它执行语句。&lt;/p&gt;
&lt;p&gt;对于UNDEFINED，MySQL自己选择所要使用的算法。如果可能，它倾向于MERGE而不是TEMPTABLE，&lt;/p&gt;
&lt;p&gt;这是因为MERGE通常更有效，而且如果使用了临时表，视图是不可更新的。&lt;/p&gt;
&lt;p&gt;LOCAL和CASCADED为可选参数，决定了检查测试的范围，默认值为CASCADED。&lt;/p&gt;
&lt;p&gt;脚本 视图的数据来自于两个表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE student (stuno INT ,stuname NVARCHAR(60))

CREATE TABLE stuinfo (stuno INT ,class NVARCHAR(60),city NVARCHAR(60))

INSERT INTO student VALUES(1,&#39;wanglin&#39;),(2,&#39;gaoli&#39;),(3,&#39;zhanghai&#39;)

INSERT INTO stuinfo VALUES(1,&#39;wuban&#39;,&#39;henan&#39;),(2,&#39;liuban&#39;,&#39;hebei&#39;),(3,&#39;qiban&#39;,&#39;shandong&#39;)

-- 创建视图
CREATE VIEW stu_class(id,NAME,glass) AS SELECT student.`stuno`,student.`stuname`,stuinfo.`class`
FROM student ,stuinfo WHERE student.`stuno`=stuinfo.`stuno`

SELECT * FROM stu_class&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1ff0817e3d251536ec4221101b73c94f.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;查看视图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看视图必须要有SHOW VIEW权限&lt;/p&gt;
&lt;p&gt;查看视图的方法包括：DESCRIBE、SHOW TABLE STATUS、SHOW CREATE VIEW&lt;/p&gt;
&lt;p&gt;DESCRIBE查看视图基本信息&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DESCRIBE 视图名
DESCRIBE stu_class&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/adae552d24b7270e73d3b2b369f25f1b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;结果显示了视图的字段定义、字段的数据类型、是否为空、是否为主/外键、默认值和额外信息&lt;/p&gt;
&lt;p&gt;DESCRIBE一般都简写成DESC&lt;/p&gt;
&lt;p&gt;SHOW TABLE STATUS语句查看查看视图基本信息&lt;/p&gt;
&lt;p&gt;查看视图的信息可以通过SHOW TABLE STATUS的方法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW TABLE STATUS LIKE &#39;stu_class&#39;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Name       Engine  Version  Row_format    Rows  Avg_row_length  Data_length  Max_data_length  Index_length  Data_free  Auto_increment  Create_time  Update_time  Check_time  Collation  Checksum  Create_options  Comment
---------  ------  -------  ----------  ------  --------------  -----------  ---------------  ------------  ---------  --------------  -----------  -----------  ----------  ---------  --------  --------------  -------
stu_class  (NULL)   (NULL)  (NULL)      (NULL)          (NULL)       (NULL)           (NULL)        (NULL)     (NULL)          (NULL)  (NULL)       (NULL)       (NULL)      (NULL)       (NULL)  (NULL)          VIEW&lt;/pre&gt;
&lt;p&gt;COMMENT的值为VIEW说明该表为视图，其他的信息为NULL说明这是一个虚表，如果是基表那么会基表的信息，这是基表和视图的区别&lt;/p&gt;
&lt;p&gt;SHOW CREATE VIEW语句查看视图详细信息&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE VIEW stu_class&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;View       Create View                                                                                                                                                                                                                                                               character_set_client  collation_connection
---------  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  --------------------  --------------------
stu_class  CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `stu_class` AS select `student`.`stuno` AS `id`,`student`.`stuname` AS `name`,`stuinfo`.`class` AS `class` from (`student` join `stuinfo`) where (`student`.`stuno` = `stuinfo`.`stuno`)  utf8                  utf8_general_ci&lt;/pre&gt;
&lt;p&gt;执行结果显示视图的名称、创建视图的语句等信息&lt;/p&gt;
&lt;p&gt;在VIEWS表中查看视图的详细信息&lt;/p&gt;
&lt;p&gt;在MYSQL中，INFORMATION_SCHEMA VIEWS表存储了关于数据库中的视图的信息&lt;/p&gt;
&lt;p&gt;通过对VIEWS表的查询可以查看数据库中所有视图的详细信息&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM `information_schema`.`VIEWS`&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;TABLE_CATALOG  TABLE_SCHEMA  TABLE_NAME  VIEW_DEFINITION                                                                                                                                                                                                                         CHECK_OPTION  IS_UPDATABLE  DEFINER         SECURITY_TYPE  CHARACTER_SET_CLIENT  COLLATION_CONNECTION
-------------  ------------  ----------  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ------------  ------------  --------------  -------------  --------------------  --------------------
def            school        stu_class   select `school`.`student`.`stuno` AS `id`,`school`.`student`.`stuname` AS `name`,`school`.`stuinfo`.`class` AS `class` from `school`.`student` join `school`.`stuinfo` where (`school`.`student`.`stuno` = `school`.`stuinfo`.`stuno`)  NONE          YES           root@localhost  DEFINER        utf8                  utf8_general_ci&lt;/pre&gt;
&lt;p&gt;当前实例下只有一个视图stu_class&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ced55d9d4ebf0284a349ec5a0140ddaa.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;修改视图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改视图是指修改数据库中存在的视图，当基本表的某些字段发生变化时，可以通过修改视图来保持与基本表的一致性。&lt;/p&gt;
&lt;p&gt;MYSQL中通过CREATE OR REPLACE VIEW 语句和ALTER语句来修改视图&lt;/p&gt;
&lt;p&gt;语法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER OR REPLACE [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
VIEW view_name [(column_list)]
AS select_statement
[WITH [CASCADED | LOCAL] CHECK OPTION]&lt;/pre&gt;
&lt;p&gt;该语句用于更改已有视图的定义。其语法与CREATE VIEW类似。当视图不存在时创建，存在时进行修改&lt;/p&gt;
&lt;p&gt;修改视图&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DELIMITER &lt;span class=&quot;MathJax_Preview&quot;&gt;\(

CREATE OR REPLACE VIEW `stu_class` AS 
SELECT
  `student`.`stuno`   AS `id`
FROM (`student` JOIN `stuinfo`)
WHERE (`student`.`stuno` = `stuinfo`.`stuno`)\)&lt;/span&gt;

DELIMITER ;&lt;/pre&gt;
&lt;p&gt;通过DESC来查看更改之后的视图定义&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DESC stu_class&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8879d4d2cf049f8f34de18597c2a101f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到只查询一个字段&lt;/p&gt;
&lt;p&gt;ALTER语句修改视图&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
VIEW view_name [(column_list)]
AS select_statement
[WITH [CASCADED | LOCAL] CHECK OPTION]&lt;/pre&gt;
&lt;p&gt;这里关键字跟前面的一样，这里不做介绍&lt;/p&gt;
&lt;p&gt;使用ALTER语句修改视图 stu_class&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER VIEW  stu_class AS SELECT stuno FROM student;&lt;/pre&gt;
&lt;p&gt;使用DESC查看&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DESC stu_class&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1c7b0cb195b4334ba6e7ced822b88f85.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/70ac03f4d1176f87faf7c7533928ff61.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;更新视图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更新视图是指通过视图来插入、更新、删除表数据，因为视图是虚表，其中没有数据。&lt;/p&gt;
&lt;p&gt;通过视图更新的时候都是转到基表进行更新，如果对视图增加或者删除记录，实际上是对基表增加或删除记录&lt;/p&gt;
&lt;p&gt;我们先修改一下视图定义&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER VIEW  stu_class AS SELECT stuno,stuname FROM student;&lt;/pre&gt;
&lt;p&gt;查询视图数据&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/db46e7816796354001ec3cd13a74c838.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;UPDATE stu_class SET stuname=&#39;xiaofang&#39; WHERE stuno=2&lt;/pre&gt;
&lt;p&gt;查询视图数据&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/97873cb54ae68d572120708ccf303854.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;更新成功&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;INSERT&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO stu_class VALUES(6,&#39;haojie&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e87e01547e4ffaa8875f0a8e7432cc68.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;插入成功&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DELETE&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DELETE FROM stu_class WHERE stuno=1&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/446eb4c53a80203018760671df5d27ee.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;删除成功&lt;/p&gt;
&lt;p&gt;当视图中包含如下内容的时候，视图的更新操作将不能被执行&lt;/p&gt;
&lt;p&gt;（1）视图中包含基本中被定义为非空的列&lt;/p&gt;
&lt;p&gt;（2）定义视图的SELECT语句后的字段列表中使用了数学表达式&lt;/p&gt;
&lt;p&gt;（3）定义视图的SELECT语句后的字段列表中使用聚合函数&lt;/p&gt;
&lt;p&gt;（4）定义视图的SELECT语句中使用了DISTINCT、UNION、TOP、GROUP BY 、HAVING子句&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;删除视图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除视图使用DROP VIEW语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP VIEW [IF EXISTS]
view_name [, view_name] ...
[RESTRICT | CASCADE]&lt;/pre&gt;
&lt;p&gt;DROP VIEW能够删除1个或多个视图。必须在每个视图上拥有DROP权限&lt;/p&gt;
&lt;p&gt;可以使用关键字IF EXISTS来防止因不存在的视图而出错&lt;/p&gt;
&lt;p&gt;删除stu_class视图&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP VIEW IF EXISTS stu_class&lt;/pre&gt;
&lt;p&gt;如果名称为 stu_class 的视图存在则删除&lt;/p&gt;
&lt;p&gt;使用SHOW CREATE VIEW语句查看结果&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE VIEW stu_class&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Query: -- update stu_class set stuname=&#39;xiaofang&#39; where stuno=2; -- delete from stu_class where stuno=1 -- select * from stu_class; -- ...

Error Code: 1146
Table &#39;school.stu_class&#39; doesn&#39;t exist

Execution Time : 0 sec
Transfer Time  : 0 sec
Total Time     : 0.004 sec
---------------------------------------------------&lt;/pre&gt;
&lt;p&gt;该视图不存在，删除成功&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQLSERVER&lt;/strong&gt;里实际上跟&lt;strong&gt;MYSQL&lt;/strong&gt;一样，也是有信息架构视图的&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://technet.microsoft.com/zh-cn/library/ms186778.aspx&quot; href=&quot;http://technet.microsoft.com/zh-cn/library/ms186778.aspx&quot; target=&quot;_blank&quot;&gt;信息架构视图 (Transact-SQL)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;信息架构视图是 SQL Server 提供的几种获取元数据的方法之一。&lt;/p&gt;
&lt;p&gt;信息架构视图提供独立于系统表的内部 SQL Server 元数据视图。&lt;/p&gt;
&lt;p&gt;尽管已经对基础系统表进行了重要的修改，信息架构视图仍然可使应用程序正常工作。&lt;/p&gt;
&lt;p&gt;SQL Server 中包含的信息架构视图符合 ISO 标准中的信息架构定义。&lt;/p&gt;
&lt;p&gt;信息架构视图的数据是存放在系统数据库&lt;a title=&quot;http://technet.microsoft.com/zh-cn/library/ms190940.aspx&quot; href=&quot;http://technet.microsoft.com/zh-cn/library/ms190940.aspx&quot; target=&quot;_blank&quot;&gt;Resource 数据库&lt;/a&gt;里面&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mssqlsystemresource.mdf&lt;/pre&gt;
&lt;p&gt;&lt;a title=&quot;http://social.msdn.microsoft.com/Forums/zh-CN/eb3805d6-7b78-4b00-9aba-b362223b1290/sql-?forum=sqlserverzhchs&quot; href=&quot;http://social.msdn.microsoft.com/Forums/zh-CN/eb3805d6-7b78-4b00-9aba-b362223b1290/sql-?forum=sqlserverzhchs&quot; target=&quot;_blank&quot;&gt;利用INFORMATION_SCHEMA视图来拼接 SQL 语句&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87353&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87353votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87353&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Fri, 05 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-05-87353-b35b17c0a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-05-87353-b35b17c0a.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（10） ： 自定义存储过程和函数</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87340/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（7） ： 查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87345/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（8） ： 插入 更新 删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87348/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（9） ： 索引&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一篇《我的MYSQL学习心得（十）》将会讲解MYSQL的存储过程和函数&lt;/p&gt;
&lt;p&gt;MYSQL中创建存储过程和函数分别使用CREATE PROCEDURE和CREATE FUNCTION&lt;/p&gt;
&lt;p&gt;使用CALL语句来调用存储过程，存储过程也可以调用其他存储过程&lt;/p&gt;
&lt;p&gt;函数可以从语句外调用，能返回标量值&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;创建存储过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE PROCEDURE sp_name ([ proc_parameter ]) [ characteristics..] routine_body&lt;/pre&gt;
&lt;p&gt;proc_parameter指定存储过程的参数列表，列表形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[IN|OUT|INOUT] param_name type&lt;/pre&gt;
&lt;p&gt;其中in表示输入参数，out表示输出参数，inout表示既可以输入也可以输出；param_name表示参数名称；type表示参数的类型&lt;/p&gt;
&lt;p&gt;该类型可以是MYSQL数据库中的任意类型&lt;/p&gt;
&lt;p&gt;有以下取值：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;characteristic: 
    LANGUAGE SQL 
  | [NOT] DETERMINISTIC 
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } 
  | SQL SECURITY { DEFINER | INVOKER } 
  | COMMENT &#39;string&#39; 
routine_body: 
    Valid SQL procedure statement or statements&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LANGUAGE SQL&lt;/strong&gt; ：说明routine_body部分是由SQL语句组成的，当前系统支持的语言为SQL，SQL是LANGUAGE特性的唯一值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[NOT] DETERMINISTIC&lt;/strong&gt; ：指明存储过程执行的结果是否正确。DETERMINISTIC 表示结果是确定的。每次执行存储过程时，相同的输入会得到&lt;/p&gt;
&lt;p&gt;相同的输出。&lt;/p&gt;
&lt;p&gt;[NOT] DETERMINISTIC 表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为[NOT] DETERMINISTIC&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&lt;/strong&gt;：指明子程序使用SQL语句的限制。&lt;/p&gt;
&lt;p&gt;CONTAINS SQL表明子程序包含SQL语句，但是不包含读写数据的语句；&lt;/p&gt;
&lt;p&gt;NO SQL表明子程序不包含SQL语句；&lt;/p&gt;
&lt;p&gt;READS SQL DATA：说明子程序包含读数据的语句；&lt;/p&gt;
&lt;p&gt;MODIFIES SQL DATA表明子程序包含写数据的语句。&lt;/p&gt;
&lt;p&gt;默认情况下，系统会指定为CONTAINS SQL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL SECURITY { DEFINER | INVOKER }&lt;/strong&gt; ：指明谁有权限来执行。DEFINER 表示只有定义者才能执行&lt;/p&gt;
&lt;p&gt;INVOKER 表示拥有权限的调用者可以执行。默认情况下，系统指定为DEFINER&lt;/p&gt;
&lt;p&gt;COMMENT ‘string’ ：注释信息，可以用来描述存储过程或函数&lt;/p&gt;
&lt;p&gt;routine_body是SQL代码的内容，可以用BEGIN…END来表示SQL代码的开始和结束。&lt;/p&gt;
&lt;p&gt;下面的语句创建一个查询t1表全部数据的存储过程&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP PROCEDURE IF EXISTS Proc; 

DELIMITER //
CREATE PROCEDURE Proc() 
BEGIN
  SELECT * FROM t3;
END//
DELIMITER ;

CALL Proc();&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/22a685e7909890673385fe67966d953d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;t3表是我们上一节创建的表&lt;/p&gt;
&lt;p&gt;这里的逻辑是&lt;/p&gt;
&lt;p&gt;1、先判断是否有Proc() 这个存储过程，有就drop掉&lt;/p&gt;
&lt;p&gt;2、创建Proc() 存储过程&lt;/p&gt;
&lt;p&gt;3、执行Proc() 存储过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：“DELIMITER //”语句的作用是将MYSQL的结束符设置为//，因为MYSQL默认的语句结束符为分号;，为了避免与存储过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中SQL语句结束符相冲突，需要使用DELIMITER 改变存储过程的结束符，并以“END//”结束存储过程。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你是这样写的话，就会得到如下错误，初学者很容易犯这个错误，包括本人&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE PROCEDURE Proc() 
BEGIN
  SELECT * FROM t3;
END

Query: CREATE PROCEDURE Proc() BEGIN SELECT * FROM t3

Error Code: 1064
You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; at line 3

Execution Time : 0 sec
Transfer Time  : 0 sec
Total Time     : 0.001 sec
---------------------------------------------------

Query: END 

Error Code: 1064&lt;/pre&gt;
&lt;p&gt;创建名为CountProc的存储过程，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DELIMITER //
CREATE PROCEDURE CountProc(OUT param1 INT)
BEGIN
SELECT    COUNT(*) INTO  param1 FROM t3;
END//
DELIMITER ;&lt;/pre&gt;
&lt;p&gt;上面代码的作用是创建一个获取t3表记录数的存储过程，名称是CountProc，&lt;/p&gt;
&lt;p&gt;COUNT(*)计算后把结果放入参数param1中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：当使用DELIMITER命令时，应该避免使用反斜杠（\）字符，因为反斜杠是MYSQL的转义字符！！！&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;存储函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建存储函数，需要使用CREATE FUNCTION语句，基本语法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE FUNCTION func_name([func_parameter])
RETURNS TYPE
[characteristics...] routine_body&lt;/pre&gt;
&lt;p&gt;CREATE FUNCTION为用来创建存储函数的关键字；func_name表示存储函数的名称&lt;/p&gt;
&lt;p&gt;func_parameter为存储函数的参数列表，参数列表如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[IN|OUT|INOUT]PARAM_NAMETYPE&lt;/pre&gt;
&lt;p&gt;其中，IN表示输入参数，OUT表示输出参数，INOUT表示既可以输入也可以输出；&lt;/p&gt;
&lt;p&gt;param_name表示参数名称；type表示参数类型，该类型可以是MYSQL数据库中的任意类型&lt;/p&gt;
&lt;p&gt;RETURNS TYPE语句表示函数返回数据的类型；characteristics：指定存储函数的特性，取值与创建存储过程时相同&lt;/p&gt;
&lt;p&gt;创建存储函数，名称为NameByT，该函数返回SELECT语句的查询结果，数值类型为字符串型&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DELIMITER //

CREATE FUNCTION NameByT()
RETURNS CHAR(50)
RETURN (SELECT NAME FROM t3 WHERE id=2);
//
DELIMITER ;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：RETURNS CHAR(50)数据类型的时候，RETURNS 是有S的，而RETURN (SELECT NAME FROM t3 WHERE id=2)的时候RETURN是没有S的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以有时候大家可能觉得MYSQL很烦，谁不知是自己写错了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里有一个方法，就是利用SQLYOG的代码格式化功能，选中要格式化的代码，然后按F12，如果能格式化，证明你的代码没有问题，如果不能格式化&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不加s的话就会出现语法错误了&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Query: create function NameByT() return char(50) return (select name from t3 where id=2)

Error Code: 1064
You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;return char(50)
return (select name from t3 where id=2)&#39; at line 2

Execution Time : 0 sec
Transfer Time  : 0 sec
Total Time     : 0.003 sec
-----------------------------&lt;/pre&gt;
&lt;p&gt;调用函数&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT nameByT()&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b63b20cd7c96fcf4167a765d7fa9c4a4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果在存储函数中的RETURN语句返回一个类型不同于函数的RETURNS子句中指定类型的值，返回值将被强制转换为恰当的类型。&lt;/p&gt;
&lt;p&gt;例如，如果一个函数返回一个SET或ENUM值，但是RETURN语句返回一个整数，对于SET成员集的相应ENUM成员，从函数返回的值&lt;/p&gt;
&lt;p&gt;是字符串。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;指定参数为IN、OUT、INOUT只对PROCEDURE是合法的。&lt;/p&gt;
&lt;p&gt;（FUNCTION中总是默认是IN参数）RETURNS子句对FUNCTION做指定，对函数而言这是强制的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;变量的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变量可以在子程序中声明并使用，这些变量的作用范围是在BEGIN…END程序中&lt;/p&gt;
&lt;p&gt;1、定义变量&lt;/p&gt;
&lt;p&gt;在存储过程中定义变量&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DECLARE var_name[,varname]...date_type[DEFAULT VALUE];&lt;/pre&gt;
&lt;p&gt;var_name为局部变量的名称。DEFAULT VALUE子句给变量提供一个默认值。值除了可以被声明为一个常数外，还可以被指定为一个表达式。&lt;/p&gt;
&lt;p&gt;如果没有DEFAULT子句，初始值为NULL&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DECLARE MYPARAM INT DEFAULT 100;&lt;/pre&gt;
&lt;p&gt;2、为变量赋值&lt;/p&gt;
&lt;p&gt;定义变量之后，为变量赋值可以改变变量的默认值，MYSQL中使用SET语句为变量赋值&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SET var_name=expr[,var_name=expr]...&lt;/pre&gt;
&lt;p&gt;在存储过程中的SET语句是一般SET语句的扩展版本。&lt;/p&gt;
&lt;p&gt;被SET的变量可能是子程序内的变量，或者是全局服务器变量，如系统变量或者用户变量&lt;/p&gt;
&lt;p&gt;他运行SET a=x,b=y,….&lt;/p&gt;
&lt;p&gt;声明3个变量，分别为var1，var2和var3&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DECLARE var1,var2,var3 INT;
SET var1=10,var2=20;
SET var3=var1+var2;&lt;/pre&gt;
&lt;p&gt;MYSQL中还可以通过SELECT…INTO为一个或多个变量赋值&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DECLARE NAME CHAR(50);
DECLARE id DECIMAL(8,2);
SELECT id,NAME INTO id ,NAME FROM t3 WHERE id=2;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;定义条件和处理程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特定条件需要特定处理。这些条件可以联系到错误，以及子程序中的一般流程控制。定义条件是事先定义程序执行过程中遇到的问题，&lt;/p&gt;
&lt;p&gt;处理程序定义了在遇到这些问题时候应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。&lt;/p&gt;
&lt;p&gt;这样可以增强存储程序处理问题的能力，避免程序异常停止运行&lt;/p&gt;
&lt;p&gt;1、定义条件&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DECLARE condition_name CONDITION FOR[condition_type]
[condition_type]:
SQLSTATE[VALUE] sqlstate_value |mysql_error_code&lt;/pre&gt;
&lt;p&gt;condition_name：表示条件名称&lt;/p&gt;
&lt;p&gt;condition_type：表示条件的类型&lt;/p&gt;
&lt;p&gt;sqlstate_value和mysql_error_code都可以表示mysql错误&lt;/p&gt;
&lt;p&gt;sqlstate_value为长度5的字符串错误代码&lt;/p&gt;
&lt;p&gt;mysql_error_code为数值类型错误代码，例如：ERROR1142(42000)中，sqlstate_value的值是42000，&lt;/p&gt;
&lt;p&gt;mysql_error_code的值是1142&lt;/p&gt;
&lt;p&gt;这个语句指定需要特殊处理条件。他将一个名字和指定的错误条件关联起来。&lt;/p&gt;
&lt;p&gt;这个名字随后被用在定义处理程序的DECLARE HANDLER语句中&lt;/p&gt;
&lt;p&gt;定义ERROR1148(42000)错误，名称为command_not_allowed。&lt;/p&gt;
&lt;p&gt;可以用两种方法定义&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;//方法一：使用sqlstate_value
DECLARE command_not_allowed CONDITION FOR SQLSTATE &#39;42000&#39;

//方法二：使用mysql_error_code
DECLARE command_not_allowed CONDITION FOR SQLSTATE 1148&lt;/pre&gt;
&lt;p&gt;2．定义处理程序&lt;/p&gt;
&lt;p&gt;MySQL中可以使用DECLARE关键字来定义处理程序。其基本语法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DECLARE handler_type HANDLER FOR 
condition_value[,...] sp_statement 
handler_type: 
CONTINUE | EXIT | UNDO 
condition_value: 
SQLSTATE [VALUE] sqlstate_value |
condition_name | SQLWARNING 
| NOT FOUND | SQLEXCEPTION | mysql_error_code&lt;/pre&gt;
&lt;p&gt;其中，handler_type参数指明错误的处理方式，该参数有3个取值。这3个取值分别是CONTINUE、EXIT和UNDO。&lt;/p&gt;
&lt;p&gt;CONTINUE表示遇到错误不进行处理，继续向下执行；&lt;/p&gt;
&lt;p&gt;EXIT表示遇到错误后马上退出；&lt;/p&gt;
&lt;p&gt;UNDO表示遇到错误后撤回之前的操作，MySQL中暂时还不支持这种处理方式。&lt;/p&gt;
&lt;p&gt;注意：通常情况下，执行过程中遇到错误应该立刻停止执行下面的语句，并且撤回前面的操作。&lt;/p&gt;
&lt;p&gt;但是，MySQL中现在还不能支持UNDO操作。&lt;/p&gt;
&lt;p&gt;因此，遇到错误时最好执行EXIT操作。如果事先能够预测错误类型，并且进行相应的处理，那么可以执行CONTINUE操作。&lt;/p&gt;
&lt;p&gt;condition_value参数指明错误类型，该参数有6个取值。&lt;/p&gt;
&lt;p&gt;sqlstate_value和mysql_error_code与条件定义中的是同一个意思。&lt;/p&gt;
&lt;p&gt;condition_name是DECLARE定义的条件名称。&lt;/p&gt;
&lt;p&gt;SQLWARNING表示所有以01开头的sqlstate_value值。&lt;/p&gt;
&lt;p&gt;NOT FOUND表示所有以02开头的sqlstate_value值。&lt;/p&gt;
&lt;p&gt;SQLEXCEPTION表示所有没有被SQLWARNING或NOT FOUND捕获的sqlstate_value值。&lt;/p&gt;
&lt;p&gt;sp_statement表示一些存储过程或函数的执行语句。&lt;/p&gt;
&lt;p&gt;下面是定义处理程序的几种方式。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;//方法一：捕获sqlstate_value 
DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;42000&#39;
SET @info=&#39;CAN NOT FIND&#39;; 
//方法二：捕获mysql_error_code 
DECLARE CONTINUE HANDLER FOR &amp;lt;strong&amp;gt;1148&amp;lt;/strong&amp;gt;SET @info=&#39;CAN NOT FIND&#39;; 
//方法三：先定义条件，然后调用 
DECLARE can_not_find CONDITION FOR 1146 ; 
DECLARE CONTINUE HANDLER FOR can_not_find SET 
@info=&#39;CAN NOT FIND&#39;; 
//方法四：使用SQLWARNING 
DECLARE EXIT HANDLER FOR SQLWARNING SET @info=&#39;ERROR&#39;; 
//方法五：使用NOT FOUND 
DECLARE EXIT HANDLER FOR NOT FOUND SET @info=&#39;CAN NOT FIND&#39;; 
//方法六：使用SQLEXCEPTION 
DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info=&#39;ERROR&#39;;&lt;/pre&gt;
&lt;p&gt;上述代码是6种定义处理程序的方法。&lt;/p&gt;
&lt;p&gt;第一种方法是捕获sqlstate_value值。如果遇到sqlstate_value值为42000，执行CONTINUE操作，并且输出”CAN NOT FIND”信息。&lt;/p&gt;
&lt;p&gt;第二种方法是捕获mysql_error_code值。如果遇到mysql_error_code值为1148，执行CONTINUE操作，并且输出”CAN NOT FIND”信息。&lt;/p&gt;
&lt;p&gt;第三种方法是先定义条件，然后再调用条件。这里先定义can_not_find条件，遇到1148错误就执行CONTINUE操作。&lt;/p&gt;
&lt;p&gt;第四种方法是使用SQLWARNING。SQLWARNING捕获所有以01开头的sqlstate_value值，然后执行EXIT操作，并且输出”ERROR”信息。&lt;/p&gt;
&lt;p&gt;第五种方法是使用NOT FOUND。NOT FOUND捕获所有以02开头的sqlstate_value值，然后执行EXIT操作，并且输出”CAN NOT FIND”信息。&lt;/p&gt;
&lt;p&gt;第六种方法是使用SQLEXCEPTION。SQLEXCEPTION捕获所有没有被SQLWARNING或NOT FOUND捕获的sqlstate_value值，然后执行EXIT操作，并且输出”ERROR”信息&lt;/p&gt;
&lt;p&gt;定义条件和处理程序&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t8(s1 INT,PRIMARY KEY(s1))

DELIMITER //
CREATE PROCEDURE handlerdemo()
BEGIN
DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;23000&#39; SET @X2=1;
SET @X=1;
INSERT INTO t8 VALUES(1);
SET @X=2;
INSERT INTO t8 VALUES(1);
SET @X=3;
END;
//
DELIMITER ;

/* 调用存储过程*/
CALL handlerdemo();

/* 查看调用存储过程结果*/
SELECT @X&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e5babb3004c51af760eb55b5ef533fc4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;@X是一个用户变量，执行结果@X等于3，这表明MYSQL执行到程序的末尾。&lt;/p&gt;
&lt;p&gt;如果DECLARE CONTINUE HANDLER FOR SQLSTATE ’23000′ SET @X2=1;，这一行不存在&lt;/p&gt;
&lt;p&gt;第二个INSERT因PRIMARY KEY约束而失败之后，MYSQL可能已经采取EXIT策略，并且SELECT @X可能已经返回2&lt;/p&gt;
&lt;p&gt;注意：@X表示用户变量，使用SET语句为其赋值，用户变量与连接有关，一个客户端定义的变量不能被其他客户端所使用&lt;/p&gt;
&lt;p&gt;即有作用域的，该客户端退出时，客户端连接的所有变量将自动释放&lt;/p&gt;
&lt;p&gt;这里的变量跟SQLSERVER没有什么区别，都是用来存储临时值的&lt;/p&gt;
&lt;p&gt;MYSQL这里的条件和预定义程序其实跟&lt;a title=&quot;http://www.cnblogs.com/renyb/archive/2012/05/23/2515139.html&quot; href=&quot;http://www.cnblogs.com/renyb/archive/2012/05/23/2515139.html&quot; target=&quot;_blank&quot;&gt;SQLSERVER的自定义错误&lt;/a&gt;是一样的&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;光标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MYSQL里叫光标，SQLSERVER里叫游标，实际上一样的&lt;/p&gt;
&lt;p&gt;查询语句可能查询出多条记录，在存储过程和函数中使用光标来逐条读取查询结果集中的记录。&lt;/p&gt;
&lt;p&gt;光标的使用包括声明光标、打开光标、使用光标和关闭光标。光标必须声明在处理程序之前，并且声明在变量和条件之后。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1．声明光标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL中使用DECLARE关键字来声明光标。其语法的基本形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DECLARE cursor_name CURSOR FOR select_statement ;&lt;/pre&gt;
&lt;p&gt;其中，cursor_name参数表示光标的名称；select_statement参数表示SELECT语句的内容，返回一个用于创建光标的结果集&lt;/p&gt;
&lt;p&gt;下面声明一个名为cur_employee的光标。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DECLARE cur_employee CURSOR FOR SELECT name, age FROM employee ;&lt;/pre&gt;
&lt;p&gt;上面的示例中，光标的名称为cur_employee；SELECT语句部分是从employee表中查询出name和age字段的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2．打开光标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL中使用OPEN关键字来打开光标。其语法的基本形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;OPEN  cursor_name ;&lt;/pre&gt;
&lt;p&gt;其中，cursor_name参数表示光标的名称。&lt;/p&gt;
&lt;p&gt;下面打开一个名为cur_employee的光标，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;OPEN  cur_employee ;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3．使用光标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL中使用FETCH关键字来使用光标。其语法的基本形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;FETCH cur_employee INTO var_name[,var_name…] ;&lt;/pre&gt;
&lt;p&gt;其中，cursor_name参数表示光标的名称；var_name参数表示将光标中的SELECT语句查询出来的信息存入该参数中。var_name必须在声明光标之前就定义好。&lt;/p&gt;
&lt;p&gt;下面使用一个名为cur_employee的光标。将查询出来的数据存入emp_name和emp_age这两个变量中，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;FETCH  cur_employee INTO emp_name, emp_age ;&lt;/pre&gt;
&lt;p&gt;上面的示例中，将光标cur_employee中SELECT语句查询出来的信息存入emp_name和emp_age中。emp_name和emp_age必须在前面已经定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4．关闭光标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL中使用CLOSE关键字来关闭光标。其语法的基本形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CLOSE  cursor_name ;&lt;/pre&gt;
&lt;p&gt;其中，cursor_name参数表示光标的名称。&lt;/p&gt;
&lt;p&gt;【示例14-11】 下面关闭一个名为cur_employee的光标。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CLOSE  cur_employee ;&lt;/pre&gt;
&lt;p&gt;上面的示例中，关闭了这个名称为cur_employee的光标。关闭之后就不能使用FETCH来使用光标了。&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;到目前为止存储函数，存储过程、变量、条件、预定义程序、光标跟SQLSERVER差不多，只不过语法不同，结构不同&lt;/p&gt;
&lt;p&gt;刚开始的时候会有不适应&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;流程控制的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储过程和函数中可以使用流程控制来控制语句的执行。&lt;/p&gt;
&lt;p&gt;MySQL中可以使用IF语句、CASE语句、LOOP语句、LEAVE语句、ITERATE语句、REPEAT语句和WHILE语句来进行流程控制。&lt;/p&gt;
&lt;p&gt;每个流程中可能包含一个单独语句，或者是使用BEGIN…END构造的复合语句，构造可以被嵌套&lt;/p&gt;
&lt;p&gt;1．IF语句&lt;/p&gt;
&lt;p&gt;IF语句用来进行条件判断。根据是否满足条件，将执行不同的语句。其语法的基本形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;IF search_condition THEN statement_list 
[ELSEIF search_condition THEN statement_list] ... 
[ELSE statement_list] 
END IF&lt;/pre&gt;
&lt;p&gt;其中，search_condition参数表示条件判断语句；statement_list参数表示不同条件的执行语句。&lt;/p&gt;
&lt;p&gt;注意：MYSQL还有一个IF()函数，他不同于这里描述的IF语句&lt;/p&gt;
&lt;p&gt;下面是一个IF语句的示例。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;IF age&amp;gt;20 THEN SET @count1=@count1+1;  
ELSEIF age=20 THEN SET @count2=@count2+1;  
ELSE SET @count3=@count3+1;  
END IF;&lt;/pre&gt;
&lt;p&gt;该示例根据age与20的大小关系来执行不同的SET语句。&lt;/p&gt;
&lt;p&gt;如果age值大于20，那么将count1的值加1；如果age值等于20，那么将count2的值加1；&lt;/p&gt;
&lt;p&gt;其他情况将count3的值加1。IF语句都需要使用END IF来结束。&lt;/p&gt;
&lt;p&gt;2．CASE语句&lt;/p&gt;
&lt;p&gt;CASE语句也用来进行条件判断，其可以实现比IF语句更复杂的条件判断。CASE语句的基本形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CASE case_value 
WHEN when_value THEN statement_list 
[WHEN when_value THEN statement_list] ... 
[ELSE statement_list] 
END CASE&lt;/pre&gt;
&lt;p&gt;其中，case_value参数表示条件判断的变量；&lt;/p&gt;
&lt;p&gt;when_value参数表示变量的取值；&lt;/p&gt;
&lt;p&gt;statement_list参数表示不同when_value值的执行语句。&lt;/p&gt;
&lt;p&gt;CASE语句还有另一种形式。该形式的语法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CASE 
WHEN search_condition THEN statement_list 
[WHEN search_condition THEN statement_list] ... 
[ELSE statement_list] 
END CASE&lt;/pre&gt;
&lt;p&gt;其中，search_condition参数表示条件判断语句；&lt;/p&gt;
&lt;p&gt;statement_list参数表示不同条件的执行语句。&lt;/p&gt;
&lt;p&gt;下面是一个CASE语句的示例。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CASE age 
WHEN 20 THEN SET @count1=@count1+1; 
ELSE SET @count2=@count2+1; 
END CASE ;&lt;/pre&gt;
&lt;p&gt;代码也可以是下面的形式：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CASE 
WHEN age=20 THEN SET @count1=@count1+1; 
ELSE SET @count2=@count2+1; 
END CASE ;&lt;/pre&gt;
&lt;p&gt;本示例中，如果age值为20，count1的值加1；否则count2的值加1。CASE语句都要使用END CASE结束。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：这里的CASE语句和“控制流程函数”里描述的SQL CASE表达式的CASE语句有轻微不同。这里的CASE语句不能有ELSE NULL子句&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3．LOOP语句&lt;/p&gt;
&lt;p&gt;LOOP语句可以使某些特定的语句重复执行，实现一个简单的循环。&lt;/p&gt;
&lt;p&gt;但是LOOP语句本身没有停止循环的语句，必须是遇到LEAVE语句等才能停止循环。&lt;/p&gt;
&lt;p&gt;LOOP语句的语法的基本形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[begin_label:] LOOP 
statement_list 
END LOOP [end_label]&lt;/pre&gt;
&lt;p&gt;其中，begin_label参数和end_label参数分别表示循环开始和结束的标志，这两个标志必须相同，而且都可以省略；&lt;/p&gt;
&lt;p&gt;statement_list参数表示需要循环执行的语句。&lt;/p&gt;
&lt;p&gt;下面是一个LOOP语句的示例。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;add_num: LOOP  
SET @count=@count+1;  
END LOOP add_num ;&lt;/pre&gt;
&lt;p&gt;该示例循环执行count加1的操作。因为没有跳出循环的语句，这个循环成了一个死循环。&lt;/p&gt;
&lt;p&gt;LOOP循环都以END LOOP结束。&lt;/p&gt;
&lt;p&gt;4．LEAVE语句&lt;/p&gt;
&lt;p&gt;LEAVE语句主要用于跳出循环控制。其语法形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;LEAVE label&lt;/pre&gt;
&lt;p&gt;其中，label参数表示循环的标志。&lt;/p&gt;
&lt;p&gt;下面是一个LEAVE语句的示例。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;add_num: LOOP 
SET @count=@count+1; 
IF @count=100 THEN 
LEAVE add_num ; 
END LOOP add_num ;&lt;/pre&gt;
&lt;p&gt;该示例循环执行count加1的操作。当count的值等于100时，则LEAVE语句跳出循环。&lt;/p&gt;
&lt;p&gt;5．ITERATE语句&lt;/p&gt;
&lt;p&gt;ITERATE语句也是用来跳出循环的语句。但是，ITERATE语句是跳出本次循环，然后直接进入下一次循环。&lt;/p&gt;
&lt;p&gt;ITERATE语句只可以出现在LOOP、REPEAT、WHILE语句内。&lt;/p&gt;
&lt;p&gt;ITERATE语句的基本语法形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ITERATE label&lt;/pre&gt;
&lt;p&gt;其中，label参数表示循环的标志。&lt;/p&gt;
&lt;p&gt;下面是一个ITERATE语句的示例。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;add_num: LOOP 
SET @count=@count+1; 
IF @count=100 THEN 
LEAVE add_num ; 
ELSE IF MOD(@count,3)=0 THEN 
ITERATE add_num; 
SELECT * FROM employee ; 
END LOOP add_num ;&lt;/pre&gt;
&lt;p&gt;该示例循环执行count加1的操作，count值为100时结束循环。如果count的值能够整除3，则跳出本次循环，不再执行下面的SELECT语句。&lt;/p&gt;
&lt;p&gt;说明：LEAVE语句和ITERATE语句都用来跳出循环语句，但两者的功能是不一样的。&lt;/p&gt;
&lt;p&gt;LEAVE语句是跳出整个循环，然后执行循环后面的程序。而ITERATE语句是跳出本次循环，然后进入下一次循环。&lt;/p&gt;
&lt;p&gt;使用这两个语句时一定要区分清楚。&lt;/p&gt;
&lt;p&gt;6．REPEAT语句&lt;/p&gt;
&lt;p&gt;REPEAT语句是有条件控制的循环语句。当满足特定条件时，就会跳出循环语句。REPEAT语句的基本语法形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[begin_label:] REPEAT 
statement_list 
UNTIL search_condition 
END REPEAT [end_label]&lt;/pre&gt;
&lt;p&gt;其中，statement_list参数表示循环的执行语句；search_condition参数表示结束循环的条件，满足该条件时循环结束。&lt;/p&gt;
&lt;p&gt;下面是一个ITERATE语句的示例。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;REPEAT 
SET @count=@count+1; 
UNTIL @count=100 
END REPEAT ;&lt;/pre&gt;
&lt;p&gt;该示例循环执行count加1的操作，count值为100时结束循环。&lt;/p&gt;
&lt;p&gt;REPEAT循环都用END REPEAT结束。&lt;/p&gt;
&lt;p&gt;7．WHILE语句&lt;/p&gt;
&lt;p&gt;WHILE语句也是有条件控制的循环语句。但WHILE语句和REPEAT语句是不一样的。&lt;/p&gt;
&lt;p&gt;WHILE语句是当满足条件时，执行循环内的语句。&lt;/p&gt;
&lt;p&gt;WHILE语句的基本语法形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;[begin_label:] WHILE search_condition DO 
statement_list 
END WHILE [end_label]&lt;/pre&gt;
&lt;p&gt;其中，search_condition参数表示循环执行的条件，满足该条件时循环执行；&lt;/p&gt;
&lt;p&gt;statement_list参数表示循环的执行语句。&lt;/p&gt;
&lt;p&gt;下面是一个ITERATE语句的示例。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;WHILE @count&amp;lt;100 DO 
SET @count=@count+1; 
END WHILE ;&lt;/pre&gt;
&lt;p&gt;该示例循环执行count加1的操作，count值小于100时执行循环。&lt;/p&gt;
&lt;p&gt;如果count值等于100了，则跳出循环。WHILE循环需要使用END WHILE来结束。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;调用存储过程和函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储过程和存储函数都是存储在服务器端的SQL语句的集合，要使用这些已经定义好的存储过程和存储函数就必须要通过调用的方式来实现&lt;/p&gt;
&lt;p&gt;存储过程是通过CALL语句来调用的。而存储函数的使用方法与MySQL内部函数的使用方法是一样的&lt;/p&gt;
&lt;p&gt;执行存储过程和存储函数需要拥有EXECUTE权限&lt;/p&gt;
&lt;p&gt;EXECUTE权限的信息存储在information_schema数据库下面的&lt;strong&gt;USER_PRIVILEGES&lt;/strong&gt;表中&lt;/p&gt;
&lt;p&gt;调用存储过程&lt;/p&gt;
&lt;p&gt;MySQL中使用CALL语句来调用存储过程。调用存储过程后，数据库系统将执行存储过程中的语句。&lt;/p&gt;
&lt;p&gt;然后，将结果返回给输出值。&lt;/p&gt;
&lt;p&gt;CALL语句的基本语法形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CALL sp_name([parameter[,…]]) ;&lt;/pre&gt;
&lt;p&gt;其中，sp_name是存储过程的名称；parameter是指存储过程的参数。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CALL proc()&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/28d2bc67876665c422d4f12a01decd20.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;调用存储函数&lt;/p&gt;
&lt;p&gt;在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。&lt;/p&gt;
&lt;p&gt;换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。&lt;/p&gt;
&lt;p&gt;区别在于，存储函数是用户自己定义的，而内部函数是MySQL的开发者定义的。&lt;/p&gt;
&lt;p&gt;下面定义一个存储函数，然后调用这个存储函数。&lt;/p&gt;
&lt;p&gt;代码执行如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;-- 创建存储函数 
DELIMITER //
CREATE FUNCTION name_from_t3(id INT )
RETURNS CHAR(80)  
RETURN (SELECT  NAME  FROM  t3  WHERE  id=id );
//
DELIMITER ;

SELECT name_from_t3(2);&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f9a2df7145ec99479414296b95d7261a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上述存储函数的作用是根据输入的id值到t3表中查询记录。&lt;/p&gt;
&lt;p&gt;查询出id字段的值等于id的记录。然后将该记录的name字段的值返回。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;查看存储过程和函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储过程和函数创建以后，可以查看存储过程和函数的状态和定义。&lt;/p&gt;
&lt;p&gt;通过SHOW STATUS语句来查看存储过程和函数的状态，也可以通过SHOW CREATE语句来查看存储过程和函数的定义。&lt;/p&gt;
&lt;p&gt;通过查询information_schema数据库下的Routines表来查看存储过程和函数的信息&lt;/p&gt;
&lt;p&gt;1、SHOW STATUS语句查看存储过程和函数的状态&lt;/p&gt;
&lt;p&gt;MySQL中可以通过SHOW STATUS语句查看存储过程和函数的状态。其基本语法形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW { PROCEDURE | FUNCTION } STATUS [ LIKE  &#39; pattern &#39; ] ;&lt;/pre&gt;
&lt;p&gt;其中，PROCEDURE参数表示查询存储过程；FUNCTION参数表示查询存储函数；&lt;/p&gt;
&lt;p&gt;LIKE ‘ pattern ‘参数用来匹配存储过程或函数的名称。&lt;/p&gt;
&lt;p&gt;下面查询名为name_from_t3的函数的状态。代码执行如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW  FUNCTION STATUS LIKE &#39;%name_from_t3%&#39;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Db      Name          Type      Definer         Modified             Created              Security_type  Comment  character_set_client  collation_connection  Database Collation
------  ------------  --------  --------------  -------------------  -------------------  -------------  -------  --------------------  --------------------  ------------------
school  name_from_t3  FUNCTION  root@localhost  2014-06-21 18:52:39  2014-06-21 18:52:39  DEFINER                 utf8                  utf8_general_ci       utf8_general_ci&lt;/pre&gt;
&lt;p&gt;查询结果显示了函数的创建时间、修改时间和字符集等信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：SHOW STATUS语句只能查看存储过程或函数是操作哪一个数据库、存储过程或函数的名称、类型、谁定义的、创建和修改时间、字符编码等信息。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、SHOW CREATE语句查看存储过程和函数的定义&lt;/p&gt;
&lt;p&gt;MySQL中可以通过SHOW CREATE语句查看存储过程和函数的状态。其基本语法形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE { PROCEDURE | FUNCTION } sp_name ;&lt;/pre&gt;
&lt;p&gt;其中，PROCEDURE参数表示查询存储过程；&lt;/p&gt;
&lt;p&gt;FUNCTION参数表示查询存储函数；&lt;/p&gt;
&lt;p&gt;sp_name参数表示存储过程或函数的名称&lt;/p&gt;
&lt;p&gt;下面查询名为name_from_t3的函数的定义。代码执行如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE FUNCTION  name_from_t3&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Function      sql_mode  Create Function                                                                                                                                  character_set_client  collation_connection  Database Collation
------------  --------  -----------------------------------------------------------------------------------------------------------------------------------------------  --------------------  --------------------  ------------------
name_from_t3            CREATE DEFINER=`root`@`localhost` FUNCTION `name_from_t3`(id INT ) RETURNS char(80) CHARSET utf8                                                 utf8                  utf8_general_ci       utf8_general_ci   
                        RETURN (SELECT  NAME  FROM  t3  WHERE  id=id )&lt;/pre&gt;
&lt;p&gt;3、从information_schema.Routines表中查看存储过程和函数的信息&lt;/p&gt;
&lt;p&gt;存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。&lt;/p&gt;
&lt;p&gt;其基本语法形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM information_schema.Routines 
WHERE ROUTINE_NAME=&#39; sp_name &#39; ;&lt;/pre&gt;
&lt;p&gt;其中，ROUTINE_NAME字段中存储的是存储过程和函数的名称；&lt;/p&gt;
&lt;p&gt;sp_name参数表示存储过程或函数的名称。&lt;/p&gt;
&lt;p&gt;下面从Routines表中查询名为name_from_t3函数的信息。&lt;/p&gt;
&lt;p&gt;代码执行如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM information_schema.Routines   WHERE ROUTINE_NAME=&#39;name_from_t3&#39;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SPECIFIC_NAME  ROUTINE_CATALOG  ROUTINE_SCHEMA  ROUTINE_NAME  ROUTINE_TYPE  DATA_TYPE  CHARACTER_MAXIMUM_LENGTH  CHARACTER_OCTET_LENGTH  NUMERIC_PRECISION  NUMERIC_SCALE  CHARACTER_SET_NAME  COLLATION_NAME   DTD_IDENTIFIER  ROUTINE_BODY  ROUTINE_DEFINITION                              EXTERNAL_NAME  EXTERNAL_LANGUAGE  PARAMETER_STYLE  IS_DETERMINISTIC  SQL_DATA_ACCESS  SQL_PATH  SECURITY_TYPE  CREATED              LAST_ALTERED         SQL_MODE  ROUTINE_COMMENT  DEFINER         CHARACTER_SET_CLIENT  COLLATION_CONNECTION  DATABASE_COLLATION
-------------  ---------------  --------------  ------------  ------------  ---------  ------------------------  ----------------------  -----------------  -------------  ------------------  ---------------  --------------  ------------  ----------------------------------------------  -------------  -----------------  ---------------  ----------------  ---------------  --------  -------------  -------------------  -------------------  --------  ---------------  --------------  --------------------  --------------------  ------------------
name_from_t3   def              school          name_from_t3  FUNCTION      char                             80                     240             (NULL)         (NULL)  utf8                utf8_general_ci  char(80)        SQL           RETURN (SELECT  NAME  FROM  t3  WHERE  id=id )  (NULL)         (NULL)             SQL              NO                CONTAINS SQL     (NULL)    DEFINER        2014-06-21 18:52:39  2014-06-21 18:52:39                             root@localhost  utf8                  utf8_general_ci       utf8_general_ci&lt;/pre&gt;
&lt;p&gt;查询结果显示name_from_t3的详细信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：在information_schema数据库下的Routines表中，存储着所有存储过程和函数的定义。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果使用SELECT语句查询Routines表中的存储过程和函数的定义时，一定要使用ROUTINE_NAME字段指定存储过程或函数的名称。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;修改存储过程和函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改存储过程和函数是指修改已经定义好的存储过程和函数。&lt;/p&gt;
&lt;p&gt;MySQL中通过ALTER PROCEDURE语句来修改存储过程。&lt;/p&gt;
&lt;p&gt;通过ALTER FUNCTION语句来修改存储函数。&lt;/p&gt;
&lt;p&gt;MySQL中修改存储过程和函数的语句的语法形式如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER {PROCEDURE | FUNCTION} sp_name [characteristic ...]  
characteristic:  
{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }  
| SQL SECURITY { DEFINER | INVOKER }  
| COMMENT &#39;string&#39;&lt;/pre&gt;
&lt;p&gt;其中，sp_name参数表示存储过程或函数的名称；&lt;/p&gt;
&lt;p&gt;characteristic参数指定存储函数的特性。&lt;/p&gt;
&lt;p&gt;CONTAINS SQL表示子程序包含SQL语句，但不包含读或写数据的语句；&lt;/p&gt;
&lt;p&gt;NO SQL表示子程序中不包含SQL语句；&lt;/p&gt;
&lt;p&gt;READS SQL DATA表示子程序中包含读数据的语句；&lt;/p&gt;
&lt;p&gt;MODIFIES SQL DATA表示子程序中包含写数据的语句。&lt;/p&gt;
&lt;p&gt;SQL SECURITY { DEFINER | INVOKER }指明谁有权限来执行。&lt;/p&gt;
&lt;p&gt;DEFINER表示只有定义者自己才能够执行；&lt;/p&gt;
&lt;p&gt;INVOKER表示调用者可以执行。&lt;/p&gt;
&lt;p&gt;COMMENT ‘string’是注释信息。&lt;/p&gt;
&lt;p&gt;说明：修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。&lt;/p&gt;
&lt;p&gt;但是，这两个语句的结构是一样的，语句中的所有参赛都是一样的。&lt;/p&gt;
&lt;p&gt;而且，它们与创建存储过程或函数的语句中的参数也是基本一样的。&lt;/p&gt;
&lt;p&gt;修改存储过程和函数，只能修改他们的权限，目前MYSQL还不提供对已存在的存储过程和函数代码的修改&lt;/p&gt;
&lt;p&gt;如果要修改，只能通过先DROP掉，然后重新建立新的存储过程和函数来实现&lt;/p&gt;
&lt;p&gt;在SQLYOG里选中选中函数，然后右键ALTER FUNCTION的时候，也是这样，先DROP掉，然后重新建立新的函数来实现&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1dc10509f698708d5ed08eb82bf71d7b.jpg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DELIMITER &lt;span class=&quot;MathJax_Preview&quot;&gt;\(
DROP FUNCTION IF EXISTS `name_from_t3`\)&lt;/span&gt;

CREATE DEFINER=`root`@`localhost` FUNCTION `name_from_t3`(id INT ) RETURNS CHAR(80) CHARSET utf8
RETURN (SELECT  NAME  FROM  t3  WHERE  id=id )$$

DELIMITER ;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;删除存储过程和函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除存储过程和函数指删除数据库中已经存在的存储过程和函数。&lt;/p&gt;
&lt;p&gt;MySQL中使用DROP PROCEDURE语句来删除存储过程。通过DROP FUNCTION语句来删除存储函数。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP { PROCEDURE| FUNCTION } sp_name;&lt;/pre&gt;
&lt;p&gt;其中，sp_name参数表示存储过程或函数的名称&lt;/p&gt;
&lt;p&gt;下面删除存储过程Proc和存储函数name_from_t3。删除存储过程的代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP  PROCEDURE  Proc;&lt;/pre&gt;
&lt;p&gt;删除存储函数name_from_employee的代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP  FUNCTION  name_from_t3;&lt;/pre&gt;
&lt;p&gt;删除完毕之后，查询information_schema.Routines来确认上面的删除是否成功&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM information_schema.Routines
WHERE ROUTINE_NAME=&#39;proc&#39; OR ROUTINE_NAME=&#39;name_from_t3&#39;;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIPS:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储过程里面是可以调用其他存储过程的，使用CALL语句调用其他存储过程就可以了&lt;/p&gt;
&lt;p&gt;存储过程参数列表里的参数名尽量不要和数据库中表的字段名一样，否则有可能出错&lt;/p&gt;
&lt;p&gt;存储过程的参数可以使用中文，在定义存储过程的时候加上character set gbk就可以了&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE PROCEDURE useInfo(IN u_name VARCHAR(50) CHARACTER SET gbk,OUT u_age INT)&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2014-6-22补充&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DECLARE 语句要写在存储过程里面，否则会报错！！&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP PROCEDURE IF EXISTS Proc;

DELIMITER //
CREATE PROCEDURE Proc() 
BEGIN
DECLARE command_not_allowed CONDITION FOR SQLSTATE &#39;42000&#39; ;
END//
DELIMITER ;

CALL Proc();&lt;/pre&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87351&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87351votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87351&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Fri, 05 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-05-87351-b346f5dba.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-05-87351-b346f5dba.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Go并发编程基础</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;本文是一篇并发编程方面的入门文章，以&lt;a href=&quot;http://golang.org/&quot;&gt;Go语言&lt;/a&gt;编写示例代码，内容涵盖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行期并发线程（goroutines）&lt;/li&gt;
&lt;li&gt;基本的同步技术（管道和锁）&lt;/li&gt;
&lt;li&gt;Go语言中基本的并发模式&lt;/li&gt;
&lt;li&gt;死锁和数据竞争&lt;/li&gt;
&lt;li&gt;并行计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在开始阅读本文之前，你应该知道如何编写简单的Go程序。如果你熟悉的是C/C++、Java或Python之类的语言，那么 &lt;a href=&quot;http://tour.golang.org/welcome/1&quot;&gt;Go语言之旅&lt;/a&gt; 能提供所有必要的背景知识。也许你还有兴趣读一读 &lt;a href=&quot;http://code.google.com/p/go-wiki/wiki/GoForCPPProgrammers&quot;&gt;为C++程序员准备的Go语言教程&lt;/a&gt; 或 &lt;a href=&quot;http://www.nada.kth.se/~snilsson/go_for_java_programmers/&quot;&gt;为Java程序员准备的Go语言教程&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Go允许使用&lt;code&gt;go&lt;/code&gt;语句开启一个新的运行期线程，即 &lt;a href=&quot;http://golang.org/ref/spec#Go_statements&quot;&gt;goroutine&lt;/a&gt;，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享同一个地址空间。&lt;/p&gt;
&lt;p&gt;Goroutine非常轻量，除了为之分配的栈空间，其所占用的内存空间微乎其微。并且其栈空间在开始时非常小，之后随着堆存储空间的按需分配或释放而变化。内部实现上，goroutine会在多个操作系统线程上多路复用。如果一个goroutine阻塞了一个操作系统线程，例如：等待输入，这个线程上的其他goroutine就会迁移到其他线程，这样能继续运行。开发者并不需要关心/担心这些细节。&lt;/p&gt;
&lt;p&gt;下面所示程序会输出“Hello from main goroutine”。也可能会输出“Hello from another goroutine”，具体依赖于两个goroutine哪个先结束。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func main() {
    go fmt.Println(&quot;Hello from another goroutine&quot;)
    fmt.Println(&quot;Hello from main goroutine&quot;)

    // 至此，程序运行结束，
    // 所有活跃的goroutine被杀死
}&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/goroutine1.go&quot;&gt;goroutine1.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来的这个程序，多数情况下，会输出“Hello from main goroutine”和“Hello from another goroutine”，输出的顺序不确定。但还有另一个可能性是：第二个goroutine运行得极其慢，在程序结束之前都没来得及输出相应的消息。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func main() {
    go fmt.Println(&quot;Hello from another goroutine&quot;)
    fmt.Println(&quot;Hello from main goroutine&quot;)

    time.Sleep(time.Second)        // 等待1秒，等另一个goroutine结束
}&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/goroutine2.go&quot;&gt;goroutine2.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面则是一个相对更加实际的示例，其中定义了一个函数使用并发来推迟触发一个事件。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;// 函数Publish在给定时间过期后打印text字符串到标准输出
   // 该函数并不会阻塞而是立即返回
func Publish(text string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(&quot;BREAKING NEWS:&quot;, text)
    }()    // 注意这里的括号。必须调用匿名函数
}&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/publish1.go&quot;&gt;publish1.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你可能会这样使用&lt;code&gt;Publish&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func main() {
    Publish(&quot;A goroutine starts a new thread of execution.&quot;, 5*time.Second)
    fmt.Println(&quot;Let’s hope the news will published before I leave.&quot;)

    // 等待发布新闻
    time.Sleep(10 * time.Second)

    fmt.Println(&quot;Ten seconds later: I’m leaving now.&quot;)
}&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/publish1.go&quot;&gt;publish1.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个程序，绝大多数情况下，会输出以下三行，顺序固定，每行输出之间相隔5秒。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ go run publish1.go
Let’s hope the news will published before I leave.
BREAKING NEWS: A goroutine starts a new thread of execution.
Ten seconds later: I’m leaving now.&lt;/pre&gt;
&lt;p&gt;一般来说，通过睡眠的方式来编排线程之间相互等待是不太可能的。下一章节会介绍Go语言中的一种同步机制 – 管道，并演示如何使用管道让一个goroutine等待另一个goroutine。&lt;/p&gt;
&lt;h4&gt;2. 管道（channel）&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;Sushi conveyor belt&quot; src=&quot;/images/jobbole.com/38436ee7cda92f2d9ba4ab1e24755cf1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://golang.org/ref/spec#Channel_types&quot;&gt;管道&lt;/a&gt;是Go语言的一个构件，提供一种机制用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;code&gt;&amp;lt;-&lt;/code&gt;用于指定管道的方向，发送或接收。如果未指定方向，则为双向管道。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;chan Sushi        // 可用来发送和接收Sushi类型的值
chan&amp;lt;- float64    // 仅可用来发送float64类型的值
&amp;lt;-chan int        // 仅可用来接收int类型的值&lt;/pre&gt;
&lt;p&gt;管道是引用类型，基于make函数来分配。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;ic := make(chan int)    // 不带缓冲的int类型管道
wc := make(chan *Work, 10)    // 带缓冲的Work类型指针管道&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果通过管道发送一个值，则将&lt;code&gt;&amp;lt;-&lt;/code&gt;作为二元操作符使用。通过管道接收一个值，则将其作为一元操作符使用：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;ic &amp;lt;- 3        // 往管道发送3
work := &amp;lt;-wc    // 从管道接收一个指向Work类型值的指针&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果管道不带缓冲，发送方会阻塞直到接收方从管道中接收了值。如果管道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。&lt;/p&gt;
&lt;p&gt;关闭管道（Close）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://golang.org/ref/spec#Close&quot;&gt;close&lt;/a&gt; 函数标志着不会再往某个管道发送值。在调用&lt;code&gt;close&lt;/code&gt;之后，并且在之前发送的值都被接收后，接收操作会返回一个零值，不会阻塞。一个多返回值的接收操作会额外返回一个布尔值用来指示返回的值是否发送操作传递的。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;ch := make(chan string)
go func() {
    ch &amp;lt;- &quot;Hello!&quot;
    close(ch)
}()
fmt.Println(&amp;lt;-ch)    // 输出字符串&quot;Hello!&quot;
fmt.Println(&amp;lt;-ch)    // 输出零值 - 空字符串&quot;&quot;，不会阻塞
fmt.Println(&amp;lt;-ch)    // 再次打印输出空字符串&quot;&quot;
v, ok := &amp;lt;-ch        // 变量v的值为空字符串&quot;&quot;，变量ok的值为false&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;一个带有&lt;code&gt;range&lt;/code&gt;子句的&lt;code&gt;for&lt;/code&gt;语句会依次读取发往管道的值，直到该管道关闭：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func main() {
    // 译注：要想运行该示例，需要先定义类型Sushi，如type Sushi string
    var ch &amp;lt;-chan Sushi = Producer()
    for s := range ch {
        fmt.Println(&quot;Consumed&quot;, s)
    }
}

func Producer() &amp;lt;-chan Sushi {
    ch := make(chan Sushi)
    go func(){
        ch &amp;lt;- Sushi(&quot;海老握り&quot;)    // Ebi nigiri
        ch &amp;lt;- Sushi(&quot;鮪とろ握り&quot;) // Toro nigiri
        close(ch)
    }()
    return ch
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/sushi.go&quot;&gt;sushi.go&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;3. 同步&lt;/h4&gt;
&lt;p&gt;下一个示例中，我们让&lt;code&gt;Publish&lt;/code&gt;函数返回一个管道 – 用于在发布text变量值时广播一条消息：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;// 在给定时间过期时，Publish函数会打印text变量值到标准输出
// 在text变量值发布后，该函数会关闭管道wait
func Publish(text string, delay time.Duration) (wait &amp;lt;-chan struct{}) {
    ch := make(chan struct{})
    go func() {
        time.Sleep(delay)
        fmt.Println(&quot;BREAKING NEWS:&quot;, text)
        close(ch)    // 广播 - 一个关闭的管道都会发送一个零值
    }()
    return ch
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/publish2.go&quot;&gt;publish2.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意：我们使用了一个空结构体的管道：&lt;code&gt;struct{}&lt;/code&gt;。这明确地指明该管道仅用于发信号，而不是传递数据。&lt;/p&gt;
&lt;p&gt;我们可能会这样使用这个函数：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func main() {
    wait := Publish(&quot;Channels let goroutines communicate.&quot;, 5*time.Second)
    fmt.Println(&quot;Waiting for the news...&quot;)
    &amp;lt;-wait
    fmt.Println(&quot;The news is out, time to leave.&quot;)
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/publish2.go&quot;&gt;publish2.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个程序会按指定的顺序输出以下三行内容。最后一行在新闻（news）一出就会立即输出。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ go run publish2.go
Waiting for the news...
BREAKING NEWS: Channels let goroutines communicate.
The news is out, time to leave.&lt;/pre&gt;
&lt;/div&gt;
&lt;h4&gt;4. 死锁&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;traffic jam&quot; src=&quot;/images/jobbole.com/997828f6288d361449662bfc63fce0cd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在我们在&lt;code&gt;Publish&lt;/code&gt;函数中引入一个bug：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func Publish(text string, delay time.Duration) (wait &amp;lt;-chan struct{}) {
    ch := make(chan struct{})
    go func() {
        time.Sleep(delay)
        fmt.Println(&quot;BREAKING NEWS:&quot;, text)
        // 译注：注意这里将close函数调用注释掉了
        //close(ch)
    }()
    return ch
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;主程序还是像之前一样开始运行：输出第一行，然后等待5秒，这时&lt;code&gt;Publish&lt;/code&gt;函数开启的goroutine会输出突发新闻（breaking news），然后退出，留下主goroutine独自等待。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func main() {
    wait := Publish(&quot;Channels let goroutines communicate.&quot;, 5*time.Second)
    fmt.Println(&quot;Waiting for the news...&quot;)
    // 译注：注意下面这一句
    &amp;lt;-wait
    fmt.Println(&quot;The news is out, time to leave.&quot;)
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;此刻之后，程序无法再继续往下执行。众所周知，这种情形即为死锁。&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;Go语言对于运行时的死锁检测具备良好的支持。当没有任何goroutine能够往前执行的情形发生时，Go程序通常会提供详细的错误信息。以下就是我们的问题程序的输出：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;Waiting for the news...
BREAKING NEWS: Channels let goroutines communicate.
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
main.main()
    .../goroutineStop.go:11 +0xf6

goroutine 2 [syscall]:
created by runtime.main
    .../go/src/pkg/runtime/proc.c:225

goroutine 4 [timer goroutine (idle)]:
created by addtimer
    .../go/src/pkg/runtime/ztime_linux_amd64.c:73&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;大多数情况下找出Go程序中造成死锁的原因都比较容易，那么剩下的就是如何解决这个bug了。&lt;/p&gt;
&lt;h4&gt;5. 数据竞争（data race）&lt;/h4&gt;
&lt;p&gt;死锁也许听起来令人挺忧伤的，但伴随并发编程真正灾难性的错误其实是数据竞争，相当常见，也可能非常难于调试。&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;下面的这个函数就有数据竞争问题，其行为是未定义的。例如，可能输出数值1。代码之后是一个可能性解释，试图搞清楚这一切是如何发生得。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func race() {
    wait := make(chan struct{})
    n := 0
    go func() {
        // 译注：注意下面这一行
        n++ // 一次访问: 读, 递增, 写
        close(wait)
    }()
    // 译注：注意下面这一行
    n++ // 另一次冲突的访问
    &amp;lt;-wait
    fmt.Println(n) // 输出：未指定
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/datarace.go&quot;&gt;datarace.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码中的两个goroutine（假设命名为&lt;code&gt;g1&lt;/code&gt;和&lt;code&gt;g2&lt;/code&gt;）参与了一次竞争，我们无法获知操作会以何种顺序发生。以下是诸多可能中的一种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;g1&lt;/code&gt; 从 &lt;code&gt;n&lt;/code&gt; 中获取值0&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;g2&lt;/code&gt; 从 &lt;code&gt;n&lt;/code&gt; 中获取值0&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;g1&lt;/code&gt; 将值从0增大到1&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;g1&lt;/code&gt; 将1写到 &lt;code&gt;n&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;g2&lt;/code&gt; 将值从0增大到1&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;g2&lt;/code&gt; 将1写到 &lt;code&gt;n&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;程序输出 n 的值，当前为1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“数据竞争（data race）”这名字有点误导的嫌疑。不仅操作的顺序是未定义的，其实根本没有任何保证（no guarantees whatsoever）。编译器和硬件为了得到更好的性能，经常都会对代码进行上下内外的顺序变换。如果你看到一个线程处于中间行为状态时，那么当时的场景可能就像下图所示的一样：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;mid action&quot; src=&quot;/images/jobbole.com/82799ce07a124cc68655d2460f56225c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;避免数据竞争的唯一方式是线程间同步访问所有的共享可变数据。有几种方式能够实现这一目标。Go语言中，通常是使用管道或者锁。（&lt;a href=&quot;http://golang.org/pkg/sync/&quot;&gt;sync&lt;/a&gt;和&lt;a href=&quot;http://golang.org/pkg/sync/atomic/&quot;&gt;sync/atomic&lt;/a&gt;包中还有更低层次的机制可供使用，但本文中不做讨论）。&lt;/p&gt;
&lt;p&gt;Go语言中，处理并发数据访问的推荐方式是使用管道从一个goroutine中往下一个goroutine传递实际的数据。有格言说得好：“不要通过共享内存来通讯，而是通过通讯来共享内存”。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func sharingIsCaring() {
    ch := make(chan int)
    go func() {
        n := 0 // 仅为一个goroutine可见的局部变量.
        n++
        ch &amp;lt;- n // 数据从一个goroutine离开...
    }()
    n := &amp;lt;-ch   // ...然后安全到达另一个goroutine.
    n++
    fmt.Println(n) // 输出: 2
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/datarace.go&quot;&gt;datarace.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上代码中的管道肩负双重责任 – 从一个goroutine将数据传递到另一个goroutine，并且起到同步的作用：发送方goroutine会等待另一个goroutine接收数据，接收方goroutine也会等待另一个goroutine发送数据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://golang.org/ref/mem&quot;&gt;Go语言内存模型&lt;/a&gt; - 要保证一个goroutine中对一个变量的读操作得到的值正好是另一个goroutine中对同一个变量写操作产生的值，条件相当复杂，但goroutine之间只要通过管道来共享所有可变数据，那么就能远离数据竞争了。&lt;/p&gt;
&lt;h4&gt;6. 互斥锁&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;lock&quot; src=&quot;/images/jobbole.com/7b391b0da156817c680bf2ebf44a9994.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;有时，通过显式加锁，而不是使用管道，来同步数据访问，可能更加便捷。Go语言标准库为这一目的提供了一个互斥锁 - &lt;a href=&quot;http://golang.org/pkg/sync/#Mutex&quot;&gt;sync.Mutex&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;要想这类加锁起效的话，关键之处在于：所有对共享数据的访问，不管读写，仅当goroutine持有锁才能操作。一个goroutine出错就足以破坏掉一个程序，引入数据竞争。&lt;/p&gt;
&lt;p&gt;因此，应该设计一个自定义数据结构，具备明确的API，确保所有的同步都在数据结构内部完成。下例中，我们构建了一个安全、易于使用的并发数据结构，&lt;code&gt;AtomicInt&lt;/code&gt;，用于存储一个整型值。任意数量的goroutine都能通过&lt;code&gt;Add&lt;/code&gt;和&lt;code&gt;Value&lt;/code&gt;方法安全地访问这个数值。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;// AtomicInt是一个并发数据结构，持有一个整数值
// 该数据结构的零值为0
type AtomicInt struct {
    mu sync.Mutex // 锁，一次仅能被一个goroutine持有。
    n  int
}

// Add方法作为一个原子操作将n加到AtomicInt
func (a *AtomicInt) Add(n int) {
    a.mu.Lock() // 等待锁释放，然后持有它
    a.n += n
    a.mu.Unlock() // 释放锁
}

// Value方法返回a的值
func (a *AtomicInt) Value() int {
    a.mu.Lock()
    n := a.n
    a.mu.Unlock()
    return n
}

func lockItUp() {
    wait := make(chan struct{})
    var n AtomicInt
    go func() {
        n.Add(1) // 一个访问
        close(wait)
    }()
    n.Add(1) // 另一个并发访问
    &amp;lt;-wait
    fmt.Println(n.Value()) // 输出: 2
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/datarace.go&quot;&gt;datarace.go&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;7. 检测数据竞争&lt;/h4&gt;
&lt;p&gt;竞争有时非常难于检测。下例中的这个函数有一个数据竞争问题，执行这个程序时会输出&lt;code&gt;55555&lt;/code&gt;。尝试一下，也许你会得到一个不同的结果。（&lt;a href=&quot;http://golang.org/pkg/sync/#WaitGroup&quot;&gt;sync.WaitGroup&lt;/a&gt;是Go语言标准库的一部分；用于等待一组goroutine结束运行。）&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func race() {
    var wg sync.WaitGroup
    wg.Add(5)
    // 译注：注意下面这行代码中的i++
    for i := 0; i &amp;lt; 5; i++ {
        go func() {
            // 注意下一行代码会输出什么？为什么？
            fmt.Print(i) // 6个goroutine共享变量i
            wg.Done()
        }()
    }
    wg.Wait() // 等待所有（5个）goroutine运行结束
    fmt.Println()
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/raceClosure.go&quot;&gt;raceClosure.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于输出&lt;code&gt;55555&lt;/code&gt;，一个貌似合理的解释是：执行&lt;code&gt;i++&lt;/code&gt;的goroutine在其他goroutine执行打印语句之前就完成了5次&lt;code&gt;i++&lt;/code&gt;操作。实际上变量&lt;code&gt;i&lt;/code&gt;更新后的值为其他goroutine所见纯属巧合。&lt;/p&gt;
&lt;p&gt;一个简单的解决方案是：使用一个局部变量，然后当开启新的goroutine时，将数值作为参数传递：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func correct() {
    var wg sync.WaitGroup
    wg.Add(5)
    for i := 0; i &amp;lt; 5; i++ {
        go func(n int) { // 使用局部变量
            fmt.Print(n)
            wg.Done()
        }(i)
    }
    wg.Wait()
    fmt.Println()
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/raceClosure.go&quot;&gt;raceClosure.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这次代码就对了，程序会输出期望的结果，如：&lt;code&gt;24031&lt;/code&gt;。注意：goroutine之间的运行顺序是不确定的。&lt;/p&gt;
&lt;p&gt;仍旧使用闭包，但能够避免数据竞争也是可能的，必须小心翼翼地让每个goroutine使用一个独有的变量。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func alsoCorrect() {
    var wg sync.WaitGroup
    wg.Add(5)
    for i := 0; i &amp;lt; 5; i++ {
        n := i // 为每个闭包创建一个独有的变量
        go func() {
            fmt.Print(n)
            wg.Done()
        }()
    }
    wg.Wait()
    fmt.Println()
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/raceClosure.go&quot;&gt;raceClosure.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据竞争自动检测&lt;/p&gt;
&lt;p&gt;一般来说，不太可能能够自动检测发现所有可能的数据竞争情况，但Go（从版本1.1开始）有一个强大的&lt;a href=&quot;http://tip.golang.org/doc/articles/race_detector.html&quot;&gt;数据竞争检测器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这个工具用起来也很简单：只要在使用&lt;code&gt;go&lt;/code&gt;命令时加上&lt;code&gt;-race&lt;/code&gt;标记即可。开启检测器运行上面的程序会给出清晰且信息量大的输出：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ go run -race raceClosure.go
Race:
==================
WARNING: DATA RACE
Read by goroutine 2:
    main.func·001()
      ../raceClosure.go:22 +0x65

Previous write by goroutine 0:
    main.race()
        ../raceClosure.go:20 +0x19b
    main.main()
        ../raceClosure.go:10 +0x29
    runtime.main()
        ../go/src/pkg/runtime/proc.c:248 +0x91

Goroutine 2 (running) created at:
    main.race()
      ../raceClosure.go:24 +0x18b
    main.main()
      ../raceClosure.go:10 +0x29
     runtime.main()
      ../go/src/pkg/runtime/proc.c:248 +0x91

==================
55555
Correct:
01234
Also correct:
01324
Found 1 data race(s)
exit status 66&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;该工具发现一处数据竞争，包含：一个goroutine在第20行对一个变量进行写操作，跟着另一个goroutine在第22行对同一个变量进行了未同步的读操作。&lt;/p&gt;
&lt;p&gt;注意：竞争检测器只能发现在运行期确实发生的数据竞争（译注：我也不太理解这话，请指导）&lt;/p&gt;
&lt;h4&gt;8. Select语句&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://golang.org/ref/spec#Select_statements&quot;&gt;select语句&lt;/a&gt;是Go语言并发工具集中的终极工具。select用于从一组可能的通讯中选择一个进一步处理。如果任意一个通讯都可以进一步处理，则从中随机选择一个，执行对应的语句。否则，如果又没有默认分支（default case），select语句则会阻塞，直到其中一个通讯完成。&lt;/p&gt;
&lt;p&gt;以下是一个玩具示例，演示&lt;code&gt;select&lt;/code&gt;语句如何用于实现一个随机数生成器：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;// RandomBits函数 返回一个管道，用于产生一个比特随机序列
func RandomBits() &amp;lt;-chan int {
    ch := make(chan int)
    go func() {
        for {
            select {
            case ch &amp;lt;- 0: // 注意：分支没有对应的处理语句
            case ch &amp;lt;- 1:
            }
        }
    }()
    return ch
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/randBits.go&quot;&gt;randBits.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是相对更加实际一点的例子：如何使用select语句为一个操作设置一个时间限制。代码会输出变量news的值或者超时消息，具体依赖于两个接收语句哪个先执行：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;select {
case news := &amp;lt;-NewsAgency:
    fmt.Println(news)
case &amp;lt;-time.After(time.Minute):
    fmt.Println(&quot;Time out: no news in one minute.&quot;)
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;函数 &lt;a href=&quot;http://golang.org/pkg/time/#After&quot;&gt;time.After&lt;/a&gt; 是Go语言标准库的一部分；它会在等待指定时间后将当前的时间发送到返回的管道中。&lt;/p&gt;
&lt;h4&gt;9. 综合所有示例&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;couples&quot; src=&quot;/images/jobbole.com/658dc92be67c8684ef665a0f503f311c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;花点时间认真研究一下这个示例。如果你完全理解，也就对Go语言中并发的应用方式有了全面的掌握。&lt;/p&gt;
&lt;p&gt;这个程序演示了如何将管道用于被任意数量的goroutine发送和接收数据，也演示了如何将select语句用于从多个通讯中选择一个。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func main() {
    people := []string{&quot;Anna&quot;, &quot;Bob&quot;, &quot;Cody&quot;, &quot;Dave&quot;, &quot;Eva&quot;}
    match := make(chan string, 1) // 为一个未匹配的发送操作提供空间
    wg := new(sync.WaitGroup)
    wg.Add(len(people))
    for _, name := range people {
        go Seek(name, match, wg)
    }
    wg.Wait()
    select {
    case name := &amp;lt;-match:
        fmt.Printf(&quot;No one received %s’s message.\n&quot;, name)
    default:
        // 没有待处理的发送操作
    }
}

// 函数Seek 发送一个name到match管道或从match管道接收一个peer，结束时通知wait group
func Seek(name string, match chan string, wg *sync.WaitGroup) {
    select {
    case peer := &amp;lt;-match:
        fmt.Printf(&quot;%s sent a message to %s.\n&quot;, peer, name)
    case match &amp;lt;- name:
        // 等待某个goroutine接收我的消息
    }
    wg.Done()
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/matching.go&quot;&gt;matching.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;示例输出：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ go run matching.go
Cody sent a message to Bob.
Anna sent a message to Eva.
No one received Dave’s message.&lt;/pre&gt;
&lt;/div&gt;
&lt;h4&gt;10. 并行计算&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;CPUs&quot; src=&quot;/images/jobbole.com/9ae757c809cff5932dedb3d8aac4127a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;并发的一个应用是将一个大的计算切分成一些工作单元，调度到不同的CPU上同时地计算。&lt;/p&gt;
&lt;p&gt;将计算分布到多个CPU上更多是一门艺术，而不是一门科学。以下是一些经验法则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个工作单元应该花费大约100微秒到1毫秒的时间用于计算。如果单元粒度太小，切分问题以及调度子问题的管理开销可能就会太大。如果单元粒度太大，整个计算也许不得不等待一个慢的工作项结束。这种缓慢可能因为多种原因而产生，比如：调度、其他进程的中断或者糟糕的内存布局。（注意：工作单元的数目是不依赖于CPU的数目的）&lt;/li&gt;
&lt;li&gt;尽可能减小共享的数据量。并发写操作的代价非常大，特别是如果goroutine运行在不同的CPU上。读操作之间的数据共享则通常不会是个问题。&lt;/li&gt;
&lt;li&gt;数据访问尽量利用良好的局部性。如果数据能保持在缓存中，数据加载和存储将会快得多得多，这对于写操作也格外地重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的这个示例展示如何切分一个开销很大的计算并将其分布在所有可用的CPU上进行计算。先看一下有待优化的代码：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;type Vector []float64

// 函数Convolve 计算 w = u * v，其中 w[k] = Σ u[i]*v[j], i + j = k
// 先决条件：len(u) &amp;gt; 0, len(v) &amp;gt; 0
func Convolve(u, v Vector) (w Vector) {
    n := len(u) + len(v) - 1
    w = make(Vector, n)

    for k := 0; k &amp;lt; n; k++ {
        w[k] = mul(u, v, k)
    }
    return
}

// 函数mul 返回 Σ u[i]*v[j], i + j = k.
func mul(u, v Vector, k int) (res float64) {
    n := min(k+1, len(u))
    j := min(k, len(v)-1)
    for i := k - j; i &amp;lt; n; i, j = i+1, j-1 {
        res += u[i] * v[j]
    }
    return
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;思路很简单：确定合适大小的工作单元，然后在不同的goroutine中执行每个工作单元。以下是并发版本的 &lt;code&gt;Convolve&lt;/code&gt;：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func Convolve(u, v Vector) (w Vector) {
    n := len(u) + len(v) - 1
    w = make(Vector, n)

    // 将 w 切分成花费 ~100μs-1ms 用于计算的工作单元
    size := max(1, 1&amp;lt;&amp;lt;20/n)

    wg := new(sync.WaitGroup)
    wg.Add(1 + (n-1)/size)
    for i := 0; i &amp;lt; n &amp;amp;&amp;amp; i &amp;gt;= 0; i += size { // 整型溢出后 i &amp;lt; 0
        j := i + size
        if j &amp;gt; n || j &amp;lt; 0 { // 整型溢出后 j &amp;lt; 0
            j = n
        }

        // 这些goroutine共享内存，但是只读
        go func(i, j int) {
            for k := i; k &amp;lt; j; k++ {
                w[k] = mul(u, v, k)
            }
            wg.Done()
        }(i, j)
    }
    wg.Wait()
    return
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nada.kth.se/~snilsson/concurrency/src/convolution.go&quot;&gt;convolution.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工作单元定义之后，通常情况下最好将调度工作交给运行时和操作系统。然而，对于Go 1.* 你也许需要告诉运行时希望多少个goroutine来同时地运行代码。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;func init() {
    numcpu := runtime.NumCPU()
    runtime.GOMAXPROCS(numcpu) // 尝试使用所有可用的CPU
}&lt;/pre&gt;
&lt;/div&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87400&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87400votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87400&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt; 1 收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 04 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-04-87400-6f2963676.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-04-87400-6f2963676.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>超大 Cookie 拒绝服务攻击</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;有没有想过，如果网站的 Cookie 特别多特别大，会发生什么情况？&lt;/p&gt;
&lt;p&gt;不多说，马上来试验一下：&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;for (i = 0; i &amp;lt; 20; i++)
    document.cookie = i + &#39;=&#39; + &#39;X&#39;.repeat(2000)&lt;/pre&gt;
&lt;p&gt;什么，网站居然报错了？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1d76453a82e07056d1b3fbb84a4eaeaa.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;众所周知，Cookie 是塞在请求头里的。如果 Cookie 太多，显然整个 HTTP 头也会被撑大。&lt;/p&gt;
&lt;p&gt;然而现实中，几乎所有的服务器都会对请求头长度做限制，避免畸形封包消耗服务器资源。&lt;/p&gt;
&lt;p&gt;那么有趣的事就来了 —— Cookie 是可以长期储存的，所以只要不过期，对应的站点就一直无法访问！&lt;/p&gt;
&lt;p&gt;不信？&lt;a href=&quot;http://www.cnblogs.com/jsapp&quot;&gt;点击这里试试&lt;/a&gt; （&lt;strong&gt;警告：不会清 Cookie 的用户慎点&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;为什么会这样！因为博客园是支持自定义装扮的，用户可以嵌入自己的脚本。于是，一旦执行了恶作剧脚本，站点 Cookie 被污染，导致整个网站都无法访问了！&lt;/p&gt;
&lt;h2&gt;进阶&lt;/h2&gt;
&lt;p&gt;根据这个原理，我们继续挖掘 Cookie 的相关属性，让攻击效果变得更好。&lt;/p&gt;
&lt;h3 id=&quot;expires&quot;&gt;expires&lt;/h3&gt;
&lt;p&gt;Cookie 之所以能被持久储存，完全得益于 &lt;code&gt;expires 这个过期值。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;理论上，Cookie 的过期时间可以足够长。不过鉴于实际情况，最多也就几个月的时间。&lt;/p&gt;
&lt;p&gt;但对于互联网来说，这也非常长了，谁能容忍一个网站几个月没法用？&lt;/p&gt;
&lt;p&gt;所以，我们可以设置足够久的过期时间 —— 只要用户不主动清空 Cookie，相应的站点就一直没法访问！&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;domain&quot;&gt;domain&lt;/h3&gt;
&lt;p&gt;例如博客园，所有用户都在 www.cnblogs.com 下。除了这个主站，能否将其他的子站服务也一起破坏呢？&lt;/p&gt;
&lt;p&gt;答案是可以！因为 Cookie 具有一个特殊的属性 &lt;code&gt;domain，它允许子站设置上级站点的 Cookie。甚至可以是根域！&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;于是 www.cnblogs.com 的页面，就能写入超大 Cookie 到 cnblogs.com 域下了。&lt;/p&gt;
&lt;p&gt;未来，只要用户访问 *.cnblogs.com 的资源，统统变成 400 了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c3cb6db1afeb2f17095586e767db6235.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个特征可被利用到 XSS 攻击上。只要某网站任何一个子站能够运行跨站脚本，攻击者就可以对该网站进行全站屏蔽了！（GFW：比我还狠~）&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;path&quot;&gt;path&lt;/h3&gt;
&lt;p&gt;不过太霸道也是不好的。尤其是这年头大家都懂些网络知识，清缓存这样简单的事，不少小白用户都会尝试下。&lt;/p&gt;
&lt;p&gt;所以，为了低调起见，我们不对页面进行屏蔽，以免被过早被用户发现。&lt;/p&gt;
&lt;p&gt;我们只屏蔽特殊的 URL，例如 AJAX 请求接口。这样，页面仍能正常打开，只是后期的一些操作总是提示失败 —— 于是，用户大多会认为是网站出问题了，而不会怀疑是自己的原因。&lt;/p&gt;
&lt;p&gt;为了能更精确的控制 Cookie 粒度，&lt;code&gt;path 属性得利用起来。例如，我们只污染博客园的 /mvc/vote/VoteComment.aspx 页面：&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;for (i = 0; i &amp;lt; 20; i++) {
	document.cookie = i + &#39;=&#39; + &#39;X&#39;.repeat(2000) + &#39;;domain=cnblogs.com; path=/mvc/vote/VoteComment.aspx&#39;&lt;/pre&gt;
&lt;p&gt;这样，页面仍能正常浏览，只是把『点赞』功能给屏蔽了：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0848d17a9884634733739f5070b3faa8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;是不是很有趣：）&lt;/p&gt;
&lt;p&gt;这种局部屏蔽的效果，显然有更好的迷惑性。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;协议&lt;/h3&gt;
&lt;p&gt;仔细回顾一遍 Cookie 属性，除了 &lt;code&gt;secure，再没和 URL Scheme 相关的属性了。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这意味着，HTTP 和 HTTPS 的 Cookie 默认都是共享的。因此，我们可以在 HTTP 下屏蔽 HTTPS 站点了！&lt;/p&gt;
&lt;p&gt;不过 XSS 也不是也想有就能有的，但在特殊的条件下，任何站点都可以有 XSS —— 那就是流量被劫持的时候。&lt;/p&gt;
&lt;p&gt;当用户流量被劫持时，中间人可以模拟出任何 HTTP 站点，因此就能对任意站点设置 Cookie：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/464b82497f83ac7d5a430e13c47c61fb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当用户打开任意 HTTP 页面时，往其中注入脚本。接着悄悄创建目标站点的隐藏框架页，中间人返回特定的页面内容，其中的脚本即可修改目标站点 Cookie 了。&lt;/p&gt;
&lt;p&gt;下面就来尝试一下吧。&lt;/p&gt;
&lt;p&gt;通过代理，我们模拟流量被劫持的场景。当打开任意页面时，开始对目标站点释放 DeBuff：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/acb284a50aa9c890c025790063634959.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;主页面的实现：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5417afd8357a7ad866fe5037ca39da6d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;目标框架页实现：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5ecc5a0ac15459ea2523224aece9766a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过一堆框架页，即可批量对目标站点的 Cookie 进行修改。&lt;/p&gt;
&lt;p&gt;最后，切换回正常网络 —— 发现邪恶光环仍在生效：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f3da75dbbbaaff76204d6aaeb35033d1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;更杯具的是，连加密传输的 HTTPS 站点也未能幸免：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a302b7031390adbf52e526c54d9bf1fc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;中间人缓存攻击，又多了一种新玩法！&lt;/p&gt;
&lt;h2&gt;用途&lt;/h2&gt;
&lt;p&gt;或许你要说了，这除了恶作剧恶搞之外，有实际意义吗。&lt;/p&gt;
&lt;p&gt;不过，只要充分发挥想象，还是能玩出一些有趣的效果。例如配合 XSS：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;屏蔽资料修改页面，阻止用户改密码&lt;/li&gt;
&lt;li&gt;屏蔽注销接口，保持用户会话不过期&lt;/li&gt;
&lt;li&gt;屏蔽管理后台，让管理员暂时无法操作（XSS 盲打时，对管理员造成眩晕效果，持续时间视管理员 IQ 而定）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者流量劫持的场合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;屏蔽前端检测脚本，降低用户安全性&lt;/li&gt;
&lt;li&gt;屏蔽程序、补丁的更新站点，等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;当然，这种所谓的『拒绝服务』，只是本地自欺欺人而已，对真实服务器并没什么影响。&lt;/p&gt;
&lt;p&gt;虽然效果不及传统攻击，但这种方式显得更文明一些。只对部分人、甚至部分功能实施攻击，而完全不妨碍其他用户。&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87394&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87394votetotal&quot;&gt;2&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87394&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 04 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-04-87394-ca71531ed.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-04-87394-ca71531ed.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（9） ： 索引</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87340/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（7） ： 查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87345/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（8） ： 插入 更新 删除&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一篇《我的MYSQL学习心得（九）》将会讲解MYSQL的索引&lt;/p&gt;
&lt;p&gt;索引是在存储引擎中实现的，因此每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。&lt;/p&gt;
&lt;p&gt;根据存储引擎定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。&lt;/p&gt;
&lt;p&gt;大多数存储引擎有更高的限制。MYSQL中索引的存储类型有两种：BTREE和HASH，具体和表的存储引擎相关；&lt;/p&gt;
&lt;p&gt;MYISAM和InnoDB存储引擎只支持BTREE索引；MEMORY和HEAP存储引擎可以支持HASH和BTREE索引&lt;/p&gt;
&lt;p&gt;索引的优点：&lt;/p&gt;
&lt;p&gt;1、通过创建唯一索引，保证数据库表每行数据的唯一性&lt;/p&gt;
&lt;p&gt;2、大大加快数据查询速度&lt;/p&gt;
&lt;p&gt;3、在使用分组和排序进行数据查询时，可以显著减少查询中分组和排序的时间&lt;/p&gt;
&lt;p&gt;索引的缺点：&lt;/p&gt;
&lt;p&gt;1、维护索引需要耗费数据库资源&lt;/p&gt;
&lt;p&gt;2、索引需要占用磁盘空间，索引文件可能比数据文件更快达到最大文件尺寸&lt;/p&gt;
&lt;p&gt;3、当对表的数据进行增删改的时候，因为要维护索引，速度会受到影响&lt;/p&gt;
&lt;p&gt;索引的分类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、普通索引和唯一索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主键索引是一种特殊的唯一索引，不允许有空值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、单列索引和复合索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单列索引只包含单个列&lt;/p&gt;
&lt;p&gt;复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、全文索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在&lt;/p&gt;
&lt;p&gt;CHAR、VARCHAR、TEXT类型列上创建。MYSQL只有MYISAM存储引擎支持全文索引&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、空间索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，&lt;/p&gt;
&lt;p&gt;分别是GEOMETRY、POINT、LINESTRING、POLYGON。&lt;/p&gt;
&lt;p&gt;MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须&lt;/p&gt;
&lt;p&gt;将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建&lt;/p&gt;
&lt;p&gt;以上的索引在&lt;strong&gt;SQLSERVER&lt;/strong&gt;里都支持&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE table_name[col_name data type]
[unique|fulltext|spatial][index|key][index_name](col_name[length])[asc|desc]&lt;/pre&gt;
&lt;p&gt;unique|fulltext|spatial为可选参数，分别表示唯一索引、全文索引和空间索引；&lt;/p&gt;
&lt;p&gt;index和key为同义词，两者作用相同，用来指定创建索引&lt;/p&gt;
&lt;p&gt;col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择；&lt;/p&gt;
&lt;p&gt;index_name指定索引的名称，为可选参数，如果不指定，MYSQL默认col_name为索引值；&lt;/p&gt;
&lt;p&gt;length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；&lt;/p&gt;
&lt;p&gt;asc或desc指定升序或降序的索引值存储&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;普通索引&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE book (
  bookid INT NOT NULL,
  bookname VARCHAR (255) NOT NULL,
  AUTHORS VARCHAR (255) NOT NULL,
  info VARCHAR (255) NULL,
  COMMENT VARCHAR (255) NULL,
  year_publication YEAR NOT NULL,
  INDEX (year_publication)
) ;&lt;/pre&gt;
&lt;p&gt;使用SHOW CREATE TABLE查看表结构&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE `book` (
  `bookid` INT(11) NOT NULL,
  `bookname` VARCHAR(255) NOT NULL,
  `authors` VARCHAR(255) NOT NULL,
  `info` VARCHAR(255) DEFAULT NULL,
  `comment` VARCHAR(255) DEFAULT NULL,
  `year_publication` YEAR(4) NOT NULL,
  KEY `year_publication` (`year_publication`)
) ENGINE=MYISAM DEFAULT CHARSET=latin1&lt;/pre&gt;
&lt;p&gt;可以发现，book表的year_publication字段成功建立了索引其索引名字为year_publication&lt;/p&gt;
&lt;p&gt;我们向表插入一条数据，然后使用EXPLAIN语句查看索引是否有在使用&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO BOOK VALUES(12,&#39;NIHAO&#39;,&#39;NIHAO&#39;,&#39;文学&#39;,&#39;henhao&#39;,1990)

EXPLAIN SELECT * FROM book WHERE year_publication=1990&lt;/pre&gt;
&lt;p&gt;因为语句比较简单，系统判断有可能会用到索引或者全文扫描&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b303b083754eba03e0397a7714fb765d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;EXPLAIN语句输出结果的各个行的解释如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;select_type：&lt;/strong&gt; 表示查询中每个select子句的类型（简单 OR复杂）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;type：&lt;/strong&gt;表示MySQL在表中找到所需行的方式，又称“访问类型”，常见类型如下：（从上至下，效果依次变好）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;possible_keys&lt;/strong&gt; ：指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;key：&lt;/strong&gt; 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;key_len&lt;/strong&gt; ：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ref&lt;/strong&gt; ：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rows&lt;/strong&gt; ：表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Extra&lt;/strong&gt; ：包含不适合在其他列中显示但十分重要的额外信息 如using where，using index&lt;/p&gt;
&lt;p&gt;参考：&lt;a title=&quot;http://www.cnblogs.com/SQLSERVERZOUQI/p/3737199.html&quot; href=&quot;http://www.cnblogs.com/SQLSERVERZOUQI/p/3737199.html&quot; target=&quot;_blank&quot;&gt;MySQL学习系列2–MySQL执行计划分析EXPLAIN&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;唯一索引列的值必须唯一，但允许有空值。如果是复合索引则列值的组合必须唯一&lt;/p&gt;
&lt;p&gt;建表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t1
(
 id INT NOT NULL,
 NAME CHAR(30) NOT NULL,
 UNIQUE INDEX UniqIdx(id)&lt;/pre&gt;
&lt;p&gt;SHOW CREATE TABLE t1 查看表结构&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE TABLE t1&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt; CREATE TABLE `t1` (                                                                                                                        
          `id` int(11) NOT NULL,                                                                                                                   
          `name` char(30) NOT NULL,                                                                                                                
          UNIQUE KEY `UniqIdx` (`id`)                                                                                                              
        ) ENGINE=MyISAM DEFAULT CHARSET=utf8&lt;/pre&gt;
&lt;p&gt;可以看到id字段上已经成功建立了一个名为UniqIdx的唯一索引&lt;/p&gt;
&lt;p&gt;创建复合索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t3 (
  id INT NOT NULL,
  NAME CHAR(30) NOT NULL,
  age INT NOT NULL,
  info VARCHAR (255),
  INDEX MultiIdx (id, NAME, age (100))
)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE TABLE t3

CREATE TABLE `t3` (                                                                                                                                                                                             
          `id` int(11) NOT NULL,                                                                                                                                                                                        
          `NAME` char(30) NOT NULL,                                                                                                                                                                                     
          `age` int(11) NOT NULL,                                                                                                                                                                                       
          `info` varchar(255) DEFAULT NULL,                                                                                                                                                                             
          KEY `MultiIdx` (`id`,`NAME`,`age`)                                                                                                                                                                            
        ) ENGINE=MyISAM DEFAULT CHARSET=utf8&lt;/pre&gt;
&lt;p&gt;由结果可以看到id,name,age字段上已经成功建立了一个名为MultiIdx的复合索引&lt;/p&gt;
&lt;p&gt;我们向表插入两条数据&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO t3(id ,NAME,age,info) VALUES(1,&#39;小明&#39;,12,&#39;nihao&#39;),(2,&#39;小芳&#39;,16,&#39;nihao&#39;)&lt;/pre&gt;
&lt;p&gt;使用EXPLAIN语句查看索引使用情况&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;EXPLAIN SELECT * FROM t3 WHERE id=1 AND NAME=&#39;小芳&#39;&lt;/pre&gt;
&lt;p&gt;可以看到  &lt;strong&gt;possible_keys&lt;/strong&gt;和 &lt;strong&gt;key&lt;/strong&gt; 为MultiIdx证明使用了复合索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;    id  select_type  table   type    possible_keys  key       key_len  ref            rows  Extra      
------  -----------  ------  ------  -------------  --------  -------  -----------  ------  -----------
     1  SIMPLE       t3      ref     MultiIdx       MultiIdx  94       const,const       1  Using where&lt;/pre&gt;
&lt;p&gt;如果我们只指定name而不指定id&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;EXPLAIN SELECT * FROM t3 WHERE  NAME=&#39;小芳&#39;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;    id  select_type  table   type    possible_keys  key     key_len  ref       rows  Extra      
------  -----------  ------  ------  -------------  ------  -------  ------  ------  -----------
     1  SIMPLE       t3      ALL     (NULL)         (NULL)  (NULL)   (NULL)       2  Using where&lt;/pre&gt;
&lt;p&gt;结果跟SQLSERVER一样，也是不走索引， &lt;strong&gt;possible_keys&lt;/strong&gt;和&lt;strong&gt;key&lt;/strong&gt;都为NULL&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;全文索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FULLTEXT索引可以用于全文搜索。只有MYISAM存储引擎支持FULLTEXT索引，并且只支持CHAR、VARCHAR和TEXT类型&lt;/p&gt;
&lt;p&gt;全文索引不支持过滤索引。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t4 (
  id INT NOT NULL,
  NAME CHAR(30) NOT NULL,
  age INT NOT NULL,
  info VARCHAR (255),
  FULLTEXT INDEX FulltxtIdx (info)
) ENGINE = MYISAM&lt;/pre&gt;
&lt;p&gt;由于MYSQL5.6默认存储引擎为InnoDB，这里创建表的时候要修改表的存储引擎为MYISAM，不然创建索引会出错&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE TABLE t4&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Table   Create Table                                                                                                                                                                                                    
------  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
t4      CREATE TABLE `t4` (                                                                                                                                                                                             
          `id` int(11) NOT NULL,                                                                                                                                                                                        
          `name` char(30) NOT NULL,                                                                                                                                                                                     
          `age` int(11) NOT NULL,                                                                                                                                                                                       
          `info` varchar(255) DEFAULT NULL,                                                                                                                                                                             
          FULLTEXT KEY `FulltxtIdx` (`info`)                                                                                                                                                                            
        ) ENGINE=MyISAM DEFAULT CHARSET=utf8&lt;/pre&gt;
&lt;p&gt;由结果可以看到，info字段上已经成功建立名为FulltxtIdx的FULLTEXT索引。&lt;/p&gt;
&lt;p&gt;全文索引非常适合大型数据集合&lt;/p&gt;
&lt;p&gt;在SQLSERVER里使用全文索引比MYSQL还要复杂&lt;/p&gt;
&lt;p&gt;详细可以参考下面两篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/lyhabc/archive/2012/08/05/2623795.html&quot; href=&quot;http://www.cnblogs.com/lyhabc/archive/2012/08/05/2623795.html&quot; target=&quot;_blank&quot;&gt;关于SQLSERVER的全文目录跟全文索引的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/chegan/archive/2005/08/02/205756.html&quot; href=&quot;http://www.cnblogs.com/chegan/archive/2005/08/02/205756.html&quot; target=&quot;_blank&quot;&gt;[SQLSERVER]SQL中的全文检索(转邹建)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;空间索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;空间索引必须在 MYISAM类型的表中创建，而且空间类型的字段必须为&lt;strong&gt;非空&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建表t5&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t5
(g GEOMETRY NOT NULL ,SPATIAL INDEX spatIdx(g))ENGINE=MYISAM&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE TABLE t5

TABLE   CREATE TABLE                                                                                                   
------  ---------------------------------------------------------------------------------------------------------------
t5      CREATE TABLE `t5` (                                                                                            
          `g` GEOMETRY NOT NULL,                                                                                       
          SPATIAL KEY `spatIdx` (`g`)                                                                                  
        ) ENGINE=MYISAM DEFAULT CHARSET=utf8&lt;/pre&gt;
&lt;p&gt;可以看到，t5表的g字段上创建了名称为spatIdx的空间索引。注意创建时指定空间类型字段值的非空约束&lt;/p&gt;
&lt;p&gt;并且表的存储引擎为MYISAM&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;已经存在的表上创建索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在已经存在的表中创建索引，可以使用ALTER TABLE或者CREATE INDEX语句&lt;/p&gt;
&lt;p&gt;1、使用ALTER TABLE语句创建索引，语法如下&lt;/p&gt;
&lt;p&gt;ALTER TABLE table_name ADD [UNIQUE|FULLTEXT|SPATIAL][INDEX|KEY]&lt;/p&gt;
&lt;p&gt;[index_name](col_name[length],…)[ASC|DESC]&lt;/p&gt;
&lt;p&gt;与创建表时创建索引的语法不同，在这里使用了ALTER TABLE和ADD关键字，ADD表示向表中添加索引&lt;/p&gt;
&lt;p&gt;在t1表中的name字段上建立NameIdx普通索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE t1 ADD INDEX NameIdx(NAME)&lt;/pre&gt;
&lt;p&gt;添加索引之后，使用SHOW INDEX语句查看指定表中创建的索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW INDEX FROM t1

TABLE   Non_unique  Key_name  Seq_in_index  Column_name  COLLATION  Cardinality  Sub_part  Packed  NULL    Index_type  COMMENT  Index_comment
------  ----------  --------  ------------  -----------  ---------  -----------  --------  ------  ------  ----------  -------  -------------
t1               0  UniqIdx              1  id           A                    0    (NULL)  (NULL)          BTREE                             
t1               1  NameIdx              1  NAME         A               (NULL)    (NULL)  (NULL)          BTREE&lt;/pre&gt;
&lt;p&gt;各个参数的含义&lt;/p&gt;
&lt;p&gt;1、TABLE：要创建索引的表&lt;/p&gt;
&lt;p&gt;2、Non_unique：索引非唯一，1代表是非唯一索引，0代表唯一索引&lt;/p&gt;
&lt;p&gt;3、Key_name：索引的名称&lt;/p&gt;
&lt;p&gt;4、Seq_in_index：该字段在索引中的位置，单列索引该值为1，复合索引为每个字段在索引定义中的顺序&lt;/p&gt;
&lt;p&gt;5、Column_name：定义索引的列字段&lt;/p&gt;
&lt;p&gt;6、Sub_part：索引的长度&lt;/p&gt;
&lt;p&gt;7、NULL：该字段是否能为空值&lt;/p&gt;
&lt;p&gt;8、Index_type：索引类型&lt;/p&gt;
&lt;p&gt;可以看到，t1表已经存在了一个唯一索引&lt;/p&gt;
&lt;p&gt;在t3表的age和info字段上创建复合索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE t3 ADD INDEX t3AgeAndInfo(age,info)&lt;/pre&gt;
&lt;p&gt;使用SHOW INDEX查看表中的索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW INDEX FROM t3&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Table   Non_unique  Key_name      Seq_in_index  Column_name  Collation  Cardinality  Sub_part  Packed  Null    Index_type  Comment  Index_comment
------  ----------  ------------  ------------  -----------  ---------  -----------  --------  ------  ------  ----------  -------  -------------
t3               1  MultiIdx                 1  id           A               (NULL)    (NULL)  (NULL)          BTREE                             
t3               1  MultiIdx                 2  NAME         A               (NULL)    (NULL)  (NULL)          BTREE                             
t3               1  MultiIdx                 3  age          A               (NULL)    (NULL)  (NULL)          BTREE                             
t3               1  t3AgeAndInfo             1  age          A               (NULL)    (NULL)  (NULL)          BTREE                             
t3               1  t3AgeAndInfo             2  info         A               (NULL)    (NULL)  (NULL)  YES     BTREE&lt;/pre&gt;
&lt;p&gt;可以看到表中的字段的顺序，第一个位置是age，第二个位置是info，info字段是可空字段&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f43a17002244b0c7693125ac65e0e4ba.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e84c50cedafa28082e4ba63dcb8947be.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;创建表t6，在t6表上创建全文索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t6
(
  id INT NOT NULL,
  info CHAR(255)
)ENGINE= MYISAM;&lt;/pre&gt;
&lt;p&gt;注意修改ENGINE参数为MYISAM，MYSQL默认引擎InnoDB不支持全文索引&lt;/p&gt;
&lt;p&gt;使用ALTER TABLE语句在info字段上创建全文索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE t6 ADD FULLTEXT INDEX infoFTIdx(info)&lt;/pre&gt;
&lt;p&gt;使用SHOW INDEX查看索引情况&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW INDEX FROM t6&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Table   Non_unique  Key_name   Seq_in_index  Column_name  Collation  Cardinality  Sub_part  Packed  Null    Index_type  Comment  Index_comment
------  ----------  ---------  ------------  -----------  ---------  -----------  --------  ------  ------  ----------  -------  -------------
t6               1  infoFTIdx             1  info         (NULL)          (NULL)    (NULL)  (NULL)  YES     FULLTEXT&lt;/pre&gt;
&lt;p&gt;创建表t7，并在空间数据类型字段g上创建名称为spatIdx的空间索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t7(g GEOMETRY NOT NULL)ENGINE=MYISAM;&lt;/pre&gt;
&lt;p&gt;使用ALTER TABLE在表t7的g字段建立空间索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE t7 ADD SPATIAL INDEX spatIdx(g)&lt;/pre&gt;
&lt;p&gt;使用SHOW INDEX查看索引情况&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW INDEX FROM t7&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Table   Non_unique  Key_name  Seq_in_index  Column_name  Collation  Cardinality  Sub_part  Packed  Null    Index_type  Comment  Index_comment
------  ----------  --------  ------------  -----------  ---------  -----------  --------  ------  ------  ----------  -------  -------------
t7               1  spatIdx              1  g            A               (NULL)        32  (NULL)          SPATIAL&lt;/pre&gt;
&lt;p&gt;2、使用CREATE INDEX语句创建索引，语法如下&lt;/p&gt;
&lt;p&gt;CREATE [UNIQUE|FULLTEXT|SPATIAL]  INDEX index_name&lt;/p&gt;
&lt;p&gt;ON table_name(col_name[length],…)  [ASC|DESC]&lt;/p&gt;
&lt;p&gt;可以看到CREATE INDEX语句和ALTER INDEX语句的基本语法一样，只是关键字不同。&lt;/p&gt;
&lt;p&gt;我们建立一个book表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE book (
  bookid INT NOT NULL,
  bookname VARCHAR (255) NOT NULL,
  AUTHORS VARCHAR (255) NOT NULL,
  info VARCHAR (255) NULL,
  COMMENT VARCHAR (255) NULL,
  year_publication YEAR NOT NULL
)&lt;/pre&gt;
&lt;p&gt;建立普通索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE INDEX BkNameIdx ON book(bookname)&lt;/pre&gt;
&lt;p&gt;建立唯一索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE UNIQUE INDEX UniqidIdx ON book(bookId)&lt;/pre&gt;
&lt;p&gt;建立复合索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE INDEX BkAuAndInfoIdx ON book(AUTHORS(20),info(50))&lt;/pre&gt;
&lt;p&gt;建立全文索引，我们drop掉t6表，重新建立t6表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP TABLE IF EXISTS t6

CREATE TABLE t6
(
  id INT NOT NULL,
  info CHAR(255)
)ENGINE= MYISAM;

CREATE FULLTEXT INDEX infoFTIdx ON t6(info);&lt;/pre&gt;
&lt;p&gt;建立空间索引，我们drop掉t7表，重新建立t7表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP TABLE IF EXISTS t7

CREATE TABLE t7(g GEOMETRY NOT NULL)ENGINE=MYISAM;

CREATE SPATIAL INDEX spatIdx  ON t7(g)&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;删除索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MYSQL中使用ALTER TABLE或者DROP INDEX语句来删除索引，两者实现相同功能&lt;/p&gt;
&lt;p&gt;1、使用ALTER TABLE删除索引&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;p&gt;ALTER TABLE table_name DROP INDEX index_name&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE book DROP INDEX UniqidIdx&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE TABLE book&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Table   Create Table                                                                                                                                                                                                                                                                                                                                                      
------  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
book    CREATE TABLE `book` (                                                                                                                                                                                                                                                                                                                                             
          `bookid` int(11) NOT NULL,                                                                                                                                                                                                                                                                                                                                      
          `bookname` varchar(255) NOT NULL,                                                                                                                                                                                                                                                                                                                               
          `authors` varchar(255) NOT NULL,                                                                                                                                                                                                                                                                                                                                
          `info` varchar(255) DEFAULT NULL,                                                                                                                                                                                                                                                                                                                               
          `comment` varchar(255) DEFAULT NULL,                                                                                                                                                                                                                                                                                                                            
          `year_publication` year(4) NOT NULL,                                                                                                                                                                                                                                                                                                                            
          KEY `BkNameIdx` (`bookname`),                                                                                                                                                                                                                                                                                                                                   
          KEY `BkAuAndInfoIdx` (`authors`(20),`info`(50))                                                                                                                                                                                                                                                                                                                 
        ) ENGINE=MyISAM DEFAULT CHARSET=utf8&lt;/pre&gt;
&lt;p&gt;可以看到，book表中已经没有名为UniqidIdx的唯一索引，删除索引成功&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：AUTO_INCREMENT约束字段的唯一索引不能被删除！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、使用DROP INDEX 语句删除索引&lt;/p&gt;
&lt;p&gt;DROP INDEX index_name ON table_name&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP INDEX BkAuAndInfoIdx ON book&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE TABLE book;

Table   Create Table                                                                                                                                                                                                                                                                                                   
------  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
book    CREATE TABLE `book` (                                                                                                                                                                                                                                                                                          
          `bookid` int(11) NOT NULL,                                                                                                                                                                                                                                                                                   
          `bookname` varchar(255) NOT NULL,                                                                                                                                                                                                                                                                            
          `authors` varchar(255) NOT NULL,                                                                                                                                                                                                                                                                             
          `info` varchar(255) DEFAULT NULL,                                                                                                                                                                                                                                                                            
          `comment` varchar(255) DEFAULT NULL,                                                                                                                                                                                                                                                                         
          `year_publication` year(4) NOT NULL,                                                                                                                                                                                                                                                                         
          KEY `BkNameIdx` (`bookname`)                                                                                                                                                                                                                                                                                 
        ) ENGINE=MyISAM DEFAULT CHARSET=utf8&lt;/pre&gt;
&lt;p&gt;可以看到，复合索引BkAuAndInfoIdx已经被删除了&lt;/p&gt;
&lt;p&gt;提示：删除表中的某列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。&lt;/p&gt;
&lt;p&gt;如果索引中的所有列都被删除，则整个索引将被删除！！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节介绍了MYSQL中的索引，索引语句的创建和删除和一些简单用法，希望对大家有帮助&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87348&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87348votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87348&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 04 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-04-87348-24a09a32c.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-04-87348-24a09a32c.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（8） ： 插入 更新 删除</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87340/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（7） ： 查询&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一篇《我的MYSQL学习心得（八）》将会讲解MYSQL的插入、更新和删除语句&lt;/p&gt;
&lt;p&gt;同样的，只会讲解跟SQLSERVER不同的地方&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将多行查询结果插入到表中&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO table_name1(column_list1) SELECT (column_list2) FROM table_name2 WHERE (condition)&lt;/pre&gt;
&lt;p&gt;INSERT INTO SELECT 在&lt;strong&gt;SQLSERVER&lt;/strong&gt;里也是支持的&lt;/p&gt;
&lt;p&gt;table_name1指定待插入数据的表；column_list1指定待插入表中要插入数据的哪些列；table_name2指定插入数据是从&lt;/p&gt;
&lt;p&gt;哪个表中查询出来的；column_list2指定数据来源表的查询列，该列表必须和column_list1列表中的字段个数相同，数据类型相同；&lt;/p&gt;
&lt;p&gt;condition指定SELECT语句的查询条件&lt;/p&gt;
&lt;p&gt;从person_old表中查询所有的记录，并将其插入到person表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE person (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  NAME CHAR(40) NOT NULL DEFAULT &#39;&#39;,
  age INT NOT NULL DEFAULT 0,
  info CHAR(50) NULL,
  PRIMARY KEY (id)
)

CREATE TABLE person_old (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  NAME CHAR(40) NOT NULL DEFAULT &#39;&#39;,
  age INT NOT NULL DEFAULT 0,
  info CHAR(50) NULL,
  PRIMARY KEY (id)
)

INSERT INTO person_old
VALUES (11,&#39;Harry&#39;,20,&#39;student&#39;),(12,&#39;Beckham&#39;,31,&#39;police&#39;)

SELECT * FROM person_old&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/09fabba930296c8b98d475f836b9d20b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，插入记录成功，person_old表现在有两条记录。接下来将person_oldperson_old表中的所有记录插入到person表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO person(id,NAME,age,info)
SELECT id,NAME,age,info FROM person_old;

SELECT * FROM person&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5dfb0a618d41670d35c12349425441c1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到数据转移成功，这里的id字段为自增的主键，在插入时要保证该字段值的唯一性，如果不能确定，可以插入的时候忽略该字段，&lt;/p&gt;
&lt;p&gt;只插入其他字段的值&lt;/p&gt;
&lt;p&gt;如果再执行一次就会出错&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dc7e53e53af44f79cbb6c80354d2afea.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;MYSQL和SQLSERVER的区别：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区别一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当要导入的数据中有重复值的时候，MYSQL会有三种方案&lt;/p&gt;
&lt;p&gt;方案一：使用 ignore 关键字&lt;br&gt;
方案二：使用 replace into&lt;br&gt;
方案三：ON DUPLICATE KEY UPDATE&lt;/p&gt;
&lt;p&gt;第二和第三种方案这里不作介绍，因为比较复杂，而且不符合要求，这里只讲第一种方案&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;TRUNCATE TABLE person

TRUNCATE TABLE persona_old 

INSERT INTO person_old
VALUES (11,&#39;Harry&#39;,20,&#39;student&#39;),(12,&#39;Beckham&#39;,31,&#39;police&#39;)

##注意下面这条insert语句是没有ignore关键字的
INSERT  INTO person(id,NAME,age,info)
SELECT id,NAME,age,info FROM person_old;

INSERT INTO person_old 
VALUES (13,&#39;kay&#39;,26,&#39;student&#39;)

##注意下面这条insert语句是有ignore关键字的
INSERT IGNORE INTO person(id,NAME,age,info)
SELECT id,NAME,age,info FROM person_old;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6bf8e08daca8360b8f265f61edc4d11e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/96a99a18a228ff9a7a7e599f3770714d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到插入成功&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQLSERVER&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SQLSERVER这边，如果要忽略重复键，需要在建表的时候指定 WITH (IGNORE_DUP_KEY = ON) ON [PRIMARY]&lt;/p&gt;
&lt;p&gt;这样在插入重复值的时候，SQLSERVER第一次会保留值，第二次发现有重复值的时候，SQLSERVER就会忽略掉&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区别二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插入自增列时的区别&lt;/p&gt;
&lt;p&gt;SQLSERVER需要使用 SET IDENTITY_INSERT 表名 ON 才能把自增字段的值插入到表中，如果不加 SET IDENTITY_INSERT 表名 ON&lt;/p&gt;
&lt;p&gt;则在插入数据到表中时，不能指定自增字段的值，则id字段不能指定值，SQLSERVER会自动帮你自动增加一&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERTINTO person(NAME,age,info) VALUES (&#39;feicy&#39;,33,&#39;student&#39;)&lt;/pre&gt;
&lt;p&gt;而MYSQL则不需要，而且自由度非常大&lt;/p&gt;
&lt;p&gt;你可以将id字段的值指定为NULL，MYSQL会自动帮你增一&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERTINTO person(id,NAME,age,info) VALUES (NULL,&#39;feicy&#39;,33,&#39;student&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b5c1cf5d0ccf1d5420123b2ce5b34f3c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;也可以指定值&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT IGNORE INTO person(id,NAME,age,info) VALUES (16,&#39;tom&#39;,88,&#39;student&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/919f120d40a62c085650a2814dd6d5bb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;也可以不写id的值，MYSQL会自动帮你增一&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT IGNORE INTO person(NAME,age,info) VALUES (&#39;amy&#39;,12,&#39;bb&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a3cc6e24cd90921727b0c1595b7ba64a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;你可以指定id字段的值也可以不指定，指定的时候只要当前id字段列没有你正在插入的那个值就可以，即没有重复值就可以&lt;/p&gt;
&lt;p&gt;自由度非常大，而且无须指定 SET IDENTITY_INSERT 表名 ON 选项&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区别三&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;唯一索引的NULL值重复问题&lt;/p&gt;
&lt;p&gt;MYSQL&lt;/p&gt;
&lt;p&gt;在MYSQL中UNIQUE 索引将会对null字段失效&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;insert into test(a) values(null)

insert into test(a) values(null)&lt;/pre&gt;
&lt;p&gt;上面的插入语句是可以重复插入的（联合唯一索引也一样）&lt;/p&gt;
&lt;p&gt;SQLSERVER&lt;/p&gt;
&lt;p&gt;SQLSERVER则不行&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE person (
  id INT  NOT NULL IDENTITY(1,1),
  NAME CHAR(40)  NULL DEFAULT &#39;&#39;,
  age INT NOT NULL DEFAULT 0,
  info CHAR(50) NULL,
  PRIMARY KEY (id)
)

CREATE UNIQUE INDEX IX_person_unique ON [dbo].[person](name)

INSERT INTO [dbo].[person]
        ( [NAME], [age], [info] )
VALUES  ( NULL, -- NAME - char(40)
          1, -- age - int
          &#39;aa&#39;  -- info - char(50)
          ),
          ( NULL, -- NAME - char(40)
          2, -- age - int
          &#39;bb&#39;  -- info - char(50)
          )&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;消息 2601，级别 14，状态 1，第 1 行
不能在具有唯一索引“IX_person_unique”的对象“dbo.person”中插入重复键的行。重复键值为 (&amp;lt;NULL&amp;gt;)。
语句已终止。&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更新比较简单，就不多说了&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;UPDATE person SET info =&#39;police&#39; WHERE id BETWEEN 14 AND 17

SELECT * FROM person&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/af11cc5f6e3a26b848a968cade650386.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除person表中一定范围的数据&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DELETE FROM  person  WHERE id BETWEEN 14 AND 17

SELECT * FROM person&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5b016dd565ee6e3c1a014c081ff509ef.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果要删除表的所有记录可以使用下面的两种方法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;##方法一
DELETE     FROM person

##方法二
TRUNCATE TABLE  person&lt;/pre&gt;
&lt;p&gt;跟SQLSERVER一样，TRUNCATE TABLE会比DELETE FROM TABLE 快&lt;/p&gt;
&lt;p&gt;MYISAM引擎下的测试结果，30行记录&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/68874e86427f5ed4cec4d57f20335565.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/75380d42a6a4e41b7130a81c298744dc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1dfc40ff095ea900869e5f7c51224f35.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;跟SQLSERVER一样，执行完TRUNCATE TABLE后，自增字段重新从一开始。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;################################
INSERT IGNORE INTO person(id,NAME,age,info)
SELECT id,NAME,age,info FROM person_old;

SELECT * FROM person

TRUNCATE TABLE  person

INSERT IGNORE INTO person(NAME,age,info) VALUES (&#39;amy&#39;,12,&#39;bb&#39;)

SELECT * FROM person&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/205107df6d91ecb896c03b0cd1e0b7e7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当你刚刚truncate了表之后执行下面语句就会看到重新从一开始&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW TABLE STATUS LIKE &#39;person&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e6c5c1d733173aaf6594c7b31771a517.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节介绍了MYSQL里的的插入、更新和删除，并且比较了与SQLSERVER的区别，特别是MYSQL里插入语句的灵活性&lt;/p&gt;
&lt;p&gt;刚刚开始从SQLSERVER转过来可能会有一些不适应&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.2cto.com/database/201308/234179.html&quot; href=&quot;http://www.2cto.com/database/201308/234179.html&quot; target=&quot;_blank&quot;&gt;mysql忽略主键冲突、避免重复插入的几种方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.it118.org/specials/c9fba99e-4401-49cf-8256-ac3c1a34c0d9/5bf5f814-8a57-4a77-a607-709083cba0aa.htm&quot; href=&quot;http://www.it118.org/specials/c9fba99e-4401-49cf-8256-ac3c1a34c0d9/5bf5f814-8a57-4a77-a607-709083cba0aa.htm&quot; target=&quot;_blank&quot;&gt;SQLSERVER忽略重复键进行数据导入的解决方案&lt;/a&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87345&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87345votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87345&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 04 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-04-87345-5164ec302.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-04-87345-5164ec302.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（7） ： 查询</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个《我的MYSQL学习心得》系列里面，我一直都把MYSQL跟SQLSERVER进行比较，相互进行比较是学习一样东西比较好的方法&lt;/p&gt;
&lt;p&gt;比较出大家的异同点，从而加深记忆&lt;/p&gt;
&lt;p&gt;这一篇《我的MYSQL学习心得（七）》也是一样，相同的地方略略带过，不同的地方我会给出例子，谢谢大家的支持o(∩_∩)o&lt;/p&gt;
&lt;p&gt;这一节主要介绍MYSQL里的基本查询（&lt;a title=&quot;http://dev.mysql.com/doc/refman/5.1/zh/preface.html&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/preface.html&quot; target=&quot;_blank&quot;&gt;MYSQL官方参考手册&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;MySQL中select的基本语法形式：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;select 属性列表
from 表名和视图列表
[where 条件表达式]
[group by 属性名[having 条件表达式]]
[order by 属性名[asc|desc]]
[limit &amp;lt;offset&amp;gt;,row count]&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;where子句：按照“条件表达式”指定的条件进行查询。&lt;/p&gt;
&lt;p&gt;group by子句：按照“属性名”指定的字段进行分组。&lt;/p&gt;
&lt;p&gt;having子句：有group by才能having子句，只有满足“条件表达式”中指定的条件的才能够输出。&lt;/p&gt;
&lt;p&gt;group by子句通常和count()、sum()等聚合函数一起使用。&lt;/p&gt;
&lt;p&gt;order by子句：按照“属性名”指定的字段进行排序。排序方式由“asc”和“desc”两个参数指出，默认是按照“asc”来排序，即升序。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;建立测试表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建测试表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE fruits
(
  f_id CHAR(10)  NOT NULL,
  s_id INT NOT NULL,
  f_name  CHAR(255)  NOT NULL,
  f_price DECIMAL(8,2) NOT NULL,
  PRIMARY KEY(f_id)
)&lt;/pre&gt;
&lt;p&gt;插入测试数据&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO fruits(f_id,s_id,f_name,f_price)
VALUES(&#39;a1&#39;,101,&#39;apple&#39;,5.2),
(&#39;b1&#39;,102,&#39;blackberry&#39;,5.2),
(&#39;bs1&#39;,105,&#39;orange&#39;,5.2),
(&#39;bs2&#39;,103,&#39;melon&#39;,5.2),
(&#39;t1&#39;,106,&#39;banana&#39;,5.2);&lt;/pre&gt;
&lt;p&gt;使用select语句查询f_id字段的数据&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT f_id,f_name FROM fruits&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ae561734b7827920de9540b636aa2489.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：MYSQL中SQL语句是不区分大小写的，因此select和SELECT作用是相同的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这一点跟SQLSERVER是一样的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用查询&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE fruits
(
  f_id CHAR(10)  NOT NULL,
  s_id INT NOT NULL,
  f_name  CHAR(255)  NOT NULL,
  f_price DECIMAL(8,2) NOT NULL,
  PRIMARY KEY(f_id)
)&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;带like的字符匹配查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、百分号通配符“%”，匹配任意长度的字符，甚至包括零字符&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT f_id,f_name FROM fruits WHERE f_name LIKE &#39;b%y&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/96c71b347e44828e68c3ec9bb5432fd8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、下划线通配符“_”,一次只能匹配任意一个字符&lt;/p&gt;
&lt;p&gt;下面语句有四个下划线&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT f_id,f_name FROM fruits WHERE f_name LIKE &#39;____n&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1794b429b479f3ae76bca4be2b15226d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;同样，在SQLSERVER里面也是有的&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE [sss]
GO
SELECT * FROM [dbo].[aaa] WHERE [name] LIKE &#39;s_____&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a64c7060bbe515a2185a59a3d82ebb23.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;查询空值&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE customers
(
  c_id INT  NOT NULL AUTO_INCREMENT,
  c_name CHAR(25) NOT NULL,
  c_city  CHAR(50)   NULL,
  PRIMARY KEY(c_id)
)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO customers(c_name,c_city)
VALUES(&#39;liming&#39;,&#39;china&#39;),
(&#39;hongfang&#39;,NULL)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM customers WHERE c_city IS NULL&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0d94fbc3e1b3d5c21d198289074a9101.jpg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM customers WHERE c_city IS NOT NULL&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f54500dffbae1246e043132028d6e0f1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;AND、OR、DISTINCT关键字&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT f_id,f_name FROM fruits WHERE f_name LIKE &#39;____n&#39; AND f_id=&#39;bs2&#39;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT f_id,f_name FROM fruits WHERE f_name LIKE &#39;____n&#39; OR f_id=&#39;bs2&#39;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT DISTINCT s_id FROM fruits&lt;/pre&gt;
&lt;p&gt;GROUP BY&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT s_id ,COUNT(1) AS total FROM fruits GROUP BY s_id&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b3d8dc3036bab6b786b2f4245af5a380.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;再插入两条记录&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO fruits(f_id,s_id,f_name,f_price)
VALUES(&#39;a6&#39;,101,&#39;cherry&#39;,6),
(&#39;a8&#39;,102,&#39;coconut&#39;,7)&lt;/pre&gt;
&lt;p&gt;如果要查看每个供应商提供的水果的种类的名称，MYSQL中可以在GROUP BY中使用GROUP_CONCAT()函数，&lt;/p&gt;
&lt;p&gt;将每个分组中各个字段的值显示出来&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT s_id,GROUP_CONCAT(f_name) AS NAMES FROM fruits GROUP BY s_id&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ab469e0303dc3638e053e17ccaeb9683.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;SQLSERVER是没有GROUP_CONCAT()函数的，SQLSERVER要达到同样效果需要使用xml函数，MYSQL这方面做得非常好&lt;/p&gt;
&lt;p&gt;having：过滤分组&lt;/p&gt;
&lt;p&gt;根据s_id对fruits表中的数据进行分组，并显示水果种类大于1的分组信息&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT s_id ,GROUP_CONCAT(f_name) AS NAMES FROM fruits GROUP BY s_id HAVING COUNT(f_name)&amp;gt;1&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2bee1f7b73b24ce598d926bc14282eeb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在group by中使用with rollup&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT s_id ,COUNT(1) AS total FROM fruits GROUP BY s_id WITH ROLLUP&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7a18a39dce88c88aeb90b6743ed7db91.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;增加了最后一行，7表示total列的所有值的总和&lt;/p&gt;
&lt;p&gt;而rollup关键字在SQLSERVER里面也有，详见：&lt;a title=&quot;http://www.cnblogs.com/lyhabc/p/3280634.html&quot; href=&quot;http://www.cnblogs.com/lyhabc/p/3280634.html&quot; target=&quot;_blank&quot;&gt;SQLSERVER中的ALL、PERCENT、CUBE关键字、ROLLUP关键字和GROUPING函数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的！&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;limit限制查询结果的数量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SQLSERVER中是使用&lt;strong&gt;TOP&lt;/strong&gt;关键字，而在MYSQL中是使用&lt;strong&gt;LIMIT&lt;/strong&gt;关键字&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;LIMIT[位置偏移量]，行数&lt;/pre&gt;
&lt;p&gt;第一个“位置偏移量”参数指示MYSQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”&lt;/p&gt;
&lt;p&gt;将会从表中第一条记录开始（第一条记录的位置偏移量是0，第二天记录的位置偏移量是1……以此类推）&lt;/p&gt;
&lt;p&gt;第二个参数“行数”指示返回的记录条数&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b4ab7943f78fd3e8111c860b9c5932a3.jpg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits LIMIT 4,3&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8808e0652fdcc17373f12fdd1ba2114d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面结果返回从第5条记录行（因为从0开始数）开始之后的3条记录&lt;/p&gt;
&lt;p&gt;注意：在MYSQL5.6中可以使用 LIMIT 4 OFFSET 3 ，意思是获取从第5行记录开始的3条记录，和 LIMIT 4,3 返回的结果是一样的&lt;/p&gt;
&lt;p&gt;在SQLSERVER2012里面开始支持类似MYSQL的这种语法，但是需要按某一列先排序，而不像MYSQL那样不用按照某一列排序&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE [sss]
GO

CREATE TABLE fruits
(
    f_id CHAR(10) NOT NULL ,
    s_id INT NOT NULL ,
    f_name CHAR(255) NOT NULL ,
    f_price DECIMAL(8, 2) NOT NULL ,
    PRIMARY KEY ( f_id )
)

INSERT  INTO fruits
        ( f_id ,
          s_id ,
          f_name ,
          f_price
        )
        SELECT  &#39;a1&#39; ,
                101 ,
                &#39;apple&#39; ,
                5.2
        UNION ALL
        SELECT  &#39;b1&#39; ,
                102 ,
                &#39;blackberry&#39; ,
                5.2
        UNION ALL
        SELECT  &#39;bs1&#39; ,
                105 ,
                &#39;orange&#39; ,
                5.2
        UNION ALL
        SELECT  &#39;bs2&#39; ,
                103 ,
                &#39;melon&#39; ,
                5.2
        UNION ALL
        SELECT  &#39;t1&#39; ,
                106 ,
                &#39;banana&#39; ,
                5.2
        UNION ALL
        SELECT  &#39;a6&#39; ,
                101 ,
                &#39;cherry&#39; ,
                6
        UNION ALL
        SELECT  &#39;a8&#39; ,
                102 ,
                &#39;coconut&#39; ,
                7&lt;/pre&gt;
&lt;p&gt;先按s_id排序，然后返回第5行开始的3条记录&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT  *
FROM    [dbo].[fruits]
ORDER BY [s_id] ASC
        OFFSET 4 ROWS
FETCH NEXT 3 ROWS ONLY;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d292be1939ee7f1a25b331a45f9305ff.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;虽然没有MYSQL那么方便，不过也算是一种进步，而对于OFFSET FETCH NEXT的性能可以参考宋沄剑的文章：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/CareySon/archive/2012/03/09/2387825.html#top&quot; href=&quot;http://www.cnblogs.com/CareySon/archive/2012/03/09/2387825.html#top&quot; target=&quot;_blank&quot;&gt;SQL Server2012 T-SQL对分页的增强尝试&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;子查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子查询&lt;/strong&gt;这个特性从&lt;strong&gt;MYSQL4.1&lt;/strong&gt;开始引入。&lt;/p&gt;
&lt;p&gt;插入测试数据&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE tbl1(num1 INT NOT NULL);
CREATE TABLE tbl2(num2 INT NOT NULL)

INSERT INTO tbl1 VALUES(1),(4),(13),(27);
INSERT INTO tbl2 VALUES(6),(14),(11),(20)&lt;/pre&gt;
&lt;p&gt;ANY关键字接在一个比较操作符的后面，表示若与子查询返回的任何值比较为TRUE，则返回TRUE&lt;/p&gt;
&lt;p&gt;返回tbl2表的所有num2列，然后将tbl1中的num1的值与之进行比较，只要大于num2的任何一个值，即为符合查询条件的结果&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT num1 FROM tbl1 WHERE num1&amp;gt;ANY(SELECT num2 FROM tbl2)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/54d1d343f9a723838d2e1c4ef8e61e40.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;ALL关键字接在一个比较操作符的后面，表示与子查询返回的所有值比较为TRUE，则返回TRUE&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT num1 FROM tbl1 WHERE num1&amp;gt;ALL(SELECT num2 FROM tbl2)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7d1cacd1d652ff6f7c73685788dd0a7e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;SQLSERVER&lt;/strong&gt;中也可以使用ANY和ALL关键字&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE [sss]
GO
CREATE TABLE tbl1(num1 INT NOT NULL)
CREATE TABLE tbl2(num2 INT NOT NULL)

INSERT INTO tbl1 VALUES(1),(4),(13),(27)
INSERT INTO tbl2 VALUES(6),(14),(11),(20)

SELECT num1 FROM tbl1 WHERE num1&amp;gt;ANY(SELECT num2 FROM tbl2)
SELECT num1 FROM tbl1 WHERE num1&amp;gt;ALL(SELECT num2 FROM tbl2)&lt;/pre&gt;
&lt;p&gt;结果是一样的&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e9bf1355920f676c1e6ab76d95b90171.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;合并查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用UNION关键字，合并结果时，两个查询对应的列数和数据类型必须相同。&lt;/p&gt;
&lt;p&gt;各个SELECT语句之间使用UNION或UNION ALL关键字分隔&lt;/p&gt;
&lt;p&gt;UNION：执行的时候删除重复的记录，所有返回的行都是唯一的&lt;/p&gt;
&lt;p&gt;UNION ALL：不删除重复行也不对结果进行自动排序&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT s_id,f_name,f_price    
FROM fruits
WHERE f_price&amp;lt;9.0
UNION 
SELECT s_id,f_name,f_price
FROM fruits
WHERE s_id IN (101,103)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/41af7c24f3ffe44d0e81644227c142c7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一个查询把f_price小于9.0的记录查询出来，第二个查询把s_id为101和103的记录查询处理&lt;/p&gt;
&lt;p&gt;因为f_price小于9.0的记录里有些记录的s_id是102、105、106，这些结果不会被去掉会跟第二个查询进行合并&lt;/p&gt;
&lt;p&gt;所以最终的结果会有s_id为102、105、106的记录&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;正则表达式查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正则表达式在&lt;strong&gt;SQLSERVER&lt;/strong&gt;里面是没有的，但是在MYSQL里不单只有，而且功能也比较丰富&lt;/p&gt;
&lt;p&gt;MYSQL中使用REGEXP关键字指定正则表达式的字符匹配模式&lt;/p&gt;
&lt;p&gt;1、查询以特定字符或字符串开头的记录&lt;/p&gt;
&lt;p&gt;字符“^”匹配以特定字符或者字符串开头的文本&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;^b&#39;&lt;/pre&gt;
&lt;p&gt;返回f_name字段以b开头的记录&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2ebeb2b809c204aab52f76de11729d71.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、查询以特定字符或字符串结尾的记录&lt;/p&gt;
&lt;p&gt;字符“$”匹配以特定字符或者字符串结尾的文本&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;y$&#39;&lt;/pre&gt;
&lt;p&gt;返回f_name字段以y结尾的记录&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3060ac4a8482566be87a91b6ad79d975.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5bf217763e5f665fc5834b841fe12d67.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、用符号“.”来代替字符串中的任意一个字符&lt;/p&gt;
&lt;p&gt;字符“.”匹配任意一个字符&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;a.g&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e4332e28119f8390d1921407b732bebc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;a和g两个字母之间包含单个字符，orange符合要求&lt;/p&gt;
&lt;p&gt;4、使用“*”和“+”来匹配多个字符&lt;/p&gt;
&lt;p&gt;星号“*”匹配前面的字符任意多次，包括0次。加号“+”匹配前面的字符至少一次&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;^ba*&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/381e9e42644dde28934d611a5126a050.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;blackberry和banana符合要求，b开头，a匹配任意多次，不管出现的顺序在哪里&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;^ba+&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/658c0d71007a951dd2407b86795e494e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;“a+”匹配字母“a”至少一次，只有banana满足匹配条件&lt;/p&gt;
&lt;p&gt;5、匹配指定字符串&lt;/p&gt;
&lt;p&gt;正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符“|”隔开&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;on|ap&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0684a46eedc5221b460ccdf5b15edee5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到apple 、melon 、coconut 3个值中都包含有字符串“on”和“ap”，满足匹配条件&lt;/p&gt;
&lt;p&gt;6、匹配指定字符中的任意一个&lt;/p&gt;
&lt;p&gt;方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;[ot]&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/70343a46c2a95d62d1e8b54c8a2f5644.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;方括号[]还可以指定数值集合&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE s_id REGEXP &#39;[456]&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/53ad94c26b2ff17b0c262746119e1283.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;s_id字段值中有3个数字中的1个即为匹配记录字段&lt;/p&gt;
&lt;p&gt;[456]也可以写成[4-6]即指定集合区间&lt;/p&gt;
&lt;p&gt;7、匹配指定字符以外的字符&lt;/p&gt;
&lt;p&gt;“[^字符集合]”匹配不在指定集合中的任何字符&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_id REGEXP &#39;[^a-e1-2]&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/85adc18f7cdebad4a196bddbbf9516cc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;返回开头不在a-e  1-2字母的记录，例如a1，b1这些记录就不符合要求&lt;/p&gt;
&lt;p&gt;8、使用{n,} 或者{n,m}来指定字符串连续出现的次数&lt;/p&gt;
&lt;p&gt;“字符串{n,}”，表示至少匹配n次前面的字符；“字符串{n,m}”表示匹配前面的字符串不少于n次，不多于m次。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt; SELECT * FROM fruits WHERE f_name REGEXP &#39;b{1,}&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/21c11cf6d5bef8ab166447aaafbf43b4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;至少匹配1次字母b，blackberry和banana都符合要求&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt; SELECT * FROM fruits WHERE f_name REGEXP &#39;ba{1,3}&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6d3a8f427364a03979c3453f5b547f8d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;“ba”字符串最少出现一次，最多三次，banana这个字符串符合要求&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节介绍了MYSQL里的查询，并且比较了与SQLSERVER的区别，特别是MYSQL里的正则查询灵活多变&lt;/p&gt;
&lt;p&gt;这一点比SQLSERVER略为优胜&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87340&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87340votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87340&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 04 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-04-87340-ab5cf6ef0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-04-87340-ab5cf6ef0.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（6） ： 函数</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一节主要介绍MYSQL里的函数，MYSQL里的函数很多，&lt;strong&gt;我这里主要介绍MYSQL里有而SQLSERVER没有的函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数学函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、求余函数MOD(X,Y)&lt;/p&gt;
&lt;p&gt;MOD(X,Y)返回x被y除后的余数，MOD()对于带有小数部分的数值也起作用，他返回除法运算后的精确余数&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT MOD(31,8)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f9e743cb3035684e8f41747dc4eaa65b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、四舍五入函数TRUNCATE(X,Y)&lt;/p&gt;
&lt;p&gt;TRUNCATE(X,Y)返回被舍去至小数点后y位的数字x。若y的值为0，则结果不带有小数点或不带有小数部分。&lt;/p&gt;
&lt;p&gt;若y设为负数，则截去（归零）x小数点左边起第y位开始后面所有低位的值。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT TRUNCATE(1.32,1)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4376ff79d783e66a346bf7e9c134e9b0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;TRUNCATE(1.32,1)保留小数点后一位数字，返回值为1.3&lt;/p&gt;
&lt;p&gt;TIPS：ROUND(X,Y)函数在截取值的时候会四舍五入，而TRUNCATE(x，y)直接截取值，并不进行四舍五入&lt;/p&gt;
&lt;p&gt;3、求余函数HEX(X)和UNHEX（X）函数&lt;/p&gt;
&lt;p&gt;有以下的代码可以演示HEX和UNHEX的功能：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT HEX(&#39;this is a test str&#39;)&lt;/pre&gt;
&lt;p&gt;查询的结果为：746869732069732061207465737420737472&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT UNHEX(&#39;746869732069732061207465737420737472&#39;)&lt;/pre&gt;
&lt;p&gt;查询的结果为：this is a test str&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;字符串函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算字符串字符数的函数&lt;/p&gt;
&lt;p&gt;1、CHAR_LENGTH(STR)返回值为字符串str所包含的字符个数。一个多字节字符算作一个单字符&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT CHAR_LENGTH(&#39;DATE&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d464fd75f54610077fd753a0045b6a9c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、合并字符串函数CONCAT_WS（x,s1,s2,……）&lt;/p&gt;
&lt;p&gt;CONCAT_WS（x,s1,s2,……）,CONCAT_WS代表CONCAT with Separator，是CONCAT（）函数的特殊形式。&lt;/p&gt;
&lt;p&gt;第一个参数x是其他参数的分隔符，分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是&lt;/p&gt;
&lt;p&gt;其他参数。如果分隔符为NULL，则结果为NULL。函数会忽略任何分隔符参数后的NULL值。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT CONCAT_WS(&#39;-&#39;,&#39;1st&#39;,&#39;2nd&#39;,&#39;3rd&#39;),CONCAT_WS(&#39;-&#39;,&#39;1st&#39;,NULL,&#39;3rd&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/64e229c481f49152d3194d3205b96203.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;CONCAT_WS(‘-’,’1st’,’2nd’,’3rd’)使用分隔符‘-’将3个字符串连接成一个字符串，结果为“1st-2nd-3rd”；&lt;/p&gt;
&lt;p&gt;CONCAT_WS(‘-’,’1st’,NULL,’3rd’)因为第二个值为NULL，所以第二个值不会出现在结果里&lt;/p&gt;
&lt;p&gt;3、替换字符串的函数INSERT(S1,X,LEN,S2)&lt;/p&gt;
&lt;p&gt;INSERT(S1,X,LEN,S2)函数跟SQLSERVER里的STUFF()函数的功能是一样的，这里不作介绍了&lt;/p&gt;
&lt;p&gt;4、填充字符串的函数LPAD(S1,LEN,S2)和RPAD(S1,LEN,S2)&lt;/p&gt;
&lt;p&gt;LPAD(S1,LEN,S2)返回字符串s1，其左边由字符串s2填补到len字符串长度。假如s1的长度大于len，则返回值被缩短至len字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LPAD（）&lt;/strong&gt;函数和&lt;strong&gt;RPAD（&lt;/strong&gt;）函数功能跟SQLSERVER里的 REPLACE()相似，不过功能更加强大&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT LPAD(&#39;hello&#39;,4,&#39;??&#39;),LPAD(&#39;hello&#39;,10,&#39;??&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/68fde155a35e15594afe7a916e545327.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;字符串“hello”长度大于4，不需要填充，因此LPAD(‘hello’,4,’??’)只返回被缩短的长度为4的子串&lt;/p&gt;
&lt;p&gt;字符串“hello”长度小于10，LPAD(‘hello’,10,’??’)返回结果为“?????hello”，左侧填充“？”，长度为10&lt;/p&gt;
&lt;p&gt;5、RPAD(S1,LEN,S2)返回字符串s1，其右边被字符串s2填补至len字符长度。假如字符串s1的长度大于len，则返回值被缩短到len字符长度&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT RPAD(&#39;hello&#39;,4,&#39;?&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/eb85affb906047b65abaee449c75c674.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;字符串“hello”长度大于4，不需要填充，因此RPAD(‘hello’,4,’?&#39;)只返回被缩短的长度为4的子串”hell”&lt;/p&gt;
&lt;p&gt;6、删除空格的函数TRIM(S)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TRIM(S)&lt;/strong&gt;删除字符串s两侧的空格&lt;/p&gt;
&lt;p&gt;MYSQL这里比SQLSERVER方便，SQLSERVER要删除两边的空格，需要使用： SELECT LTRIM(RTRIM(‘ hello ’))&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT TRIM(&#39; book &#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e549617108326b2431010461b4828ba5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;删除指定字符串的函数TRIM(S1 FROM S)&lt;/p&gt;
&lt;p&gt;7、TRIM(S1 FROM S)删除字符串s中两端所有的子字符串s1。s1为可选项，在未指定情况下，删除空格&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT TRIM(&#39;xy&#39; FROM &#39;xyxboxyokxxyxy&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/81bae1bb5c2ad431c5809756b030aa5a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;‘xyxboxyokxxyxy’两端的重复字符串“xy”，而中间的“xy”并不删除，结果为&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;xboxyokx&lt;/pre&gt;
&lt;p&gt;8、重复生成字符串的函数REPEAT(S,N)&lt;/p&gt;
&lt;p&gt;这个函数跟SQLSERVER里的&lt;strong&gt;REPLICATE()&lt;/strong&gt;函数是一样的，参数个数都是一样的，这里不作介绍了&lt;/p&gt;
&lt;p&gt;9、比较字符串大小的函数STRCMP(S1,S2)&lt;/p&gt;
&lt;p&gt;STRCMP(S1,S2)若所有的字符串均相同，则返回0；若根据当前分类次序，第一个参数小于第二个，则返回-1，其他情况返回1&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT STRCMP(&#39;txt&#39;,&#39;txt2&#39;) ,STRCMP(&#39;txt2&#39;,&#39;txt&#39;),STRCMP(&#39;txt&#39;,&#39;txt&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9b9b59d8ab97b27661d541006050e170.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;“txt”小于“txt2”，因此 STRCMP(‘txt’,&#39;txt2′) 返回结果为-1&lt;/p&gt;
&lt;p&gt;STRCMP(‘txt2′,’txt’)返回结果为1&lt;/p&gt;
&lt;p&gt;“txt”与“txt”相等，因此STRCMP(‘txt’,&#39;txt’)返回结果为0&lt;/p&gt;
&lt;p&gt;10、匹配子串开始位置的函数&lt;/p&gt;
&lt;p&gt;LOCATE(STR1,STR)、POSITION(STR1 IN STR)、INSTR(STR,STR1)3个函数作用相同，返回子字符串str1在字符串str中的开始位置&lt;/p&gt;
&lt;p&gt;这三个函数跟SQLSERVER里的&lt;strong&gt;CHARINDEX()&lt;/strong&gt;函数功能类似&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT LOCATE(&#39;ball&#39;,&#39;football&#39;),POSITION(&#39;ball&#39; IN &#39;football&#39;) ,INSTR(&#39;football&#39;,&#39;ball&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1d0c9466642a489c7a6df369facc9113.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;子字符串“ball”在字符串“football”中从第5个字母位置开始，因此3个函数返回结果都为5&lt;/p&gt;
&lt;p&gt;11、返回指定位置的字符串的函数&lt;/p&gt;
&lt;p&gt;ELT(N,字符串1,字符串2,字符串3,…,)，若N=1,则返回值为字符串1，若N=2，则返回值为字符串2，以此类推。&lt;/p&gt;
&lt;p&gt;若N小于1或大于参数的数目，则返回值为NULL&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT ELT(3,&#39;1st&#39;,&#39;2nd&#39;,&#39;3rd&#39;),ELT(3,&#39;net&#39;,&#39;os&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/abc2bc598433ea11f408b80abaf61890.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由结果可以看到,ELT(3,’1st’,’2nd’,’3rd’)返回第3个位置的字符串“3rd”；指定返回字符串位置超出参数个数，返回NULL&lt;/p&gt;
&lt;p&gt;12、返回指定字符串位置的函数FIELD(S,S1,S2,…)&lt;/p&gt;
&lt;p&gt;FIELD(S,S1,S2,…)返回字符串s在列表s1，s2，……中第一次出现的位置，在找不到s的情况下，返回值为0。&lt;/p&gt;
&lt;p&gt;如果s为NULL，则返回值为0，原因是NULL不能同任何值进行同等比较。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT FIELD(&#39;hi&#39;,&#39;hihi&#39;,&#39;hey&#39;,&#39;hi&#39;,&#39;bas&#39;) AS coll,
FIELD(&#39;hi&#39;,&#39;hihi&#39;,&#39;lo&#39;,&#39;hilo&#39;,&#39;foo&#39;) AS col2&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c936e04aa75f39c41a1959019d73ae8c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;FIELD(‘hi’,&#39;hihi’,&#39;hey’,&#39;hi’,&#39;bas’)函数中字符串hi出现在列表的第3个字符串位置，因此返回结果为3&lt;/p&gt;
&lt;p&gt;FIELD(‘hi’,&#39;hihi’,&#39;lo’,&#39;hilo’,&#39;foo’) 列表中没有字符串hi，因此返回结果为0&lt;/p&gt;
&lt;p&gt;13、返回子串位置的函数FIND_IN_SET(S1,S2)&lt;/p&gt;
&lt;p&gt;FIND_IN_SET(S1,S2)返回字符串s1在字符串列表s2中出现的位置，字符串列表是一个由多个逗号&lt;/p&gt;
&lt;p&gt;‘,’分开的字符串组成的列表。如果s1不在s2或s2为空字符串，则返回值为0。如果任意一个参数为NULL，则返回值为NULL。&lt;/p&gt;
&lt;p&gt;这个函数在第一个参数包含一个逗号‘,’时将无法正常运行。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT FIND_IN_SET(&#39;hi&#39;,&#39;hihi,hey,hi,bas&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/61750e811f9afc813f839258565b83ff.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;虽然FIND_IN_SET(S1,S2)和FIELD(S,S1,S2,…)两个函数格式不同，但作用类似，都可以返回指定字符串在字符串列表中的位置&lt;/p&gt;
&lt;p&gt;14、选取字符串的函数MAKE_SET(X,S1,S2,…)&lt;/p&gt;
&lt;p&gt;MAKE_SET(X,S1,S2,…)返回由x的二进制数指定的相应位的字符串组成的字符串，s1对应比特1，s2对应比特01以此类推。&lt;/p&gt;
&lt;p&gt;s1，s2…中的NULL值不会被添加到结果中。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT MAKE_SET(1,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) AS col1,
MAKE_SET(1|4,&#39;hello&#39;,&#39;nice&#39;,&#39;world&#39;) AS col2&lt;/pre&gt;
&lt;p&gt;1的二进制值为0001，4的二进制值为0100，1与4进行异或操作之后的二进制值为0101，从右到左第一位和第三位为1。&lt;/p&gt;
&lt;p&gt;MAKE_SET(1,’a&#39;,’b&#39;,’c&#39;)返回第一个字符串&lt;/p&gt;
&lt;p&gt;MAKE_SET(1|4,’hello’,&#39;nice’,&#39;world’) 返回从左端开始第一和第三个字符串组成的字符串&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a311aa394848476baec4bb779aea4d48.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;日期和时间函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、获取当前日期的函数和获取当前时间的函数&lt;/p&gt;
&lt;p&gt;CURDATE()、CURRENT_DATE()、CURRENT_TIMESTAMP()、LOCALTIME()、NOW()、SYSDATE()&lt;/p&gt;
&lt;p&gt;以上函数都是返回当前日期和时间值，MYSQL的函数数量的确比SQLSERVER多很多，&lt;strong&gt;SQLSERVER&lt;/strong&gt;获取当前时间和日期用的&lt;/p&gt;
&lt;p&gt;函数是： SELECT GETDATE()&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT NOW()&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7c39f94b60a87e23b2b67b1c8baf1286.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;返回UTC日期的函数和返回UTC时间的函数&lt;/p&gt;
&lt;p&gt;MYSQL里返回UTC日期和时间是分开的，而SQLSERVER里是一起的&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT GETUTCDATE()&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9b7c6996ba3d3f9a0b72abf35ccccfb8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;MYSQL&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT UTC_DATE(),UTC_TIME()&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/44ddb3e04e4edd512bdaa8967174d4f2.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、获取月份的函数MONTHNAME(DATE)&lt;/p&gt;
&lt;p&gt;MONTHNAME(DATE)函数返回日期date对应月份的英文全名&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT MONTHNAME(&#39;2013-8-2&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5a5c1728f85c40088035c84e6338b57a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;返回8月份的英文&lt;/p&gt;
&lt;p&gt;3、获取季度、分钟和秒钟的函数&lt;/p&gt;
&lt;p&gt;QUARTER(DATE)返回date对应的一年中的季度值，范围是从1~4&lt;/p&gt;
&lt;p&gt;使用QUARTER(DATE)函数返回指定日期对应的季度&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT QUARTER(&#39;11-04-01&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9ef433389e8f8af206d56be60a9b04ad.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;4月份在第二季度，所以返回2&lt;/p&gt;
&lt;p&gt;4、MINUTE(TIME)返回time对应的分钟数，范围是从0~59&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT MINUTE(&#39;11-02-03 10:10:06&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a8e631b271ea17a3247d3b3929994c45.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;返回10分钟&lt;/p&gt;
&lt;p&gt;5、SECOND(time) 返回time对应的秒数，范围是从0~59&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT SECOND(&#39;10:23:10&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/840b61cefad42500aa3e0d9e3a26fc90.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;返回10秒&lt;/p&gt;
&lt;p&gt;6、获取日期的指定值的函数EXTRACT(type FROM date)&lt;/p&gt;
&lt;p&gt;EXTRACT(type FROM date)这个函数跟SQLSERVER里的DATEPART()函数是一样的&lt;/p&gt;
&lt;p&gt;获取日期中的年份&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQLSERVER&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT DATEPART(YEAR,&#39;2013-2-3&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dfb7c1469118ab0e0b4f14fff6981bf0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MYSQL&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT EXTRACT(YEAR FROM &#39;2013-2-3&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/af8c894d2c5cb0729772035f07ca79f6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;7、时间和秒钟转换的函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIME_TO_SEC(time)&lt;/strong&gt;返回已转化为秒的time参数，转换公式为：小时*3600+分钟*60+秒&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT TIME_TO_SEC(&#39;23:22:00&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1fa3da84156fd83d0ff784355421d3c4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SEC_TO_TIME(second)&lt;/strong&gt;函数可以将秒转换为小时、分钟和秒数的second参数值&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT SEC_TO_TIME(&#39;84120&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8930567f472ed2a6a58923de4fbf3394.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;SEC_TO_TIME(second)函数和TIME_TO_SEC(time)函数互为反函数&lt;/p&gt;
&lt;p&gt;8、计算日期和时间的函数&lt;/p&gt;
&lt;p&gt;MYSQL里计算日期和时间的函数比较多&lt;/p&gt;
&lt;p&gt;增加日期：DATE_ADD(date,interval  expr type)，ADDDATE(date,interval  expr type)&lt;/p&gt;
&lt;p&gt;减去日期：DATE_SUB(date,interval  expr type)，SUBDATE(date,interval  expr type)&lt;/p&gt;
&lt;p&gt;增加时间：ADD_TIME(date,expr)&lt;/p&gt;
&lt;p&gt;减去时间：SUBTIME(date,expr)&lt;/p&gt;
&lt;p&gt;时间差：DATEDIFF()&lt;/p&gt;
&lt;p&gt;日期和时间格式化：&lt;/p&gt;
&lt;p&gt;DATE_FORMAT(date,format)&lt;/p&gt;
&lt;p&gt;TIME_FORMAT(time,format)&lt;/p&gt;
&lt;p&gt;返回日期时间字符串的显示格式：GET_FORMAT(val_type,format_type)&lt;/p&gt;
&lt;p&gt;相对来说，&lt;strong&gt;SQLSERVER&lt;/strong&gt;在时间日期方面的计算就没有那么多函数了&lt;/p&gt;
&lt;p&gt;基本上SQLSERVER利用下面两个函数来通杀日期时间计算的场景&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT DATEADD(),DATEDIFF()&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;条件判断函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;条件判断函数也称为流程控制函数，根据满足的条件的不同，执行相应的流程。&lt;/p&gt;
&lt;p&gt;MYSQL中进行条件判断的函数有IF、IFNULL、CASE&lt;/p&gt;
&lt;p&gt;虽然&lt;strong&gt;SQLSERVER&lt;/strong&gt;里也有IF和CASE，不过MYSQL里的IF语句的语法跟SQLERVER有很大出入&lt;/p&gt;
&lt;p&gt;1、IF(expr,v1,v2)函数&lt;/p&gt;
&lt;p&gt;IF(expr,v1,v2)如果表达式expr是TRUE（expr&amp;lt;&amp;gt;0 and expr&amp;lt;&amp;gt;NULL），则IF()的返回值为v1；&lt;/p&gt;
&lt;p&gt;否则返回值为v2。IF()的返回值为数字值或字符串值，具体情况视其所在语境而定&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT IF(1&amp;gt;2,2,3)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a52bf20cce6e29a2e24fdc6b232f64f0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;1&amp;gt;2的结果为FALSE，IF(1&amp;gt;2,2,3)返回第二个表达式的值3。&lt;/p&gt;
&lt;p&gt;TIPS：如果v1或v2中只有一个明确是NULL，则IF()函数的结果类型为非NULL表达式的结果类型。&lt;/p&gt;
&lt;p&gt;2、IFNULL(V1,V2)函数&lt;/p&gt;
&lt;p&gt;IFNULL(V1,V2)假如v1不为NULL，则IFNULL(V1,V2)的返回值为v1；否则其返回值为v2。&lt;/p&gt;
&lt;p&gt;IFNULL()的返回值是数字或是字符串，具体情况视语境而定&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT IFNULL(1,2),IFNULL(NULL,10)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d24c54c47df9a5e71c96d410b738cf3a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;IFNULL(1,2)虽然第二个值也不为空，但返回结果依然是第一个值；&lt;/p&gt;
&lt;p&gt;IFNULL(NULL,10)第一个值为空，因此返回“10”&lt;/p&gt;
&lt;p&gt;注意：IFNULL(V1,V2)函数跟SQLSERVER里的 SELECT NULLIF() 函数不一样&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQLSERVER&lt;/strong&gt;里的NULLIF函数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要两个参数,如果两个指定的表达式等价，则返回null&lt;/p&gt;
&lt;p&gt;例子：NULLIF(a,b)&lt;/p&gt;
&lt;p&gt;说明：如果a和b是相等的，那么返回NULL，如果不相等返回a&lt;/p&gt;
&lt;p&gt;select NULLIF(‘eqeqweqwe’,’1′) 结果是eqeqweqwe&lt;/p&gt;
&lt;p&gt;select NULLIF(1,1) 结果是NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、CASE函数&lt;/p&gt;
&lt;p&gt;注意：一个CASE表达式的默认返回值类型是任何返回值的相容集合类型，但具体情况视其所在语境而定。&lt;/p&gt;
&lt;p&gt;如果用字符串语境中，则返回结果为字符串。如果用在数字语境中，则返回结果为十进制、实数值或整数值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个数据类型在拼接SQL语句的时候特别容易忽略，有时候会在拼接SQL语句的时候，case 后面的表达式或者when后面的表达式不一致报错！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a title=&quot;http://support.microsoft.com/kb/969467/zh-cn&quot; href=&quot;http://support.microsoft.com/kb/969467/zh-cn&quot; target=&quot;_blank&quot;&gt;http://support.microsoft.com/kb/969467/zh-cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修补程序： 错误消息，当您运行查询时，SQL Server 2008年中使用 CASE 函数：”转换失败时转换为数据类型 &amp;lt; Type2 &amp;gt; &amp;lt; Type1 &amp;gt; 值 &amp;lt; 值 &amp;gt;”&lt;/p&gt;
&lt;p&gt;在MSDN论坛也有一个相关的帖子，大概是因为拼接sql的时候case 后面的表达式值的数据类型和else后面的表达式值的数据类型不一致导致拼接sql失败&lt;/p&gt;
&lt;p&gt;具体的帖子地址忘记了，也找不到，如果找到以后会补充上&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;系统信息函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、获取MYSQL版本号、连接数和数据库名的函数&lt;/p&gt;
&lt;p&gt;VERSION()返回指示MYSQL服务器版本的字符串。这个字符串使用utf8字符集&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT VERSION()&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5e51670076dec631fc3388d94c938e92.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、CONNECTION_ID()返回MYSQL服务器当前连接的次数，每个连接都有各自唯一的ID&lt;/p&gt;
&lt;p&gt;查看当前用户的连接数&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT CONNECTION_ID()&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a093a28d9c7069a47609e88115531f56.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里返回1，返回值根据登录的次数会有不同。&lt;/p&gt;
&lt;p&gt;3、SHOW PROCESSLIST;&lt;/p&gt;
&lt;p&gt;4、SHOW FULL PROCESSLIST;&lt;/p&gt;
&lt;p&gt;processlist命令的输出结果显示了有哪些线程在运行，不仅可以查看当前所有的连接数，还可以查看当前的连接状态&lt;/p&gt;
&lt;p&gt;帮助识别出有问题的查询语句等。&lt;/p&gt;
&lt;p&gt;如果是root帐号，能看到所有用户的当前连接。如果是其他普通帐号，则只能看到自己占用的连接。showprocesslist只能列出当前100条&lt;/p&gt;
&lt;p&gt;如果想全部列出，可以使用SHOW FULL PROCESSLIST命令&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW PROCESSLIST&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW FULL PROCESSLIST&lt;/pre&gt;
&lt;p&gt;show full processlist会看到连接使用的内存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;show processlist&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c3f18d255bd607b3136681cc29e45198.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;show full processlist&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/cde2f0607b42a36616315cfd8724e1f6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;各个列的含义&lt;/p&gt;
&lt;p&gt;（1）id列，用户登录mysql时，系统分配的“connection_id”&lt;/p&gt;
&lt;p&gt;（2）user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句&lt;/p&gt;
&lt;p&gt;（3）host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户&lt;/p&gt;
&lt;p&gt;（4）db列，显示这个进程目前连接的是哪个数据库&lt;/p&gt;
&lt;p&gt;（5）command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）&lt;/p&gt;
&lt;p&gt;（6）time列，显示这个状态持续的时间，单位是秒&lt;/p&gt;
&lt;p&gt;（7）state列，显示使用当前连接的sql语句的状态，很重要的列，后续会有所有状态的描述，state只是语句执行中的某一个状态。一个sql语句，&lt;/p&gt;
&lt;p&gt;以查询为例&lt;/p&gt;
&lt;p&gt;可能需要经过&lt;/p&gt;
&lt;p&gt;copying to tmp table，&lt;/p&gt;
&lt;p&gt;sorting result，&lt;/p&gt;
&lt;p&gt;sending data&lt;/p&gt;
&lt;p&gt;等状态才可以完成&lt;/p&gt;
&lt;p&gt;（8）info列，显示这个sql语句，是判断问题语句的一个重要依据。&lt;/p&gt;
&lt;p&gt;5、DATABASE()和SCHEMA()函数返回使用utf8字符集的默认（当前）数据库名&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT DATABASE(),SCHEMA()&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b72a72799c39e3b6e0de085549155827.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，两个函数的作用相同&lt;/p&gt;
&lt;p&gt;6、获取用户名的函数&lt;/p&gt;
&lt;p&gt;USER()、CURRENT_USER()、CURRENT_USER、SYSTEM_USER()、SESSION_USER()&lt;/p&gt;
&lt;p&gt;这几个函数返回当前被MYSQL服务器验证的用户名和主机名组合。这个值符合确定当前登录用户&lt;/p&gt;
&lt;p&gt;存取权限的MYSQL帐户。一般情况下，这几个函数的返回值是相同的。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT    USER(),CURRENT_USER(),SYSTEM_USER()&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3bd41b99a06b0e893d0fcaa94a89cbbd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;返回结果指示了当前帐户连接服务器的用户名以及所连接的客户主机，root为当前登录的用户名，localhost为登录的主机名&lt;/p&gt;
&lt;p&gt;7、获取字符串的字符集和排序方式的函数&lt;/p&gt;
&lt;p&gt;CHARSET(STR)返回字符串str自变量的字符集&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT    CHARSET(&#39;abc&#39;) ,CHARSET(CONVERT(&#39;abc&#39; USING latin1)),CHARSET(VERSION())&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/48bcfb5c2e521f9c6250cc1ca2653299.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;CHARSET(‘abc’)返回系统默认的字符集utf8；&lt;/p&gt;
&lt;p&gt;CHARSET(CONVERT(‘abc’ USING latin1))返回的字符集为latin1；&lt;/p&gt;
&lt;p&gt;VERSION()返回的字符串使用utf8字符集，因此CHARSET返回结果为utf8&lt;/p&gt;
&lt;p&gt;8、COLLATION(str)返回字符串str的字符排列方式&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT    COLLATION(_latin2 &#39;abc&#39;),COLLATION(CONVERT(&#39;abc&#39; USING utf8))&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/66331c5d32fe66c061968749b97bde99.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，使用不同字符集时字符串的排列方式不同&lt;/p&gt;
&lt;p&gt;9、获取最后一个自动生成的ID值的函数&lt;/p&gt;
&lt;p&gt;LAST_INSERT_ID()自动返回最后一个INSERT或UPDATE为AUTO_INCREMENT列设置的第一个发生的值&lt;/p&gt;
&lt;p&gt;（1）一次插入一条记录&lt;/p&gt;
&lt;p&gt;首先创建表worker，其ID字段带有AUTO_INCREMENT约束&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE worker(
id INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
NAME VARCHAR(30)
)&lt;/pre&gt;
&lt;p&gt;分别单独向表worker插入2条记录&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO worker VALUES(NULL,&#39;jimmy&#39;);
INSERT INTO worker VALUES(NULL,&#39;tom&#39;)

SELECT * FROM worker&lt;/pre&gt;
&lt;p&gt;查看已经插入的数据可以发现，最后一条插入的记录的ID字段值为2，使用LAST_INSERT_ID()查看最后自动生成的ID值&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT LAST_INSERT_ID()&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3ce488ea63a6a2bf4df9461a9cfc4b70.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，一次插入一条记录时，返回值为最后一条插入记录的ID值&lt;/p&gt;
&lt;p&gt;（2）一次同时插入多条记录&lt;/p&gt;
&lt;p&gt;接下来，向表中插入多条记录&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO worker VALUES(NULL,&#39;kevin&#39;),(NULL,&#39;michal&#39;),(NULL,&#39;nick&#39;)&lt;/pre&gt;
&lt;p&gt;查询已经插入的记录&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM worker&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bd948b672b7ae78424e87eae1957d4f0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到最后一条记录的ID字段值为5，使用LAST_INSERT_ID()查看最后自动生成的ID值&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT LAST_INSERT_ID()&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/350a89cc1f9907171a575beb8ab0f419.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;结果显示，ID字段值不是5而是3，这是为什麽呢？&lt;/p&gt;
&lt;p&gt;在向数据表插入一条记录时，LAST_INSERT_ID()返回带有AUTO_INCREMENT约束的字段最新生成的值2；继续向表&lt;/p&gt;
&lt;p&gt;中同时添加3条记录，这时候因为当使用一条INSERT语句插入多个行时，LAST_INSERT_ID只返回插入的第一行数据&lt;/p&gt;
&lt;p&gt;时产生的值，在这里为第3条记录。之所以这样，是&lt;strong&gt;因为这使依靠其他服务器复制同样的INSERT语句变得简单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TIPS:LAST_INSERT_ID是与table无关的，如果向表a插入数据后，再向表b插入数据，LAST_INSERT_ID返回表b中的ID值&lt;/p&gt;
&lt;p&gt;这里跟SQLSERVER不一样&lt;/p&gt;
&lt;p&gt;使用下面脚本来测试，无论使用方式一还是方式二，当前的LAST_INSERT_ID都是最后一个值&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE [dbo].[aaa](
    [a] [int] IDENTITY(1,1) NOT FOR REPLICATION NOT NULL,
    [name] [nvarchar](50) NOT NULL
) ON [PRIMARY]&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE [sss]

SELECT * FROM [dbo].[aaa]

INSERT INTO [dbo].[aaa]
        ( [name] )
VALUES  ( N&#39;sdfsdf&#39;  -- name - nvarchar(50)
          )
SELECT * FROM [dbo].[aaa]

INSERT INTO [dbo].[aaa]
        ( [name] )
VALUES  ( N&#39;sdf969&#39;  -- name - nvarchar(50)
          ),(&#39;lkjj96&#39;),(&#39;565656&#39;)

SELECT IDENT_CURRENT(&#39;aaa&#39;)

SELECT * FROM [dbo].[aaa]&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8f68dceb9adc546cc002403b33eaa834.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/16b198ee94a036be6987a7caf45b4998.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;加密函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、加密函数PASSWORD(STR)&lt;/p&gt;
&lt;p&gt;PASSWORD(STR)从原文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT PASSWORD(&#39;NEWPWD&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9f60c958d4662d3954e976cff45c17ba.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;MYSQL将PASSWORD函数加密后的密码保存到用户权限表中&lt;/p&gt;
&lt;p&gt;TIPS:PASSWOR()函数在MYSQL服务器的鉴定系统中使用；不应将他用在个人应用程序中，PASSWORD（）函数加密是单向的（不可逆）&lt;/p&gt;
&lt;p&gt;PASSWORD执行密码加密与UNIX中密码加密方式不同&lt;/p&gt;
&lt;p&gt;2、加密函数MD5(str)&lt;/p&gt;
&lt;p&gt;MD5(str)为字符串算出一个MD5 128比特校验和。该值以32位十六进制数字的二进制字符串形式返回，若参数为NULL，则会返回NULL&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT MD5(&#39;123&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/063f1744fa3ba90ad970512bbd1c894a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、加密函数ENCODE(str,pswd_str)&lt;/p&gt;
&lt;p&gt;ENCODE(str,pswd_str)使用pswd_str作为密码，加密str。使用DECODE()解密结果，结果是一个和str长度相同的二进制字符串&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT ENCODE(&#39;nihao&#39;,&#39;123&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/107faff109a3a0931cc627cfc80d9ba7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到加密后的结果为乱码&lt;/p&gt;
&lt;p&gt;4、解密函数DECODE(crypt_str,pswd_str)&lt;/p&gt;
&lt;p&gt;DECODE(crypt_str,pswd_str)使用pswd_str作为密码，解密加密字符串crypt_str，crypt_str是由ENCODE()返回的字符串&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT DECODE(ENCODE(&#39;nihao&#39;,&#39;123&#39;),&#39;123&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6075144076fd3893ac503aa177551597.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，解密出来的字符串&lt;/p&gt;
&lt;p&gt;ENCODE()和DECODE互为反函数&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;其他函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、格式化函数FORMAT(x,n)&lt;/p&gt;
&lt;p&gt;FORMAT(x,n)将数字x格式化，并以四舍五入的方式保留小数点后n位，结果以字符串的形式返回。&lt;/p&gt;
&lt;p&gt;若n为0，则返回结果函数不含小数部分&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT FORMAT(12332.123465,4)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d4d585bb83ff684f0ae83d25f3717ef9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;FORMAT(12332.123465,4)保留4位小数点值，并进行四舍五入，结果为12,332.1235&lt;/p&gt;
&lt;p&gt;2、不同进制的数字转换的函数&lt;/p&gt;
&lt;p&gt;CONV(N,from_base,to_base)函数进行不同进制数间的转换。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT CONV(&#39;a&#39;,16,2)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/25a17f132ff7bdffbe3471344f964efa.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;CONV(‘a’,16,2)将十六进制的a转换为二进制表示的数值。&lt;/p&gt;
&lt;p&gt;3、IP地址与数字相互转换的函数&lt;/p&gt;
&lt;p&gt;INET_ATON(expr)给出一个作为字符串的网络地址的点地址表示，返回一个代表该地址数值的整数。&lt;/p&gt;
&lt;p&gt;地址可以是4或8比特地址&lt;/p&gt;
&lt;p&gt;INET_NTOA(expr)给定一个数字网络地址（4或8比特），返回作为字符串的该地址的点地址表示。&lt;/p&gt;
&lt;p&gt;4、加锁函数和解锁函数&lt;/p&gt;
&lt;p&gt;GET_LOCK(str,timeout)设法使用字符串str给定的名字得到一个锁，超时为timeout秒。&lt;/p&gt;
&lt;p&gt;RELEASE_LOCK(str)解开被GET_LOCK()获取的，用字符串str所命名的锁。&lt;/p&gt;
&lt;p&gt;IS_FREE_LOCK(str)检查名为str的锁是否可以使用&lt;/p&gt;
&lt;p&gt;IS_USED_LOCK(str)检查名为str的锁是否正在被使用&lt;/p&gt;
&lt;p&gt;5、重复执行指定操作的函数&lt;/p&gt;
&lt;p&gt;BENCHMARK(count,expr)函数重复count次执行表达式expr。他可以用于计算MYSQL处理表达式的速度。&lt;/p&gt;
&lt;p&gt;结果值通常为0（0只是表示处理过程很快，并不是没有花费时间）&lt;/p&gt;
&lt;p&gt;另一个作用是他可以在MYSQL客户端内部报告语句执行的时间。&lt;/p&gt;
&lt;p&gt;首先，使用PASSWORD函数加密密码&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT PASSWORD(&#39;nihao&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c85aeb7b7bd09a49b5a7e1ef397291a9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到PASSWORD()函数执行花费的时间为0.00098秒&lt;/p&gt;
&lt;p&gt;下面使用BENCHMARK函数重复执行PASSWORD操作500000次&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT BENCHMARK(500000,PASSWORD(&#39;nihao&#39;))&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4a1cdf82b684bffb17229df6e1db4893.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由此可以看出，使用BENCHMARK执行500000次的时间为0.49690秒，明显比执行一次的时间延长了。&lt;/p&gt;
&lt;p&gt;TIPS：BENCHMARK报告的时间是客户端经过的时间，而不是在服务器端的CPU时间，每次执行后报告的时间并不一定是相同的。&lt;/p&gt;
&lt;p&gt;6、改变字符集的函数&lt;/p&gt;
&lt;p&gt;CONVERT(…using…)带有USING的CONVERT()函数被用来在不同的字符集之间转化数据。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT  CHARSET(&#39;string&#39;),CHARSET(CONVERT(&#39;string&#39; USING latin1))&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2c3fbc40a0fba07283447fa6d486d5c4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;默认为utf8字符集，通过CONVERT()将字符串“string”的默认字符集改为latin1&lt;/p&gt;
&lt;p&gt;7、改变数据类型的函数&lt;/p&gt;
&lt;p&gt;CAST(x,AS type)和CONVERT(x,type)函数将一个类型的值转换为另一个类型的值，可转换的type有：&lt;/p&gt;
&lt;p&gt;BINARY、CHAR(n)、DATE、TIME、DATETIME、DECIMAL、SIGNED、UNSIGNED&lt;/p&gt;
&lt;p&gt;在SQLSERVER里也是使用这两个函数进行数据类型转换的~&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT  CAST(100 AS CHAR(2)),CONVERT(&#39;2013-8-9 12:12:12&#39;,TIME)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5f62303819e31e1bf3a8bd8d8e12e76f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到， CAST(100 AS CHAR(2))将整数数据100转换为带有2个显示宽度的字符串类型，结果为10&lt;/p&gt;
&lt;p&gt;CONVERT(’2013-8-9 12:12:12′,TIME)将DATETIME类型的值，转换为TIME类型值，结果为“12:12:12”&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节简单介绍了MYSQL里的一些函数，并且比较了与SQLSERVER的区别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIPS:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、MYSQL中，日期时间以字符串形式存储在数据表中，因此可以使用字符串函数分别截取日期时间值的不同部分&lt;/p&gt;
&lt;p&gt;2、修改默认的字符集，更改MYSQL默认的字符集，在Windows中，只需要修改my.ini，该文件在MYSQL安装目录下。&lt;/p&gt;
&lt;p&gt;修改配置文件中的default-character-set和character-set-server参数值，将其改为想要的字符集名称，如：&lt;/p&gt;
&lt;p&gt;gbk、gb2312、latin1等，修改完之后，重启MYSQL服务，即可生效。&lt;/p&gt;
&lt;p&gt;如果不确定当前使用的字符集，可以使用下面的SQL语句来查看当前字符集进行对比&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW VARIABLES LIKE &#39;character_set_%&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/69a1082d0015bd7e8c850c8c5b03b6e9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2014-7-17&lt;/strong&gt;&lt;strong&gt;函数补充&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;http://baike.baidu.com/link?url=uwjXFFHv_ZzkloAoUMdSCTJd7xTCZwRw41w885eqwyskXUuH5jmQQPKaLZGE_IoSOmXJqZXbcKnXjB1FtKEt7K&lt;/strong&gt;&lt;br&gt;
&lt;img id=&quot;code_img_opened_f98e0dd1-aa47-4a33-8889-d5550eab1ffe&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/81178cc93a2a3bb5048d90d76e7ec935.jpg&quot;&gt;&lt;/p&gt;
&lt;div id=&quot;cnblogs_code_open_f98e0dd1-aa47-4a33-8889-d5550eab1ffe&quot;&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;控制流程函数
编辑

[1] a) CASE WHEN THEN 函数
语法：CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ……] [ELSE result ]END
CASE WHEN [condition] THEN result [WHEN[condition] THEN result ……] [ELSE result] END ；
函数用法说明：在第一个方案中， 当满足条件value =compare-value 时，返回对应的result，否则返回ELSE后的result。
在第二个方案中，当满足条件condition时，返回对应的result，否则返回ELSE后的result。
两种方案中，如果都不满足而且如果没有ELSE 部分，则返回值为NULL
b) IF 函数用法
语法： IF(expr1,expr2,expr3)
函数用法说明：如果 expr1 是 TRUE (expr1 &amp;lt;&amp;gt; 0 and expr1 &amp;lt;&amp;gt; NULL) ，则 IF() 的返回值为 expr2 ; 否则返回值则为 expr3 。 IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定
c) IFNULL 函数
语法： IFNULL(expr1,expr2)
函数用法说明：假如 expr1 不为 NULL ，则 IFNULL() 的返回值为 expr1 ; 否则其返回值为 expr2 。 IFNULL() 的返回值是数字或是字符串，具体情况取决于其所使用的语境
2字符串函数
编辑

a) 函数 ascii(str)
函数用法说明：返回值为字符串 str 的最左字符的数值。假如 str 为空字符串，则返回值为 0 。假如 str 为 NULL ，则返回值为 NULL 。 ASCII() 用于带有从 0 到 255 的数值的字符
b) 函数 BIN(N)
函数用法说明：返回值为 N 的二进制值的字符串表示，其中 N 为一个 longlong (BIGINT) 数字。这等同于 CONV(N ,10,2) 。假如 N 为 NULL ，则返回值为 NULL 。
c) 函数CHAR(N ,... [USING charset ])
函数用法说明： CHAR() 将每个参数 N 理解为一个整数，其返回值为一个包含这些整数的代码值所给出的字符的字符串。 NULL 值被省略。
d) 函数CHAR_LENGTH(str )
函数使用说明：返回值为字符串 str 的长度，长度的单位为字符。一个多字节字符算作一个单字符。对于一个 包含五个二字节字符集 , LENGTH() 返回值为 10, 而 CHAR_LENGTH() 的返回值为 5
e) 函数 CHARACTER_LENGTH(str )
函数使用说明： CHARACTER_LENGTH() 是 CHAR_LENGTH() 的同义词。
f) 函数 COMPRESS(string_to_compress )
函数使用说明： COMPRESS( 压缩一个字符串。这个函数要求 MySQL 已经用一个
诸如 zlib 的压缩库压缩过。 否则，返回值始终是 NULL 。 UNCOMPRESS() 可将压缩过的字符串进行解压缩 ) 。
g) 函数 CONCAT(str1 ,str2 ,...)
函数使用说明：返回结果为连接参数产生的字符串。如有任何一个参数为 NULL ，则
返回值为 NULL 。或许有一个或多个参数。 如果所有参数均为非二进制字符串，则结果为非二进制字符串。 如果自变量中含有任一二进制字符串，则结果为一个二进制字符串。一个数字参数被转化为与之相等的二进制字符串格式；若要避免这种情况，可使用显式类型 cast, 例如： SELECT CONCAT(CAST(int_col AS CHAR), char_col)
h) 函数 CONCAT_WS(separator ,str1 ,str2 ,...)
函数使用说明： CONCAT_WS() 代表 CONCAT With Separator ，是 CONCAT() 的
特殊形式。 第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL ，则结果为 NULL 。函数会忽略任何分隔符参数后的 NULL 值。
i) 函数CONV(N from_base, to_base)
函数使用说明：不同数基间转换数字。返回值为数字的 N 字符串表示，由 from_base 基转化为 to_base 基。如有任意一个参数为 NULL ，则返回值为 NULL 。自变量 N 被理解为一个整数，但是可以被指定为一个整数或字符串。最小基数为 2 ，而最大基数则为 36 。 If to_base 是一个负数，则 N 被看作一个带符号数。否则， N 被看作无符号数。 CONV() 的运行精确度为 64 比特。
j) 函数 ELT(N ,str1 ,str2 ,str3 ,...)
函数使用说明：若 N = 1 ，则返回值为 str1 ，若 N = 2 ，则返回值为 str2 ，以此
类推。 若 N 小于 1 或大于参数的数目，则返回值为 NULL 。 ELT() 是 FIELD() 的补数
k) 函数 EXPORT_SET(bits ,on ,off [,separator [,number_of_bits ]])
函数使用说明： 返回值为一个字符串，其中对于 bits 值中的每个位组，可以得到
一个 on 字符串，而对于每个清零比特位，可以得到一个 off 字符串。 bits 中的比特值按照从右到左的顺序接受检验 ( 由低位比特到高位比特 ) 。字符串被分隔字符串分开 ( 默认为逗号 ‘,’) ，按照从左到右的顺序被添加到结果中。 number_of_bits 会给出被检验的二进制位数 ( 默认为 64) 。
l) 函数 FIELD(str, str1, str2, str3, …...)
函数使用说明：返回值为 str1 , str2 , str3 ,…… 列表中的 str 指数。在找不到 str 的情况下，返回值为 0 。如果所有对于 FIELD() 的参数均为字符串，则所有参数均按照字符串进行比较。如果所有的参数均为数字，则按照数字进行比较。否则，参数按照双倍进行比较。如果 str 为 NULL ，则返回值为 0 ，原因是 NULL 不能同任何值进行同等比较。 FIELD() 是 ELT() 的补数。
m) 函数FIND_IN_SET(str, strlist)
函数使用说明： 假如字符串 str 在由 N 子链组成的字符串列表 strlist 中， 则返
回值的范围在 1 到 N 之间 。一个字符串列表就是一个由一些被 ‘,’ 符号分开的自链组成的字符串。如果第一个参数是一个常数字符串，而第二个是 type SET 列，则 FIND_IN_SET() 函数被优化，使用比特计算。如果 str 不在 strlist 或 strlist 为空字符串，则返回值为 0 。如任意一个参数为 NULL ，则返回值为 NULL 。 这个函数在第一个参数包含一个逗号 (‘,’) 时将无法正常运行。
n) 函数 FORMAT(X ,D )
函数使用说明： 将 number X 设置为格式 &#39;#,###,###.##&#39;, 以四舍五入的方式保留到小数点后 D 位 , 而返回结果为一个字符串。
o) 函数 HEX(N_or_S )
函数使用说明：如果N_OR_S 是一个数字，则返回一个 十六进制值 N 的 字符串表示，在这里， N 是一个longlong (BIGINT) 数。这相当于 CONV(N,10,16) 。如果N_OR_S 是一个字符串，则返回值为一个N_OR_S 的十六进制字符串表示，其中每个N_OR_S 里的每个字符被转化为两个十六进制数字。
p) 函数INSTR(str,substr)
函数使用说明：返回字符串 str 中子字符串的第一个出现位置。这和LOCATE() 的双参数形式相同，除非参数的顺序被颠倒。
q) 函数LCASE(str)
函数使用说明：LCASE() 是 LOWER() 的同义词
r) 函数LEFT(str,len)
函数使用说明：返回从字符串str 开始的len 最左字符
s) 函数 LENGTH(str )
函数使用说明： 返回值为字符串 str 的长度，单位为字节。一个多字节字符算作多字节。这意味着 对于一个包含 5 个 2 字节字符的字符串， LENGTH() 的返回值为 10, 而 CHAR_LENGTH() 的返回值则为5 。
t) 函数 LOAD_FILE(file_name)
函数使用说明：读取文件并将这一文件按照字符串的格式返回。 文件的位置必须在服务器上 , 你必须为文件制定路径全名，而且你还必须拥有 FILE 特许权。文件必须可读取，文件容量必须小于 max_allowed_packet 字节。若文件不存在，或因不满足上述条件而不能被读取， 则函数返回值为 NULL
u) 函数 LOCATE(substr ,str ) , LOCATE(substr ,str ,pos )
函数使用说明：第一个语法返回字符串 str 中子字符串substr 的第一个出现位置。第二个语法返回字符串 str 中子字符串substr 的第一个出现位置, 起始位置在pos 。如若substr 不在str 中，则返回值为0 。
v) 函数LOWER(str )
函数使用说明：返回字符串 str 以及所有根据最新的字符集映射表变为小写字母的字符
w) 函数LPAD(str ,len ,padstr )
函数使用说明：返回字符串 str , 其左边由字符串padstr 填补到len 字符长度。假如str 的长度大于len , 则返回值被缩短至 len 字符。
x) 函数LTRIM(str )
函数使用说明：返回字符串 str ，其引导空格字符被删除。
y) 函数 MAKE_SET(bits ,str1 ,str2 ,...)
函数使用说明： 返回一个设定值 ( 一个包含被 ‘,’ 号分开的字字符串的字符串 ) ，由在 bits 组中具有相应的比特的字符串组成。 str1 对应比特 0, str2 对应比特 1, 以此类推。 str1 , str2 , ... 中的 NULL 值不会被添加到结果中。
z) 函数 MID(str ,pos ,len )
函数使用说明： MID(str ,pos ,len ) 是 SUBSTRING(str ,pos ,len ) 的同义词。
aa) 函数 OCT(N )
函数使用说明：返回一个 N 的八进制值的字符串表示，其中 N 是一个 longlong (BIGINT) 数。这等同于 CONV(N,10,8) 。若 N 为 NULL ，则返回值为 NULL 。
bb) 函数 OCTET_LENGTH(str )
函数使用说明： OCTET_LENGTH() 是 LENGTH() 的同义词。
cc) 函数ORD(str )
函数使用说明：若字符串str 的最左字符是一个多字节字符，则返回该字符的代码， 代码的计算通过使用以下公式计算其组成字节的数值而得出:
(1st byte code)
+ (2nd byte code × 256)
+ (3rd byte code × 2562
) ...
假如最左字符不是一个多字节字符，那么 ORD() 和函数ASCII() 返回相同的值
dd) 函数 POSITION(substr IN str )
函数使用说明：POSITION(substr IN str ) 是 LOCATE(substr ,str ) 同义词
ee) 函数QUOTE(str )
函数使用说明：引证一个字符串，由此产生一个在SQL 语句中可用作完全转义数据值的结果。 返回的字符串由单引号标注，每例都带有单引号 (‘&#39;’) 、 反斜线符号 (‘\’) 、 ASCII NUL 以及前面有反斜线符号的Control-Z 。如果自变量的值为NULL, 则返回不带单引号的单词 “NULL” 。
ff) 函数REPEAT(str ,count )
函数使用说明：返回一个由重复的字符串str 组成的字符串，字符串str 的数目等于count 。 若 count &amp;lt;= 0, 则返回一个空字符串。若str 或 count 为 NULL ，则返回 NULL 。
gg) 函数REPLACE(str ,from_str ,to_str )
函数使用说明：返回字符串str 以及所有被字符串to_str 替代的字符串from_str 。
hh) 函数REVERSE(str )
函数使用说明：返回字符串 str ，顺序和字符顺序相反。
ii) 函数RIGHT(str ,len )
函数使用说明：从字符串str 开始，返回最右len 字符。
jj) 函数RPAD(str ,len ,padstr )
函数使用说明：返回字符串str , 其右边被字符串 padstr 填补至len 字符长度。假如字符串str 的长度大于 len , 则返回值被缩短到与 len 字符相同长度
kk) 函数RTRIM(str )
函数使用说明：返回字符串 str ，结尾空格字符被删去。
ll) 函数 SOUNDEX(str )
函数使用说明：从str 返回一个soundex 字符串。 两个具有几乎同样探测的字符串应该具有同样的 soundex 字符串。一个标准的soundex 字符串的长度为4 个字符，然而SOUNDEX() 函数会返回一个人以长度的字符串。 可使用结果中的SUBSTRING() 来得到一个标准 soundex 字符串。在str 中， 会忽略所有未按照字母顺序排列的字符。所有不在A-Z 范围之内的国际字母符号被视为元音字母。
mm) 函数expr1 SOUNDS LIKE expr2
函数使用说明： 这相当于SOUNDEX(expr1 ) = SOUNDEX(expr2 ) 。
nn) 函数SPACE(N )
函数使用说明：返回一个由N 间隔符号组成的字符串
oo) 函数SUBSTRING(str ,pos ) , SUBSTRING(str FROM pos ) SUBSTRING(str ,pos ,len ) , SUBSTRING(str FROM pos FOR len )
函数使用说明：不带有len 参数的格式从字符串str 返回一个子字符串，起始于位置 pos 。带有len 参数的格式从字符串str 返回一个长度同len 字符相同的子字符串，起始于位置 pos 。 使用 FROM 的格式为标准 SQL 语法。也可能对pos 使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。
pp) 函数SUBSTRING_INDEX(str ,delim ,count )
函数使用说明：在定界符 delim 以及count 出现前，从字符串str 返回自字符串。若count 为正值, 则返回最终定界符( 从左边开始) 左边的一切内容。若count 为负值，则返回定界符（从右边开始）右边的一切内容。
qq) 函数 TRIM([{BOTH | LEADING | TRAILING} [remstr ] FROM] str ) TRIM(remstr FROM] str )
函数使用说明：返回字符串 str ， 其中所有remstr 前缀和/ 或后缀都已被删除。若分类符BOTH 、LEADIN 或TRAILING 中没有一个是给定的, 则假设为BOTH 。 remstr 为可选项，在未指定情况下，可删除空格
rr) 函数UCASE(str)
函数使用说明：UCASE() 是UPPER() 的同义词
ss) 函数UNCOMPRESS(string_to_uncompress )
函数使用说明：对经COMPRESS() 函数压缩后的字符串进行解压缩。若参数为压缩值，则结果为 NULL 。这个函数要求 MySQL 已被诸如zlib 之类的压缩库编译过。否则, 返回值将始终是 NULL
tt) 函数 UNCOMPRESSED_LENGTH(compressed_string )
函数使用说明： 返回压缩字符串压缩前的长度。
uu) 函数 UNHEX(str)
函数使用说明：执行从 HEX(str ) 的反向操作。就是说，它将参数中的每一对十六进制数字理解为一个数字，并将其转化为该数字代表的字符。结果字符以二进制字符串的形式返回
vv) 函数 UPPER(str )
函数使用说明：返回字符串 str ， 以及根据最新字符集映射转化为大写字母的字符
3数学函数
编辑

a) 函数 ABS(X)
函数使用说明：返回 X 的绝对值
b) 函数 ACOS(X )
函数使用说明：返回 X 反余弦 , 即 , 余弦是 X 的值。若 X 不在 -1 到 1 的范围之内，则返回 NULL 。
c) 函数 ASIN （ X ）
函数使用说明：返回X 的反正弦，即，正弦为X 的值。若X 若X 不在-1 到 1 的范围之内，则返回 NULL 。
d) 函数ATAN(X )
函数使用说明：返回 X 的反正切，即，正切为 X 的值。
e) 函数 ATAN(Y ,X ) , ATAN2(Y ,X )
函数使用说明：返回两个变量 X 及 Y 的反正切。 它类似于 Y 或 X 的反正切计
算 , 除非两个参数的符号均用于确定结果所在象限。
f) 函数 CEILING(X ) CEIL(X )
函数使用说明：返回不小于 X 的最小整数值。
g) 函数 COS(X )
函数使用说明：返回 X 的余弦，其中 X 在弧度上已知。
h) 函数 COT(X )
函数使用说明：返回 X 的余切
i) 函数 CRC32(expr )
函数使用说明：计算循环冗余码校验值并返回一个 32 比特无符号值。若参数为 NULL ，则结果为 NULL 。该参数应为一个字符串，而且在不是字符串的情况下会被作为字符串处理（若有可能）
j) 函数 DEGREES(X )
函数使用说明：返回参数 X , 该参数由弧度被转化为度。
k) 函数 EXP(X )
函数使用说明：返回 e 的 X 乘方后的值 ( 自然对数的底 ) 。
l) 函数 FLOOR(X )
函数使用说明：返回不大于 X 的最大整数值 。
m) 函数 FORMAT(X ,D )
函数使用说明：将数字 X 的格式写成 &#39;#,###,###.##&#39; 格式 , 即保留小数点后 D 位，而第 D 位的保留方式为四舍五入，然后将结果以字符串的形式返回
n) 函数 LN(X )
函数使用说明：返回 X 的自然对数 , 即 , X 相对于基数 e 的对数
o) 函数 LOG(X ) LOG(B ,X )
函数使用说明：若用一个参数调用，这个函数就会返回 X 的自然对数。
p) 函数 LOG2(X )
函数使用说明：返回 X 的基数为 2 的对数。
q) 函数 LOG10(X )
函数使用说明：返回 X 的基数为 10 的对数。
r) 函数 MOD(N ,M ) , N % M N MOD M
函数使用说明： 模操作。返回 N 被 M 除后的余数。
s) 函数 PI()
函数使用说明：返回 ϖ (pi) 的值。默认的显示小数位数是 7 位 , 然而 MySQL 内部会使用完全双精度值。
t) 函数 POW(X ,Y ) , POWER(X ,Y )
函数使用说明：返回 X 的 Y 乘方的结果值。
u) 函数 RADIANS(X )
函数使用说明：返回由度转化为弧度的参数 X , ( 注意 ϖ 弧度等于 180 度）。
v) 函数 RAND() RAND(N )
函数使用说明：返回一个随机浮点值 v ，范围在 0 到 1 之间 ( 即 , 其范围为 0 ≤ v ≤ 1.0) 。若已指定一个整数参数 N ，则它被用作种子值，用来产生重复序列。
w) 函数 ROUND(X ) ROUND(X ,D )
函数使用说明：返回参数 X , 其值接近于最近似的整数。在有两个参数的情况下，返回 X ，其值保留到小数点后 D 位，而第 D 位的保留方式为四舍五入。若要接保留 X 值小数点左边的 D 位，可将 D 设为负值。
x) 函数 SIGN(X )
函数使用说明：返回参数作为 -1 、 0 或 1 的符号，该符号取决于 X 的值为负、零或正。
y) 函数 SIN(X )
函数使用说明：返回 X 正弦，其中 X 在弧度中被给定。
z) 函数 SQRT(X )
函数使用说明： 返回非负数 X 的二次方根。
aa) 函数TAN(X )
函数使用说明： 返回 X 的正切，其中 X 在弧度中被给定。
bb) 函数TRUNCATE(X ,D )
函数使用说明： 返回被舍去至小数点后 D 位的数字 X 。若 D 的值为 0, 则结果
不带有小数点或不带有小数部分。可以将 D 设为负数 , 若要截去 ( 归零 ) X 小数点左起第 D 位开始后面所有低位的值
4日期时间函数
编辑

a) 函数ADDDATE(date ,INTERVAL expr type ) ADDDATE(expr ,days )
函数使用说明： 当被第二个参数的 INTERVAL 格式激活后， ADDDATE() 就是 DATE_ADD() 的同义词。相关函数 SUBDATE() 则是 DATE_SUB() 的同义词。对于 INTERVAL 参数上的信息 ，请参见关于 DATE_ADD() 的论述。
b) 函数 ADDTIME(expr ,expr2 )
函数使用说明： ADDTIME() 将 expr2 添加至 expr 然后返回结果。 expr 是一个时间或时间日期表达式，而 expr2 是一个时间表达式。
c) 函数 CONVERT_TZ(dt ,from_tz ,to_tz )
函数使用说明： CONVERT_TZ() 将时间日期值 dt 从 from_tz 给出的时区转到 to_tz 给出的时区，然后返回结果值。关于可能指定的时区的详细论述，若自变量无效，则这个函数会返回 NULL
d) 函数 CURDATE()
函数使用说明：将当前日期按照 &#39;YYYY-MM-DD&#39; 或 YYYYMMDD 格式的值返回，具体格式根据函数用在字符串或是数字语境中而定。
e) 函数 CURRENT_DATE CURRENT_DATE()
函数使用说明： CURRENT_DATE 和 CURRENT_DATE() 是的同义词 .
f) 函数 CURTIME()
函数使用说明： 将当前时间以 &#39;HH:MM:SS&#39; 或 HHMMSS 的格式返回， 具体格式根据函数用在字符串或是数字语境中而定。
g) 函数 CURRENT_TIME, CURRENT_TIME()
函数使用说明： CURRENT_TIME 和 CURRENT_TIME() 是 CURTIME() 的同义词。
h) 函数 CURRENT_TIMESTAMP, CURRENT_TIMESTAMP()
函数使用说明： CURRENT_TIMESTAMP 和 CURRENT_TIMESTAMP() 是 NOW() 的同义词
i) 函数 DATE(expr )
函数使用说明： 提取日期或时间日期表达式expr 中的日期部分。
j) 函数 DATEDIFF(expr ,expr2 )
函数使用说明： DATEDIFF() 返回起始时间 expr 和结束时间 expr2 之间的天数。 Expr 和 expr2 为日期或 date-and-time表达式。计算中只用到这些值的日期部分。
k) 函数 DATE_ADD(date ,INTERVAL expr type ) DATE_SUB(date ,INTERVAL expr type )
函数使用说明：这些函数执行日期运算。 date 是一个 DATETIME 或 DATE 值，用来指定起始时间。 expr 是一个表达式，用来指定从起始日期添加或减去的时间间隔值。 Expr 是一个字符串 ; 对于负值的时间间隔，它可以以一个 ‘-’ 开头。 type 为关键词，它指示了表达式被解释的方式。
l) 函数 DATE_FORMAT(date ,format )
函数使用说明：根据 format 字符串安排 date 值的格式。
m) 函数 DAY(date )
函数使用说明： DAY() 和 DAYOFMONTH() 的意义相同
n) 函数 DAYNAME(date )
函数使用说明：返回 date 对应的工作日名称。
o) 函数 DAYOFMONTH(date )
函数使用说明：返回 date 对应的该月日期，范围是从 1 到 31
p) 函数 DAYOFWEEK(date )
函数使用说明：返回 date (1 = 周日 , 2 = 周一 , ..., 7 = 周六 ) 对应的工作日索引。这些索引值符合 ODBC 标准
q) 函数 DAYOFYEAR(date )
函数使用说明：返回date 对应的一年中的天数，范围是从 1 到366 。
r) 函数 EXTRACT(type FROM date )
函数使用说明： EXTRACT() 函数所使用的时间间隔类型说明符同 DATE_ADD() 或 DATE_SUB() 的相同 , 但它从日期中提取其部分，而不是执行日期运算。
s) 函数FROM_DAYS(N )
函数使用说明： 给定一个天数 N , 返回一个 DATE 值。
t) 函数 FROM_UNIXTIME(unix_timestamp ) FROM_UNIXTIME(unix_timestamp ,format )
函数使用说明：返回&#39;YYYY-MM-DD HH:MM:SS&#39; 或YYYYMMDDHHMMSS 格式值的unix_timestamp 参数表示，具体格式取决于该函数是否用在字符串中或是数字语境中。 若format 已经给出，则结果的格式是根据format 字符串而定。 format 可以包含同DATE_FORMAT() 函数输入项列表中相同的说明符。
u) 函数 GET_FORMAT(DATE|TIME|DATETIME, &#39;EUR&#39;|&#39;USA&#39;|&#39;JIS&#39;|&#39;ISO&#39;|&#39;INTERNAL&#39;)
函数使用说明：返回一个格式字符串。这个函数在同 DATE_FORMAT() 及 STR_TO_DATE() 函数结合时很有用
v) 函数 HOUR(time )
函数使用说明：返回 time 对应的小时数。对于日时值的返回值范围是从 0 到 23
w) 函数 LAST_DAY(date )
函数使用说明：获取一个日期或日期时间值，返回该月最后一天对应的值。若参数无效，则返回 NULL 。
x) 函数 LOCALTIME, LOCALTIME()
函数使用说明： LOCALTIME 及 LOCALTIME() 和 NOW() 具有相同意义。
y) 函数 LOCALTIMESTAMP, LOCALTIMESTAMP()
函数使用说明： LOCALTIMESTAMP 和 LOCALTIMESTAMP() 和 NOW() 具有相同意义。
z) 函数 MAKEDATE(year ,dayofyear )
函数使用说明：给出年份值和一年中的天数值，返回一个日期。 dayofyear 必须大于 0 ，否则结果为 NULL 。
aa) 函数 MAKETIME(hour ,minute ,second )
函数使用说明： 返回由 hour 、 minute 和 second 参数计算得出的时间值
bb) 函数 CROSECOND(expr )
函数使用说明：从时间或日期时间表达式expr 返回微秒值，其数字范围从 0 到 999999 。
cc) 函数 MINUTE(time )
函数使用说明：返回 time 对应的分钟数 , 范围是从 0 到 59 。
dd) 函数 MONTH(date )
函数使用说明：返回 date 对应的月份，范围时从 1 到 12 。
ee) 函数 MONTHNAME(date )
函数使用说明： 返回 date 对应月份的全名
ff) 函数 NOW()
函数使用说明：返回当前日期和时间值，其格式为 &#39;YYYY-MM-DD HH:MM:SS&#39; 或 YYYYMMDDHHMMSS ， 具体格式取决于该函数是否用在字符串中或数字语境中。
gg) 函数 PERIOD_ADD(P ,N )
函数使用说明：添加 N 个月至周期 P ( 格式为 YYMM 或 YYYYMM) ，返回值的格式为 YYYYMM 。注意周期参数 P 不是 日期值。
hh) 函数 PERIOD_DIFF(P1 ,P2 )
函数使用说明：返回周期 P1 和 P2 之间的月份数。 P1 和 P2 的格式应该为 YYMM 或 YYYYMM 。注意周期参数 P1 和 P2 不是 日期值。
ii) 函数 QUARTER(date )
函数使用说明：返回 date 对应的一年中的季度值，范围是从 1 到 4
jj) 函数 SECOND(time )
函数使用说明：返回 time 对应的秒数 , 范围是从 0 到 59 。
kk) 函数 SEC_TO_TIME(seconds )
函数使用说明： 返回被转化为小时、 分钟和秒数的 seconds 参数值 , 其格式为 &#39;HH:MM:SS&#39; 或 HHMMSS ，具体格式根据该函数是否用在字符串或数字语境中而定
ll) 函数 STR_TO_DATE(str ,format )
函数使用说明：这是 DATE_FORMAT() 函数的倒转。它获取一个字符串 str 和一个格式字符串 format 。若格式字符串包含日期和时间部分，则 STR_TO_DATE() 返回一个 DATETIME 值， 若该字符串只包含日期部分或时间部分，则返回一个 DATE 或 TIME 值。
mm) 函数 SUBDATE(date ,INTERVAL expr type ) SUBDATE(expr ,days )
函数使用说明：当被第二个参数的 INTERVAL 型式调用时 , SUBDATE() 和 DATE_SUB() 的意义相同。对于有关 INTERVAL 参数的信息， 见有关 DATE_ADD() 的讨论。
nn) 函数 SUBTIME(expr ,expr2 )
函数使用说明： SUBTIME() 从 expr 中提取 expr2 ，然后返回结果。 expr 是一个时间或日期时间表达式，而 xpr2 是一个时间表达式。
oo) 函数 SYSDATE()
函数使用说明：返回当前日期和时间值，格式为 &#39;YYYY-MM-DD HH:MM:SS&#39; 或 YYYYMMDDHHMMSS ， 具体格式根据函数是否用在字符串或数字语境而定。
pp) 函数 TIME(expr )
函数使用说明：提取一个时间或日期时间表达式的时间部分，并将其以字符串形式返回。
qq) 函数 TIMEDIFF(expr ,expr2 )
函数使用说明： TIMEDIFF() 返回起始时间 expr 和结束时间 expr2 之间的时间。 expr 和 expr2 为时间或 date-and-time表达式, 两个的类型必须一样。
rr) 函数TIMESTAMP(expr ) , TIMESTAMP(expr ,expr2 )
函数使用说明： 对于一个单参数 , 该函数将日期或日期时间表达式expr 作为日期时间值返回 . 对于两个参数 , 它将时间表达式 expr2 添加到日期或日期时间表达式 expr 中，将 theresult 作为日期时间值返回。
ss) 函数 TIMESTAMPADD(interval ,int_expr ,datetime_expr )
函数使用说明：将整型表达式int_expr 添加到日期或日期时间表达式 datetime_expr 中。 int_expr 的单位被时间间隔参数给定，该参数必须是以下值的其中一个： FRAC_SECOND 、SECOND 、 MINUTE 、 HOUR 、 DAY 、 WEEK 、 MONTH 、 QUARTER 或 YEAR 。可使用所显示的关键词指定Interval 值，或使用SQL_TSI_ 前缀。例如, DAY 或SQL_TSI_DAY 都是正确的
tt) 函数 TIMESTAMPDIFF(interval ,datetime_expr1 ,datetime_expr2 )
函数使用说明：返回日期或日期时间表达式 datetime_expr1 和 datetime_expr2 the 之间的整数差。其结果的单位由 interval 参数给出。 interval 的法定值同 TIMESTAMPADD() 函数说明中所列出的相同。
uu) 函数 TIME_FORMAT(time ,format )
函数使用说明：其使用和 DATE_FORMAT() 函数相同 , 然而 format 字符串可能仅会包含处理小时、分钟和秒的格式说明符。其它说明符产生一个 NULL 值或 0 。
vv) 函数 TIME_TO_SEC(time )
函数使用说明：返回已转化为秒的 time 参数
ww) 函数 TO_DAYS(date )
函数使用说明：给定一个日期 date , 返回一个天数 ( 从年份 0 开始的天数 ) 。
xx) 函数 UNIX_TIMESTAMP(), UNIX_TIMESTAMP(date )
函数使用说明：若无参数调用，则返回一个 Unix timestamp (&#39;1970-01-01 00:00:00&#39; GMT 之后的秒数 ) 作为无符号整数。若用 date 来调用 UNIX_TIMESTAMP() ，它会将参数值以 &#39;1970-01-01 00:00:00&#39; GMT 后的秒数的形式返回。 date 可以是一个 DATE 字符串、一个 DATETIME 字符串、一个 TIMESTAMP 或一个当地时间的 YYMMDD 或 YYYMMDD 格式的数字。
yy) 函数 UTC_DATE, UTC_DATE()
函数使用说明：返回当前 UTC 日期值，其格式为 &#39;YYYY-MM-DD&#39; 或 YYYYMMDD ，具体格式取决于函数是否用在字符串或数字语境中。
zz) 函数 UTC_TIME, UTC_TIME()
函数使用说明：返回当前 UTC 值，其格式为 &#39;HH:MM:SS&#39; 或 HHMMSS ，具体格式根据该函数是否用在字符串或数字语境而定。
aaa) 函数 UTC_TIMESTAMP, UTC_TIMESTAMP()
函数使用说明：返回当前 UTC 日期及时间值，格式为 &#39;YYYY-MM-DD HH:MM:SS&#39; 或 YYYYMMDDHHMMSS ，具体格式根据该函数是否用在字符串或数字语境而定
bbb) 函数 WEEK(date [,mode ])
函数使用说明：该函数返回 date 对应的星期数。 WEEK() 的双参数形式允许你指定该星期是否起始于周日或周一， 以及返回值的范围是否为从 0 到 53 或从 1 到 53 。若 mode 参数被省略，则使用 default_week_format 系统自变量的值。
ccc) 函数 WEEKDAY(date )
函数使用说明：返回 date (0 = 周一 , 1 = 周二 , ... 6 = 周日 ) 对应的工作日索引 weekday index for
ddd) 函数 WEEKOFYEAR(date )
函数使用说明：将该日期的阳历周以数字形式返回，范围是从 1 到 53 。它是一个兼容度函数，相当于 WEEK(date ,3) 。
eee) 函数 YEAR(date )
函数使用说明：返回 date 对应的年份 , 范围是从 1000 到 9999 。
fff) 函数 YEARWEEK(date ), YEARWEEK(date ,start )
函数使用说明：返回一个日期对应的年或周。 start 参数的工作同 start 参数对 WEEK() 的工作相同。结果中的年份可以和该年的第一周和最后一周对应的日期参数有所不同。
5搜索函数
编辑

a) 函数 MATCH (col1,col2,...) AGAINST (expr [IN BOOLEAN MODE | WITH QUERY EXPANSION])
6加密函数
编辑

a) 函数 AES_ENCRYPT(str ,key_str ) , AES_DECRYPT(crypt_str ,key_str )
函数使用说明：这些函数允许使用官方 AES 进行加密和数据加密 ( 高级加密标准 ) 算法 , 即以前人们所熟知的 “Rijndael” 。 保密关键字的长度为 128 比特，不过你可以通过改变源而将其延长到 256 比特。我们选择了 128 比特的原因是它的速度要快得多，且对于大多数用途而言这个保密程度已经够用。
b) 函数DECODE(crypt_str ,pass_str )
函数使用说明：使用 pass_str 作为密码，解密加密字符串 crypt_str ， crypt_str 应该是由 ENCODE() 返回的字符串。
c) 函数 ENCODE(str ,pass_str )
函数使用说明：使用 pass_str 作为密码，解密 str 。 使用 DECODE() 解密结果。
d) 函数 DES_DECRYPT(crypt_str [,key_str ])
函数使用说明：使用 DES_ENCRYPT() 加密一个字符串。若出现错误，这个函数会返回 NULL 。
e) 函数 DES_ENCRYPT(str [,(key_num |key_str )])
函数使用说明：用 Triple-DES 算法给出的关键字加密字符串。若出现错误，这个函数会返回 NULL 。
f) 函数 ENCRYPT(str [,salt ])
函数使用说明：使用 Unix crypt() 系统调用加密 str 。 salt 参数应为一个至少包含 2 个字符的字符串。若没有给出 salt 参数，则使用任意值。
g) 函数 MD5(str )
函数使用说明：为字符串算出一个 MD5 128 比特检查和。该值以 32 位十六进制数字的二进制字符串的形式返回 , 若参数为 NULL 则会返回 NULL 。例如，返回值可被用作散列关键字
h) 函数 OLD_PASSWORD(str )
函数使用说明：当 PASSWORD() 的执行变为改善安全性时， OLD_PASSWORD() 会被添加到 MySQL 。 OLD_PASSWORD() 返回从前的 PASSWORD() 执行值 ( 4.1 之前 ) ，同时允许你为任何 4.1 之前的需要连接到你的 5.1 版本 MySQL 服务器前客户端设置密码，从而不至于将它们切断
i) 函数PASSWORD(str )
函数使用说明：从原文密码str 计算并返回密码字符串，当参数为 NULL 时返回 NULL 。这个函数用于用户授权表的Password 列中的加密MySQL 密码存储
7信息函数
编辑

a) 函数 BENCHMARK(count ,expr )
函数使用说明： BENCHMARK() 函数重复 count 次执行表达式 expr 。 它可以被用于计算 MySQL 处理表达式的速度。结果值通常为 0 。另一种用处来自 mysql 客户端内部 , 能够报告问询执行的次数
b) 函数 CHARSET(str )
函数使用说明：返回字符串自变量的字符集。
c) 函数 COERCIBILITY(str )
函数使用说明：返回字符串自变量的整序可压缩性值。
d) 函数 COLLATION(str )
函数使用说明：返回惠字符串参数的排序方式。
e) 函数 CONNECTION_ID()
函数使用说明：返回对于连接的连接 ID ( 线程 ID) 。每个连接都有各自的唯一 ID 。
f) 函数 CURRENT_USER, CURRENT_USER()
函数使用说明：返回当前话路被验证的用户名和主机名组合。这个值符合确定你的存取权限的 MySQL 账户。在被指定 SQL SECURITY DEFINER 特征的存储程序内， CURRENT_USER() 返回程序的创建者
g) 函数 DATABASE()
函数使用说明：返回使用 utf8 字符集的默认 ( 当前 ) 数据库名。在存储程序里，默认数据库是同该程序向关联的数据库，但并不一定与调用语境的默认数据库相同。
h) 函数 FOUND_ROWS()
函数使用说明： A SELECT 语句可能包括一个 LIMIT 子句，用来限制服务器返回客户端的行数。在有些情况下，需要不用再次运行该语句而得知在没有 LIMIT 时到底该语句返回了多少行。为了知道这个行数 , 包括在 SELECT 语句中选择 SQL_CALC_FOUND_ROWS ，随后调用 FOUND_ROWS()
i) 函数 LAST_INSERT_ID() LAST_INSERT_ID(expr )
函数使用说明：自动返回最后一个 INSERT 或 UPDATE 问询为 AUTO_INCREMENT 列设置的第一个 发生的值。
j) 函数 ROW_COUNT()
函数使用说明： ROW_COUNT() 返回被前面语句升级的、插入的或删除的行数。 这个行数和 mysql 客户端显示的行数及 mysql_affected_rows() C API 函数返回的值相同。
k) 函数 SCHEMA()
函数使用说明：这个函数和 DATABASE() 具有相同的意义
l) 函数 SESSION_USER()
函数使用说明： SESSION_USER() 和 USER() 具有相同的意义。
m) 函数 SYSTEM_USER()
函数使用说明： SYSTEM_USER() 合 USER() 具有相同的意义
n) 函数 USER()
函数使用说明：返回当前 MySQL 用户名和机主名
o) 函数 VERSION()
函数使用说明：返回指示 MySQL 服务器版本的字符串。这个字符串使用 utf8 字符集。
8其他函数
编辑

a) 函数 DEFAULT(col_name )
函数使用说明：返回一个表列的默认值。若该列没有默认值则会产生错误。
b) 函数 FORMAT(X ,D )
函数使用说明：将数字 X 的格式写为 &#39;#,###,###.##&#39;, 以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若 D 为 0, 则返回结果不带有小数点，或不含小数部分。
c) 函数 GET_LOCK(str ,timeout )
函数使用说明：设法使用字符串 str 给定的名字得到一个锁， 超时为 timeout 秒。若成功得到锁，则返回 1 ，若操作超时则返回 0 ( 例如 , 由于另一个客户端已提前封锁了这个名字 ), 若发生错误则返回 NULL ( 诸如缺乏记忆或线程 mysqladmin kill 被断开 ) 。假如你有一个用 GET_LOCK() 得到的锁，当你执行 RELEASE_LOCK() 或你的连接断开 ( 正常或非正常 ) 时，这个锁就会解除
d) 函数 INET_ATON(expr )
函数使用说明：给出一个作为字符串的网络地址的点地址表示，返回一个代表该地址数值的整数。地址可以是 4 或 8 比特地址。
e) 函数 INET_NTOA(expr )
函数使用说明：给定一个数字网络地址 (4 或 8 比特 ), 返回作为字符串的该地址的电地址表示
f) 函数 IS_FREE_LOCK(str )
函数使用说明：检查名为 str 的锁是否可以使用 ( 换言之 , 没有被封锁 ) 。若锁可以使用，则返回 1 ( 没有人在用这个锁 ), 若这个锁正在被使用，则返回 0 ，出现错误则返回 NULL ( 诸如不正确的参数 ) 。
g) 函数 IS_USED_LOCK(str )
函数使用说明：检查名为 str 的锁是否正在被使用 ( 换言之 , 被封锁 ) 。若被封锁，则返回使用该锁的客户端的连接标识符。否则返回 NULL 。
h) 函数 MASTER_POS_WAIT(log_name ,log_pos [,timeout ])
函数使用说明：该函数对于控制主从同步很有用处。它会持续封锁，直到从设备阅读和应用主机记录中所有补充资料到指定的位置。返回值是其为到达指定位置而必须等待的记录事件的数目。若从设备 SQL 线程没有被启动、从设备主机信息尚未初始化、参数不正确或出现任何错误，则该函数返回 NULL 。若超时时间被超过，则返回 -1 。若在 MASTER_POS_WAIT() 等待期间，从设备 SQL 线程中止，则该函数返回 NULL 。若从设备由指定位置通过，则函数会立即返回结果。
i) 函数 NAME_CONST(name ,value )
函数使用说明：返回给定值。 当用来产生一个结果集合列时 , NAME_CONST() 促使该列使用给定名称。
j) 函数 RELEASE_LOCK(str )
函数使用说明：解开被 GET_LOCK() 获取的，用字符串 str 所命名的锁。若锁被解开，则返回 1 ，若改线程尚未创建锁，则返回 0 ( 此时锁没有被解开 ), 若命名的锁不存在，则返回 NULL 。若该锁从未被对 GET_LOCK() 的调用获取，或锁已经被提前解开，则该锁不存在。
k) 函数 SLEEP(duration )
函数使用说明：睡眠 ( 暂停 ) 时间为 duration 参数给定的秒数，然后返回 0 。若 SLEEP() 被中断 , 它会返回 1 。 duration 或许或包括一个给定的以微秒为单位的分数部分。
l) 函数 UUID()
函数使用说明：返回一个通用唯一标识符 (UUID) ， UUID 被设计成一个在时间和空间上都独一无二的数字。 2 个对 UUID() 的调用应产生 2 个不同的值，即使这些调用的执行是在两个互不相连的单独电脑上进行。
m) 函数 VALUES(col_name )
函数使用说明：在一个 INSERT … ON DUPLICATE KEY UPDATE … 语句中，你可以在 UPDATE 子句中使用 VALUES(col_name ) 函数，用来访问来自该语句的 INSERT 部分的列值。换言之， UPDATE 子句中的 VALUES(col_name ) 访问需要被插入的 col_name 的值 , 并不会发生重复键冲突。这个函数在多行插入中特别有用。 VALUES() 函数只在 INSERT ... UPDATE 语句中有意义，而在其它情况下只会返回 NULL
9聚合函数
编辑

a) 函数 AVG([DISTINCT] expr )
函数使用说明：返回 expr 的平均值。 DISTINCT 选项可用于返回 expr 的不同值的平均值。
b) 函数 BIT_AND(expr )
函数使用说明：返回expr 中所有比特的 bitwise AND 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则这个函数返回1844 ( 这是无符号 BIGINT 值，所有比特被设置为 1 ）。
c) 函数 BIT_OR(expr )
函数使用说明：返回expr 中所有比特的bitwise OR 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则函数返回 0 。
d) 函数BIT_XOR(expr )
函数使用说明：返回expr 中所有比特的bitwise XOR 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则函数返回 0 。
e) 函数 COUNT(expr )
函数使用说明：返回SELECT 语句检索到的行中非NULL 值的数目。若找不到匹配的行，则COUNT() 返回 0
f) 函数 COUNT(DISTINCT expr ,[expr ...])
函数使用说明：返回不同的非NULL 值数目。若找不到匹配的项，则COUNT(DISTINCT) 返回 0
g) 函数 GROUP_CONCAT(expr )
函数使用说明：该函数返回带有来自一个组的连接的非NULL 值的字符串结果。其完整的语法如下所示：
GROUP_CONCAT([DISTINCT] expr [,expr ...] [ORDER BY {unsigned_integer | col_name | expr }
[ASC | DESC] [,col_name ...]]
[SEPARATOR str_val ])
h) 函数 MIN([DISTINCT] expr ), MAX([DISTINCT] expr )
函数使用说明：返回 expr 的最小值和最大值。 MIN() 和 MAX() 的取值可以是一个字符串参数；在这些情况下， 它们返回最小或最大字符串值。
i) 函数 STD(expr ) STDDEV(expr )
函数使用说明：返回 expr 的总体标准偏差。这是标准 SQL 的延伸。这个函数的 STDDEV() 形式用来提供和 Oracle 的兼容性。可使用标准 SQL 函数 STDDEV_POP() 进行代替
j) 函数 STDDEV_POP(expr )
函数使用说明：返回expr 的总体标准偏差(VAR_POP() 的平方根) 。你也可以使用 STD() 或STDDEV(), 它们具有相同的意义，然而不是标准的 SQL 。若找不到匹配的行，则STDDEV_POP() 返回 NULL
k) 函数 STDDEV_SAMP(expr )
函数使用说明：返回expr 的样本标准差 ( VAR_SAMP() 的平方根) 。若找不到匹配的行，则STDDEV_SAMP() 返回 NULL
l) 函数 SUM([DISTINCT] expr )
函数使用说明：返回expr 的总数。 若返回集合中无任何行，则 SUM() 返回NULL 。DISTINCT 关键词可用于 MySQL 5.1 中，求得expr 不同值的总和。 若找不到匹配的行，则SUM() 返回 NULL
m) 函数 VAR_POP(expr )
函数使用说明：返回 expr 总体标准方差。它将行视为总体，而不是一个样本， 所以它将行数作为分母。你也可以使用 VARIANCE(), 它具有相同的意义然而不是 标准的 SQL
n) 函数 VAR_SAMP(expr )
函数使用说明：返回expr 的样本方差。更确切的说，分母的数字是行数减去1 。若找不到匹配的行，则VAR_SAMP() 返回NULL
o) 函数VARIANCE(expr )
函数使用说明：返回expr 的总体标准方差。这是标准SQL 的延伸。可使用标准SQL 函数 VAR_POP() 进行代替。若找不到匹配的项，则VARIANCE() 返回NULL&lt;/pre&gt;
&lt;/div&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87337&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87337votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87337&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Wed, 03 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-03-87337-aeb631cdb.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-03-87337-aeb631cdb.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（5） ： 运算符</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MYSQL中的运算符很多，这一节主要讲MYSQL中有的，而SQLSERVER没有的运算符&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;安全等于运算符（&amp;lt;=&amp;gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个操作符和=操作符执行相同的比较操作，不过&amp;lt;=&amp;gt;可以用来判断NULL值。&lt;/p&gt;
&lt;p&gt;在两个操作数均为NULL时，其返回值为1而不为NULL；&lt;/p&gt;
&lt;p&gt;而当一个操作数为NULL时，其返回值为0而不为NULL。&lt;/p&gt;
&lt;p&gt;下面分别是 SELECT NULL &amp;lt;=&amp;gt;1   SELECT 1&amp;lt;=&amp;gt;0  SELECT NULL &amp;lt;=&amp;gt;NULL 的执行结果&lt;/p&gt;
&lt;p&gt;在两个操作数均为NULL时，其返回值为1而不为NULL；&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4b835e4e9259147e5588cdd09018ae6e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/248c214c40bf10fc9da4c3f988b64cbd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/011ee95bc4b90f9b349f51026ce5cd17.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;LEAST运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法格式为：LEAST（值1,值2,…值n），其中值n表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。&lt;/p&gt;
&lt;p&gt;假如任意一个自变量为NULL，则LEAST()的返回值为NULL&lt;/p&gt;
&lt;p&gt;使用LEAST运算符进行大小判断，SQL语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT LEAST(2,0),LEAST(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;),LEAST(10,NULL)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c04c8e5fdf1b5851bfa0d741319b077e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由结果可以看到，当参数中是整数或者浮点数时，LEAST将返回其中最小的值；&lt;/p&gt;
&lt;p&gt;当参数为字符串时，返回字母中顺序最靠前的字符；&lt;/p&gt;
&lt;p&gt;当比较值列表中有NULL时，不能判断大小，返回值为NULL&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;GREATEST运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法格式为： GREATEST(值1，值2，…值n)，其中n表示参数列表中有n个值。&lt;/p&gt;
&lt;p&gt;在有两个或多个参数的情况下，返回最大值。&lt;/p&gt;
&lt;p&gt;假如任意一个自变量为NULL，则GREATEST()的返回值为NULL&lt;/p&gt;
&lt;p&gt;使用GREATEST运算符进行大小判断，SQL语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT GREATEST(2,0),GREATEST(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;),GREATEST(10,NULL)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/560166a778071d3de91925438cb18183.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；&lt;/p&gt;
&lt;p&gt;当参数为字符串时，返回字母中顺序最靠后的字符；&lt;/p&gt;
&lt;p&gt;当比较值列表中有NULL时，不能判断大小，返回值为NULL&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;REGEXP 运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SQLSERVER里是没有正则函数或者运算符的，MYSQL在这方面的确比较完善&lt;/p&gt;
&lt;p&gt;用来匹配字符串，语法格式为：expr REGEXP  匹配条件，如果expr满足匹配条件，返回1；&lt;/p&gt;
&lt;p&gt;如果不满足，则返回0；&lt;/p&gt;
&lt;p&gt;若expr或匹配条件任意一个为NULL，则结果为NULL&lt;/p&gt;
&lt;p&gt;常用的几种通配符：&lt;/p&gt;
&lt;p&gt;（1）’^&#39;匹配以该字符后面的字符开头的字符串&lt;/p&gt;
&lt;p&gt;（2）’$&#39;匹配以该字符后面的字符结尾的字符串&lt;/p&gt;
&lt;p&gt;（3）’.&#39;匹配任何一个单字符&lt;/p&gt;
&lt;p&gt;（4）’[...]‘匹配在方括号内的任何字符。例如，“[abc]” 匹配a、b或c。&lt;/p&gt;
&lt;p&gt;字符的范围可以使用一个’-&#39;，“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字&lt;/p&gt;
&lt;p&gt;（5）’*’ 匹配零个或多个在他前面的字符。例如，“x*”匹配任何数量的’*&#39;字符，“[0-9]*”匹配任何数量的数字，&lt;/p&gt;
&lt;p&gt;而“.*”匹配任何数量的任何字符。&lt;/p&gt;
&lt;p&gt;使用REGEXP  运算符进行字符串匹配运算，SQL语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT &#39;ssky&#39; REGEXP &#39;^s&#39;,&#39;ssky&#39; REGEXP &#39;y$&#39; ,&#39;ssky&#39; REGEXP &#39;.sky&#39;,&#39;ssky&#39; REGEXP &#39;[ab]&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/77b45156fbeb05e637c267df12e5ee95.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由结果可以看到，指定匹配字符串为ssky。&lt;/p&gt;
&lt;p&gt;‘^s’表示匹配任何以字母s开头的字符串，因此满足匹配条件，返回1；&lt;/p&gt;
&lt;p&gt;‘y$’表示匹配任何以字母y结尾的字符串，因此满足匹配条件，返回1；&lt;/p&gt;
&lt;p&gt;‘.sky’表示匹配任何以sky结尾，字符长度为4的字符串，因此满足匹配条件，返回1；&lt;/p&gt;
&lt;p&gt;‘^s’表示匹配任何以字母s开头的字符串，因此满足匹配条件，返回1；&lt;/p&gt;
&lt;p&gt;‘[ab]‘表示匹配任何包含字母a或者b的字符串，指定字符串中没有字母a也没有字母b，因此不满足匹配条件，返回0；&lt;/p&gt;
&lt;p&gt;TIPS：正则表达式是一个可以进行复杂查询的强大工具，相对于LIKE字符串匹配，他可以使用更多的通配符类型&lt;/p&gt;
&lt;p&gt;查询结果更加灵活。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;逻辑运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;逻辑与运算符：AND或者&amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;逻辑或运算符：OR或者||&lt;/p&gt;
&lt;p&gt;上面两个运算符就不说了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在SQLSERVER里，与运算符是AND或者&amp;amp; ；&lt;/strong&gt;&lt;strong&gt;或运算符是OR或者|&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://sqlfool.com/2009/02/bitwise-operations/&quot; href=&quot;http://sqlfool.com/2009/02/bitwise-operations/&quot; target=&quot;_blank&quot;&gt;http://sqlfool.com/2009/02/bitwise-operations/&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--DROP TABLE myTable
CREATE Table myTable
(
      id            int identity(1,1)
    , item          varchar(10)
    , attributes    int
);
 
Insert Into myTable
Select &#39;Broccoli&#39;, 200 Union All
Select &#39;Tomato&#39;, 193 Union All
Select &#39;Car&#39;, 276 Union All
Select &#39;Ball&#39;, 292;

DECLARE @statusLookup Table
(
      attribute int
    , value     varchar(10)
);
 
Insert Into @statusLookup
Select 1, &#39;Red&#39; Union All
Select 4, &#39;Blue&#39; Union All
Select 8, &#39;Green&#39; Union All
Select 16, &#39;Metal&#39; Union All
 
Select 32, &#39;Plastic&#39; Union All
Select 64, &#39;Plant&#39; Union All
Select 128, &#39;Edible&#39; Union All
Select 256, &#39;Non-Edible&#39;;
 
Select a.item, b.value
From myTable a
Cross Join @statusLookup b
Where a.attributes &amp;amp; b.attribute &amp;lt;&amp;gt; 0
Order By a.item
    , b.value&lt;/pre&gt;
&lt;p&gt;异或运算符：XOR&lt;/p&gt;
&lt;p&gt;当任意一个操作数为NULL时，返回值为NULL;对于非NULL的操作数，如果两个操作数都是非0值或者都是0值，则返回结果为0；&lt;/p&gt;
&lt;p&gt;如果一个为0值，另一个为非0值，返回结果为1&lt;/p&gt;
&lt;p&gt;使用异或运算符XOR进行逻辑判断，SQL语句如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT 1 XOR 1, 0 XOR 0,1 XOR 0,1 XOR NULL,1 XOR 1 XOR 1&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1b4823dea97d373f6caf8f7613b451bb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由结果可以看到‘1 XOR 1’和‘0 XOR 0’中运算符两边的操作数都为非零值，或者都是零值，因此返回0；&lt;/p&gt;
&lt;p&gt;’1 XOR 0′中两边的操作数，一个为0值，另一个为非0值，返回结果为1；&lt;/p&gt;
&lt;p&gt;’1 XOR NULL’中有一个操作数为NULL，返回结果为NULL；&lt;/p&gt;
&lt;p&gt;’1 XOR 1 XOR 1′中有多个操作数，运算符相同，因此运算符从左到右依次计算，’1 XOR 1′的结果为0，再与1进行异或运算，因此结果为1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIPS: a XOR b的计算等同于(a AND (NOT b))或者(NOT a AND ( b))&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;位运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于比较少用到，这里只做简单介绍&lt;/p&gt;
&lt;p&gt;位运算符是用来对二进制字节中的位进行测试、移位或者测试处理&lt;/p&gt;
&lt;p&gt;MYSQL中提供的位运算有&lt;/p&gt;
&lt;p&gt;按位或(|)&lt;/p&gt;
&lt;p&gt;按位与(&amp;amp;)&lt;/p&gt;
&lt;p&gt;按位异或(^)&lt;/p&gt;
&lt;p&gt;按位左移(&amp;lt;&amp;lt;)&lt;/p&gt;
&lt;p&gt;按位右移(&amp;gt;&amp;gt;)&lt;/p&gt;
&lt;p&gt;按位取反(~)：反转所有比特&lt;/p&gt;
&lt;p&gt;TIPS：可以使用BIN()=binary函数查看一个十进制数的二进制表示&lt;/p&gt;
&lt;p&gt;例如20这个数字 SELECT BIN(20)&lt;/p&gt;
&lt;p&gt;二进制表示为：10100&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/815f99cfacd9228c1e878ce10e6ae582.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;同样 sqlserver也是有位运算符的，但是没有mysql那么多，如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DECLARE @i BIT
SET @i=0
SELECT @i | 3 AS &#39;按位或&#39;
SELECT @i &amp;amp; 3 AS &#39;按位与&#39;
SELECT @i ^ 3 AS &#39;按位异或&#39;
SELECT ~@i AS &#39;非&#39;

SET @i=1
SELECT ~@i AS &#39;非&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d252552ed4e03e2afb69bcc6b8005bd1.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;特别提示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某一些MYSQL中的特殊字符需要用转义字符才能插入数据库，否则产生意料之外的结果。&lt;/p&gt;
&lt;p&gt;下面的特殊字符需要在输入时加反斜线符号开头&lt;/p&gt;
&lt;p&gt;输入单引号需要：\’&lt;/p&gt;
&lt;p&gt;输入双引号需要：\”&lt;/p&gt;
&lt;p&gt;输入反斜杠：\\&lt;/p&gt;
&lt;p&gt;输入回车符：\r&lt;/p&gt;
&lt;p&gt;输入换行符：\n&lt;/p&gt;
&lt;p&gt;输入制表符：\tab&lt;/p&gt;
&lt;p&gt;输入退格符：\b&lt;/p&gt;
&lt;p&gt;在插入这些特殊字符到数据库之前一定要进行转义处理&lt;/p&gt;
&lt;p&gt;在SQLSERVER里，这些特殊字符不是在前面加反斜杠\，而是加单引号’&lt;/p&gt;
&lt;p&gt;例如插入一个单引号，加了反斜杠，插入成功&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO table_1(NAME) VALUES(&#39;\&#39;&#39;)

SELECT * FROM table_1&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9088b1b9387a4a8fd179bbb80d23cd8c.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节简单介绍了MYSQL里的一些运算符和特殊字符，并且比较了与SQLSERVER的区别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87327&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87327votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87327&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Wed, 03 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-03-87327-81bd46d12.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-03-87327-81bd46d12.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（4） ： 数据类型</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;MYSQL&lt;/strong&gt;里的BLOB数据类型&lt;/p&gt;
&lt;p&gt;BLOB是一个二进制大对象，用来存储可变数量的数据。BLOB类型分为4种：TinyBlob、Blob、MediumBlob、LongBlob，&lt;/p&gt;
&lt;p&gt;这几个类型之间的唯一区别是在存储文件的最大大小上不同。&lt;/p&gt;
&lt;p&gt;MySQL的四种BLOB类型     类型 大小(单位：字节)&lt;/p&gt;
&lt;p&gt;TinyBlob                            最大 255&lt;br&gt;
Blob                                  最大 65K&lt;br&gt;
MediumBlob                       最大 16M&lt;br&gt;
LongBlob                           最大 4G&lt;/p&gt;
&lt;p&gt;BLOB列存储的是二进制字符串（字节字符串）；TEXT列存储的是非二进制字符串（字符字符串）。&lt;/p&gt;
&lt;p&gt;BLOB列没有字符集，并且排序和比较基于列值字节的数值；TEXT列有一个字符集，并且根据字符集对值进行排序和比较&lt;/p&gt;
&lt;p&gt;BLOB是二进制字符串，TEXT是非二进制字符串，两者均可存放大容量的信息。&lt;strong&gt;BLOB主要存储图片、音频信息等&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;而TEXT只能存储文本文件。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;SQLSERVER&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQLSERVER并没有BLOB数据类型，只有大型对象数据类型（BLOB）：&lt;/p&gt;
&lt;p&gt;text,ntext,image,nvarchar(max),varchar(max),varbinary(max)和xml数据类型&lt;/p&gt;
&lt;p&gt;这些数据类型的数据都存放在LOB类型的数据页面里&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他类型&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;第11章：列类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#column-type-overview&quot;&gt;11.1. 列类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-type-overview&quot;&gt;11.1.1. 数值类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#date-and-time-type-overview&quot;&gt;11.1.2. 日期和时间类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#string-type-overview&quot;&gt;11.1.3. 字符串类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-types&quot;&gt;11.2. 数值类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#date-and-time-types&quot;&gt;11.3. 日期和时间类型&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#datetime&quot;&gt;11.3.1. DATETIME、DATE和TIMESTAMP类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#time&quot;&gt;11.3.2. TIME类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#year&quot;&gt;11.3.3. YEAR类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#y2k-issues&quot;&gt;11.3.4. Y2K事宜和日期类型&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#string-types&quot;&gt;11.4. String类型&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#char&quot;&gt;11.4.1. CHAR和VARCHAR类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#binary-varbinary&quot;&gt;11.4.2. BINARY和VARBINARY类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#blob&quot;&gt;11.4.3. BLOB和TEXT类型&lt;code&gt;&lt;/code&gt;&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#enum&quot;&gt;11.4.4. ENUM类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#set&quot;&gt;11.4.5. SET类型&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements&quot;&gt;11.5. 列类型存储需求&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#choosing-types&quot;&gt;11.6. 选择正确的列类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#other-vendor-column-types&quot;&gt;11.7. 使用来自其他数据库引擎的列类型&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;p&gt;MySQL支持多种列类型：数值类型、日期/时间类型和字符串(字符)类型。本章首先对这些列类型进行了概述，然后更加详细地描述了各种列的类型，以及列类型存储需求的总结。概述很简单。关于具体列类型的详细信息应查阅详细的描述，例如指定值时允许使用的格式。&lt;/p&gt;
&lt;p&gt;MySQL支持处理空间数据的扩展名。关于空间类型的信息参见&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/spatial-extensions-in-mysql.html&quot;&gt;第19章：&lt;/a&gt;&lt;a title=&quot;Chapter 19. Spatial Extensions in MySQL&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/spatial-extensions-in-mysql.html&quot;&gt;&lt;em&gt;MySQL中的空间扩展&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;几种列类型描述使用了下述惯例：&lt;/p&gt;
&lt;p&gt;·         &lt;em&gt;M&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;表示最大显示宽度。最大有效显示宽度是255。&lt;/p&gt;
&lt;p&gt;·         &lt;em&gt;D&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;适用于浮点和定点类型，并表示小数点后面的位数。最大可能的值是30，但不应大于&lt;em&gt;M&lt;/em&gt;-2。&lt;/p&gt;
&lt;p&gt;·         方括号(‘[’和‘]’)表示可选部分。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;column-type-overview&quot;&gt;&lt;/a&gt;11.1. 列类型概述&lt;/h2&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-type-overview&quot;&gt;11.1.1. 数值类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#date-and-time-type-overview&quot;&gt;11.1.2. 日期和时间类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#string-type-overview&quot;&gt;11.1.3. 字符串类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;p&gt;&lt;a name=&quot;id2844482&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;numeric-type-overview&quot;&gt;&lt;/a&gt;11.1.1. 数值类型概述&lt;/h3&gt;
&lt;p&gt;下面为数值列类型的概述。详细信息参见&lt;a title=&quot;11.2. Numeric Types&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-types&quot;&gt;11.2节，“数值类型”&lt;/a&gt;。列存储需求参见&lt;a title=&quot;11.5. Column Type Storage Requirements&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements&quot;&gt;11.5节，“列类型存储需求”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;M&lt;/em&gt;指示最大显示宽度。最大有效显示宽度是255。显示宽度与存储大小或类型包含的值的范围无关，相关描述见&lt;a title=&quot;11.2. Numeric Types&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-types&quot;&gt;11.2节，“数值类型”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果为一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性。&lt;/p&gt;
&lt;p&gt;SERIAL是BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE的一个别名。&lt;/p&gt;
&lt;p&gt;在整数列定义中，SERIAL DEFAULT VALUE是NOT NULL AUTO_INCREMENT UNIQUE的一个别名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt;应当清楚，当使用在整数值（其中一个是UNSIGNED类型）之间使用减号时，结果是无符号。参见&lt;a title=&quot;12.8. Cast Functions and Operators&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/functions.html#cast-functions&quot;&gt;12.8节，“Cast函数和操作符”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;·         BIT[(&lt;em&gt;M&lt;/em&gt;)]&lt;/p&gt;
&lt;p&gt;位字段类型。&lt;em&gt;M&lt;/em&gt;表示每个值的位数，范围为从1到64。如果&lt;em&gt;M&lt;/em&gt;被省略， 默认为1。&lt;/p&gt;
&lt;p&gt;·         TINYINT[(&lt;em&gt;M&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;很小的整数。带符号的范围是-128到127。无符号的范围是0到255。&lt;/p&gt;
&lt;p&gt;·         BOOL，BOOLEAN&lt;/p&gt;
&lt;p&gt;是TINYINT(1)的同义词。zero值被视为假。非zero值视为真。&lt;/p&gt;
&lt;p&gt;在将来，将根据标准SQL引入完全布尔类型的处理。&lt;/p&gt;
&lt;p&gt;·         SMALLINT[(&lt;em&gt;M&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;小的整数。带符号的范围是-32768到32767。无符号的范围是0到65535。&lt;/p&gt;
&lt;p&gt;·         MEDIUMINT[(&lt;em&gt;M&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;中等大小的整数。带符号的范围是-8388608到8388607。无符号的范围是0到16777215。&lt;/p&gt;
&lt;p&gt;·         INT[(&lt;em&gt;M&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;普通大小的整数。带符号的范围是-2147483648到2147483647。无符号的范围是0到4294967295。&lt;/p&gt;
&lt;p&gt;·         INTEGER[(&lt;em&gt;M&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;这是INT的同义词。&lt;/p&gt;
&lt;p&gt;·         BIGINT[(&lt;em&gt;M&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;大整数。带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615。&lt;/p&gt;
&lt;p&gt;应清楚BIGINT列的下述内容：&lt;/p&gt;
&lt;p&gt;o        使用带符号的BIGINT或DOUBLE值进行所有算法，因此除了位函数，不应使用大于9223372036854775807(63位)的无符号的大整数! 如果这样做，结果中的最后几位可能出错，这是由于将BIGINT值转换为DOUBLE进行四舍五入时造成的错误。&lt;/p&gt;
&lt;p&gt;MySQL可以在以下情况下处理BIGINT：&lt;/p&gt;
&lt;p&gt;§         当使用整数在一个BIGINT列保存大的无符号的值时。&lt;/p&gt;
&lt;p&gt;§         在MIN(&lt;em&gt;col_name&lt;/em&gt;)或MAX(&lt;em&gt;col_name&lt;/em&gt;)中，其中&lt;em&gt;col_name&lt;/em&gt;指BIGINT列。&lt;/p&gt;
&lt;p&gt;§         使用操作符(+，-，*等等)并且两个操作数均为整数时。&lt;/p&gt;
&lt;p&gt;o        总是可以使用一个字符串在BIGINT列中保存严格整数值。在这种情况下，MySQL执行字符串-数字转换，其间不存在双精度表示。&lt;/p&gt;
&lt;p&gt;o        当两个操作数均为整数值时，-、+和* 操作符使用BIGINT算法。这说明如果乘两个大整数(或来自返回整数的函数)，当结果大于9223372036854775807时，会得到意想不到的结果。&lt;/p&gt;
&lt;p&gt;·         FLOAT[(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;小(单精度)浮点数。允许的值是-3.402823466E+38到-1.175494351E-38、0和1.175494351E-38到3.402823466E+38。这些是理论限制，基于IEEE标准。实际的范围根据硬件或操作系统的不同可能稍微小些。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;M&lt;/em&gt;是小数纵位数，&lt;em&gt;D&lt;/em&gt;是小数点后面的位数。如果&lt;em&gt;M&lt;/em&gt;和&lt;em&gt;D&lt;/em&gt;被省略，根据硬件允许的限制来保存值。单精度浮点数精确到大约7位小数位。&lt;/p&gt;
&lt;p&gt;如果指定UNSIGNED，不允许负值。&lt;/p&gt;
&lt;p&gt;使用浮点数可能会遇到意想不到的问题，因为在MySQL中的所有计算用双精度完成。参见&lt;a title=&quot;A.5.7. Solving Problems with No Matching Rows&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/problems.html#no-matching-rows&quot;&gt;A.5.7节，“解决与不匹配行有关的问题”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;·         DOUBLE[(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;普通大小(双精度)浮点数。允许的值是-1.7976931348623157E+308到-2.2250738585072014E-308、0和2.2250738585072014E-308到 1.7976931348623157E+308。这些是理论限制，基于IEEE标准。实际的范围根据硬件或操作系统的不同可能稍微小些。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;M&lt;/em&gt;是小数总位数，&lt;em&gt;D&lt;/em&gt;是小数点后面的位数。如果&lt;em&gt;M&lt;/em&gt;和&lt;em&gt;D&lt;/em&gt;被省略，根据硬件允许的限制来保存值。双精度浮点数精确到大约15位小数位。&lt;/p&gt;
&lt;p&gt;如果指定UNSIGNED，不允许负值。&lt;/p&gt;
&lt;p&gt;·         DOUBLE PRECISION[(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)] [UNSIGNED] [ZEROFILL], REAL[(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;为DOUBLE的同义词。除了：如果SQL服务器模式包括REAL_AS_FLOAT选项，REAL是FLOAT的同义词而不是DOUBLE的同义词。&lt;/p&gt;
&lt;p&gt;·         FLOAT(&lt;em&gt;p&lt;/em&gt;) [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;浮点数。&lt;em&gt;p&lt;/em&gt;表示精度（以位数表示），但MySQL只使用该值来确定是否结果列的数据类型为FLOAT或DOUBLE。如果&lt;em&gt;p&lt;/em&gt;为从0到24，数据类型变为没有&lt;em&gt;M&lt;/em&gt;或&lt;em&gt;D&lt;/em&gt;值的FLOAT。如果&lt;em&gt;p&lt;/em&gt;为从25到53，数据类型变为没有&lt;em&gt;M&lt;/em&gt;或&lt;em&gt;D&lt;/em&gt;值的DOUBLE。结果列范围与本节前面描述的单精度FLOAT或双精度DOUBLE数据类型相同。&lt;/p&gt;
&lt;p&gt;FLOAT(&lt;em&gt;p&lt;/em&gt;)语法与ODBC兼容。&lt;/p&gt;
&lt;p&gt;·         DECIMAL[(&lt;em&gt;M&lt;/em&gt;[,&lt;em&gt;D&lt;/em&gt;])] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;压缩的“严格”定点数。&lt;em&gt;M&lt;/em&gt;是小数位数(精度)的总数，&lt;em&gt;D&lt;/em&gt;是小数点(标度)后面的位数。小数点和(负数)的‘-’符号不包括在&lt;em&gt;M&lt;/em&gt;中。如果&lt;em&gt;D&lt;/em&gt;是0，则值没有小数点或分数部分。DECIMAL整数最大位数(&lt;em&gt;M&lt;/em&gt;)为65。支持的十进制数的最大位数(&lt;em&gt;D&lt;/em&gt;)是30。如果&lt;em&gt;D&lt;/em&gt;被省略， 默认是0。如果&lt;em&gt;M&lt;/em&gt;被省略， 默认是10。&lt;/p&gt;
&lt;p&gt;如果指定UNSIGNED，不允许负值。&lt;/p&gt;
&lt;p&gt;所有DECIMAL列的基本计算(+，-，*，/)用65位精度完成。&lt;/p&gt;
&lt;p&gt;·         DEC[(&lt;em&gt;M&lt;/em&gt;[,&lt;em&gt;D&lt;/em&gt;])] [UNSIGNED] [ZEROFILL], NUMERIC[(&lt;em&gt;M&lt;/em&gt;[,&lt;em&gt;D&lt;/em&gt;])] [UNSIGNED] [ZEROFILL], FIXED[(&lt;em&gt;M&lt;/em&gt;[,&lt;em&gt;D&lt;/em&gt;])] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;是DECIMAL的同义词。FIXED同义词适用于与其它服务器的兼容性。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;date-and-time-type-overview&quot;&gt;&lt;/a&gt;11.1.2. 日期和时间类型概述&lt;/h3&gt;
&lt;p&gt;本节综合讨论了临时列类型。详细信息，参见&lt;a title=&quot;11.3. Date and Time Types&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#date-and-time-types&quot;&gt;11.3节，“日期和时间类型”&lt;/a&gt;。列存储需求参见&lt;a title=&quot;11.5. Column Type Storage Requirements&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements&quot;&gt;11.5节，“列类型存储需求”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;·         DATE&lt;/p&gt;
&lt;p&gt;日期。支持的范围为’1000-01-01′到’9999-12-31′。MySQL以’YYYY-MM-DD’格式显示DATE值，但允许使用字符串或数字为DATE列分配值。&lt;/p&gt;
&lt;p&gt;·         DATETIME&lt;/p&gt;
&lt;p&gt;日期和时间的组合。支持的范围是’1000-01-01 00:00:00′到’9999-12-31 23:59:59′。MySQL以’YYYY-MM-DD HH:MM:SS’格式显示DATETIME值，但允许使用字符串或数字为DATETIME列分配值。&lt;/p&gt;
&lt;p&gt;·         TIMESTAMP[(&lt;em&gt;M&lt;/em&gt;)]&lt;/p&gt;
&lt;p&gt;时间戳。范围是’1970-01-01 00:00:00′到2037年。&lt;/p&gt;
&lt;p&gt;TIMESTAMP列用于INSERT或UPDATE操作时记录日期和时间。如果你不分配一个值，表中的第一个TIMESTAMP列自动设置为最近操作的日期和时间。也可以通过分配一个NULL值，将TIMESTAMP列设置为当前的日期和时间。&lt;/p&gt;
&lt;p&gt;TIMESTAMP值返回后显示为’YYYY-MM-DD HH:MM:SS’格式的字符串，显示宽度固定为19个字符。如果想要获得数字值，应在TIMESTAMP 列添加+0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注释：&lt;/strong&gt;MySQL 4.1以前使用的TIMESTAMP格式在MySQL 5.1中不支持；关于旧格式的信息参见&lt;em&gt;MySQL 4.1 参考手册&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;·         TIME&lt;/p&gt;
&lt;p&gt;时间。范围是’-838:59:59′到’838:59:59′。MySQL以’HH:MM:SS’格式显示TIME值，但允许使用字符串或数字为TIME列分配值。&lt;/p&gt;
&lt;p&gt;·         YEAR[(2|4)]&lt;/p&gt;
&lt;p&gt;两位或四位格式的年。默认是四位格式。在四位格式中，允许的值是1901到2155和0000。在两位格式中，允许的值是70到69，表示从1970年到2069年。MySQL以YYYY 格式显示YEAR值，但允许使用字符串或数字为YEAR列分配值。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;string-type-overview&quot;&gt;&lt;/a&gt;11.1.3. 字符串类型概述&lt;/h3&gt;
&lt;p&gt;本节综合讨论了字符串列类型。详细信息参见&lt;a title=&quot;11.4. String Types&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#string-types&quot;&gt;11.4节，“String类型”&lt;/a&gt;。列存储需求参见&lt;a title=&quot;11.5. Column Type Storage Requirements&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements&quot;&gt;11.5节，“列类型存储需求”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在某些情况中，MySQL可以将一个字符串列更改为不同于CREATE TABLE或ALTER TABLE语句中所给出的类型。参见&lt;a title=&quot;13.1.5.1. Silent Column Specification Changes&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/sql-syntax.html#silent-column-changes&quot;&gt;13.1.5.1节，“沉寂的列规格变更”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;MySQL 5.1字符串数据类型包括部分在MySQL 4.1之前的版本中没有的特性：&lt;/p&gt;
&lt;p&gt;·         许多字符串数据类型的列定义可以包括指定字符集的CHARACTER SET属性，也可能包括校对规则。(CHARSET是CHARACTER SET的一个同义词）。这些属性适用于CHAR、VARCHAR、TEXT类型、ENUM和SET。例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t
(
  c1 CHAR(20) CHARACTER SET utf8,
  c2 CHAR(20) CHARACTER SET latin1 COLLATE  latin1_bin
);&lt;/pre&gt;
&lt;p&gt;该表定义创建了一个名为c1的列，具有一个utf8字符集和该字符集的默认 校对规则，和一个名为c2的列以及latin1字符集和该字符集的二元 校对规则。二元校对规则对大小写不敏感。&lt;/p&gt;
&lt;p&gt;·         MySQL 5.1用字符单位解释在字符列定义中的长度规范。(以前的一些MySQL版本以字节解释长度）。&lt;/p&gt;
&lt;p&gt;·         对于CHAR、VARCHAR和TEXT类型，BINARY属性可以为列分配该列字符集的 校对规则。&lt;/p&gt;
&lt;p&gt;·         字符列的排序和比较基于分配给列的字符集。在以前的版本中，排序和比较基于服务器字符集的校对规则。对于CHAR和VARCHAR 列，你可以用BINARY属性声明列让排序和 校对规则使用当前的字符代码值而不是词汇顺序。&lt;/p&gt;
&lt;p&gt;关于MySQL 5.1中字符集的支持，参见&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/charset.html&quot;&gt;第10章：&lt;/a&gt;&lt;a title=&quot;Chapter 10. Character Set Support&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/charset.html&quot;&gt;&lt;em&gt;字符集支持&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;·         [NATIONAL] CHAR(&lt;em&gt;M&lt;/em&gt;) [BINARY| ASCII | UNICODE]&lt;/p&gt;
&lt;p&gt;固定长度字符串，当保存时在右侧填充空格以达到指定的长度。&lt;em&gt;M&lt;/em&gt;表示列长度。&lt;em&gt;M&lt;/em&gt;的范围是0到255个字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注释：&lt;/strong&gt;当检索CHAR值时尾部空格被删除。&lt;/p&gt;
&lt;p&gt;如果想要将某个CHAR的长度设为大于255，执行的CREATE TABLE或ALTER TABLE语句将失败并提示错误：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; CREATE TABLE c1 (col1 INT, col2 CHAR(500));
ERROR 1074 (42000): Column length too big for column &#39;col&#39; (max = 255); use BLOB or TEXT instead
mysql&amp;gt; SHOW CREATE TABLE c1;
ERROR 1146 (42S02): Table &#39;test.c1&#39; doesn&#39;t exist&lt;/pre&gt;
&lt;p&gt;CHAR是CHARACTER的简写。NATIONAL CHAR(或其等效短形式NCHAR)是标准的定义CHAR列应使用 默认字符集的SQL方法。这在MySQL中为默认值。&lt;/p&gt;
&lt;p&gt;BINARY属性是指定列字符集的二元 校对规则的简写。排序和比较基于数值字符值。&lt;/p&gt;
&lt;p&gt;列类型CHAR BYTE是CHAR BINARY的一个别名。这是为了保证兼容性。&lt;/p&gt;
&lt;p&gt;可以为CHAR指定ASCII属性。它分配latin1字符集。&lt;/p&gt;
&lt;p&gt;可以为CHAR指定UNICODE属性。它分配ucs2字符集。&lt;/p&gt;
&lt;p&gt;MySQL允许创建类型CHAR(0)的列。这主要用于必须有一个列但实际上不使用值的旧版本的应用程序相兼容。当你需要只能取两个值的列时也很好：没有定义为NOT NULL的一个CHAR(0)列只占用一位，只可以取值NULL和”(空字符串)。&lt;/p&gt;
&lt;p&gt;·         CHAR&lt;/p&gt;
&lt;p&gt;这是CHAR(1)的同义词。&lt;/p&gt;
&lt;p&gt;·         [NATIONAL] VARCHAR(&lt;em&gt;M&lt;/em&gt;) [BINARY]&lt;/p&gt;
&lt;p&gt;变长字符串。&lt;em&gt;M&lt;/em&gt; 表示最大列长度。&lt;em&gt;M&lt;/em&gt;的范围是0到65,535。(VARCHAR的最大实际长度由最长的行的大小和使用的字符集确定。最大&lt;em&gt;有效&lt;/em&gt;长度是65,532字节）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注释：&lt;/strong&gt;MySQL 5.1遵从标准SQL规范，并且不删除VARCHAR值的尾部空格。&lt;/p&gt;
&lt;p&gt;VARCHAR是字符VARYING的简写。&lt;/p&gt;
&lt;p&gt;BINARY属性是指定列的字符集的二元 校对规则的简写。排序和比较基于数值字符值。&lt;/p&gt;
&lt;p&gt;VARCHAR保存时用一个字节或两个字节长的前缀+数据。如果VARCHAR列声明的长度大于255，长度前缀是两个字节。&lt;/p&gt;
&lt;p&gt;·         BINARY(&lt;em&gt;M&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;BINARY类型类似于CHAR类型，但保存二进制字节字符串而不是非二进制字符串。&lt;/p&gt;
&lt;p&gt;·         VARBINARY(&lt;em&gt;M&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;VARBINARY类型类似于VARCHAR类型，但保存二进制字节字符串而不是非二进制字符串。&lt;/p&gt;
&lt;p&gt;·         TINYBLOB&lt;/p&gt;
&lt;p&gt;最大长度为255(2&lt;sup&gt;8&lt;/sup&gt;–1)字节的BLOB列。&lt;/p&gt;
&lt;p&gt;·         TINYTEXT&lt;/p&gt;
&lt;p&gt;最大长度为255(2&lt;sup&gt;8&lt;/sup&gt;–1)字符的TEXT列。&lt;/p&gt;
&lt;p&gt;·         BLOB[(&lt;em&gt;M&lt;/em&gt;)]&lt;/p&gt;
&lt;p&gt;最大长度为65,535(2&lt;sup&gt;16&lt;/sup&gt;–1)字节的BLOB列。&lt;/p&gt;
&lt;p&gt;可以给出该类型的可选长度&lt;em&gt;M&lt;/em&gt;。如果给出，则MySQL将列创建为最小的但足以容纳&lt;em&gt;M&lt;/em&gt;字节长的值的BLOB类型。&lt;/p&gt;
&lt;p&gt;·         TEXT[(&lt;em&gt;M&lt;/em&gt;)]&lt;/p&gt;
&lt;p&gt;最大长度为65,535(2&lt;sup&gt;16&lt;/sup&gt;–1)字符的TEXT列。&lt;/p&gt;
&lt;p&gt;可以给出可选长度&lt;em&gt;M&lt;/em&gt;。则MySQL将列创建为最小的但足以容纳&lt;em&gt;M&lt;/em&gt;字符长的值的TEXT类型。&lt;/p&gt;
&lt;p&gt;·         MEDIUMBLOB&lt;/p&gt;
&lt;p&gt;最大长度为16,777,215(2&lt;sup&gt;24&lt;/sup&gt;–1)字节的BLOB列。&lt;/p&gt;
&lt;p&gt;·         MEDIUMTEXT&lt;/p&gt;
&lt;p&gt;最大长度为16,777,215(2&lt;sup&gt;24&lt;/sup&gt;–1)字符的TEXT列。&lt;/p&gt;
&lt;p&gt;·         LONGBLOB&lt;/p&gt;
&lt;p&gt;最大长度为4,294,967,295或4GB(2&lt;sup&gt;32&lt;/sup&gt;–1)字节的BLOB列。LONGBLOB列的最大&lt;em&gt;有效&lt;/em&gt;(允许的)长度取决于客户端/服务器协议中配置最大包大小和可用的内存。&lt;/p&gt;
&lt;p&gt;·         LONGTEXT&lt;/p&gt;
&lt;p&gt;最大长度为4,294,967,295或4GB(2&lt;sup&gt;32&lt;/sup&gt;–1)字符的TEXT列。LONGTEXT列的最大&lt;em&gt;有效&lt;/em&gt;(允许的)长度取决于客户端/服务器协议中配置最大包大小和可用的内存。&lt;/p&gt;
&lt;p&gt;·         ENUM(‘&lt;em&gt;value1&lt;/em&gt;‘,’&lt;em&gt;value2&lt;/em&gt;‘,…)&lt;/p&gt;
&lt;p&gt;枚举类型。只能有一个值的字符串，从值列’&lt;em&gt;value1&lt;/em&gt;‘，’&lt;em&gt;value2&lt;/em&gt;‘，…，NULL中或特殊 ”错误值中选出。ENUM列最多可以有65,535个截然不同的值。ENUM值在内部用整数表示。&lt;/p&gt;
&lt;p&gt;·         SET(‘&lt;em&gt;value1&lt;/em&gt;‘,’&lt;em&gt;value2&lt;/em&gt;‘,…)&lt;/p&gt;
&lt;p&gt;一个设置。字符串对象可以有零个或多个值，每个值必须来自列值’&lt;em&gt;value1&lt;/em&gt;‘，’&lt;em&gt;value2&lt;/em&gt;‘，…SET列最多可以有64个成员。SET值在内部用整数表示。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;numeric-types&quot;&gt;&lt;/a&gt;11.2. 数值类型&lt;/h2&gt;
&lt;p&gt;MySQL支持所有标准SQL数值数据类型。这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。&lt;/p&gt;
&lt;p&gt;BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。&lt;/p&gt;
&lt;p&gt;作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。&lt;/p&gt;
&lt;table id=&quot;table1&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;字节&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;最小值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;最大值&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;(带符号的/无符号的)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;(带符号的/无符号的)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TINYINT&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-128&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;-32768&lt;/td&gt;
&lt;td&gt;32767&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;65535&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;-8388608&lt;/td&gt;
&lt;td&gt;8388607&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;16777215&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-2147483648&lt;/td&gt;
&lt;td&gt;2147483647&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;4294967295&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BIGINT&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-9223372036854775808&lt;/td&gt;
&lt;td&gt;9223372036854775807&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;18446744073709551615&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;MySQL还支持选择在该类型关键字后面的括号内指定整数值的显示宽度(例如，INT(4))。该可选显示宽度规定用于显示宽度小于指定的列宽度的值时从左侧填满宽度。&lt;/p&gt;
&lt;p&gt;显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。&lt;/p&gt;
&lt;p&gt;当结合可选扩展属性ZEROFILL使用时， 默认补充的空格用零代替。例如，对于声明为INT(5) ZEROFILL的列，值4检索为00004。请注意如果在整数列保存超过显示宽度的一个值，当MySQL为复杂联接生成临时表时会遇到问题，因为在这些情况下MySQL相信数据适合原列宽度。&lt;/p&gt;
&lt;p&gt;所有整数类型可以有一个可选(非标准)属性UNSIGNED。当你想要在列内只允许非负数和该列需要较大的上限数值范围时可以使用无符号值。&lt;/p&gt;
&lt;p&gt;浮点和定点类型也可以为UNSIGNED。同数类型，该属性防止负值保存到列中。然而，与整数类型不同的是，列值的上范围保持不变。&lt;/p&gt;
&lt;p&gt;如果为一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性。&lt;/p&gt;
&lt;p&gt;对于浮点列类型，在MySQL中单精度值使用4个字节，双精度值使用8个字节。&lt;/p&gt;
&lt;p&gt;FLOAT类型用于表示近似数值数据类型。SQL标准允许在关键字FLOAT后面的括号内选择用位指定精度(但不能为指数范围)。MySQL还支持可选的只用于确定存储大小的精度规定。0到23的精度对应FLOAT列的4字节单精度。24到53的精度对应DOUBLE列的8字节双精度。&lt;/p&gt;
&lt;p&gt;MySQL允许使用非标准语法：FLOAT(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)或REAL(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)或DOUBLE PRECISION(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)。这里，“(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)”表示该值一共显示&lt;em&gt;M&lt;/em&gt;位整数，其中&lt;em&gt;D&lt;/em&gt;位位于小数点后面。例如，定义为FLOAT(7,4)的一个列可以显示为-999.9999。MySQL保存值时进行四舍五入，因此如果在FLOAT(7,4)列内插入999.00009，近似结果是999.0001。&lt;/p&gt;
&lt;p&gt;MySQL将DOUBLE视为DOUBLE PRECISION(非标准扩展)的同义词。MySQL还将REAL视为DOUBLE PRECISION(非标准扩展)的同义词，除非SQL服务器模式包括REAL_AS_FLOAT选项。&lt;/p&gt;
&lt;p&gt;为了保证最大可能的可移植性，需要使用近似数值数据值存储的代码应使用FLOAT或DOUBLE PRECISION，不规定精度或位数。&lt;/p&gt;
&lt;p&gt;DECIMAL和NUMERIC类型在MySQL中视为相同的类型。它们用于保存必须为确切精度的值，例如货币数据。当声明该类型的列时，可以(并且通常要)指定精度和标度；例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;salary DECIMAL(5,2)&lt;/pre&gt;
&lt;p&gt;在该例子中，5是精度，2是标度。精度表示保存值的主要位数，标度表示小数点后面可以保存的位数。&lt;/p&gt;
&lt;p&gt;在MySQL 5.1中以二进制格式保存DECIMAL和NUMERIC值。&lt;/p&gt;
&lt;p&gt;标准SQL要求salary列能够用5位整数位和两位小数保存任何值。因此，在这种情况下可以保存在salary列的值的范围是从-999.99到999.99。&lt;/p&gt;
&lt;p&gt;在标准SQL中，语法DECIMAL(&lt;em&gt;M&lt;/em&gt;)等价于DECIMAL(&lt;em&gt;M&lt;/em&gt;,0)。同样，语法DECIMAL等价于DECIMAL(&lt;em&gt;M&lt;/em&gt;,0)，可以通过计算确定&lt;em&gt;M&lt;/em&gt;的值。在MySQL 5.1中支持DECIMAL和NUMERIC数据类型的变量形式。&lt;em&gt;M&lt;/em&gt;默认值是10。&lt;/p&gt;
&lt;p&gt;DECIMAL或NUMERIC的最大位数是65，但具体的DECIMAL或NUMERIC列的实际范围受具体列的精度或标度约束。如果此类列分配的值小数点后面的位数超过指定的标度允许的范围，值被转换为该标度。(具体操作与操作系统有关，但一般结果均被截取到允许的位数）。&lt;/p&gt;
&lt;p&gt;BIT数据类型可用来保存位字段值。BIT(&lt;em&gt;M&lt;/em&gt;)类型允许存储&lt;em&gt;M&lt;/em&gt;位值。&lt;em&gt;M&lt;/em&gt;范围为1到64。&lt;/p&gt;
&lt;p&gt;要指定位值，可以使用b’&lt;em&gt;value&lt;/em&gt;‘符。&lt;em&gt;value&lt;/em&gt;是一个用0和1编写的二进制值。例如，b’111′和b’100000000′分别表示7和128。参见&lt;a title=&quot;9.1.5. Bit-Field Values&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/language-structure.html#bit-field-values&quot;&gt;9.1.5节，“位字段值”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果为BIT(M)列分配的值的长度小于&lt;em&gt;M&lt;/em&gt;位，在值的左边用0填充。例如，为BIT(6)列分配一个值b’101′，其效果与分配b’000101′相同。&lt;/p&gt;
&lt;p&gt;当要在一个数值列内保存一个超出该列允许范围的值时，MySQL的操作取决于此时有效的SQL模式。如果模式未设置，MySQL将值裁剪到范围的相应端点，并保存裁减好的值。但是，如果模式设置为traditional(“严格模式”)，超出范围的值将被拒绝并提示错误，并且根据SQL标准插入会失败。参见&lt;a title=&quot;5.3.2. The Server SQL Mode&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode&quot;&gt;5.3.2节，“SQL服务器模式”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果INT列是UNSIGNED，列范围的大小相同，但其端点会变为到0和4294967295。如果你试图保存-9999999999和9999999999，以非严格模式保存到列中的值是0和4294967296。&lt;/p&gt;
&lt;p&gt;如果在浮点或定点列中分配的值超过指定(或默认)精度和标度规定的范围，MySQL以非严格模式保存表示范围相应端点的值。&lt;/p&gt;
&lt;p&gt;当MySQL没有工作在严格模式时，对于ALTER TABLE、LOAD DATA INFILE、UPDATE和多行INSERT语句，由于裁剪发生的转换将报告为警告。当MySQL工作在严格模式时，这些语句将失败，并且部分或全部值不会插入或更改，取决于是否表为事务表和其它因素。详情参见&lt;a title=&quot;5.3.2. The Server SQL Mode&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode&quot;&gt;5.3.2节，“SQL服务器模式”&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;date-and-time-types&quot;&gt;&lt;/a&gt;11.3. 日期和时间类型&lt;/h2&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#datetime&quot;&gt;11.3.1. DATETIME、DATE和TIMESTAMP类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#time&quot;&gt;11.3.2. TIME类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#year&quot;&gt;11.3.3. YEAR类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#y2k-issues&quot;&gt;11.3.4. Y2K事宜和日期类型&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;p&gt;&lt;a name=&quot;id2849193&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2849203&quot;&gt;&lt;/a&gt;表示时间值的DATE和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。每个时间类型有一个有效值范围和一个“零”值，当指定不合法的MySQL不能表示的值时使用“零”值。TIMESTAMP类型有专有的自动更新特性，将在后面描述。&lt;/p&gt;
&lt;p&gt;如果试图插入一个不合法的日期，MySQL将给出警告或错误。可以使用ALLOW_INVALID_DATES SQL模式让MySQL接受某些日期，例如’1999-11-31′。当你想要保存一个“可能错误的”用户已经在数据库中指定(例如，以web形式)用于将来处理的值时很有用。在这种模式下，MySQL只验证月范围为从0到12，日范围为从0到31。这些范围可以包括零，因为MySQL允许在DATE或DATETIME列保存日/月和日是零的日期。这在应用程序需要保存一个你不知道确切日期的生日时非常有用。在这种情况下，只需要将日期保存为’1999-00-00′或’1999-01-00′。如果保存此类日期，DATE_SUB()或DATE_ADD等需要完整日期的函数不会得到正确的结果。(如果你不想在日期中出现零，可以使用NO_ZERO_IN_DATE SQL模式)。&lt;/p&gt;
&lt;p&gt;MySQL还允许将’0000-00-00′保存为“伪日期”(如果不使用NO_ZERO_DATE SQL模式)。这在某些情况下比使用NULL值更方便(并且数据和索引占用的空间更小)。&lt;/p&gt;
&lt;p&gt;将sql_mode系统变量设置为相应模式值，可以更确切你想让MySQL支持哪种日期。参见&lt;a title=&quot;5.3.2. The Server SQL Mode&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode&quot;&gt;5.3.2节，“SQL服务器模式”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当使用日期和时间类型时应记住以下几点：&lt;/p&gt;
&lt;p&gt;·         MySQL以标准输出格式检索给定日期或时间类型的值，但它尽力解释你指定的各种输入值格式(例如，当你指定一个分配给或与日期或时间类型进行比较的值时)。只支持下面章节中描述的格式。期望你能提供有效值。如果你使用其它格式的值会发生意想不到的结果。&lt;/p&gt;
&lt;p&gt;·         包含两位年值的日期会令人模糊，因为世纪不知道。MySQL使用以下规则解释两位年值：&lt;/p&gt;
&lt;p&gt;o        70-99范围的年值转换为1970-1999。&lt;/p&gt;
&lt;p&gt;o        00-69范围的年值转换为2000-2069。&lt;/p&gt;
&lt;p&gt;·         尽管MySQL尝试解释几种格式的值，日期总是以年-月-日顺序(例如，’98-09-04′)，而不是其它地方常用的月-日-年或日-月-年顺序(例如，’09-04-98′，’04-09-98′)。&lt;/p&gt;
&lt;p&gt;·         如果值用于数值上下文中，MySQL自动将日期或时间类型的值转换为数字，反之亦然。&lt;/p&gt;
&lt;p&gt;·         当 MySQL遇到一个日期或时间类型的超出范围或对于该类型不合法的值时(如本节开始所描述)，它将该值转换为该类的“零”值。一个例外是超出范围的TIME值被裁剪到TIME范围的相应端点。&lt;/p&gt;
&lt;p&gt;下面的表显示了各类“零”值的格式。请注意如果启用NO_ZERO_DATE SQL模式，使用这些值会产生警告。&lt;/p&gt;
&lt;table id=&quot;table2&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;列类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;
&lt;strong&gt;“&lt;/strong&gt;&lt;strong&gt;零&lt;/strong&gt;&lt;strong&gt;”值&lt;/strong&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DATETIME&lt;/td&gt;
&lt;td&gt;’0000-00-00 00:00:00′&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DATE&lt;/td&gt;
&lt;td&gt;’0000-00-00′&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIMESTAMP&lt;/td&gt;
&lt;td&gt;00000000000000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;’00:00:00′&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;·         “零”值是特殊值，但你可以使用表内显示的值显式保存或引用它们。你也可以使用值’0′或0来保存或引用，写起来更容易。&lt;/p&gt;
&lt;p&gt;·         MyODBC中使用的“零”日期或时间值在MyODBC 2.50.12和以上版本中被自动转换为NULL，因为ODBC不能处理此类值。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;datetime&quot;&gt;&lt;/a&gt;11.3.1. DATETIME、DATE和TIMESTAMP类型&lt;/h3&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#timestamp-4-1&quot;&gt;11.3.1.1. 自MySQL 4.1以来的TIMESTAMP属性&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;p&gt;&lt;a name=&quot;id2849637&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2849646&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2849655&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2849664&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2849677&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2849689&quot;&gt;&lt;/a&gt;DATETIME、DATE和TIMESTAMP类型是相关的。该节描述了它们的特征，它们的相似点和不同点。&lt;/p&gt;
&lt;p&gt;当你需要同时包含日期和时间信息的值时则使用DATETIME类型。MySQL以’YYYY-MM-DD HH:MM:SS’格式检索和显示DATETIME值。支持的范围为’1000-01-01 00:00:00′到’9999-12-31 23:59:59′。(“支持”表示尽管先前的值可能工作，但没有保证)。&lt;/p&gt;
&lt;p&gt;当你只需要日期值而不需要时间部分时应使用DATE类型。MySQL用’YYYY-MM-DD’格式检索和显示DATE值。支持的范围是’1000-01-01′到 ’9999-12-31′。&lt;/p&gt;
&lt;p&gt;TIMESTAMP列类型的属性不固定，取决于MySQL版本和服务器运行的SQL模式。这些属性将在本节后面描述。&lt;/p&gt;
&lt;p&gt;可以使用任何常见格式指定DATETIME、DATE和TIMESTAMP值：&lt;/p&gt;
&lt;p&gt;·         ’YYYY-MM-DD HH:MM:SS’或’YY-MM-DD HH:MM:SS’格式的字符串。允许“不严格”语法：任何标点符都可以用做日期部分或时间部分之间的间割符。例如，’98-12-31 11:30:45′、’98.12.31 11+30+45′、’98/12/31 11*30*45′和’98@12@31 11^30^45′是等价的。&lt;/p&gt;
&lt;p&gt;·         ’YYYY-MM-DD’或’YY-MM-DD’格式的字符串。这里也允许使用“不严格的”语法。例如，’98-12-31′、’98.12.31′、’98/12/31′和’98@12@31′是等价的。&lt;/p&gt;
&lt;p&gt;·         ’YYYYMMDDHHMMSS’或’YYMMDDHHMMSS’格式的没有间割符的字符串，假定字符串对于日期类型是有意义的。例如，’19970523091528′和’970523091528′被解释为’1997-05-23 09:15:28′，但’971122129015′是不合法的(它有一个没有意义的分钟部分)，将变为’0000-00-00 00:00:00′。&lt;/p&gt;
&lt;p&gt;·         ’YYYYMMDD’或’YYMMDD’格式的没有间割符的字符串，假定字符串对于日期类型是有意义的。例如，’19970523′和’970523′被解释为 ’1997-05-23′，但’971332′是不合法的(它有一个没有意义的月和日部分)，将变为’0000-00-00′。&lt;/p&gt;
&lt;p&gt;·         YYYYMMDDHHMMSS或YYMMDDHHMMSS格式的数字，假定数字对于日期类型是有意义的。例如，19830905132800和830905132800被解释为 ’1983-09-05 13:28:00′。&lt;/p&gt;
&lt;p&gt;·         YYYYMMDD或YYMMDD格式的数字，假定数字对于日期类型是有意义的。例如，19830905和830905被解释为’1983-09-05′。&lt;/p&gt;
&lt;p&gt;·         函数返回的结果，其值适合DATETIME、DATE或者TIMESTAMP上下文，例如NOW()或CURRENT_DATE。&lt;/p&gt;
&lt;p&gt;无效DATETIME、DATE或者TIMESTAMP值被转换为相应类型的“零”值(’0000-00-00 00:00:00′、’0000-00-00′或者00000000000000)。&lt;/p&gt;
&lt;p&gt;对于包括日期部分间割符的字符串值，如果日和月的值小于10，不需要指定两位数。’1979-6-9′与’1979-06-09′是相同的。同样，对于包括时间部分间割符的字符串值，如果时、分和秒的值小于10，不需要指定两位数。’1979-10-30 1:2:3′与’1979-10-30 01:02:03′相同。&lt;/p&gt;
&lt;p&gt;数字值应为6、8、12或者14位长。如果一个数值是8或14位长，则假定为YYYYMMDD或YYYYMMDDHHMMSS格式，前4位数表示年。如果数字 是6或12位长，则假定为YYMMDD或YYMMDDHHMMSS格式，前2位数表示年。其它数字被解释为仿佛用零填充到了最近的长度。&lt;/p&gt;
&lt;p&gt;指定为非限定符字符串的值使用给定的长度进行解释。如果字符串为8或14字符长，前4位数表示年。否则，前2位数表示年。从左向右解释字符串内出现的各部分，以发现年、月、日、小时、分和秒值。这说明不应使用少于6字符的字符串。例如，如果你指定’9903′，认为它表示1999年3月，MySQL将在你的表内插入一个“零”日期值。这是因为年和月值是99和03，但日部分完全丢失，因此该值不是一个合法的日期。但是，可以明显指定一个零值来代表缺少的月或日部分。例如，可以使用’990300′来插入值’1999-03-00′。&lt;/p&gt;
&lt;p&gt;在一定程度上，可以将一个日期类型的值分配给一个不同的日期类型。但是，值可能会更改或丢失一些信息：&lt;/p&gt;
&lt;p&gt;·         如果你为一个DATETIME或TIMESTAMP对象分配一个DATE值，结果值的时间部分被设置为’00:00:00′，因为DATE值未包含时间信息。&lt;/p&gt;
&lt;p&gt;·         如果你为一个DATE对象分配一个DATETIME或TIMESTAMP值，结果值的时间部分被删除，因为DATE值未包含时间信息。&lt;/p&gt;
&lt;p&gt;·         记住尽管可以使用相同的格式指定DATETIME、DATE和TIMESTAMP值，不同类型的值的范围却不同。例如，TIMESTAMP值不能早于1970或晚于2037。这说明一个日期，例如’1968-01-01′，虽然对于DATETIME或DATE值是有效的，但对于TIMESTAMP值却无效，如果分配给这样一个对象将被转换为0。&lt;/p&gt;
&lt;p&gt;当指定日期值时请注意某些缺陷：&lt;/p&gt;
&lt;p&gt;·         指定为字符串的值允许的非严格格式可能会欺骗。例如，值’10:11:12′由于‘:’间割符看上去可能象时间值，但如果用于日期上下文值则被解释为年’2010-11-12′。值’10:45:15′被转换为’0000-00-00′因为’45′不是合法月。&lt;/p&gt;
&lt;p&gt;·         在非严格模式，MySQL服务器只对日期的合法性进行基本检查：年、月和日的范围分别是1000到9999、00到12和00到31。任何包含超出这些范围的部分的日期被转换成’0000-00-00′。请注意仍然允许你保存非法日期，例如’2002-04-31′。要想确保不使用严格模式时日期有效，应检查应用程序。&lt;/p&gt;
&lt;p&gt;在严格模式，非法日期不被接受，并且不转换。&lt;/p&gt;
&lt;p&gt;详细信息参见&lt;a title=&quot;5.3.2. The Server SQL Mode&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode&quot;&gt;5.3.2节，“SQL服务器模式”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;·         包含两位年值的日期会令人模糊，因为世纪不知道。MySQL使用以下规则解释两位年值：&lt;/p&gt;
&lt;p&gt;o        00-69范围的年值转换为2000-2069。&lt;/p&gt;
&lt;p&gt;o        70-99范围的年值转换为1970-1999。&lt;/p&gt;
&lt;h4&gt;
&lt;a name=&quot;timestamp-4-1&quot;&gt;&lt;/a&gt;11.3.1.1. 自MySQL 4.1以来的TIMESTAMP属性&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;注释：在&lt;/strong&gt;旧版本的MySQL中(4.1之前)，TIMESTAMP列类型的属性在许多方面于本节所描述的大大不同。如果你需要对旧的TIMESTAMP数据进行转化以便在MySQL 5.1中工作，详情请参见&lt;em&gt;MySQL 4.1 参考手册&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;TIMESTAMP列的显示格式与DATETIME列相同。换句话说，显示宽度固定在19字符，并且格式为YYYY-MM-DD HH:MM:SS。&lt;/p&gt;
&lt;p&gt;MySQL服务器也可以以MAXDB模式运行。当服务器以该模式运行时，TIMESTAMP与DATETIME相等。也就是说，如果创建表时服务器以MAXDB模式运行，TIMESTAMP列创建为DATETIME列。结果是，该列使用DATETIME显示格式，有相同的值范围，并且没有自动对当前的日期和时间进行初始化或更新。&lt;/p&gt;
&lt;p&gt;要想启用MAXDB模式，在启动服务器时使用–sql-mode=MAXDB服务器选项或在运行时通过设置全局sql_mode变量将SQL服务器模式设置为MAXDB：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SET GLOBAL sql_mode=MAXDB；&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;客户端可以按照下面方法让服务器为它的连接以MAXDB模式运行：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SET SESSION sql_mode=MAXDB;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;MySQL不接受在日或月列包括一个零或包含非法日期值的时间戳值。该规则的唯一例外是特殊值’0000-00-00 00:00:00′。&lt;/p&gt;
&lt;p&gt;你可以非常灵便地确定什么时候初始化和更新TIMESTAMP和对哪些列进行初始化和更新：&lt;/p&gt;
&lt;p&gt;·         你可以将当前的时间戳指定为默认值和自动更新的值。但只能选择一个，或者两者都不选。(不可能一个列选择一个行为而另一个列选择另一个行为）。&lt;/p&gt;
&lt;p&gt;·         你可以指定哪个TIMESTAMP列自动初始化或更新为当前的日期和时间。不再需要为第1个TIMESTAMP列。&lt;/p&gt;
&lt;p&gt;请注意下面讨论所信息只适用于创建时未启用MAXDB模式的表的TIMESTAMP列。(如上所述，MAXDB模式使列创建为DATETIME列）。控制TIMESTAMP列的初始化和更新的规则如下所示：&lt;/p&gt;
&lt;p&gt;·         如果一个表内的第1个TIMESTAMP列指定为一个DEFAULT值，则不能忽略。 默认值可以为CURRENT_TIMESTAMP或常量日期和时间值。&lt;/p&gt;
&lt;p&gt;·         DEFAULT NULL与第1个&lt;em&gt;TIMESTAMP&lt;/em&gt; 列的DEFAULT CURRENT_TIMESTAMP相同。对于其它TIMESTAMP列，DEFAULT NULL被视为DEFAULT 0。&lt;/p&gt;
&lt;p&gt;·         表内的任何一个TIMESTAMP列可以设置为自动初始化为当前时间戳和/或更新。&lt;/p&gt;
&lt;p&gt;·         在CREATE TABLE语句中，可以用下面的任何一种方式声明第1个TIMESTAMP列：&lt;/p&gt;
&lt;p&gt;o        用DEFAULT CURRENT_TIMESTAMP和ON UPDATE CURRENT_TIMESTAMP子句，列为默认值使用当前的时间戳，并且自动更新。&lt;/p&gt;
&lt;p&gt;o        不使用DEFAULT或ON UPDATE子句，与DEFAULT CURRENT_TIMESTAMP ON UPDATECURRENT_TIMESTAMP相同。&lt;/p&gt;
&lt;p&gt;o        用DEFAULT CURRENT_TIMESTAMP子句不用ON UPDATE子句，列为默认值使用当前的时间戳但是不自动更新。&lt;/p&gt;
&lt;p&gt;o        不用DEFAULT子句但用ON UPDATE CURRENT_TIMESTAMP子句，列有默认值0并自动更新。&lt;/p&gt;
&lt;p&gt;o        用常量DEFAULT值，列有给出的 默认值。如果列有一个ON UPDATE CURRENT_TIMESTAMP子句，它自动更新，否则不。&lt;/p&gt;
&lt;p&gt;换句话说，你可以为初始值和自动更新的值使用当前的时间戳，或者其中一个使用，或者两个皆不使用。(例如，你可以指定ON UPDATE来启用自动更新而不让列自动初始化）。&lt;/p&gt;
&lt;p&gt;·         在DEFAULT和ON UPDATE子句中可以使用CURRENT_TIMESTAMP、CURRENT_TIMESTAMP()或者NOW()。它们均具有相同的效果。&lt;/p&gt;
&lt;p&gt;两个属性的顺序并不重要。如果一个TIMESTAMP列同时指定了DEFAULT和ON UPDATE，任何一个可以在另一个的前面。&lt;/p&gt;
&lt;p&gt;例子，下面这些语句是等效的：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t (ts TIMESTAMP);
CREATE TABLE t (ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t (ts TIMESTAMP ON UPDATE CURRENT_TIMESTAMP DEFAULT CURRENT_TIMESTAMP);&lt;/pre&gt;
&lt;p&gt;·         要为TIMESTAMP列而不是第1列指定自动默认或更新，必须通过将第1个TIMESTAMP列显式分配一个常量DEFAULT值来禁用自动初始化和更新。(例如，DEFAULT 0或DEFAULT’2003-01-01 00:00:00′)。然后，对于其它TIMESTAMP列，规则与第1个TIMESTAMP列相同，例外情况是不能忽略DEFAULT和ON UPDATE子句。如果这样做，则不会自动进行初始化或更新。&lt;/p&gt;
&lt;p&gt;例如：下面这些语句是等效的：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t (
    ts1 TIMESTAMP DEFAULT 0,
    ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                  ON UPDATE CURRENT_TIMESTAMP);&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t (
    ts1 TIMESTAMP DEFAULT 0,
    ts2 TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                  DEFAULT CURRENT_TIMESTAMP);&lt;/pre&gt;
&lt;p&gt;可以对每个连接设置当前的时区，相关描述参见&lt;a title=&quot;5.10.8. MySQL Server Time Zone Support&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#time-zone-support&quot;&gt;5.10.8节，“MySQL服务器时区支持”&lt;/a&gt;。TIMESTAMP值以UTC格式保存，存储时对当前的时区进行转换，检索时再转换回当前的时区。只要时区设定值为常量，便可以得到保存时的值。如果保存一个TIMESTAMP值，应更改时区然后检索该值，它与你保存的值不同。这是因为在两个方向的转换中没有使用相同的时区。当前的时区可以用作time_zone系统变量的值。&lt;/p&gt;
&lt;p&gt;可以在TIMESTAMP列的定义中包括NULL属性以允许列包含NULL值。例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t
(
  ts1 TIMESTAMP NULL DEFAULT NULL,
  ts2 TIMESTAMP NULL DEFAULT 0,
  ts3 TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP
);&lt;/pre&gt;
&lt;p&gt;如果未指定NULL属性，将列设置为NULL设置则会将它设置为当前的时间戳。请注意允许NULL值的TIMESTAMP列不会采用当前的时间戳，除非要么其 默认值定义为CURRENT_TIMESTAMP，或者NOW()或CURRENT_TIMESTAMP被插入到该列内。换句话说，只有使用如下定义创建，定义为 NULL的TIMESTAMP列才会自动更新：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t (ts NULLDEFAULT CURRENT_TIMESTAMP)；&lt;/pre&gt;
&lt;p&gt;否则-也就是说，如果使用NULL而不是DEFAULT TIMESTAMP来定义TIMESTAMP列，如下所示…&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t1 (ts NULL DEFAULT NULL);
CREATE TABLE t2 (ts NULL DEFAULT &#39;0000-00-00 00:00:00&#39;);&lt;/pre&gt;
&lt;p&gt;…则必须显式插入一个对应当前日期和时间的值。例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO t1 VALUES (NOW());
INSERT INTO t2 VALUES (CURRENT_TIMESTAMP);&lt;/pre&gt;
&lt;h3&gt;
&lt;a name=&quot;time&quot;&gt;&lt;/a&gt;11.3.2. TIME类型&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2851158&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2851167&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MySQL以’HH:MM:SS’格式检索和显示TIME值(或对于大的小时值采用’HHH:MM:SS’格式)。TIME值的范围可以从’-838:59:59′到’838:59:59′。小时部分会因此大的原因是TIME类型不仅可以用于表示一天的时间(必须小于24小时)，还可能为某个事件过去的时间或两个事件之间的时间间隔(可以大于24小时，或者甚至为负)。&lt;/p&gt;
&lt;p&gt;你可以用各种格式指定TIME值：&lt;/p&gt;
&lt;p&gt;·         ’D HH:MM:SS.fraction’格式的字符串。还可以使用下面任何一种“非严格”语法：’HH:MM:SS.fraction’、’HH:MM:SS’、’HH:MM’、’D HH:MM:SS’、’D HH:MM’、’D HH’或’SS’。这里D表示日，可以取0到34之间的值。请注意MySQL还不保存分数。&lt;/p&gt;
&lt;p&gt;·         ’HHMMSS’格式的没有间割符的字符串，假定是有意义的时间。例如，’101112′被理解为’10:11:12′，但’109712′是不合法的(它有一个没有意义的分钟部分)，将变为’00:00:00′。&lt;/p&gt;
&lt;p&gt;·         HHMMSS格式的数值，假定是有意义的时间。例如，101112被理解为’10:11:12′。下面格式也可以理解：SS、MMSS、HHMMSS、HHMMSS.fraction。请注意MySQL还不保存分数。&lt;/p&gt;
&lt;p&gt;·         函数返回的结果，其值适合TIME上下文，例如CURRENT_TIME。&lt;/p&gt;
&lt;p&gt;对于指定为包括时间部分间割符的字符串的TIME值，如果时、分或者秒值小于10，则不需要指定两位数。’8:3:2′与’08:03:02′相同。&lt;/p&gt;
&lt;p&gt;为TIME列分配简写值时应注意。没有冒号，MySQL解释值时假定最右边的两位表示秒。(MySQL解释TIME值为过去的时间而不是当天的时间）。例如，你可能认为’1112′和1112表示’11:12:00′(11点过12分)，但MySQL将它们解释为’00:11:12′(11分，12 秒)。同样，’12′和12 被解释为 ’00:00:12′。相反，TIME值中使用冒号则肯定被看作当天的时间。也就是说，’11:12′表示’11:12:00′，而不是’00:11:12′。&lt;/p&gt;
&lt;p&gt;超出TIME范围但合法的值被裁为范围最接近的端点。例如，’-850:00:00′和’850:00:00′被转换为’-838:59:59′和’838:59:59′。&lt;/p&gt;
&lt;p&gt;无效TIME值被转换为’00:00:00′。请注意由于’00:00:00′本身是一个合法TIME值，只从表内保存的一个’00:00:00′值还不能说出原来的值是 ’00:00:00′还是不合法的值。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;year&quot;&gt;&lt;/a&gt;11.3.3. YEAR类型&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2851517&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2851526&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;YEAR类型是一个单字节类型用于表示年。&lt;/p&gt;
&lt;p&gt;MySQL以YYYY格式检索和显示YEAR值。范围是1901到2155。&lt;/p&gt;
&lt;p&gt;可以指定各种格式的YEAR值：&lt;/p&gt;
&lt;p&gt;·         四位字符串，范围为’1901′到’2155′。&lt;/p&gt;
&lt;p&gt;·         四位数字，范围为1901到2155。&lt;/p&gt;
&lt;p&gt;·         两位字符串，范围为’00′到’99′。’00′到’69′和’70′到’99′范围的值被转换为2000到2069和1970到1999范围的YEAR值。&lt;/p&gt;
&lt;p&gt;·         两位整数，范围为1到99。1到69和70到99范围的值被转换为2001到2069和1970到1999范围的YEAR值。请注意两位整数范围与两位字符串范围稍有不同，因为你不能直接将零指定为数字并将它解释为2000。你必须将它指定为一个字符串’0′或’00′或它被解释为0000。&lt;/p&gt;
&lt;p&gt;·         函数返回的结果，其值适合YEAR上下文，例如NOW()。&lt;/p&gt;
&lt;p&gt;非法YEAR值被转换为0000。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;y2k-issues&quot;&gt;&lt;/a&gt;11.3.4. Y2K事宜和日期类型&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2851772&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2851779&quot;&gt;&lt;/a&gt;MySQL本身对于2000年(Y2K)是安全的(参见&lt;a title=&quot;1.4.5. Year 2000 Compliance&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/introduction.html#year-2000-compliance&quot;&gt;1.4.5节，“2000年兼容性”&lt;/a&gt;)，但输入给MySQL的值可能不安全。任何包含两位年值的输入都会令人模糊，因为世纪不知道。这些值必须解释为四位形式，因为MySQL内部使用四位来保存年。&lt;/p&gt;
&lt;p&gt;对于DATETIME、DATE、TIMESTAMP和YEAR类型，MySQL使用以下规则解释含模糊年值的日期：&lt;/p&gt;
&lt;p&gt;·         00-69范围的年值转换为2000-2069。&lt;/p&gt;
&lt;p&gt;·         70-99范围的年值转换为1970-1999。&lt;/p&gt;
&lt;p&gt;请记住这些规则只是合理猜测数据值表示什么。如果MySQL使用的启发不能产生正确的值，你应提供包含四位年值的确切输入。&lt;/p&gt;
&lt;p&gt;ORDER BY可以正确排序有两位年的TIMESTAMP或YEAR值。&lt;/p&gt;
&lt;p&gt;部分函数如MIN()和MAX()将TIMESTAMP或YEAR转换为一个数字。这说明使用有两位年值的值，这些函数不能工作正确。在这种情况下的修复方法是将TIMESTAMP或YEAR转换为四位年格式或使用MIN(DATE_ADD(TIMESTAMP,INTERVAL 0 DAYS))。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;string-types&quot;&gt;&lt;/a&gt;11.4. String类型&lt;/h2&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#char&quot;&gt;11.4.1. CHAR和VARCHAR类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#binary-varbinary&quot;&gt;11.4.2. BINARY和VARBINARY类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#blob&quot;&gt;11.4.3. BLOB和TEXT类型&lt;code&gt;&lt;/code&gt;&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#enum&quot;&gt;11.4.4. ENUM类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#set&quot;&gt;11.4.5. SET类型&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;p&gt;字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;char&quot;&gt;&lt;/a&gt;11.4.1. CHAR和VARCHAR类型&lt;/h3&gt;
&lt;p&gt;CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。&lt;/p&gt;
&lt;p&gt;CHAR和VARCHAR类型声明的长度表示你想要保存的最大字符数。例如，CHAR(30)可以占用30个字符。&lt;/p&gt;
&lt;p&gt;CHAR列的长度固定为创建表时声明的长度。长度可以为从0到255的任何值。当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。&lt;/p&gt;
&lt;p&gt;VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值。(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。&lt;/p&gt;
&lt;p&gt;同CHAR对比，VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。&lt;/p&gt;
&lt;p&gt;VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。&lt;/p&gt;
&lt;p&gt;如果分配给CHAR或VARCHAR列的值超过列的最大长度，则对值进行裁剪以使其适合。如果被裁掉的字符不是空格，则会产生一条警告。如果裁剪非空格字符，则会造成错误(而不是警告)并通过使用严格SQL模式禁用值的插入。参见&lt;a title=&quot;5.3.2. The Server SQL Mode&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode&quot;&gt;5.3.2节，“SQL服务器模式”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面的表显示了将各种字符串值保存到CHAR(4)和VARCHAR(4)列后的结果，说明了CHAR和VARCHAR之间的差别：&lt;/p&gt;
&lt;table id=&quot;table3&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CHAR(4)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;存储需求&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;VARCHAR(4)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;存储需求&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;”&lt;/td&gt;
&lt;td&gt;‘    ’&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;td&gt;”&lt;/td&gt;
&lt;td&gt;1个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘ab’&lt;/td&gt;
&lt;td&gt;‘ab  ’&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;td&gt;‘ab ‘&lt;/td&gt;
&lt;td&gt;3个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘abcd’&lt;/td&gt;
&lt;td&gt;‘abcd’&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;td&gt;‘abcd’&lt;/td&gt;
&lt;td&gt;5个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘abcdefgh’&lt;/td&gt;
&lt;td&gt;‘abcd’&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;td&gt;‘abcd’&lt;/td&gt;
&lt;td&gt;5个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;请注意上表中最后一行的值只适用&lt;em&gt;不使用严格模式&lt;/em&gt;时；如果MySQL运行在严格模式，超过列长度不的值&lt;em&gt;不&lt;em&gt;保存&lt;/em&gt;&lt;/em&gt;，并且会出现错误。&lt;/p&gt;
&lt;p&gt;从CHAR(4)和VARCHAR(4)列检索的值并不总是相同，因为检索时从CHAR列删除了尾部的空格。通过下面的例子说明该差别：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;CREATE TABLE vc (v VARCHAR(4), c CHAR(4));
&amp;lt;/strong&amp;gt;Query OK, 0 rows affected (0.02 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;INSERT INTO vc VALUES (&#39;ab  &#39;, &#39;ab  &#39;);
&amp;lt;/strong&amp;gt;Query OK, 1 row affected (0.00 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT CONCAT(v, &#39;+&#39;), CONCAT(c, &#39;+&#39;) FROM vc;
&amp;lt;/strong&amp;gt;+----------------+----------------+
| CONCAT(v, &#39;+&#39;) | CONCAT(c, &#39;+&#39;) |
+----------------+----------------+
| ab  +          | ab+            |
+----------------+----------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;根据分配给列的字符集校对规则对CHAR和VARCHAR列中的值进行排序和比较。&lt;/p&gt;
&lt;p&gt;请注意所有MySQL校对规则属于PADSPACE类。这说明在MySQL中的所有CHAR和VARCHAR值比较时不需要考虑任何尾部空格。例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;CREATE TABLE names (myname CHAR(10), yourname VARCHAR(10));
&amp;lt;/strong&amp;gt;Query OK, 0 rows affected (0.09 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;INSERT INTO names VALUES (&#39;Monty &#39;, &#39;Monty &#39;);
&amp;lt;/strong&amp;gt;Query OK, 1 row affected (0.00 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT myname = &#39;Monty  &#39;, yourname = &#39;Monty  &#39; FROM names;
&amp;lt;/strong&amp;gt;+--------------------+----------------------+
| myname = &#39;Monty  &#39; | yourname = &#39;Monty  &#39; |
+--------------------+----------------------+
|                  1 |                    1 |
+--------------------+----------------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;请注意所有MySQL版本均如此，并且它不受SQL服务器模式的影响。&lt;/p&gt;
&lt;p&gt;对于尾部填充字符被裁剪掉或比较时将它们忽视掉的情形，如果列的索引需要唯一的值，在列内插入一个只是填充字符数不同的值将会造成复制键值错误。&lt;/p&gt;
&lt;p&gt;CHAR BYTE是CHAR BINARY的别名。这是为了保证兼容性。&lt;/p&gt;
&lt;p&gt;ASCII属性为CHAR列分配latin1字符集。UNICODE属性分配ucs2字符集。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;binary-varbinary&quot;&gt;&lt;/a&gt;11.4.2. BINARY和VARBINARY类型&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2852527&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852536&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852545&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852558&quot;&gt;&lt;/a&gt;BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。&lt;/p&gt;
&lt;p&gt;BINARY和VARBINARY允许的最大长度一样，如同CHAR和VARCHAR，不同的是BINARY和VARBINARY的长度是字节长度而不是字符长度。&lt;/p&gt;
&lt;p&gt;BINARY和VARBINARY数据类型不同于CHAR BINARY和VARCHAR BINARY数据类型。对于后一种类型，BINARY属性不会将列视为二进制字符串列。相反，它致使使用列字符集的二元 校对规则，并且列自身包含非二进制字符字符串而不是二进制字节字符串。例如CHAR(5) BINARY被视为CHAR(5) CHARACTER SET latin1 COLLATE latin1_bin，假定默认字符集是latin1。这不同于BINARY(5)，它保存5字节二进制字符串，没有字符集或 校对规则。&lt;/p&gt;
&lt;p&gt;当保存BINARY值时，在它们右边填充值以达到指定长度。填充值是0×00(零字节)。插入值时在右侧添加0×00 on，并且选择时不删除尾部的字节。比较时所有字节很重要，包括ORDER BY和DISTINCT操作。比较时0×00字节和空格是不同的，0×00&amp;lt;空格。&lt;/p&gt;
&lt;p&gt;例如：对于一个BINARY(3)列，当插入时 ’a&#39; 变为 ’a ’。’a&#39;插入时变为’a&#39;。当选择时两个插入的值均不更改。&lt;/p&gt;
&lt;p&gt;对于VARBINARY，插入时不填充字符，选择时不裁剪字节。比较时所有字节很重要，包括ORDER BY和DISTINCT操作。比较时0×00字节和空格是不同的，0×00&amp;lt;空格。&lt;/p&gt;
&lt;p&gt;对于尾部填充字符被裁剪掉或比较时将它们忽视掉的情形，如果列的索引需要唯一的值，在列内插入一个只是填充字符数不同的值将会造成复制键值错误。&lt;/p&gt;
&lt;p&gt;如果你计划使用这些数据类型来保存二进制数据并且需要检索的值与保存的值完全相同，应考虑前面所述的填充和裁剪特征。下面的例子说明了用0×00填充的BINARY值如何影响列值比较：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;CREATE TABLE t (c BINARY(3));
&amp;lt;/strong&amp;gt;Query OK, 0 rows affected (0.01 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;INSERT INTO t SET c = &#39;a&#39;;
&amp;lt;/strong&amp;gt;Query OK, 1 row affected (0.01 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT HEX(c), c = &#39;a&#39;, c = &#39;a&#39; from t;
&amp;lt;/strong&amp;gt;+--------+---------+-------------+
| HEX(c) | c = &#39;a&#39; | c = &#39;a&#39; |
+--------+---------+-------------+
| 610000 |       0 |           1 |
+--------+---------+-------------+
1 row in set (0.09 sec)&lt;/pre&gt;
&lt;p&gt;如果检索的值必须与指定进行存储而没有填充的值相同，最好使用BLOB数据类型。&lt;/p&gt;
&lt;p&gt;创建表时，MySQL可以默默更改BINARY或VARBINARY列的类型。参见&lt;a title=&quot;13.1.5.1. Silent Column Specification Changes&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/sql-syntax.html#silent-column-changes&quot;&gt;13.1.5.1节，“沉寂的列规格变更”&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;blob&quot;&gt;&lt;/a&gt;11.4.3. BLOB和TEXT类型&lt;code&gt;&lt;/code&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2852869&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852878&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852887&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852900&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852912&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852921&quot;&gt;&lt;/a&gt;BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同。&lt;/p&gt;
&lt;p&gt;有4种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些对应4种BLOB类型，有相同的最大长度和存储需求。&lt;/p&gt;
&lt;p&gt;参见&lt;a title=&quot;11.5. Column Type Storage Requirements&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements&quot;&gt;11.5节，“列类型存储需求”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;BLOB 列被视为二进制字符串(字节字符串)。TEXT列被视为非二进制字符串(字符字符串)。BLOB列没有字符集，并且排序和比较基于列值字节的数值值。TEXT列有一个字符集，并且根据字符集的 校对规则对值进行排序和比较。&lt;/p&gt;
&lt;p&gt;在TEXT或BLOB列的存储或检索过程中，不存在大小写转换。&lt;/p&gt;
&lt;p&gt;当未运行在严格模式时，如果你为BLOB或TEXT列分配一个超过该列类型的最大长度的值值，值被截取以保证适合。如果截掉的字符不是空格，将会产生一条警告。使用严格SQL模式，会产生错误，并且值将被拒绝而不是截取并给出警告。参见&lt;a title=&quot;5.3.2. The Server SQL Mode&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode&quot;&gt;5.3.2节，“SQL服务器模式”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在大多数方面，可以将BLOB列视为能够足够大的VARBINARY列。同样，可以将TEXT列视为VARCHAR列。BLOB和TEXT在以下几个方面不同于VARBINARY和VARCHAR：&lt;/p&gt;
&lt;p&gt;·         当保存或检索BLOB和TEXT列的值时不删除尾部空格。(这与VARBINARY和VARCHAR列相同）。&lt;/p&gt;
&lt;p&gt;请注意比较时将用空格对TEXT进行扩充以适合比较的对象，正如CHAR和VARCHAR。&lt;/p&gt;
&lt;p&gt;·         对于BLOB和TEXT列的索引，必须指定索引前缀的长度。对于CHAR和VARCHAR，前缀长度是可选的。参见&lt;a title=&quot;7.4.3. Column Indexes&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/optimization.html#indexes&quot;&gt;7.4.3节，“列索引”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;·         BLOB和TEXT列不能有 默认值。&lt;/p&gt;
&lt;p&gt;LONG和LONG VARCHAR对应MEDIUMTEXT数据类型。这是为了保证兼容性。如果TEXT列类型使用BINARY属性，将为列分配列字符集的二元 校对规则。&lt;/p&gt;
&lt;p&gt;MySQL连接程序/ODBC将BLOB值定义为LONGVARBINARY，将TEXT值定义为LONGVARCHAR。&lt;/p&gt;
&lt;p&gt;由于BLOB和TEXT值可能会非常长，使用它们时可能遇到一些约束：&lt;/p&gt;
&lt;p&gt;·         当排序时只使用该列的前max_sort_length个字节。max_sort_length的 默认值是1024；该值可以在启动&lt;strong&gt;mysqld&lt;/strong&gt;服务器时使用–max_sort_length选项进行更改。参见&lt;a title=&quot;5.3.3. Server System Variables&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-system-variables&quot;&gt;5.3.3节，“服务器系统变量”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;运行时增加max_sort_length的值可以在排序或组合时使更多的字节有意义。任何客户端可以更改其会话max_sort_length变量的值：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SET max_sort_length = 2000;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT id, comment FROM &amp;lt;em&amp;gt;tbl_name
&amp;lt;/em&amp;gt;&amp;lt;/strong&amp;gt;    -&amp;amp;gt; &amp;lt;strong&amp;gt;ORDER BY comment;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;当你想要使超过max_sort_length的字节有意义，对含长值的BLOB或TEXT列使用GROUP BY或ORDER BY的另一种方式是将列值转换为固定长度的对象。标准方法是使用SUBSTRING函数。例如，下面的语句对comment列的2000个字节进行排序：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT id, SUBSTRING(comment,1,2000) FROM &amp;lt;em&amp;gt;tbl_name
&amp;lt;/em&amp;gt;&amp;lt;/strong&amp;gt;    -&amp;amp;gt; &amp;lt;strong&amp;gt;ORDER BY SUBSTRING(comment,1,2000);&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;·         BLOB或TEXT对象的最大大小由其类型确定，但在客户端和服务器之间实际可以传递的最大值由可用内存数量和通信缓存区大小确定。你可以通过更改max_allowed_packet变量的值更改消息缓存区的大小，但必须同时修改服务器和客户端程序。例如，可以使用 &lt;strong&gt;mysql&lt;/strong&gt;和&lt;strong&gt;mysqldump&lt;/strong&gt;来更改客户端的max_allowed_packet值。参见&lt;a title=&quot;7.5.2. Tuning Server Parameters&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/optimization.html#server-parameters&quot;&gt;7.5.2节，“调节服务器参数”&lt;/a&gt;、&lt;a title=&quot;8.3. mysql — The MySQL Command-Line Tool&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/client-side-scripts.html#mysql&quot;&gt;8.3节，“mysql：MySQL命令行工具”&lt;/a&gt;和&lt;a title=&quot;8.8. mysqldump — A Database Backup Program&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/client-side-scripts.html#mysqldump&quot;&gt;8.8节，“mysqldump：数据库备份程序”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;每个BLOB或TEXT值分别由内部分配的对象表示。这与其它列类型形成对比，后者是当打开表时为每1列分配存储引擎。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;enum&quot;&gt;&lt;/a&gt;11.4.4. ENUM类型&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2853488&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2853497&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ENUM是一个字符串对象，其值来自表创建时在列规定中显式枚举的一列值。&lt;/p&gt;
&lt;p&gt;在某些情况下，ENUM值也可以为空字符串(”)或NULL：&lt;/p&gt;
&lt;p&gt;·         如果你将一个非法值插入ENUM(也就是说，允许的值列之外的字符串)，将插入空字符串以作为特殊错误值。该字符串与“普通”空字符串不同，该字符串有数值值0。后面有详细讨论。&lt;/p&gt;
&lt;p&gt;·         如果将ENUM列声明为允许NULL，NULL值则为该列的一个有效值，并且 默认值为NULL。如果ENUM列被声明为NOT NULL，其默认值为允许的值列的第1个元素。&lt;/p&gt;
&lt;p&gt;每个枚举值有一个索引：&lt;/p&gt;
&lt;p&gt;·         来自列规定的允许的值列中的值从1开始编号。&lt;/p&gt;
&lt;p&gt;·         空字符串错误值的索引值是0。这说明你可以使用下面的SELECT语句来找出分配了非法ENUM值的行：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;·    mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT * FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt; WHERE &amp;lt;em&amp;gt;enum_col&amp;lt;/em&amp;gt;=0;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;·         NULL值的索引是NULL。&lt;/p&gt;
&lt;p&gt;例如，定义为ENUM的列(‘one’，’two’，’three’)可以有下面所示任何值。还显示了每个值的索引：&lt;/p&gt;
&lt;table id=&quot;table4&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;索引&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;”&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘one’&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘two’&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘three’&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;枚举最多可以有65,535个元素。&lt;/p&gt;
&lt;p&gt;当创建表时，ENUM成员值的尾部空格将自动被删除。&lt;/p&gt;
&lt;p&gt;当检索时，保存在ENUM列的值使用列定义中所使用的大小写来显示。请注意可以为ENUM列分配字符集和 校对规则。对于二进制或大小写敏感的校对规则，当为列分配值时应考虑大小写。&lt;/p&gt;
&lt;p&gt;如果在数值上下文中检索一个ENUM值，将返回列值的索引。例如，你可以这样从ENUM列搜索数值值：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT &amp;lt;em&amp;gt;enum_col&amp;lt;/em&amp;gt;+0 FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt;;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;如果将一个数字保存到ENUM列，数字被视为索引，并且保存的值是该索引对应的枚举成员。(但是，这不适合LOAD DATA，它将所有输入视为字符串）。不建议使用类似数字的枚举值来定义一个ENUM列，因为这很容易引起混淆。例如，下面的列含有字符串值’0′、’1′和’2′的枚举成员，但数值索引值为1、2和3：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;numbers ENUM(&#39;0&#39;,&#39;1&#39;,&#39;2&#39;)&lt;/pre&gt;
&lt;p&gt;根据枚举成员在列定义中列出的顺序对ENUM值进行排序。(换句话说，ENUM值根据索引编号进行排序）。例如，对于ENUM(‘a’，’b&#39;)，’a&#39;排在’b&#39;前面，但对于ENUM(‘b’，’a&#39;)，’b&#39;排在’a&#39;前面。空字符串排在非空字符串前面，并且NULL值排在所有其它枚举值前面。要想防止意想不到的结果，按字母顺序规定ENUM列。还可以使用GROUP BY  CAST(col AS CHAR)或GROUP BY  CONCAT(col)来确保按照词汇对列进行排序而不是用索引数字。&lt;/p&gt;
&lt;p&gt;如果你想要确定一个ENUM列的所有可能的值，使用SHOW COLUMNS FROM &lt;em&gt;tbl_name&lt;/em&gt; LIKE &lt;em&gt;enum_col&lt;/em&gt;，并解析输出中第2列的ENUM定义。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;set&quot;&gt;&lt;/a&gt;11.4.5. SET类型&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2853953&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2853962&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SET是一个字符串对象，可以有零或多个值，其值来自表创建时规定的允许的一列值。指定包括多个SET成员的SET列值时各成员之间用逗号(‘,’)间隔开。这样SET成员值本身不能包含逗号。&lt;/p&gt;
&lt;p&gt;例如，指定为SET(‘one’, ‘two’) NOT NULL的列可以有下面的任何值：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;&#39;&#39;
&#39;one&#39;
&#39;two&#39;
&#39;one,two&#39;&lt;/pre&gt;
&lt;p&gt;SET最多可以有64个不同的成员。&lt;/p&gt;
&lt;p&gt;当创建表时，SET成员值的尾部空格将自动被删除。&lt;/p&gt;
&lt;p&gt;当检索时，保存在SET列的值使用列定义中所使用的大小写来显示。请注意可以为SET列分配字符集和 校对规则。对于二进制或大小写敏感的校对规则，当为列分配值时应考虑大小写。&lt;/p&gt;
&lt;p&gt;MySQL用数字保存SET值，所保存值的低阶位对应第1个SET成员。如果在数值上下文中检索一个SET值，检索的值的位设置对应组成列值的SET成员。例如，你可以这样从一个SET列检索数值值：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT &amp;lt;em&amp;gt;set_col&amp;lt;/em&amp;gt;+0 FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt;;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;如果将一个数字保存到SET列中，数字中二进制表示中的位确定了列值中的SET成员。对于指定为SET(‘a’,&#39;b’,&#39;c’,&#39;d’)的列，成员有下面的十进制和二进制值：&lt;/p&gt;
&lt;table id=&quot;table5&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SET&lt;strong&gt;成员&lt;/strong&gt;
&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;十进制值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;二进制值&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘a’&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘b’&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘c’&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘d’&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果你为该列分配一个值9，其二进制形式为1001，因此第1个和第4个SET值成员’a&#39;和’d&#39;被选择，结果值为 ’a,d’。&lt;/p&gt;
&lt;p&gt;对于包含多个SET元素的值，当插入值时元素所列的顺序并不重要。在值中一个给定的元素列了多少次也不重要。当以后检索该值时，值中的每个元素出现一次，根据表创建时指定的顺序列出元素。例如，假定某个列指定为SET(‘a’,&#39;b’,&#39;c’,&#39;d’)：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;CREATE TABLE myset (col SET(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;));&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;插入值’a,d’、’d,a’、’a,d,d’、’a,d,a’和’d,a,d’:&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;INSERT INTO myset (col) VALUES 
&amp;lt;/strong&amp;gt;-&amp;amp;gt; (&#39;a,d&#39;), (&#39;d,a&#39;), (&#39;a,d,a&#39;), (&#39;a,d,d&#39;), (&#39;d,a,d&#39;);
Query OK, 5 rows affected (0.01 sec)
Records: 5  Duplicates: 0  Warnings: 0&lt;/pre&gt;
&lt;p&gt;当检索时所有这些值显示为 ’a,d’：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT col FROM myset;
&amp;lt;/strong&amp;gt;+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------
5 rows in set (0.04 sec)&lt;/pre&gt;
&lt;p&gt;如果将SET列设置为一个不支持的值，则该值被忽略并发出警告：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;INSERT INTO myset (col) VALUES (&#39;a,d,d,s&#39;);
&amp;lt;/strong&amp;gt;Query OK, 1 row affected, 1 warning (0.03 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SHOW WARNINGS;
&amp;lt;/strong&amp;gt;+---------+------+------------------------------------------+
| Level   | Code | Message                                  |
+---------+------+------------------------------------------+
| Warning | 1265 | Data truncated for column &#39;col&#39; at row 1 |
+---------+------+------------------------------------------+
1 row in set (0.04 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT col FROM myset;
&amp;lt;/strong&amp;gt;+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
6 rows in set (0.01 sec)&lt;/pre&gt;
&lt;p&gt;SET值按数字顺序排序。NULL值排在非NULL SET值的前面。&lt;/p&gt;
&lt;p&gt;通常情况，可以使用FIND_IN_SET()函数或LIKE操作符搜索SET值：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT * FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt; WHERE FIND_IN_SET(&#39;&amp;lt;em&amp;gt;value&amp;lt;/em&amp;gt;&#39;,&amp;lt;em&amp;gt;set_col&amp;lt;/em&amp;gt;)&amp;amp;gt;0;
&amp;lt;/strong&amp;gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT * FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt; WHERE &amp;lt;em&amp;gt;set_col&amp;lt;/em&amp;gt; LIKE &#39;%&amp;lt;em&amp;gt;value&amp;lt;/em&amp;gt;%&#39;;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;第1个语句找出&lt;em&gt;SET_col&lt;/em&gt;包含&lt;em&gt;value&lt;/em&gt; set成员的行。第2个类似，但有所不同：它在其它地方找出&lt;em&gt;set_col&lt;/em&gt;包含&lt;em&gt;value&lt;/em&gt;的行，甚至是在另一个SET成员的子字符串中。&lt;/p&gt;
&lt;p&gt;下面的语句也是合法的：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT * FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt; WHERE &amp;lt;em&amp;gt;set_col&amp;lt;/em&amp;gt; &amp;amp;amp; 1;
&amp;lt;/strong&amp;gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT * FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt; WHERE &amp;lt;em&amp;gt;set_col&amp;lt;/em&amp;gt; = &#39;&amp;lt;em&amp;gt;val1&amp;lt;/em&amp;gt;,&amp;lt;em&amp;gt;val2&amp;lt;/em&amp;gt;&#39;;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;第1个语句寻找包含第1个set成员的值。第2个语句寻找一个确切匹配的值。应注意第2类的比较。将set值与’&lt;em&gt;val1&lt;/em&gt;,&lt;em&gt;val2&lt;/em&gt;‘比较返回的结果与同’&lt;em&gt;val2&lt;/em&gt;,&lt;em&gt;val1&lt;/em&gt;‘比较返回的结果不同。指定值时的顺序应与在列定义中所列的顺序相同。&lt;/p&gt;
&lt;p&gt;如果想要为SET列确定所有可能的值，使用SHOW COLUMNS FROM &lt;em&gt;tbl_name&lt;/em&gt; LIKE &lt;em&gt;set_col&lt;/em&gt;并解析输出中第2列的SET定义。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;storage-requirements&quot;&gt;&lt;/a&gt;11.5. 列类型存储需求&lt;/h2&gt;
&lt;p&gt;&lt;a name=&quot;id2854549&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2854559&quot;&gt;&lt;/a&gt;根据类别列出了MySQL支持的每个列类型的存储需求。&lt;/p&gt;
&lt;p&gt;MyISAM表中行的最大大小为65,534字节。每个BLOB和TEXT列 账户只占其中的5至9个字节。&lt;/p&gt;
&lt;p&gt;如果MyISAM表包括变长列类型，记录格式也是可变长度。当创建表时，在某些条件下，MySQL可以将一个列从变长类型改为固定长度的类型或反之亦然。详细信息参见&lt;a title=&quot;13.1.5.1. Silent Column Specification Changes&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/sql-syntax.html#silent-column-changes&quot;&gt;13.1.5.1节，“沉寂的列规格变更”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数值类型存储需求&lt;/strong&gt;&lt;/p&gt;
&lt;table id=&quot;table6&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;列类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;存储需求&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TINYINT&lt;/td&gt;
&lt;td&gt;1个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td&gt;2个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;td&gt;3个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT, INTEGER&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BIGINT&lt;/td&gt;
&lt;td&gt;8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLOAT(&lt;em&gt;p&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;如果0 &amp;lt;= &lt;em&gt;p&lt;/em&gt; &amp;lt;= 24为4个字节, 如果25 &amp;lt;= &lt;em&gt;p&lt;/em&gt; &amp;lt;= 53为8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLOAT&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DOUBLE [PRECISION], item REAL&lt;/td&gt;
&lt;td&gt;8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DECIMAL(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;), NUMERIC(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;变长；参见下面的讨论&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BIT(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;大约(&lt;em&gt;M&lt;/em&gt;+7)/8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;DECIMAL(和NUMERIC)的存储需求与具体版本有关：&lt;/p&gt;
&lt;p&gt;使用二进制格式将9个十进制(基于10)数压缩为4个字节来表示DECIMAL列值。每个值的整数和分数部分的存储分别确定。每个9位数的倍数需要4个字节，并且“剩余的”位需要4个字节的一部分。下表给出了超出位数的存储需求：&lt;/p&gt;
&lt;table id=&quot;table7&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;剩余的&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;字节&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;位数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;数目&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;日期和时间类型的存储需求&lt;/strong&gt;&lt;/p&gt;
&lt;table id=&quot;table8&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;列类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;存储需求&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DATE&lt;/td&gt;
&lt;td&gt;3个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DATETIME&lt;/td&gt;
&lt;td&gt;8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIMESTAMP&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;3个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt;1个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;字符串类型的存储需求&lt;/strong&gt;&lt;/p&gt;
&lt;table id=&quot;table9&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;列类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;存储需求&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CHAR(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;M&lt;/em&gt;个字节，0 &amp;lt;= &lt;em&gt;M&lt;/em&gt; &amp;lt;= 255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VARCHAR(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;L&lt;/em&gt;+1个字节，其中&lt;em&gt;L&lt;/em&gt; &amp;lt;= &lt;em&gt;M &lt;/em&gt;且0 &amp;lt;= &lt;em&gt;M&lt;/em&gt; &amp;lt;= 65535(参见下面的注释)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BINARY(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;M&lt;/em&gt;个字节，0 &amp;lt;= &lt;em&gt;M&lt;/em&gt; &amp;lt;= 255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VARBINARY(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;L&lt;/em&gt;+1个字节，其中&lt;em&gt;L&lt;/em&gt; &amp;lt;= &lt;em&gt;M &lt;/em&gt;且0 &amp;lt;= &lt;em&gt;M&lt;/em&gt; &amp;lt;= 255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TINYBLOB, TINYTEXT&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;L&lt;/em&gt;+1个字节，其中&lt;em&gt;L&lt;/em&gt; &amp;lt; 2&lt;sup&gt;8&lt;/sup&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BLOB, TEXT&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;L&lt;/em&gt;+2个字节，其中&lt;em&gt;L&lt;/em&gt; &amp;lt; 2&lt;sup&gt;16&lt;/sup&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUMBLOB, MEDIUMTEXT&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;L&lt;/em&gt;+3个字节，其中&lt;em&gt;L&lt;/em&gt; &amp;lt; 2&lt;sup&gt;24&lt;/sup&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONGBLOB, LONGTEXT&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;L&lt;/em&gt;+4个字节，其中&lt;em&gt;L&lt;/em&gt; &amp;lt; 2&lt;sup&gt;32&lt;/sup&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ENUM(‘&lt;em&gt;value1&lt;/em&gt;‘,’&lt;em&gt;value2&lt;/em&gt;‘,…)&lt;/td&gt;
&lt;td&gt;1或2个字节，取决于枚举值的个数(最多65,535个值)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SET(‘&lt;em&gt;value1&lt;/em&gt;‘,’&lt;em&gt;value2&lt;/em&gt;‘,…)&lt;/td&gt;
&lt;td&gt;1、2、3、4或者8个字节，取决于set成员的数目(最多64个成员)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;VARCHAR、BLOB和TEXT类是变长类型。每个类型的存储需求取决于列值的实际长度(用前面的表中的&lt;em&gt;L&lt;/em&gt;表示)，而不是该类型的最大可能的大小。例如，VARCHAR(10)列可以容纳最大长度为10的字符串。实际存储需求是字符串(&lt;em&gt;L&lt;/em&gt;)的长度，加上一个记录字符串长度的字节。对于字符串’abcd’，&lt;em&gt;L&lt;/em&gt;是4，存储需要5个字节。&lt;/p&gt;
&lt;p&gt;对于CHAR、VARCHAR和TEXT类型，前面的表中的值&lt;em&gt;L&lt;/em&gt;和&lt;em&gt;M&lt;/em&gt;应解释为字符数目，并且列定义中的这些类型的长度表示字符数目。例如，要想保存一个TINYTEXT值需要&lt;em&gt;L&lt;/em&gt;字符+ 1个字节。&lt;/p&gt;
&lt;p&gt;要想计算用于保存具体CHAR、VARCHAR或者TEXT列值的字节数，需要考虑该列使用的字符集。在具体情况中，当使用Unicode时，必须记住所有Unicode字符使用相同的字节数。为了细分用于不同类Unicode字符使用的存储，参见&lt;a title=&quot;10.5. Unicode Support&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/charset.html#charset-unicode&quot;&gt;10.5节，“Unicode支持”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注释：&lt;/strong&gt;VARCHAR列的&lt;em&gt;有效&lt;/em&gt;最大长度为65,532字符。&lt;/p&gt;
&lt;p&gt;NDBCLUSTER引擎只支持固定宽度的列。这说明MySQL簇中的表中的VARCHAR列的行为如同类型CHAR(不同的是每个记录仍然有一个额外字节空间)。例如，在Cluster表中，声明为VARCHAR(100)的列中的&lt;em&gt;每个&lt;/em&gt;记录存储时将占用101个字节，无论实际存储的记录中的字符串的长度为多少。&lt;/p&gt;
&lt;p&gt;BLOB和TEXT类需要 1、2、3或者4个字节来记录列值的长度，取决于该类的最大可能的长度。参见&lt;a title=&quot;11.4.3. The BLOB and TEXT Types&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#blob&quot;&gt;11.4.3节，“BLOB和TEXT类型&lt;code&gt;&lt;/code&gt;”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在NDB Cluster存储引擎中，TEXT和BLOB列的实施是不同的，其中TEXT列中的每个记录由两个单独部分组成。一个是固定大小(256字节)，并且实际上保存在原表中。另一个包括超出256字节的任何数据，保存在隐含的表中。第2个表中的记录总是2,000字节长。这说明如果&lt;em&gt;size&lt;/em&gt;&amp;lt;= 256，TEXT列的大小为256(其中&lt;em&gt;size&lt;/em&gt;表示记录的大小)；否则，大小是256 +&lt;em&gt;size&lt;/em&gt;+(2000–(&lt;em&gt;size&lt;/em&gt;–256)%2000)。&lt;/p&gt;
&lt;p&gt;ENUM对象的大小由不同的枚举值的数目确定。枚举用一个字节，可以有255个可能的值。当枚举的值位于256和65,535之间时，用两个字节。参见&lt;a title=&quot;11.4.4. The ENUM Type&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#enum&quot;&gt;11.4.4节，“ENUM类型”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;SET对象的大小由不同的set成员的数量确定。如果set大小是&lt;em&gt;N&lt;/em&gt;，对象占(&lt;em&gt;N&lt;/em&gt;+7)/8个字节，四舍五入到1、2、3、4或者8个字节。SET最多可以有64个成员。参见&lt;a title=&quot;11.4.5. The SET Type&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#set&quot;&gt;11.4.5节，“SET类型”&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;choosing-types&quot;&gt;&lt;/a&gt;11.6. 选择正确的列类型&lt;/h2&gt;
&lt;p&gt;&lt;a name=&quot;id2855781&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2855792&quot;&gt;&lt;/a&gt;为了优化存储，在任何情况下均应使用最精确的类型。例如，如果列的值的范围为从1到99999，若使用整数，则MEDIUMINT UNSIGNED是好的类型。在所有可以表示该列值的类型中，该类型使用的存储最少。&lt;/p&gt;
&lt;p&gt;用精度为65位十进制数(基于10)对DECIMAL 列进行所有基本计算(+、-、*、/)。参见&lt;a title=&quot;11.1.1. Overview of Numeric Types&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-type-overview&quot;&gt;11.1.1节，“数值类型概述”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;使用双精度操作对DECIMAL值进行计算。如果准确度不是太重要或如果速度为最高优先级，DOUBLE类型即足够了。为了达到高精度，可以转换到保存在BIGINT中的定点类型。这样可以用64位整数进行所有计算，根据需要将结果转换回浮点值。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;other-vendor-column-types&quot;&gt;&lt;/a&gt;11.7. 使用来自其他数据库引擎的列类型&lt;/h2&gt;
&lt;p&gt;&lt;a name=&quot;id2855869&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2855879&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2855890&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2855900&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2855912&quot;&gt;&lt;/a&gt;为了使用由其它卖方编写的SQL执行代码，MySQL按照下表所示对列类型进行映射。通过这些映射，可以很容易地从其它数据库引擎将表定义导入到MySQL中：&lt;/p&gt;
&lt;table id=&quot;table10&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;其它卖方类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;MySQL类型&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BOOL,&lt;/td&gt;
&lt;td&gt;TINYINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;TINYINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CHAR VARYING(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;VARCHAR(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DEC&lt;/td&gt;
&lt;td&gt;DECIMAL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIXED&lt;/td&gt;
&lt;td&gt;DECIMAL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLOAT4&lt;/td&gt;
&lt;td&gt;FLOAT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLOAT8&lt;/td&gt;
&lt;td&gt;DOUBLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT1&lt;/td&gt;
&lt;td&gt;TINYINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT2&lt;/td&gt;
&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT3&lt;/td&gt;
&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT4&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT8&lt;/td&gt;
&lt;td&gt;BIGINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONG VARBINARY&lt;/td&gt;
&lt;td&gt;MEDIUMBLOB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONG VARCHAR&lt;/td&gt;
&lt;td&gt;MEDIUMTEXT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONG&lt;/td&gt;
&lt;td&gt;MEDIUMTEXT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MIDDLEINT&lt;/td&gt;
&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NUMERIC&lt;/td&gt;
&lt;td&gt;DECIMAL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在创建表时对列类型进行映射，然后原来的类型定义被丢弃。如果你使用其它卖方的类型创建一个表，然后执行DESCRIBE &lt;em&gt;tbl_name&lt;/em&gt;语句，MySQL使用等效的MySQL类型来报告表的结构。例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;CREATE TABLE t (a BOOL, b FLOAT8, c LONG, d NUMERIC);
&amp;lt;/strong&amp;gt;Query OK, 0 rows affected (0.08 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;DESCRIBE t;
&amp;lt;/strong&amp;gt;+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| a     | tinyint(1)    | YES  |     | NULL    |       
&amp;lt;span style=&quot;font-family: Monaco, Consolas, &#39;Andale Mono&#39;, &#39;DejaVu Sans Mono&#39;, monospace; font-style: normal;&quot;&amp;gt;| b     | double        | YES  |     | NULL    |       |
&amp;lt;/span&amp;gt;| c     | mediumtext    | YES  |     | NULL    |       |
| d     | decimal(10,0) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
4 rows in set (0.00 sec)&lt;/pre&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87324&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87324votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87324&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Wed, 03 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-03-87324-2984cd4fb.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-03-87324-2984cd4fb.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Tmux 入门介绍</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;有关 Tmux 的教程多达 4257 篇，这个数还是我粗略统计的。而我这篇入门教程的目的是让你从“我去，Tmux 是神马”极速地转变到“Tmux 真牛B”！&lt;/p&gt;
&lt;p&gt;那么，我们就开始吧！&lt;/p&gt;
&lt;h2&gt;为什么要用 Tmux&lt;/h2&gt;
&lt;p&gt;tmux 在很多方面都很有用。就我而言，由于 tmux 允许随时随地断开或重新接入会话（Session），所以最大的作用就是在远程服务器上持久地保存工作状态。&lt;/p&gt;
&lt;p&gt;例如，你可以在服务器上新建一个会话并命名为“nodeapi”，然后用它来挖掘 node REST API 的漏洞（这是我现在的项目）。或者假设你正在咖啡店里工作，需要编译一些代码，而编译要花费 2 个小时才能完成（如果是和我一起工作的话），这时你又不得不离开咖啡店。如果使用了 tmux，你就可以轻松地断开当前的会话，并于稍后方便时重新接入该会话，继续工作。&lt;/p&gt;
&lt;p&gt;这真是太方便了。&lt;/p&gt;
&lt;p&gt;“如何使用 tmux 才能打开多个会话，如何在会话中打开多个标签（Tab），如何在标签中打开多个窗口（Window），又如何在窗口中打开多个窗格（Pane）”，也许有些人对这些操作更感兴趣。而我很少这样做的，因为我不喜欢打开太多的——实际上是尽可能少地打开——这些东西。因此，这篇入门教程主要讲解的也是作为简单的可持久化远程会话模型的 tmux。&lt;/p&gt;
&lt;h3&gt;远程操作计算机的生活方式&lt;/h3&gt;
&lt;p&gt;机动性是 tmux 带给用户的最大价值。有很多开发者都是在服务器上进行所有工作的，他们只需从某处连接上服务器就可以开始工作了。有了 tmux（或者其他类似的工具），你就可以先坐在旧金山的某个咖啡店里开始在服务器上进行构建的工作，然后断开会话去赶飞机，待飞机降落到纽约市后再继续进行刚才的工作。&lt;/p&gt;
&lt;p&gt;tmux 带来的另一个好处是在移动办公中，作为客户端的计算机变得不再那么重要了。只需要升级你的笔记本，然后从版本库中克隆出 vim 和 tmux 的配置文件，就可以再次回到配置最优的操作环境了。而且这一切只需要短短的几分钟。&lt;/p&gt;
&lt;p&gt;总之，这些就是人们喜爱 tmux 的原因。当然即使你的生活不是四处奔波，也一样能体验到 tmux 带来的好处。&lt;/p&gt;
&lt;h4&gt;那么 screen 呢？&lt;/h4&gt;
&lt;p&gt;问得好。tmux 和 screen 很像，但比 screen 更好。要问好在哪里，简单的回答就是虽然与 screen 的功能相同，但是 tmux 设计得更好。screen 虽然可用，但是很不稳定。&lt;/p&gt;
&lt;p&gt;以下是一些 tmux 超越 screen 的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;screen 的项目大体上已经终止了，并且代码中有大量的问题&lt;/li&gt;
&lt;li&gt;tmux 是一个活跃的项目，并且其代码库经常进行更新&lt;/li&gt;
&lt;li&gt;tmux 使用的是真正的客户端/服务器模型，而 screen 只是模拟了这种模型的行为&lt;/li&gt;
&lt;li&gt;tmux 同时支持 emacs 和 vim 的快捷键&lt;/li&gt;
&lt;li&gt;tmux 支持自动重命名窗口&lt;/li&gt;
&lt;li&gt;tmux 可以高度的脚本化&lt;/li&gt;
&lt;li&gt;tmux 的窗口分割功能更加先进&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些优点已经足够了吧，开始使用 tmux 吧。&lt;/p&gt;
&lt;h2&gt;基础&lt;/h2&gt;
&lt;p&gt;首先要告诉诸位的是 tmux 中的一个全局的快捷键开关，开关开启后就可以通过快捷键完成很多任务。&lt;/p&gt;
&lt;h3&gt;tmux 的快捷键&lt;/h3&gt;
&lt;p&gt;tmux 默认使用 &lt;code&gt;Ctrl-b&lt;/code&gt; 作为激活快捷键的开关，开关开启后就可以通过快捷键迅速调用大量的功能。下面就给出一些基本功能的调用方法：&lt;/p&gt;
&lt;p&gt;首先按下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ Ctrl-b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来就可以按下一些后面将会讲解的快捷键了。不过先不要着急，可以先为能方便地使用组合键 &lt;code&gt;Ctrl-b&lt;/code&gt; 做一点准备。不妨在操作系统中将键盘上的 CAPSLOCK 键映射为 Ctrl 键，这样当需要按下这个组合键时，小拇指的移动就可以更加舒服了。&lt;/p&gt;
&lt;h3&gt;运行 tmux&lt;/h3&gt;
&lt;p&gt;好了，下面让我们从运行 tmux 开始。首先选择一台你希望在断开会话后依然可以重新接入的计算机（对我来说这通常是远程服务器），然后在上面运行如下的命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ tmux&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;很简单对吧。这样就开启了一个 tmux 的会话，你可以断开这个会话并在稍后再重新接入。&lt;/p&gt;
&lt;h3&gt;显示所有会话&lt;/h3&gt;
&lt;p&gt;由于 tmux 的理念是可以开启多个会话，并且可以自由地断开会话后重新接入，为此我们需要首先能看到可用的会话。有两种方法可以实现这个目的：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;# Via shortcut (by default Ctrl-b)
# 使用快捷键（默认为 Ctrl-b）

$ Ctrl-b s&lt;/pre&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;# Via tmux command
# 使用 tmux 的子命令

$ tmux ls&lt;/pre&gt;
&lt;p&gt;上面两种方法的效果相同，都可以得到类似下面的结果：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;0: 1 windows (created Thu Nov 28 06:12:52 2013) [80x24] (attached)&lt;/pre&gt;
&lt;h3&gt;新建会话&lt;/h3&gt;
&lt;p&gt;下面我们就来新建一个会话。可以使用 &lt;code&gt;new&lt;/code&gt; 命令新建会话，并且该命令允许以参数的形式传递一个会话名。我的建议是在新建时要提供一个会话名以便于日后管理。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ tmux new -s session-name&lt;/pre&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;# Without naming the new session (not recommended) 
# 新建会话但并不指定名字 (不推荐这样做) 

$ tmux new&lt;/pre&gt;
&lt;h3&gt;接入一个之前的会话&lt;/h3&gt;
&lt;p&gt;既然我们已经创建了多个带有名称的会话，那么就可以随时接入了，有几种方法可以实现接入会话：&lt;/p&gt;
&lt;p&gt;可以简单地输入 &lt;code&gt;tmux a&lt;/code&gt; 命令，这样可以接入第一个可用的会话：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ tmux a&lt;/pre&gt;
&lt;p&gt;或者可以通过参数指定一个想接入的会话：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ tmux a -t session-name&lt;/pre&gt;
&lt;h3&gt;从会话中断开&lt;/h3&gt;
&lt;p&gt;可以使用 &lt;code&gt;detach&lt;/code&gt; 命令断开已有的会话（因此才会有稍后重新接入会话这么一说）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ tmux detach&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以使用快捷键断开会话：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ Ctrl-b d&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;关闭会话&lt;/h3&gt;
&lt;p&gt;要关闭会话的话，可以使用如下的命令，该命令和接入会话时所使用的命令很像：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ tmux kill-session -t session-name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提示：关闭窗口时也可以使用类似的命令，只不过要把 kill-session 换成 kill-window。另外，还可以使用 tmux killall 同时关闭 tmux。&lt;/p&gt;
&lt;h2&gt;配置&lt;/h2&gt;
&lt;p&gt;与其他工具一样，一旦配置好了 tmux，使用起来就将会非常顺手。下面就给出几个通常需要配置的项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tmux 的主要快捷键&lt;/li&gt;
&lt;li&gt;屏幕下方的状态条&lt;/li&gt;
&lt;li&gt;自定义的各种快捷键&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我使用了一些相当简单的配置：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;# Set a Ctrl-b shortcut for reloading your tmux config
#设置 Ctrl-b 快捷键，用于重新加载 tmux 的配置文件&lt;/pre&gt;
&lt;p&gt;access log，error log和system log。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;bind r source-file ~/.tmux.conf

# Rename your terminals
# 重命名终端
set -g set-titles on
set -g set-titles-string &#39;#(whoami)::#h::#(curl ipecho.net/plain;echo)&#39;

# Status bar customization
# 自定义状态条
set -g status-utf8 on
set -g status-bg black
set -g status-fg white
set -g status-interval 5
set -g status-left-length 90
set -g status-right-length 60
set -g status-left &quot;#[fg=Green]#(whoami)#[fg=white]::#[fg=blue]
(hostname -s)#[fg=white]::##[fg=yellow]#(curl ipecho.net/plain;echo)&quot;

set -g status-justify left
set -g status-right &#39;#[fg=Cyan]#S #[fg=white]%a %d %b %R&#39;&lt;/pre&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;这里有一点值得注意，我使用了 ipecho.net 而不是 icanhazip 来获取计算机当前的 IP 地址（IPv4）。虽然也有很多教程在使用 icanhazip，但是凭我的经验，ipecho.net 的速度更快，更稳定。&lt;/p&gt;
&lt;p&gt;提示：如果你感兴趣，可以来&lt;a href=&quot;https://raw.github.com/danielmiessler/tmux/master/.tmux.config&quot;&gt;这里&lt;/a&gt;查看我使用的最新配置。&lt;/p&gt;
&lt;h2&gt;高级功能&lt;/h2&gt;
&lt;p&gt;我平时常用的功能就是这些了。不过，我也会使用一些 tmux 中更强大的功能。&lt;/p&gt;
&lt;h3&gt;窗口和窗格&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1fb698917561cd076c0b7ad86e73bb07.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这些高级功能之一就是 tmux 可以将一个会话分割成若干个称为窗口（Window）和窗格（Pane）的相互分离的组件。这种逻辑上的分割使用户可以轻松安排各种各样的操作。&lt;/p&gt;
&lt;p&gt;下面就来看一看这几个概念之间的关系。&lt;/p&gt;
&lt;h4&gt;层次结构&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d0c3ee25486c9efee1a6b1f043acfa7e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，一个会话（Session）可以包含多个窗口，一个窗口（Window）可以包含多个窗格（Pane）。这就是我对这些概念的简单理解。当然如果诸位有更权威或者更实用的解释，我很乐意洗耳恭听。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会话适用于分别管理大的工作内容，例如日常工作，实验或是系统管理，都可以分别在一个会话中进行。&lt;/li&gt;
&lt;li&gt;窗口适用于分别管理这些大工作中的项目。例如，在用于实验的会话中可能有一叫做 noderestapi 的窗口用于调试 node REST API，有一个叫做 lua 的窗口用于调试 lua 脚本。&lt;/li&gt;
&lt;li&gt;窗格适用于查看当前的项目。例如，在系统管理的会话中有一个叫做 logs 的窗口，在这个窗口中可以打开多个窗格分别用于查看 access log，error log和system log。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们也可以在会话中直接创建窗格，而不需要先创建一个窗口。我有时也会这样做。当阅读完“层次结构”这一小节，希望我的这种做法没有听起来那样恐怖。正如我在一开始谈到的，我更倾向于简化 tmux 的使用。&lt;/p&gt;
&lt;h4&gt;在窗格间移动光标&lt;/h4&gt;
&lt;p&gt;虽然有默认的在窗格间移动光标的方法，但是我并不清楚是什么。因为我习惯用 vim，所以我会用&lt;code&gt;h&lt;/code&gt;，&lt;code&gt;j&lt;/code&gt;，&lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;l&lt;/code&gt; 键在窗格间移动光标。为此，要加入如下的配置：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;# Remap window(pane?) navigation to vim
# 用 vim 的方式在窗格间移动光标
unbind-key j
bind-key j select-pane -D
unbind-key k
bind-key k select-pane -U
unbind-key h
bind-key h select-pane -L
unbind-key l
bind-key l select-pane -R&lt;/pre&gt;
&lt;h2&gt;&lt;strong&gt;建议&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;以下几条建议也许会有助于诸位的 tmux 之旅：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尽可能少打开会话和窗口。人类没有我们自认为的那样善于处理多任务。虽然打开 47 个窗格显得很强大，但是这并没有我们想象的那样实用。&lt;/li&gt;
&lt;li&gt;当确实要使用窗口和窗格时，花一点时间为它们起个有意义的名字。这非常有用，如果只是用 0、1、2 这样的名字，切换会话或窗口时就会非常麻烦。&lt;/li&gt;
&lt;li&gt;从基础的配置、操作开始使用 tmux，别一上来就把自己搞糊涂了。我曾遇到过很多人，他们花费了大量的时间配置 vim 或 tmux，而最终带来的结果却是不但把自己绕进去了，而且项目也没有进展。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;快捷键参考&lt;/h2&gt;
&lt;p&gt;按下 &lt;code&gt;Ctrl-b&lt;/code&gt; 后的快捷键如下：&lt;/p&gt;
&lt;h3&gt;基础&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;?&lt;/code&gt; 获取帮助信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;会话管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;s&lt;/code&gt; 列出所有会话&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;$&lt;/code&gt; 重命名当前的会话&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;d&lt;/code&gt; 断开当前的会话&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;窗口管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;c&lt;/code&gt; 创建一个新窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;,&lt;/code&gt; 重命名当前窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;w&lt;/code&gt; 列出所有窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;%&lt;/code&gt; 水平分割窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;&quot;&lt;/code&gt; 竖直分割窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;n&lt;/code&gt; 选择下一个窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;p&lt;/code&gt; 选择上一个窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;0~9&lt;/code&gt; 选择0~9对应的窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;窗格管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;%&lt;/code&gt; 创建一个水平窗格&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;&quot;&lt;/code&gt; 创建一个竖直窗格&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;h&lt;/code&gt; 将光标移入左侧的窗格*&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;j&lt;/code&gt; 将光标移入下方的窗格*&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;l&lt;/code&gt; 将光标移入右侧的窗格*&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;k&lt;/code&gt; 将光标移入上方的窗格*&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;q&lt;/code&gt; 显示窗格的编号&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;o&lt;/code&gt; 在窗格间切换&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;}&lt;/code&gt; 与下一个窗格交换位置&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;{&lt;/code&gt; 与上一个窗格交换位置&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;!&lt;/code&gt; 在新窗口中显示当前窗格&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;x&lt;/code&gt; 关闭当前窗格&amp;gt; 要使用带“*”的快捷键需要提前配置，配置方法可以参考上文的“在窗格间移动光标”一节。——译者注&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;t&lt;/code&gt; 在当前窗格显示时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;希望这篇文章有助于你理解 tmux。&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;h2&gt;参考资源&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;The man page.&lt;/li&gt;
&lt;li&gt;A thousand other great tutorials.&lt;/li&gt;
&lt;li&gt;man 手册&lt;/li&gt;
&lt;li&gt;大量精彩教程&lt;/li&gt;
&lt;/ol&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87278&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87278votetotal&quot;&gt;3&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87278&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者：&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/jackalhu&quot;&gt;JackalHu&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/jackalhu&quot;&gt;
			&lt;img src=&quot;/images/jobbole.com/ca44b272678408d3e2650ac448de62da.jpg&quot;&gt;
		&lt;/a&gt;
	&lt;/div&gt;

    &lt;div class=&quot;author-bio-info&quot;&gt;

        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            热爱编程，关注设计模式，致力于提升软件开发的质量。新浪微博：@Jackal-Hu        &lt;/span&gt;
        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            &lt;a href=&quot;http://www.jobbole.com/members/jackalhu&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 个人主页&lt;/a&gt; ·
            &lt;a href=&quot;http://blog.jobbole.com/author/jackalhu/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;/i&gt; 我的文章&lt;/a&gt; ·
            &lt;a title=&quot;声望值&quot; target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/jackalhu/reputation/&quot;&gt;&lt;i class=&quot;fa fa-graduation-cap&quot;&gt;&lt;/i&gt; 12&lt;/a&gt;        &lt;/span&gt;
    &lt;/div&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Wed, 03 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-03-87278-b045c7e69.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-03-87278-b045c7e69.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（3） ： 查看字段长度</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看字段的长度&lt;/p&gt;
&lt;p&gt;SQLSERVER&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE [sss]
GO
SELECT LEN([NAME]) FROM [dbo].[aa]&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/da5a96602d04f656783bf0334f084e96.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;MYSQL&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE tmp13(vb VARBINARY(10))

INSERT INTO tmp13 (vb) VALUES(12)

SELECT LENGTH(vb) FROM tmp13

INSERT INTO tmp13 (vb) VALUES(1212)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3ee043584e99c291376d93edfa699b40.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87322&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87322votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87322&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Tue, 02 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-02-87322-7895b7eca.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-02-87322-7895b7eca.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
  </channel>
</rss>
