<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IT技术干货</title>
    <description>[IT技术干货iftti.com] @KernelHacks</description>
    <link>http://iftti.com/</link>
    <atom:link href="http://iftti.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 15 Nov 2014 18:11:38 +0800</pubDate>
    <lastBuildDate>Sat, 15 Nov 2014 18:11:38 +0800</lastBuildDate>
    <generator>Jekyll v2.2.0</generator>
    
      <item>
        <title>你所不知道的SQL Server数据库启动过程，以及启动不起来的各种问题的分析及解决技巧</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;目前SQL Server数据库作为微软一款优秀的RDBMS，其本身启动的时候是很少出问题的，我们在平时用的时候，很少关注起启动过程，或者很少了解其底层运行过程，大部分的过程只关注其内部的表、存储过程、视图、函数等一系列应用方式，而当有一天它运行的正常的时候突然启动不起来了，这时候就束手无策了，能做的或许只能是重装、配置、还原等，但这一个过程其实是一个非常耗时的过程，尤其当我们面对是庞大的生产库的时候，可能在这火烧眉毛的时刻，是不允许你再重搭建一套环境的。&lt;/p&gt;
&lt;p&gt;所以作为一个合格的数据库使用者，我们要了解其启动、运行过程的事情，一旦发生问题，我们也能及时定位，迅速解决。&lt;/p&gt;
&lt;p&gt;闲言少叙，我们进入本篇的正题。&lt;/p&gt;
&lt;p&gt;SQL Server本身就是一个Windows服务，每一个实例对应的就是一个sqlserver.exe进程。这是一个可执行的文件，默认就放在SQL Server的安装目录下，当我们启动的时候，就是直接调用这个文件，然后启动这个服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一部分、SQL Server实例启动的方法和启动所发生的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL Server实例分为下面几种启动方法：&lt;/p&gt;
&lt;p&gt;（1）在Windows服务控制台里手动启动，或者自动启动（默认），这个也是最常用的方式&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2a913c82754e496d4d60108db6615b24.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（2）第二种方式是SQL Server本身自己提供的启动方式，我们这里可以手动启动&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/66c1f8c879d4a1b8381ae83f919147cb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（3）在SQL Server的SSMS里面手动启动它，这个方式一般大部分利用这种方式进行手动重启&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/706615873a74953fd6c73620a498326c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（4）通过Windows命令窗口，用’net start’命令手动启动，这种方法也可以用&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4815091d96a7fa90deaa87c42d59ab50.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上这几种方式都可以启动SQL Sever,并且都会在SQL 日志信息中有所记录。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二部分、SQL Server实例启动的详细过程以及所发生的问题项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步、检查注册表项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个sqlserver.exe文件开始启动的时候，首先要干的第一件事就是先检查它的配置信息存放于注册表的值项&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/47026dafb41f2c2ce8a55fa32857f6e5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;比较重要的几个键值有下面几个：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/47026dafb41f2c2ce8a55fa32857f6e5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里的&lt;/p&gt;
&lt;p&gt;AuditLevel:其实就是SQL 如何记录用户登录记录；&lt;/p&gt;
&lt;p&gt;LoginMode:是SQL Server服务器身份验证方式等；&lt;/p&gt;
&lt;p&gt;BackupDirectory:默认的备份路径等信息；&lt;/p&gt;
&lt;p&gt;关于注册表信息简要了解即可，不建议做任何修改，当然这些值的信息默认在SQL Server中都能设置：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5e395a4160c16b7a5c76185cddd7dc0c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在不修改注册表的情况下，一般这一步的启动顺序一般不会出现问题，当然出现问题了也通常没有办法解决，大部分的解决方式只有重装了。&lt;/p&gt;
&lt;p&gt;但这一步骤，通常出现以下两个个问题通常是可以解决的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;1&amp;gt;启动账号权限问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们启动SQL Server的进程使用的账号连读注册表的权限都没有，那这个服务是怎么也启动不了的，通常这时候连SQL 的错误日志都没有能力生成出来。&lt;/p&gt;
&lt;p&gt;这时候我们该如何发现呢，虽然这时候它没有能力创建SQL 的错误日志，但是它在Windows层面留下了痕迹，我们来看：&lt;/p&gt;
&lt;p&gt;我将服务启动账号设置成gust来宾账号，来启动该服务&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a8373e1e88833f20a802c0d5af11ce8e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这时候会产生以下错误信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bb18f9c8613a2c1ca5733966723ee04e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Windows的日志信息里也会产生一条错误日志记录：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8c73ebaeaa00f44f4fe6b0e194f3a306.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里的拒绝访问指的就是拒绝访问注册表信息了。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;此问题的解决方式就很简单了，只需要将当然的用户提权到SQL Server服务的启动账号就行了，提权的方式也很简单，只需要添加到SQL的本地用户的启动服务组就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b41e77876b9e8f922b11cf8e38e40a12.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，也可以直接换一个更高级别的用户登录。一般默认都用的超级管理员账户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;2&amp;gt;访问日志和文件夹出现问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认在SQL Server启动的时候会创建一个启动日志文件，记录所有正确的日志信息，当然也包括错误的日志信息，如果这时候找不到这个日志信息的路径，或者已经存在一个日志，但是日志被锁定了（某些NB的杀毒软件擅长干这个），这时候这个服务也是启动不了的，同样也创建不出SQL Server的日志文件，这时候我们还得借助于Windows平台本身，来解决。&lt;/p&gt;
&lt;p&gt;SQL Server启动的创建的日志文件路径，同样存在于注册表项里，我们来看这个参数：&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a4c7557c3827ec14cf83541e66601c8d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里我们故意改成一个错误的路径，来启动下看看：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/958b20c38b06c00084c76fcdf49c850e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;会产生以下错误&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/47a19d9c4c0290d0b0a1702c5e90ae72.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;系统的错误日志信息&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/10d1c4120c0f763aab797cae69f67aac.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;错误说明的很清楚。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;这个问题解决起来也很简单，只需要检查好该路径，确保路径下的文件正确就可以。&lt;/p&gt;
&lt;p&gt;不过有一点需要注意，当SQL Server还没启动起来的时候，有部分错误信息日志需要检查Windows平台下的系统日志。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步、检查系统配置环境，包括硬盘、内存与CPU等&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们进行完第一步的时候，SQL Server已经读取完注册表信息，完成了它的errorlog文件的创建，然后开始进行第二步的进行，这一步骤所有的信息就会按照顺序依次记录到errorlog文件中，我们可以通过查看该文件来详细跟踪这一步骤的进行，根据上一步的注册表信息，我们先来手动清空下这个日志，然后重启一下SQL Server服务，查看下这个日志记录&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/31207d287167c9bc39f9a02b677abd1b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们简单大致分了以下几大步骤：&lt;/p&gt;
&lt;p&gt;一、首先检查系统的软件环境，包括OS版本、电脑信号、内存、硬盘、注册表基础配置项是否正确等&lt;/p&gt;
&lt;p&gt;二、启动系统数据库master&lt;/p&gt;
&lt;p&gt;三、开始利用服务用户登录系统、启动系统资源数据库、检查数据库版本信息等&lt;/p&gt;
&lt;p&gt;四、启动系统数据库model&lt;/p&gt;
&lt;p&gt;五、开始网络配置进行连接，对外提供服务，使用的默认的1433端口&lt;/p&gt;
&lt;p&gt;我们接着分析下面的日志：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bc3f1e9eaa4b23059059da0cae17ff5d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;六、其实完成上面的第五步之后，也就开始启动msdb系统数据库&lt;/p&gt;
&lt;p&gt;七、这时候开始真正的启动用户数据库，并且完整各个库的完整性校验，并且在启动用户数据库之前，先将系统库的tempdb进行清空&lt;/p&gt;
&lt;p&gt;八、在搭建完成之后，才开始启系统的另外一个数据库tempdb&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;上面的整个SQL  Server系统启动的过程产生了详细的日志记录，我们下面会依次按照该步骤进行详细的进行逐步分析。&lt;/p&gt;
&lt;p&gt;在检查系统软硬件环境的过程中，基本不会发生什么致命错误。比较常见的问题就是内存配置问题，其实在上面的日志记录中有一句特别重要，它反映的就是SQL Server利用内存的情况，我们来看：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/97928b0549a477473728be10791f8ceb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这句话的意思是将所有的数据页锁定到内存中，作为大部分数据库而言，内存就是生命线，SQL Server同样也是，如果系统（64bit中）没有内存压力的情况下，才能将数据页正常的锁定到内存中，如果内存压力过大，系统内存是不允许将数据页也加入到内存中，而这样导致的问题就是SQL  Server严重的性能问题。&lt;/p&gt;
&lt;p&gt;很多用户希望限制SQL Server内存使用，并且有些客户机将它限制到服务都不能启动的情况，这时候在SQL Server的日志中是这样展现的，我们来看：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/db4aea2cb5327f13068ba68e948deb55.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f51d4a3cfd296f9ddebe6b29cfd1f72d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，该错误的原因还是挺清楚的，修复该错误的解决方法也很简单，将内存配置调大就可以。&lt;/p&gt;
&lt;p&gt;跟内存有关的还有一种特殊的情况，就是SQL Server的启动账号在服务器上没有Lock page in memory的权限，如果没有这个权限，在明细日志中查看不到上面的日志记录，该问题的解决方法也很简单，只需要将需要权限加上就可，加权限的方式如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/353feb244f338a0287ffe7e0ac552fe0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过上面的步骤基本，完成数据的软硬件检测过程。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步、启动系统数据库master&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;master数据库是SQL Server系统启动过程中的第一个系统库，是非常关键的数据库。如果这个库不能被正常打开，则SQL Server就不能正常启动。&lt;/p&gt;
&lt;p&gt;和其它数据库一样，master数据库也分为数据文件和日志文件，启动的过程是依次打开，然后做恢复动作，如果这个过程没问题的话，在Errorlog日志文件中，我们会看到如下的这句话：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/33f1567229d2b31ae94742249a0d6653.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果这个过程出现了任何问题，SQL Server的启动过程都会被中断，启动过程失败。&lt;/p&gt;
&lt;p&gt;而这个过程发生的错误，无非就集中以下几种情况，我们来分析一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;1&amp;gt;在指定的路径找不到master数据的数据文件或日志文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于这个SQL Server的最主要的系统数据库的路径，它是以注册表形式存在的，在一下注册表项，可以看到&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dceb010409fb998a256e14b41c9cdbbf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果在该路径下找不到这个系统数据库的话，服务是启动不了的，并且会产生相应的错误日志信息，我们来模拟下，关掉服务，将这两个文件移除走，然后启动看一下：&lt;/p&gt;
&lt;p&gt;首先，该服务是启动失败的&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4b24e6d47b95ba2c122587da8d4201d2.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们来看一下系统日志&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/479dd53e645351c4dd6307e5f3e443a5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;看Errorlog的日志信息&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/eae780fc1e0193875674ac83b0a9f715.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，该问题提示错误信息还是挺详细的。我们来看第二种情况&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;2&amp;gt;文件找到了，但是没有权限访问，或者不能以排他的方式打开该文件（默认的是独占锁进行文件打开的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此种情况也是有可能产生的，比如某些NB的杀毒软件就可以干这个事，让你的系统库无法访问，这样同样也是启动不了的，我们这样来看，提示的错误的信息有哪些：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4fbff887b497ec1843fc7124b793e2b9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;来看Errorlog的错误记录：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fbb5fb347d971a9b98b0a1939c0861bc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;3&amp;gt;文件找到了，访问权限也有，但是文件有问题，就是说是数据库损坏了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个问题也经常出现，比如磁盘坏掉了，恢复后发现文件有问题，不能正常打开，这种问题我们来看错误信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/555097275517ed6ebe211b2d998a57a6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;日志中的信息&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/61fc6d366c9c0c4754fcfdcbd28af2c7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于master系统库的启动过程，基本就是上面的三种错误，关于这三种问题，我们该如何解决呢？&lt;/p&gt;
&lt;p&gt;解决方法：首先如果根据错误日志定位出问题的性质，如果是前两种问题其实是挺好解决的，比如文件没找到、权限项不对等，这些问题相应的去解决就可以，最棘手的就是第三种情况，出现这种情况最理想的情况是master数据库进行了备份，通过备份文件进行恢复就可以，一切就可以正常，当然通过暴力的停掉服务，拷贝文件进去也可以解决。&lt;/p&gt;
&lt;p&gt;最揪心的就是这个库就没备份，那该如何解决呢？这种方式的解决就得借助SQL Server的安装程序，进行重建master数据了，但是这种方式重建的master数据库会导致以前的SQL Server的设定全部清空掉。&lt;/p&gt;
&lt;p&gt;清空的信息包括：所有的账户信息（意味着需要重建）、msdb中的所有job信息等（也需要重建）、用户数据库信息（必须全部重新附加attch上）&lt;/p&gt;
&lt;p&gt;而这一系列过程如果是一个生产库，可能会是一个非常大的工作量！&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步、启动系统资源数据库，并检查数据版本信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;资源数据库是SQL Server2005中引入的逻辑数据库，在实例下是看不到的，但是有它的物理文件，主数据库默认名称为：mssqlsystemresource.mdf、日志名称为：mssqlsystemresource.ldf&lt;/p&gt;
&lt;p&gt;如果该数据库启动的过程中也出现了问题，那SQL Server也不能正常启动。&lt;/p&gt;
&lt;p&gt;这个系统数据库比较特别，它是一个只读数据库，完全由SQL Server自己维护，用户是不能更改的，所以我们只要保证它的是数据库文件和日志完好就可以，不需要对它进行任何的跟踪和维护。&lt;/p&gt;
&lt;p&gt;当然如果非要看这个数据库，可以通过单用户的DAC方式进行连接。&lt;/p&gt;
&lt;p&gt;所以这个数据库在一般情况下不会发生意外，基本上是能正常启动，不过特殊情况下，不能启动的情况就以下两种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;1&amp;gt;数据库文件不存在，无法访问，或者文件坏掉了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实它的报的错误信息，类似于上面的master数据库，我来截个图，看一下：&lt;/p&gt;
&lt;p&gt;这个是errorlog记录的错误信息&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a24ab8238466f37448ec40f3dea558c8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在windows层面也有它自己的错误日志信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/685e88d963c58b0dc0f93c24f41e55cf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;2&amp;gt;资源数据库的版本和SQL Server的版本不一致&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个有可能是人为的更改了这个资源数据库，导致现有的资源数据库文件和数据库版本不一致，这样的话也会导致错误的形成&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3a86b86849d143bcd0e902930388437e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;windwos平台也记录下了该错误的信息，看下面的图片：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c27f7c5041523639cacef687537f74b1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;关于资源库的这两个问题解决方法，非常的简单。只要找到和这台服务器上的SQL Server的版本一致的数据库，拷贝过来就行。&lt;/p&gt;
&lt;p&gt;当然最好的预防措施是：每当安装完SQL Server或者打完补丁之后，就及时的备份这个两个文件，放在安全的地方，用的时候拷贝过来就行，备份是数据库管理员的天职&lt;/p&gt;
&lt;p&gt;当然有时候在紧急的情况下，找不到相同版本的数据库，理论上这个库是只读的，所以不会发生任何改变，我们随便找一台机器，安装一下同版本数据库，然后拷贝过来就行，当然一定注意的是这里面是相同版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五步、启动系统数据库model&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;model系统数据库同样也是SQL Server启动过程中用到的一个非常关键的数据库，如果这个库损坏，SQL Server启动也会失败，关于model数据不能启动的原因基本和master的类似，同样也是两种：1、数据库文件早不到或者不能访问；2、数据库文件能访问但是是损坏的文件。&lt;/p&gt;
&lt;p&gt;诊断此种问题的方式也和上面的两种方式一样，查看启动过程产生的errorlog文件或者windows系统日志，这里我们就不重现该问题了。&lt;/p&gt;
&lt;p&gt;我们只给出此种问题的解决方法：&lt;/p&gt;
&lt;p&gt;1、如果该库我们已经做过备份，那最直接也是最有效的解决方式就是直接还原，这里的还原方式可能和普通库的还原方式不一样，因为SQL  Server实例还没有启动，我们恢复过程采取以下过程：&lt;/p&gt;
&lt;p&gt;a.用参数启动SQL Server，在命令提示行中执行以下命令，这样的话SQL Server启动就会跳过model数据库恢复这一步&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;net start MSSQLSERVER /f /m /T3608&lt;/pre&gt;
&lt;p&gt;b.现在恢复model数据库，打开SSMS，直接输入&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;RESTORE DATABASE model FROM DISK =&#39;G:\data\model.bak&#39;
WITH 
MOVE &#39;modeldev&#39; TO &#39;E:\dataDefaultFileManger\MSSQL10.MSSQLSERVER\MSSQL\DATA\model.mdf&#39;
MOVE &#39;modellog&#39; TO &#39;E:\dataDefaultFileManger\MSSQL10.MSSQLSERVER\MSSQL\DATA\model.ldf&#39;
,replace&lt;/pre&gt;
&lt;p&gt;c.恢复成功后，直接重启SQL Server既可以。&lt;/p&gt;
&lt;p&gt;2、将SQL Server关闭，然后直接采取暴力的方式将model数据文件拷贝回来就可以，这种方式简单有效，但是非常规操作&lt;/p&gt;
&lt;p&gt;3、还有一种方式是利用setup安装文件，重建该数据库，过程缓慢，稍显复杂，很不推荐。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第六步、开始网络配置进行连接，对外提供服务，使用的默认的1433端口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当上面的几个重要的系统库都已经启动完成之后，下一步就是开始检查网络环境，进行网络服务的配置，对外进行提供服务了，一般来讲，在SQL Server中利用的网络启动协议有三种：Shared Memory、Named Pope和TCP/IP，其实在日常我们最常用的就是TCP/IP这种方式了，并且默认开启的是1433端口。&lt;/p&gt;
&lt;p&gt;我们来看一下正常启动过程中，该部分的详细日志：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/22f4f88d3f2983e012d34478d2256401.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里面的Shared Memory是专供本地连接通过LPC(Local Procedure Call)技术向SQL Server做的连接。它不走网络层，所以他是速度最快的连接方式。正常启动后会显示上面的正常日志。&lt;/p&gt;
&lt;p&gt;Named Pipe方式正常启动，也会显示出上面的日志。可以看到。&lt;/p&gt;
&lt;p&gt;这其中我们最常用的TCP/IP这种方式，也正常的启动了，并且指定了两种访问方式，ipv4/ipv6，然后后面加上了1433端口号。&lt;/p&gt;
&lt;p&gt;在这个过程中最常出现的问题就是，1433端口被其它程序占用，这样就导致TCP/IP协议无法正常启动，这样我们会看到如下日志信息&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f5032d5079231cfbf56ef333d3240b42.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;并且在windows 系统日志中也会有记录&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/13a6bbbb7d036d55211f3598b79e49d5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;其实这里出现的问题还是挺好解决的，只需要找到占用这个端口的应用程序，采取措施让它把这个端口给让出来就可以。&lt;/p&gt;
&lt;p&gt;当然出现这些问题就意味着客户端已经无法通过TCP/IP这种远程连接的方式进行连接访问了。&lt;/p&gt;
&lt;p&gt;这时候一般管理员可以采用SQL Server给其提供的“专用管理员连接”（DAC）进行连接，这种方式我们以后再介绍。&lt;/p&gt;
&lt;p&gt;当然，在SQL Server启动的过程中，一般出现这种网络问题，或者协议不能成功加载，SQL Server会报出错误信息，但是一般情况下是不会影响SQL Server的正常启动的。受影响的可能只是出问题的那种协议功能。&lt;/p&gt;
&lt;p&gt;我们只需要根据日志，定位问题，然后解决掉，重新启动就可以了。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第七步、开始启动msdb系统数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于msdb这个系统数据库，它是被安排在系统库中接近最后一个了，除了用户数据库和临时库tempdb之外，当启动过程中已经进行到这一步的时候，其实我们的实例就已经启动起来了，并且能够连接。&lt;/p&gt;
&lt;p&gt;我们知道msdb这个库中主要的存储的信息是应用各个库的备份信息，各种job的历史跑批信息等，其实诸多的都是来自于用户数据库所产生的一些客观数据。&lt;/p&gt;
&lt;p&gt;我们来看一下这个库出现了问题会产生什么现象：&lt;/p&gt;
&lt;p&gt;我将这个库文件移除走，然后重新启动服务，启动过程中没有报任何错误，并且能够顺利启动，我们用SSMS直接连接过去，也可以正常连接&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/51ac8877c9b57e33c15e65db26c0969c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是当我们点击开数据的时候，其实是看不到任何用户数据库的，并且会产生一个错误提示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c22fd1e14d9897ec00965fd7f95bef58.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;看来是不能使用的，我们来查看一下错误日志：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3f06ae27ab116f0706d7af2ec6433a21.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;虽然这个库的重要性比起master之类的库重要性要稍显差一些，但是缺少了它我们的SQL Server虽然能启动，但是依然不能使用。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;要解决这个问题其实方式就很多种了，因为到此我们的SQL Server实例已经能够正常启动了，我们可以采取：&lt;/p&gt;
&lt;p&gt;1、利用备份还原该库，参考文章前面的方式（推荐）&lt;/p&gt;
&lt;p&gt;2、关掉服务，利用暴力的拷贝文件的方式进行恢复，简单有效，非常规操作&lt;/p&gt;
&lt;p&gt;3、找台相同的环境，找到相同的文件，直接拷贝过来使用&lt;/p&gt;
&lt;p&gt;4、利用安装文件进行恢复（不推荐）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第八步、启动用户数据库，并且完整各个库的完整性校验，并且在启动用户数据库之前，先将系统库的tempdb进行清空&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本步骤所遇到的问题层出不穷，各种样式，我打算再重新组织一篇文章，专门列举，此篇就不介绍了。&lt;/p&gt;
&lt;p&gt;但有一点需要记住：在这一步之前SQL Server会将tempdb这个系统库清空掉，也就是说，每次的重启操作，系统都会将tempdb清空，然后重建，这一步一般不会发生异常，成功之后会出现以下日志信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/93caedbde47e21908c22cc1ac614eb22.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第九步、开始重建系统的另外一个数据库tempdb&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tempdb这个库比较特殊，每次重启的时候都是重新创建的，SQL Server会根据master数据库里的记录的信息以model数据库为版本进行创建。所以只要我们保证model数据库没有问题，然后硬盘没有问题，tempdb的数据库文件就应该没有问题。&lt;/p&gt;
&lt;p&gt;关于temdb这个库的所有配置信息是存储于master的数据库中的，里面的内容信息是存储于model系统库中的&lt;/p&gt;
&lt;p&gt;这样就带来了一个问题，有时候我们的master的库是从别的机器下面备份下来的，所以它里面会记录这个tempdb这个库在原来机器上的路径，这样在启动创建的时候就会报错。&lt;/p&gt;
&lt;p&gt;所以我们需要执行以下命令更改这个库路径&lt;/p&gt;
&lt;p&gt;a、用参数启动SQL Server&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;net start MSSQLSERVER /f  /m  /T3608&lt;/pre&gt;
&lt;p&gt;b.修改数据文件和日志文件路径&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;ALTER DATABASE tempdb MODIFY FILE(NAME=tempdev,FILENAME=&#39;C:\right path....\temdb.mdf&#39;);
go
ALTER DATABASE tempdb MODIFY FILE(NAME=tempdev,FILENAME=&#39;C:\right path....\temdblog.ldf&#39;);
go&lt;/pre&gt;
&lt;p&gt;c.正常启动数据库既可以&lt;/p&gt;
&lt;p&gt;还有一种情况，就是创建该文件的时候，提供的硬盘空间不足，或者权限不够，我们也是根据上面的方式，修改到一个正确的路径，并且确保权限正确。&lt;/p&gt;
&lt;p&gt;也可以更改temp文件的大小，默认是4M，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;ALTER DATABASE tempdb MODIFY FILE(NAME=tempdev,SIZE=100MB);
go
ALTER DATABASE tempdb MODIFY FILE(NAME=tempdev,SIZE=100MB);
go&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;至此，如果上面的整个过程都没出问题的话，一个正常的SQL Server就可以启动成功的。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本篇文章到此结束了…..此篇耗时三天…..为了尽可能的呈现出所有的问题现象，我对本地的SQL Server进行了多种无情的蹂躏、各种的摧残，力求能够重显各种不同的应用场景问题现象，然后尽可能的找到合适的解决方案，当然还有很多的情况没有展现出来，后续遇到，会一一补充进来，当然有遇到不能解决的，也可以留言，我们一起分析解决。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Wed, 12 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-12-79624-3d48ea0c5.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-12-79624-3d48ea0c5.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>你不知道的 字符集和编码（编码字符集与字符集编码）</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;我的上篇文章，有朋友提出字符集和编码的区别，我在此立文和大家讨论下&lt;/p&gt;
&lt;p&gt;常说的字符集和编码区别，其实就是编码字符集和字符集编码的区别，其实，单单如果只是说字符集，没有任何编码的概念的话，那么字符集其实仅仅是一个简单的字符的集合，或者说是一个抽象的字符的集合，包括文字，符号等等，不参与任何存储形式，只是存在这么各种各样标准的字符的集合&lt;/p&gt;
&lt;p&gt;如果仅仅是抽象的字符集，我们是无需拿出讨论的，因为没有任何异议，通俗易懂，而常说的字符集指的编码字符集，比如常见的 unicode、ascii、gb2312、gbk等，这些我们常称做为字符集（其实是编码字符集），这些字符集，比如unicode其实本质上是已经“编码”过的字符集，即每个字符都有唯一的整数编号，每个字符都有自己特有的编号，同一个字符在不同编码字符集中编号也会不同，当然很多编码字符集都是ascll的超集，所以ascll字符集的编号与很多编码字符集中编号都一样，比如英文字母“A”，在ASCII及Unicode及GB2312中，均是第0×41个字符，说到这里朋友一定注意到了我上面再描述“ unicode其实本质上是已经“编码”过的字符集”中的“编码”二字加了双引号，我要强调的是这里的“编码”并不是真的我下面要说的编码，这里只是为每个字符编了一个对应的编号，但是我们还是习惯专业的称呼为“编码字符集”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们经常说“文章采用的是utf-8编码方式”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我对于这个编码方式的意义，个人理解是 &lt;strong&gt;将一个字符的整数编号用一个什么二进制的整数值来对应并在计算机存储。&lt;/strong&gt;这和上面说的编码字符集中的“编码”千差万别，这里我们称之为“字符集编码”，即我们常说的编码&lt;/p&gt;
&lt;p&gt;说到这里，很多人会觉得那么unicode和utf-8的区别在哪里？既然上文说到unicode是编码字符集，那么utf-8又是什么？就是常说的编码？&lt;/p&gt;
&lt;p&gt;“文章采用的是utf-8编码方式”，个人觉得准确的说法是“文章采用的是基于unicode编码字符集的utf-8的编码方案”，即&lt;/p&gt;
&lt;p&gt;即unicode本身作为编码字符集没有任何存储形式，只是一个编号和字符对应的表而已，如何在计算机存储？你可能想到了干脆直接把编号当作二进制数值来直接存储，那么为什么不这么做呢？这也算是一种字符集编码方案，就是基于unicode编码字符集的utf-32编码方案，那么有没有更加智能一点的编码方案呢？为什么会没有呢？那就是utf-8、utf-16等等，    等等，在我解释为何要用utf-8编码方案的时候，我必须说明一件事情：如下&lt;/p&gt;
&lt;p&gt;我在上一篇文章《&lt;a id=&quot;cb_post_title_url&quot; title=&quot;你不知道的 页面编码，浏览器选择编码，get，post各种乱码由来 &quot; href=&quot;http://blog.jobbole.com/79424/&quot; target=&quot;_blank&quot;&gt;你不知道的 页面编码，浏览器选择编码，get，post各种乱码由来&lt;/a&gt;》中说过：“如何查看中文字符的十六进制字符串？方法：BitConverter.ToString(System.Text.Encoding.UTF8.GetBytes(“阿道夫”));” 请注意我可以改为“System.Text.Encoding.Unicode.GetBytes” 如下图是vs2013 Encoding键入“.”后的智能提示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/07b7c02479df4ca8264431ae92fbabf21.png&quot; rel=&quot;lightbox[79610]&quot; title=&quot;你不知道的 字符集和编码（编码字符集与字符集编码）&quot;&gt;&lt;img class=&quot;size-full wp-image-79612 aligncenter&quot; alt=&quot;112227067411272&quot; src=&quot;/images/jobbole.com/41e0858c1d1915886f851f7e412df9d1.jpg&quot;&gt;&lt;/a&gt;&lt;img class=&quot;aligncenter size-full wp-image-79613&quot; alt=&quot;112226562562235&quot; src=&quot;/images/jobbole.com/b38326e5eb16637324f3425657aa90c3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（列表过长，用两幅图分别截图）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上图有两个疑问：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、如果说unicode是编码字符集，为何会出现在和utf-8这种编码方案并列的列表中？&lt;/p&gt;
&lt;p&gt;2、ASCII或者gb2312都是编码字符集为何也会出现在和utf-8这种编码方案并列的列表中？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们假设有两个猜测：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、此处的unicode并不是真正的unicode编码字符集，可能只是一种和unicode编码字符集关系非常紧密的一种编码方案&lt;/p&gt;
&lt;p&gt;2、ASCII或者gb2312（其实就是图中的Default,即操作系统当前的编码，国内一般为gb2312）是编码字符集没有错，但是对于ASCII或者gb2312都只有唯一一种编码，那么我称呼它们为ASCII编码或者GB2312编码也没有问题，既然这样，那我把ascii和gb2312加入和utf-8这种编码方案并列的列表中也理所当然？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的两个假设，很快得到论证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、在Encoding 的元数据看到：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;//
        // 摘要:
        //     获取使用 Little-Endian 字节顺序的 UTF-16 格式的编码。
        //
        // 返回结果:
        //     使用 Little-Endian 字节顺序的 UTF-16 格式的编码。
        public static Encoding Unicode { get; }&lt;/pre&gt;
&lt;p&gt;这里解释在这里的unicode其实本质上“获取使用 Little-Endian 字节顺序的 UTF-16 格式的编码”，即使基于unicode编码字符集的utf-16编码方案，类似的有BigEndianUnicode（获取使用 Big Endian 字节顺序的 UTF-16 格式的编码）&lt;br&gt;
2、一般的ASCII或者gb2312，我们可以称呼为ASCII字符集也可以称呼为ASCII编码，只是意义不同而已，因为对于ASCII编码字符集或者gb2312编码字符集都只有唯一一种编码，就是ASCII编码和GB2312编码，那么列表中显示的ASCII和GB2312指的不是编码字符集而是ASCII和GB2312的编码方案，我想正是这种原因，才在很多时候，不管是字符集赋值还是编码方案赋值都可以直接用gb2312或者ascii，比如：&lt;br&gt;
Encoding gb2312 = Encoding.GetEncoding(“gb2312″);&lt;br&gt;
Response.ContentEncoding = gb2312;//编码&lt;br&gt;
Response.Charset=”gb2312″;//字符集&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结下的说：&lt;/strong&gt;&lt;br&gt;
就是unicode是字符集，不是编码！但是ascii（gb2312）是字符集，这个说法肯定正确，但是我表达为“ascii编码”也不能说大错特错，但是这种说法让人误解，如果一定要说那么就说“ascii编码字符集的编码”&lt;/p&gt;
&lt;p&gt;如果理解上面两个假设的论证道理，那么我们继续讨论之前暂停的话题，即“解释为何要用utf-8等编码方案（其他utf编码方案类似）”&lt;br&gt;
utf-8将很大一部分基于unicode编码字符集的字符的整数编号作了变换后存储在计算机中。（引用）以“汉”字为例，“汉”的Unicode值为0x6C49，但其编码为UTF-8格式后的值为0xE6B189（注意到变成了三个字节）。对于UTF-16编码方案，则是对unicode编码字符集中的前65536个字符编号都不做变换，直接作为计算机存储时使用的值（对65536以后的字符，仍然要做变换），例如“汉”字的Unicode编号为0x6C49，那么经过UTF-16编码后存储在计算机上时，它的表示仍为0x6C49，对于UTF-32编码方案，他对所有的Unicode字符均不做变换，直接使用编号存储，只是这种编码方案太浪费存储空间（就连1个字节就可以搞定的英文字符，它都必须使用4个字节）&lt;/p&gt;
&lt;p&gt;既然unicode编码字符集有如此多的编码方案，那么&lt;br&gt;
utf-8，字母数字符号等占1字节，汉字占三字节&lt;br&gt;
utf-16,对unicode编码字符集中的前65536个字符都占两个字节&lt;br&gt;
utf-32，全部占四字节&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果还有人问：&lt;/strong&gt;&lt;br&gt;
“unicode编码每个字符占几个字节”，我们可以理直气壮的说，第一unicode不是编码！第二每个字符具体占多少字节是要看编码方案！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很多面试题会问：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;string param = &quot;abc阿道夫&quot;;
int length1 = System.Text.Encoding.Unicode.GetBytes(param).Length;//别忘了这里的unicode本质是utf-16编码方案
int length2 = param.Length;&lt;/pre&gt;
&lt;p&gt;那么答案就是12和6了&lt;/p&gt;
&lt;p&gt;最后，对于gb2312或者ascii编码字符集的字符的编号就是直接存储在计算机中的二进制数，也就是说gb2312和ascii编码字符集都只有一种编码方案，因为在gb2312编码字符集中的ascii字符集部分的编号并没有变化（即和ascii编码字符集中的编码一致），所以gb2312的ascii部分字符存入计算机的二进制数还是占用1个字节，而中文字符存入计算机的二进制数也是该中文字符在gb2312编码字符集中的编号，该编号一般转换成二进制数都占两个字节，这个过程也就变成了所谓的gb2312编码&lt;br&gt;
如果上面的改为System.Text.Encoding.Default.GetBytes(param).Length，则值就是9和6了&lt;/p&gt;
&lt;p&gt;如果需要了解更加深入的编码内部原理请参考：&lt;br&gt;
&lt;a href=&quot;http://blog.csdn.net/nodeathphoenix/article/details/7057760&quot;&gt;http://blog.csdn.net/nodeathphoenix/article/details/7057760&lt;/a&gt;&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Wed, 12 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-12-79610-812efd89d.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-12-79610-812efd89d.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Introduction to the Swift REPL</title>
        <description>

						
						

						&lt;p&gt;Xcode 6.1 introduces yet another way to experiment with Swift in the form of an interactive Read Eval Print Loop, or REPL. Developers familiar with interpreted languages will feel comfortable in this command-line environment, and even experienced developers will find a few unique features. To get started, launch Terminal.app (found in /Applications/Utilities) and type “swift” at the prompt in OS X Yosemite, or “xcrun swift” in OS X Mavericks. You’ll then be in the Swift REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Welcome to Swift version 1.1 (swift-600.0.20.0). Type :help for assistance.
  &lt;span class=&quot;console&quot;&gt;1&amp;gt;&lt;/span&gt;  &lt;span class=&quot;cursor&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All you need to do is type Swift statements and the REPL will immediately execute your code.  Expression results are automatically formatted and displayed along with their type, as are the results of both variable and constant declarations.  Console output flows naturally within the interactive session:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;span class=&quot;console&quot;&gt;1&amp;gt;&lt;/span&gt; &quot;100&quot;.toInt()
&lt;span class=&quot;output&quot;&gt;$R0: Int? = 100&lt;/span&gt;
  &lt;span class=&quot;console&quot;&gt;2&amp;gt;&lt;/span&gt; let name = &quot;Katherine&quot;
&lt;span class=&quot;output&quot;&gt;name: String = &quot;Katherine&quot;&lt;/span&gt;
  &lt;span class=&quot;console&quot;&gt;3&amp;gt;&lt;/span&gt; println(&quot;Hello, \(name)&quot;)
&lt;span class=&quot;output&quot;&gt;Hello, Katherine&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the result from line one has been given a name by the REPL even though the result of the expression wasn’t explicitly assigned to anything.  You can reference these results to reuse their values in subsequent statements:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;span class=&quot;console&quot;&gt;4&amp;gt;&lt;/span&gt; $R0! + 200
&lt;span class=&quot;output&quot;&gt;$R1: Int = 300&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Swift compiler recognizes incomplete code, and will prompt for additional input when needed.  Your code will even be indented automatically as it would in Xcode. For instance, starting a function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;console&quot;&gt;5&amp;gt;&lt;/span&gt; func timesTwo() {
&lt;span class=&quot;console&quot;&gt;6.		&lt;/span&gt;&lt;span class=&quot;cursor&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The prompt for continuation lines is a line number followed by a period instead of the angle bracket that indicates a new statement, so you can tell at a glance when you’re being asked to complete a code fragment.  At this point you can keep typing remaining lines in the method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;console&quot;&gt;5&amp;gt;&lt;/span&gt; func timesTwo() {
&lt;span class=&quot;console&quot;&gt;6.&lt;/span&gt;		return value * 2
&lt;span class=&quot;console&quot;&gt;7.&lt;/span&gt; }&lt;span class=&quot;cursor&quot;&gt; &lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are three noteworthy points to make here:  The first is that line six was originally indented, but the REPL automatically unindented when we typed the closing brace.  The second is that the function references a parameter we forgot to declare and needs a return type, so you’ll need to add both to the declaration.  The last is that even if you did press return after the last line, it’s not too late to fix it.&lt;/p&gt;
&lt;h3&gt;Multi-Line History&lt;/h3&gt;
&lt;p&gt;When code is submitted to the compiler it’s also recorded in the REPL history, which makes correcting mistakes trivial.  If you pressed return at the end of the incomplete function declaration above, you’d be presented with the following message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;string&quot;&gt;error:&lt;/span&gt; use of unresolved identifier &#39;value&#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Like most history implementations, you can call up your last entry by pressing up arrow from the prompt.  The REPL brings back all three lines in our example, and places the cursor at the end.  You can now proceed with editing the code to correct your mistake as described in the next section.&lt;/p&gt;
&lt;p&gt;Your history is preserved between sessions and will record hundreds of code fragments.  Each time you move up from the top line you’ll move to an earlier history entry.  Each time you move down from an empty line at the bottom of an entry you’ll move to a more recent history entry.  The empty line that opens up before moving to the next entry comes in handy for reasons discussed below.&lt;/p&gt;
&lt;h3&gt;Multi-Line Editing&lt;/h3&gt;
&lt;p&gt;Even though the REPL behaves like a traditional line editor, it also provides convenient features for dealing with multi-line input like most class or function declarations.  In the example above, before pressing return on the final line you can press up arrow to move the cursor up to the declaration line, then use the left arrow to move the cursor just after the opening parenthesis for the parameter list:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;console&quot;&gt;5&amp;gt;&lt;/span&gt; func timesTwo(&lt;span class=&quot;cursor&quot;&gt;)&lt;/span&gt; {
&lt;span class=&quot;console&quot;&gt;6.&lt;/span&gt;		return value * 2
&lt;span class=&quot;console&quot;&gt;7.&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Type the parameter declaration, press the right arrow to move past the closing parenthesis and add the return type as well:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;console&quot;&gt;5&amp;gt;&lt;/span&gt; func timesTwo(value: Int) -&amp;gt; Int&lt;span class=&quot;cursor&quot;&gt; &lt;/span&gt;{
&lt;span class=&quot;console&quot;&gt;6.&lt;/span&gt;		return value * 2
&lt;span class=&quot;console&quot;&gt;7.&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can’t press return to complete the declaration at this point because you’re in the middle of a block of text.  Pressing return here would insert a line break, which can be useful if you’re trying to insert additional lines in a function or method body, but what you want here is to move to the end of the declaration.  You can press down arrow twice to get there, or use the Emacs sequence &lt;span class=&quot;keyword&quot;&gt;ESC &amp;gt;&lt;/span&gt; (the escape key followed by a closing angle bracket).  Pressing return at the end of the last line will compile the newly declared function so it’s ready for use:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;span class=&quot;console&quot;&gt;8&amp;gt; &lt;/span&gt; timesTwo(21)
&lt;span class=&quot;output&quot;&gt;$R2: (Int) = 42&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Automatic detection of statement completion means that you can just type code and the REPL will do the right thing the vast majority of the time.  There are occasions, however, where it’s necessary to submit more than one declaration at the same time because they have mutual dependencies. Consider the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func foo() {
	bar()
}
func bar() {
	foo()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Typing everything above line by line will result in trying to compile the first function once the third line is complete, and of course this produces an error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;string&quot;&gt;error:&lt;/span&gt; use of unresolved identifier &#39;bar&#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You could declare both functions on a single line to get around automatic completion detection that takes place when you press return, but there’s a better solution.  After typing the third line above you can press the down arrow to move to create a fourth line manually, and type the remainder normally.  The two declarations are compiled together, achieving the desired goal of mutual recursion.&lt;/p&gt;
&lt;h3&gt;Quick Reference&lt;/h3&gt;
&lt;p&gt;To help you get started, here’s a handy chart with some of the most commonly used editing and navigation keys:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Arrow Keys		Move cursor left/right/up/down
Control+F		Move cursor right one character, same as right arrow
Control+B		Move cursor left one character, same as left arrow
Control+N		Move cursor to end of next line, same as down arrow
Control+P		Move cursor to end of prior line, same as up arrow
Control+D		Delete the character under the cursor
Option+Left		Move cursor to start of prior word
Option+Right	Move cursor to start of next word
Control+A		Move cursor to start of current line
Control+E		Move cursor to end of current line
Delete			Delete the character to the left of the cursor
Esc &amp;lt;			Move cursor to start of first line
Esc &amp;gt;			Move cursor to end of last line&lt;/code&gt;&lt;/pre&gt;

						
						

												
											

</description>
        <pubDate>Tue, 11 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-11--id=18-dde9d26de.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-11--id=18-dde9d26de.html</guid>
        
        
        <category>apple_swift</category>
        
      </item>
    
      <item>
        <title>Differential Flame Graphs</title>
        <description>

&lt;p&gt;How quickly can you debug a CPU performance regression? If your environment is complex and changing quickly, this becomes challenging with existing tools. If it takes a week to root cause a regression, the code may have changed multiple times, and now you have new regressions to debug.&lt;/p&gt;

&lt;p&gt;Debugging CPU usage is easy in most cases, thanks to &lt;a href=&quot;/FlameGraphs/cpuflamegraphs.html&quot;&gt;CPU flame graphs&lt;/a&gt;. To debug regressions, I would load before and after flame graphs in separate browser tabs, and then blink between them like searching for &lt;a href=&quot;http://en.wikipedia.org/wiki/Planets_beyond_Neptune#Discovery_of_Pluto&quot;&gt;Pluto&lt;/a&gt;. It got the job done, but I wondered about a better way.&lt;/p&gt;

&lt;p&gt;Introducing &lt;strong&gt;red/blue differential flame graphs&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;object data=&quot;/images/brendangregg.com/2aa60bc452509468303f37e584575032.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;720&quot; height=&quot;296&quot;&gt;
&lt;img src=&quot;/images/brendangregg.com/2aa60bc452509468303f37e584575032.jpg&quot; width=&quot;720&quot;&gt;
&lt;/object&gt;&lt;/p&gt;

&lt;p&gt;This is an interactive SVG (direct &lt;a href=&quot;/blog/images/2014/zfs-flamegraph-diff.svg&quot;&gt;link&lt;/a&gt;). The color shows &lt;strong&gt;red for growth&lt;/strong&gt;, and &lt;strong&gt;blue for reductions&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The size and shape of the flame graph is the same as a CPU flame graph for the second profile (y-axis is stack depth, x-axis is population, and the width of each frame is proportional to its presence in the profile; the top edge is what&#39;s actually running on CPU, and everything beneath it is ancestry.)&lt;/p&gt;

&lt;p&gt;In this example, a workload saw a CPU increase after a system update. Here&#39;s the CPU flame graph (&lt;a href=&quot;/blog/images/2014/zfs-flamegraph-after.svg&quot;&gt;SVG&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;object data=&quot;/images/brendangregg.com/49970762d02ea8e1b80cbd5bc5eb1a97.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;720&quot; height=&quot;296&quot;&gt;
&lt;img src=&quot;/images/brendangregg.com/49970762d02ea8e1b80cbd5bc5eb1a97.jpg&quot; width=&quot;720&quot;&gt;
&lt;/object&gt;&lt;/p&gt;

&lt;p&gt;Normally, the colors are picked at random to differentiate frames and towers. Red/blue differential flame graphs use color to show the difference between two profiles.&lt;/p&gt;

&lt;p&gt;The deflate_slow() code and children were running more in the second profile, highlighted earlier as red frames. The cause was that ZFS compression was enabled in the system update, which it wasn&#39;t previously.&lt;/p&gt;

&lt;p&gt;While this makes for a clear example, I didn&#39;t really need a differential flame graph for this one. Imagine tracking down subtle regressions, of less than 5%, and where the code is also more complex.&lt;/p&gt;

&lt;h2&gt;Red/Blue Differential Flame Graphs&lt;/h2&gt;

&lt;p&gt;I&#39;ve had many discussions about this for years, and finally wrote an implementation that I hope makes sense. It works like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Take stack profile 1.&lt;/li&gt;
&lt;li&gt;Take stack profile 2.&lt;/li&gt;
&lt;li&gt;Generate a flame graph using 2. (This sets the width of all frames using profile 2.)&lt;/li&gt;
&lt;li&gt;Colorize the flame graph using the &quot;2 - 1&quot; delta. If a frame appeared more times in 2, it is red, less times, it is blue. The saturation is relative to the delta.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The intent is for use with before &amp;amp; after profiles, such as for &lt;strong&gt;non-regression testing&lt;/strong&gt; or benchmarking code changes. The flame graph is drawn using the &quot;after&quot; profile (such that the frame widths show the current CPU consumption), and then colorized by the delta to show how we got there.&lt;/p&gt;

&lt;p&gt;The colors show the difference that function directly contributed (eg, being on-CPU), not its children.&lt;/p&gt;

&lt;h2&gt;Generation&lt;/h2&gt;

&lt;p&gt;I&#39;ve pushed a simple implementation to github (see &lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;FlameGraph&lt;/a&gt;), which includes a new program, difffolded.pl. To show how it works, here are the steps using Linux &lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;perf_events&lt;/a&gt; (you can use other profilers).&lt;/p&gt;

&lt;p&gt;Collect profile 1:&lt;/p&gt;

&lt;pre&gt;
# &lt;b&gt;perf record -F 99 -a -g -- sleep 30&lt;/b&gt;
# &lt;b&gt;perf script &amp;gt; out.stacks1&lt;/b&gt;
&lt;/pre&gt;

&lt;p&gt;Some time later (or after a code change), collect profile 2:&lt;/p&gt;

&lt;pre&gt;
# &lt;b&gt;perf record -F 99 -a -g -- sleep 30&lt;/b&gt;
# &lt;b&gt;perf script &amp;gt; out.stacks2&lt;/b&gt;
&lt;/pre&gt;

&lt;p&gt;Now fold these profile files, and generate a differential flame graph:&lt;/p&gt;

&lt;pre&gt;
$ &lt;b&gt;git clone --depth 1 http://github.com/brendangregg/FlameGraph&lt;/b&gt;
$ &lt;b&gt;cd FlameGraph&lt;/b&gt;
$ &lt;b&gt;./stackcollapse-perf.pl ../out.stacks1 &amp;gt; out.folded1&lt;/b&gt;
$ &lt;b&gt;./stackcollapse-perf.pl ../out.stacks2 &amp;gt; out.folded2&lt;/b&gt;
$ &lt;b&gt;./difffolded.pl out.folded1 out.folded2 | ./flamegraph.pl &amp;gt; diff2.svg&lt;/b&gt;
&lt;/pre&gt;

&lt;p&gt;difffolded.pl operates on the &quot;folded&quot; style of stack profiles, which are generated by the stackcollapse collection of tools (see the files in &lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;FlameGraph&lt;/a&gt;). It emits a three column output, with the folded stack trace and two value columns, one for each profile. Eg:&lt;/p&gt;

&lt;pre&gt;
func_a;func_b;func_c 31 33
[...]
&lt;/pre&gt;

&lt;p&gt;This would mean the stack composed of &quot;func_a()-&amp;gt;func_b()-&amp;gt;func_c()&quot; was seen 31 times in profile 1, and in 33 times in profile 2. If flamegraph.pl is handed this three column input, it will automatically generate a red/blue differential flame graph.&lt;/p&gt;

&lt;h2&gt;Options&lt;/h2&gt;

&lt;p&gt;Some options you&#39;ll want to know about:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;difffolded.pl -n&lt;/strong&gt;: This normalizes the first profile count to match the second. If you don&#39;t do this, and take profiles at different times of day, then all the stack counts will naturally differ due to varied load. Everything will look red if the load increased, or blue if load decreased. The -n option balances the first profile, so you get the full red/blue spectrum.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;difffolded.pl -x&lt;/strong&gt;: This strips hex addresses. Sometimes profilers can&#39;t translate addresses into symbols, and include raw hex addresses. If these addresses differ between profiles, then they&#39;ll be shown as differences, when in fact the executed function was the same. Fix with -x.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;flamegraph.pl --negate&lt;/strong&gt;: Inverts the red/blue scale. See the next section.&lt;/p&gt;

&lt;h2&gt;Negation&lt;/h2&gt;

&lt;p&gt;While my red/blue differential flame graphs are useful, there is a problem: if code paths vanish completely in the second profile, then there&#39;s nothing to color blue. You&#39;ll be looking at the current CPU usage, but missing information on how we got there.&lt;/p&gt;

&lt;p&gt;One solution is to reverse the order of the profiles and draw a negated flame graph differential. Eg:&lt;/p&gt;

&lt;p&gt;&lt;object data=&quot;/images/brendangregg.com/81122e6264570b8aefad9516038fef3a.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;720&quot; height=&quot;296&quot;&gt;
&lt;img src=&quot;/images/brendangregg.com/81122e6264570b8aefad9516038fef3a.jpg&quot; width=&quot;720&quot;&gt;
&lt;/object&gt;&lt;/p&gt;

&lt;p&gt;Now the widths show the first profile, and the colors show what &lt;em&gt;will&lt;/em&gt; happen. The blue highlighting on the right shows we&#39;re about to spend a lot less time in the CPU idle path. (Note that I usually filter out cpu_idle from the folded files, by including a grep -v cpu_idle.)&lt;/p&gt;

&lt;p&gt;This also highlights the vanishing code problem (or rather, &lt;em&gt;doesn&#39;t&lt;/em&gt; highlight), as since compression wasn&#39;t enabled in the &quot;before&quot; profile, there is nothing to color red.&lt;/p&gt;

&lt;p&gt;This was generated using:&lt;/p&gt;

&lt;pre&gt;
$ &lt;b&gt;./difffolded.pl out.folded2 out.folded1 | ./flamegraph.pl --negate &amp;gt; diff1.svg&lt;/b&gt;
&lt;/pre&gt;

&lt;p&gt;Which, along with the earlier diff2.svg, gives us:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;diff1.svg&lt;/strong&gt;: widths show the before profile, colored by what WILL happen&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;diff2.svg&lt;/strong&gt;: widths show the after profile, colored by what DID happen&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If I were to automate this for non-regression testing, I&#39;d generate and show both side by side.&lt;/p&gt;

&lt;h2&gt;CPI Flame Graphs&lt;/h2&gt;

&lt;p&gt;I first used this code for my &lt;a href=&quot;/blog/2014-10-31/cpi-flame-graphs.html&quot;&gt;CPI flame graphs&lt;/a&gt;, where instead of doing a difference between two profiles, I showed the difference between CPU cycles and stall cycles, which highlights what the CPUs were doing.&lt;/p&gt;

&lt;h2&gt;Other Differential Flame Graphs&lt;/h2&gt;

&lt;div style=&quot;float:right;padding-left:10px;padding-bottom:1px&quot;&gt;&lt;a href=&quot;http://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs/167&quot;&gt;&lt;img src=&quot;/images/brendangregg.com/6c97a332cb2bc9ee6379a7a58928be8d.jpg&quot; width=&quot;250&quot; border=&quot;0&quot;&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;There&#39;s other ways flame graph differentials can be done. &lt;a href=&quot;http://dtrace.org/blogs/rm&quot;&gt;Robert Mustacchi&lt;/a&gt; experimented with &lt;a href=&quot;http://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs/167&quot;&gt;differentials&lt;/a&gt; a while ago, and used an approach similar to a colored code review: only the difference is shown, colored red for added (increased) code paths, and blue for removed (decreased) code paths. The key difference is that the frame widths are now relative to the size of the difference only. An example is on the right. It&#39;s a good idea, but in practice I found it a bit weird, and hard to follow without the bigger picture context: a standard flame graph showing the full profile.&lt;/p&gt;

&lt;div style=&quot;float:right;padding-left:10px;padding-bottom:1px&quot;&gt;&lt;a href=&quot;https://github.com/corpaul/flamegraphdiff&quot;&gt;&lt;img src=&quot;/images/brendangregg.com/a8b78e5863c9d43ebbf6a4c588ea1548.jpg&quot; width=&quot;250&quot; border=&quot;0&quot;&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Cor-Paul Bezemer has created &lt;a href=&quot;http://corpaul.github.io/flamegraphdiff/&quot;&gt;flamegraphdiff&lt;/a&gt;, which shows the profile difference using three flame graphs at the same time: the standard before and after flame graphs, and then a differential flame graph where the widths show the difference. See the &lt;a href=&quot;http://corpaul.github.io/flamegraphdiff/demos/dispersy/dispersy_diff.html&quot;&gt;example&lt;/a&gt;. You can mouse-over frames in the differential, which highlights frames in all profiles. This solves the context problem, since you can see the standard flame graph profiles.&lt;/p&gt;

&lt;p&gt;My red/blue flame graphs, Robert&#39;s hue differential, and Cor-Paul&#39;s triple-view, all have their strengths. These could be combined: the top two flame graphs in Cor-Paul&#39;s view could be my diff1.svg and diff2.svg. Then the bottom flame graph colored using Robert&#39;s approach. For consistency, the bottom flame graph could use the same palette range as mine: blue-&amp;gt;white-&amp;gt;red.&lt;/p&gt;

&lt;p&gt;Flame graphs are spreading, and are now used by many companies. I wouldn&#39;t be surprised if there were already other implementations of flame graph differentials I didn&#39;t know about. (Leave a comment!)&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you have problems with performance regressions, red/blue differential flame graphs may be the quickest way to find the root cause. These take a normal flame graph and then use colors to show the difference between two profiles: red for greater samples, and blue for fewer. The size and shape of the flame graph shows the current (&quot;after&quot;) profile, so that you can easily see where the samples are based on the widths, and then the colors show how we got there: the profile difference.&lt;/p&gt;

&lt;p&gt;These differential flame graphs could also be generated by a nightly non-regression test suite, so that performance regressions can be quickly debugged after the fact.&lt;/p&gt;


</description>
        <pubDate>Sun, 09 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-09-differential-flame-graphs.html-eb140f444.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-09-differential-flame-graphs.html-eb140f444.html</guid>
        
        
        <category>brendangregg</category>
        
      </item>
    
      <item>
        <title>5 分钟上手 Tmux</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;如果你在做的项目需要你打开多个终端，那 Tmux（还有它的好基友 Tmuxinator）将会大大提高你的效率！Tmux 允许你在一个终端运行多个会话，Tmuxinator 则可以让你保存 tmux 的配置。&lt;/p&gt;
&lt;p&gt;例如你是一个Rails的开发者， 你可以很轻松的打开不同的会话，同时处理几件事，比如运行Rails服务器，一个Rails终端，一个tailing 日志。&lt;/p&gt;
&lt;p&gt;如果你是在一个&lt;a href=&quot;http://www.flyingmachinestudios.com/programming/building-a-forum-with-clojure-datomic-angular/&quot;&gt;Clojure-based forum&lt;/a&gt; 工作时， 我也可以打开几个会话， 一个shell，一个grunt服务器构建前端， 一个处理datomic数据库，一个用来部署，像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/10e1a81be5ad75c584117ac852e8dbe9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我可以敲入一个命令 mux ath，就可以全都启动好。 这比需要记住每个服务，然后手动单个启动要方便的多。&lt;/p&gt;
&lt;p&gt;下面是一些上手 tmux 和tmuxinator的一些步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 首先，使用安装tmux 参考 &lt;a href=&quot;https://gist.github.com/simme/1297707&quot;&gt;in this gist&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;然后，使用 gem install  tmuxinator 安装 tmuxinator&lt;code&gt;&lt;br&gt;
&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;然后在~/.tmuxinator/sample.yml 创建你的 第一个 tmuxinator配置文件，配置文件类似于下面这样，&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;name: sample
root: ~/path/to/your/project
pre: git pull
windows:
  - shell: 
  - server: bundle exec rails s&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在打开窗口前，在root的目录中运行pre选项中的命令， 你可以使用这个配置文件打开tmux的会话， 你可以使用C-b n 切换到下个窗口，&lt;code&gt;C-b p&lt;/code&gt; 切换到前一个窗口， C-b p 意味着你按下了控制键，然后按下了‘b’键， 想要离开一个tmux会话，可以使用  C-b d， 如果你离开了这个会话，它仍然在运行，任何你在一个窗口中启动的进程都依然在运行，我很少使用其他的命令，如果你需要，可以参考这里  &lt;a href=&quot;http://cheat.errtheblog.com/s/tmux&quot;&gt;tmux cheatsheet&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;如果你要完全停掉一个会话，你需要杀死它， 使用tmux kill-session -t sample， sample是你的tmuxinator配置文件中name的选项名字，我创建了一个别名 alias “tmk”=”tmux kill-session -t”，然后就只要 tmk sample 就可以了&lt;/p&gt;
&lt;p&gt;我希望这个工具对你有所帮助， 更多信息，参考  &lt;a href=&quot;https://github.com/tmuxinator/tmuxinator&quot;&gt;tmuxinator’s github repo&lt;/a&gt;， 你可以干一些很炫的事，比如把屏幕切成多个，  这里还有一个参考书 &lt;a href=&quot;http://www.amazon.com/gp/product/1934356964/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=1934356964&amp;amp;linkCode=as2&amp;amp;tag=aflyingmachin-20&amp;amp;linkId=KX7OZEGOV4WX5K7W&quot;&gt;a handy book&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;我希望这些小建议对你有所帮助。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-08-79494-3c1703041.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-08-79494-3c1703041.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>你不知道的页面编码，浏览器选择编码，get，post各种乱码由来</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;strong&gt;asp.net页面编码和浏览器的选择编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个asp.net的朋友都知道，在新版本的visual studio，在没有任何设置的情况下，新建页面时的默认编码为utf-8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以从两个地方可以看出：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一：&lt;/strong&gt;打开aspx页面，“文件”-&amp;gt;“高级保存选项”，如下图，可以看出编码为：Unicode（UTF-8带签名）&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b62ea9762abc232aaa7bd7271782ef0b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二：&lt;/strong&gt;找到aspx存放路径，用系统自带的文本编辑器打开，然后“文件”-&amp;gt;”另存为”，如下图，可以看出编码为UTF-8&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c1a2e8fbcae174f37f383f78e5b06964.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;很多时候我们有些疑问，我们经常在aspx页面的&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;强制把carset改为gb2312&lt;/p&gt;
&lt;p&gt;然后我们在“文件”-&amp;gt;“高级保存选项”，可以看出编码为：GB2312（如果你前面把carset改为gb2312，vs会自动在高级保存选项中进行绑定改变）,然后编译运行后，右击html“查看源”发现&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;没有变化，这时候一切正常&lt;/p&gt;
&lt;p&gt;下面以IE为例：我们以为此时 “右击浏览器”-&amp;gt;“编码” 看到的是 浏览器会选中简体中文（GB2312）,但是事实上，你看到的还是选中的Unicode（UTF-8）  (再勾选了‘自动选择’前提下)&lt;/p&gt;
&lt;p&gt;现象已经很明显，但是需要验证浏览器为何会这样，F12调试浏览器（如下图），我们发现content-type竟然是“text/html；charset=utf-8”！&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/42453fac14aef0a0e43e15f8fe23f6da.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个现象至少说了两个问题点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;1、&lt;/strong&gt;&lt;/em&gt;asp.net机制至少在某个地方改变了response的ContentEncoding，导致虽然html页面代码上看到的设置&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;并没有生效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2、&lt;/em&gt;&lt;/strong&gt;浏览器再自动选择编码方式的时候不会优先根据html源码中的所展示的&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;代码来决定选择什么编码方式，很明显，以上的现象证明浏览器是优先根据“响应标头-response header”中的键为“Content-Type”的值来自动选择判断，导致html中的所看到的&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;形同虚设。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上两个问题点很快得到论证：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;问题1、&lt;/strong&gt;&lt;/em&gt;在任意新建一个测试页面，在第一个“}”处设置断点,然后命中断点后再“即时窗口”中写入“Response.ContentEncoding.EncodingName”，按enter执行，输出什么？没错：”Unicode (UTF-8)”&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;protected void Page_Load(object sender, EventArgs e)
{

}&lt;/pre&gt;
&lt;p&gt;如果了解asp.net生命机制的朋友知道，在执行到Page_Load之前已经执行了很多潜在的初始化事件，类似：Page_Init，LoadViewState， LoadPostData等等，可以想象一定是在某个地方系统为响应页面指定修改了ContentEncoding的值，也就是“响应标头-response header”中的键为“Content-Type”的值为“UTF-8”&lt;/p&gt;
&lt;p&gt;我们不妨做一个测试，上面说过，我把&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;的carset改为gb2312,是没有效果的，那么我如果在Page_Load事件中如下写上代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;protected void Page_Load(object sender, EventArgs e)
{
            Encoding gb2312 = Encoding.GetEncoding(&quot;gb2312&quot;);
            Response.ContentEncoding = gb2312;
 }&lt;/pre&gt;
&lt;p&gt;即我在load事件中再次强制性把响应标头中的“Content-Type”改为gb2312，那么浏览器表现如何呢？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6aa9fc339817cd2db675de39d4718ecf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ff598546ac6d0660237a6228dc5c3bd5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这正是我们想看到的，我相信很多朋友有过中文乱码的情况，我先不说具体乱码的解决方案，但是至少搜索发现很多解决方案是在web.config下添加如下节点，即把网站内所有网页的请求编码和响应编码都改为utf-8&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;&amp;lt;system.web&amp;gt;
&amp;lt;globalization requestEncoding=&quot;utf-8&quot; responseEncoding=&quot;utf-8&quot; /&amp;gt;
&amp;lt;/system.web&amp;gt;&lt;/pre&gt;
&lt;p&gt;其实，上面案例其实只是单个页面的修改response Encoding为gb2312，我们也可以在web.config中添加&amp;lt;globalization requestEncoding=”gb2312″ responseEncoding=”gb2312″ /&amp;gt;，即整个网站有效&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;问题2、&lt;/strong&gt;&lt;/em&gt;浏览器编码方式是根据“响应标头-response header”中的键为“Content-Type”的值来自动选择判断，而不会简单的根据你在html中看到的标签值&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;来判定，虽然这个标签一般情况下会写入header，但是有时候会被暗中修改掉，导致html中看到的和调试捕捉到的Content-Type不一致的情况&lt;/p&gt;
&lt;p&gt;当然在老版本的ie中，有时候出现的页面全部为空白，右击ie浏览器编码发现没有勾选“自动选择”的情况下会出现这种白屏现象，那不是本文讨论的范围，但是简单的说下原因（拷贝）：老版本的ie浏览器解析网页编码时以HTML内的标签优先，而后才是HTTP header内的讯息，而mozilla系列的浏览器则刚刚相反，由于UTF-8为3个字节表示一个汉字，而普通的GB2312或BIG5是两个。页面输出时，由于上述原因，使浏览器解析、输 出&amp;lt;title$amp;&amp;gt;amp;$lt;/title&amp;gt;的内容时，如果在&amp;lt;/title&amp;gt;前有奇数个全角字符时，IE把UTF-8当作两 个字节解析时出现半个汉字的情况，这时该半个汉字会和&amp;lt;/title&amp;gt;的&amp;lt;结合成一个乱码字，导致IE无法读 完&amp;lt;title&amp;gt;部分，使整个页面为空百输出。而这个时候如果察看源文件的话，会发现实际上整个叶面全部已经输出了&lt;/p&gt;
&lt;p&gt;解决方法：将&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=utf-8″ /&amp;gt;放在&amp;lt;title&amp;gt;测试标题&amp;lt;/title&amp;gt;之前（好像现在新建网页默认都在title之前）&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;asp.net URL参数编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几乎所有的朋友都会遇到中文情况下乱码的问题，其原因到底是为何？&lt;/p&gt;
&lt;p&gt;我先不说乱码问题，先说get和post的区别，几乎没有人不知道&lt;/p&gt;
&lt;p&gt;我们在新建asp.net页面时，是很少去对form进行修改的，即保持默认的&amp;lt;form id=”form1″ runat=”server”&amp;gt;，可是编译运行后查看代码发现变成&amp;lt;form method=”post” action=”Default2.aspx” id=”form1″&amp;gt;&lt;/p&gt;
&lt;p&gt;很显然，asp.net默认会为form的method写上post，但是需要注意的是如果仅仅是单纯的html页面，form默认的method是get&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我这边可以举一个例子诠释一些无关紧要但是又比较重要的东西：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况1（post）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器选择编码 ：  &lt;/strong&gt;utf-8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译前的aspx  ：&lt;/strong&gt;  &amp;lt;form id=”form1″  runat=”server”&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行后的html  ：&lt;/strong&gt;  &amp;lt;form id=”form1″ action=”Default2.aspx” method=”post”&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击服务器按钮(按钮文本：阿道夫)：&lt;/strong&gt;F12在请求正文中有如下图内容&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/eefcc91951ecbb323eea06f4e7bf5ca6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况2（get）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器选择编码 ：  &lt;/strong&gt;utf-8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译前的aspx  ：&lt;/strong&gt;  &amp;lt;form id=”form1″  runat=”server” method=”get”&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行后的html  ：&lt;/strong&gt;  &amp;lt;form id=”form1″ action=”Default2.aspx” method=”get”&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击服务器按钮(按钮文本：阿道夫)：&lt;/strong&gt;F12在请求正文中有如下图内容&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/cf2b99ca759574904318487eddbe29c0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;其实，情况1和情况2的对比，并不是我今天想说的意图，但是我还是要稍微顺带说下：&lt;/p&gt;
&lt;p&gt;1、我们可以看到get方式的提交，参数仅仅是拼接在url后面，然后直接向web服务器请求，所以我们图中“请求标头-request header”中就可以看到参数的值，而post可以从图中看到，在“请求标头”中并看不到值，而在“请求正文”中看到值，说明post提交时值是包装在请求的body中，发送给服务器，然后向服务器请求数据&lt;/p&gt;
&lt;p&gt;2、在asp.net中，图中可以看到不管是get还是post，提交形式不一样，内容确是一样的，本文仅为测试，所以内容相对较少，但是看起来也非常的长了，如果用get提交方式，这就带来隐患，浏览器到底支持多长的uri，web服务器到底支持多长的uri，反正是有限制的（具体长度见：&lt;a href=&quot;http://www.cnblogs.com/henryhappier/archive/2010/10/09/1846554.html&quot;&gt;http://www.cnblogs.com/henryhappier/archive/2010/10/09/1846554.html&lt;/a&gt;），不仅仅是长度，数据量也是有限制，get数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，web服务器载体例如iis应该会有限制，比如IIS5的post最大传输量为100kb等&lt;/p&gt;
&lt;p&gt;3、安全性，get更加容易暴露参数，而且会被保存在浏览器的历史记录中，但是对于稍微专业点的人来说，post请求传送的数据也是可以被捕捉到的&lt;/p&gt;
&lt;p&gt;4、缓存和seo优化等就不提了&lt;/p&gt;
&lt;p&gt;5、&lt;strong&gt;编码问题！！！（这边上面说这么多，就是为了最后一个“编码问题”）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我将着重讲解编码问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Form元素的语法中，EncType表明提交数据的格式&lt;br&gt;
用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型。&lt;br&gt;
一般是下面几种类型：&lt;br&gt;
application/x-www-form-urlencoded： 窗体数据被编码为名称/值对。这是标准的编码格式。&lt;br&gt;
multipart/form-data： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。&lt;br&gt;
text/plain： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设此时使用get提交form方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器则会用x-www-form-urlencoded的数据格式，虽然在F12浏览器调试或者cs代码中的Request.ContentType都看不出来。注意如下是我的get提交的url：&lt;/p&gt;
&lt;p&gt;GET /Default2.aspx?__VIEWSTATE=MGASeC9kBMq4iDCI2YLRzkZYqkKYhDhWH2jlP5mpv7idP8gAoNcy0T0y6g6wRvccP%2BFz%2FVx4HdMGwLLW%2BYPbJsMEOTMi5PjS7Ea66DmHQJc%3D&amp;amp;__VIEWSTATEGENERATOR=9BD98A7D&amp;amp;__EVENTVALIDATION=BFMAr0Q6mSwngMhaCLeScGaXywIIRlFClDYAnVhHprxOeifBIGWKNbsunWO9yVOAV6jWHW%2FJ4g2laHQpTvJe%2Fc7X8vralK3hyO5Y0nuiJkT%2FdfxEj9NnCb8S5BfNvZKXVJA%2FOy8yH4Bf9K5DN%2FRI9aDR3EFR86Zm6fN4iEkvJfc%3D&amp;amp;Button2=%E9%98%BF%E9%81%93%E5%A4%AB&lt;/p&gt;
&lt;p&gt;我只看最后部分“Button2=%E9%98%BF%E9%81%93%E5%A4%AB”，这是我的服务器按钮“阿道夫”，这一串“%E9%98%BF%E9%81%93%E5%A4%AB”是“阿道夫”三个汉字编码后的，究竟这个编码方式到底是什么？又是如何经常引起乱码问题的呢？&lt;/p&gt;
&lt;p&gt;首先：get只能向服务器发送ASCII字符，这是W3C组织规定的，所以任何参数最后都要以ASCII码的形式传递，例如“Button2=%E9%98%BF%E9%81%93%E5%A4%AB”都是ASCII码中的英文字符和符号等字符，没有任何中文字符，其次编码方式是根据当前网页采用选择的编码来编码，例如asp.net网页使用的是utf-8码，那么“阿道夫”用utf-8的编码后的十六进制字符串就是“E9-98-BF-E9-81-93-E5-A4-AB”，和上面提到的“%E9%98%BF%E9%81%93%E5%A4%AB”是不是非常的类似，只是多了百分号&lt;/p&gt;
&lt;p&gt;如何查看中文字符的十六进制字符串？方法：BitConverter.ToString(System.Text.Encoding.&lt;strong&gt;UTF8&lt;/strong&gt;.GetBytes(“阿道夫”));&lt;/p&gt;
&lt;p&gt;如果用本文一开始介绍的方法，在Page_Load中加上&lt;/p&gt;
&lt;p&gt;Encoding gb2312 = Encoding.GetEncoding(“gb2312″);&lt;br&gt;
Response.ContentEncoding = gb2312;&lt;/p&gt;
&lt;p&gt;强制把当前页面编码改为gb2312，然后点击按钮，那么我们猜测在F12浏览器调试时，get提交的url的最后部分一定不再是“%E9%98%BF%E9%81%93%E5%A4%AB”，&lt;/p&gt;
&lt;p&gt;调试后发现是：“%B0%A2%B5%C0%B7%F2”&lt;/p&gt;
&lt;p&gt;那么用BitConverter.ToString(System.Text.Encoding.&lt;strong&gt;Default&lt;/strong&gt;.GetBytes(“阿道夫”))生成的值呢？答案是：B0-A2-B5-C0-B7-F2&lt;/p&gt;
&lt;p&gt;这一切证明了url参数编码方式是根据当前网页采用选择的编码来编码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后我将在服务端接受参数，这边有两种情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况1、&lt;/strong&gt;ok，我再次以get方式提交form，并是以utf-8编码（默认），此时，我在服务端通过Request.QueryString[&quot;Button2&quot;]，我将得到“阿道夫”，一切正常&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况2、&lt;/strong&gt;ok，我继续以get方式提交form，并是以gb2312编码（如何设置上文讲过），此时，我在服务端通过Request.QueryString[&quot;Button2&quot;]，我将得到“������”，正如我愿&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为何一开始正常，后面会出现乱码，我这边做几个假设：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设1、&lt;/strong&gt;对于情况1 的Request.QueryString[&quot;Button2&quot;]没有出现乱码，我是否可以猜测微软Request.QueryString内部自带有解码的操作？并且在这种情况下该操作是utf-8的解码方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设2、&lt;/strong&gt;对于情况2 的Request.QueryString[&quot;Button2&quot;]出现乱码,我是否可以猜测是因为微软Request.QueryString内部自带有解码的操作，并按照utf-8解码方式 解码我用gb2312编码的字符，这种不对称的解码肯定是错误的&lt;/p&gt;
&lt;p&gt;如何验证我的结论？&lt;a href=&quot;http://www.cnblogs.com/cyq1162/archive/2010/11/29/1891124.html&quot; target=&quot;_blank&quot;&gt;路过秋天&lt;/a&gt;  的这篇文章写的很详细，我总结下大概就是：&lt;/p&gt;
&lt;p&gt;反编译Request.QueryString属性，你会发现有这么如下代码：最后深入到代码关键点：this._queryString.FillFromEncodedBytes(queryStringBytes, this.QueryStringEncoding);从FillFromEncodedBytes方法中可以看出调用HttpUtility.UrlDecode(bytes, num2, num3 - num2, encoding)的解码方法，我们现在知道Request.QueryString内部实现是调用了HttpUtility.UrlDecode解码的方法，那么关键点就在HttpUtility.UrlDecode方法的第三个参数encoding到底是哪种解码方式&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public NameValueCollection QueryString
{
    get
    {
        this.EnsureQueryString();
        if (this._flags[1])
        {
            this._flags.Clear(1);
            this.ValidateHttpValueCollection(this._queryString, RequestValidationSource.QueryString);
        }
        return this._queryString;
    }
}

QueryString&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;internal HttpValueCollection EnsureQueryString()
{
    if (this._queryString == null)
    {
        this._queryString = new HttpValueCollection();
        if (this._wr != null)
        {
            this.FillInQueryStringCollection();
        }
        this._queryString.MakeReadOnly();
    }
    return this._queryString;
}

EnsureQueryString&lt;/pre&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private void FillInQueryStringCollection()
{
    byte[] queryStringBytes = this.QueryStringBytes;
    if (queryStringBytes != null)
    {
        if (queryStringBytes.Length != 0)
        {
            this._queryString.FillFromEncodedBytes(queryStringBytes, this.QueryStringEncoding);
            return;
        }
    }
    else
    {
        if (!string.IsNullOrEmpty(this.QueryStringText))
        {
            this._queryString.FillFromString(this.QueryStringText, true, this.QueryStringEncoding);
        }
    }
}&lt;/pre&gt;
&lt;p&gt;下面是FillFromEncodedBytes方法实现：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;internal void FillFromEncodedBytes(byte[] bytes, Encoding encoding)
{
    int num = (bytes != null) ? bytes.Length : 0;
    for (int i = 0; i &amp;lt; num; i++)
    {
        this.ThrowIfMaxHttpCollectionKeysExceeded();
        int num2 = i;
        int num3 = -1;
        while (i &amp;lt; num)
        {
            byte b = bytes[i];
            if (b == 61)
            {
                if (num3 &amp;lt; 0)
                {
                    num3 = i;
                }
            }
            else
            {
                if (b == 38)
                {
                    break;
                }
            }
            i++;
        }
        string name;
        string value;
        if (num3 &amp;gt;= 0)
        {
            name = HttpUtility.UrlDecode(bytes, num2, num3 - num2, encoding);
            value = HttpUtility.UrlDecode(bytes, num3 + 1, i - num3 - 1, encoding);
        }
        else
        {
            name = null;
            value = HttpUtility.UrlDecode(bytes, num2, i - num2, encoding);
        }
        base.Add(name, value);
        if (i == num - 1 &amp;amp;&amp;amp; bytes[i] == 38)
        {
            base.Add(null, string.Empty);
        }
    }
}&lt;/pre&gt;
&lt;p&gt;this.QueryStringEncoding是HttpUtility.UrlDecode解码的关键，我们发现系统默认会先取globalization配置节点的编码方式，如果取不到，则默认为UTF-8编码方式&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;internal Encoding QueryStringEncoding
{
    get
    {
        Encoding contentEncoding = this.ContentEncoding;
        if (!contentEncoding.Equals(Encoding.Unicode))
        {
            return contentEncoding;
        }
        return Encoding.UTF8;
    }
}&lt;/pre&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public Encoding ContentEncoding
{
    get
    {
        if (this._flags[32] &amp;amp;&amp;amp; this._encoding != null)
        {
            return this._encoding;
        }
        this._encoding = this.GetEncodingFromHeaders();
        if (this._encoding is UTF7Encoding &amp;amp;&amp;amp; !AppSettings.AllowUtf7RequestContentEncoding)
        {
            this._encoding = null;
        }
        if (this._encoding == null)
        {
            GlobalizationSection globalization = RuntimeConfig.GetLKGConfig(this._context).Globalization;
            this._encoding = globalization.RequestEncoding;
        }
        this._flags.Set(32);
        return this._encoding;
    }
    set
    {
        this._encoding = value;
        this._flags.Set(32);
    }
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;得出结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在method为get的提交方式中，如果在web.config中不配置任何globalization相关节点，那么Request.QueryString属性获取uri参数时会自动用utf-8解码，如果此时你的页面是采用gb2312编码，那么cs端获取必定会是乱码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法（form提交method为get）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法1、&lt;/strong&gt;配置globalization节点，例如&amp;lt;globalization requestEncoding=”gb2312″ responseEncoding=”gb2312″ fileEncoding=”gb2312″ culture=”zh-CN”/&amp;gt;&lt;br&gt;
那么get提交的uri附加的参数会采用gb2312编码，cs服务端Request.QueryString就会根据globalization配置的requestEncoding值gb2312进行内部的HttpUtility.UrlDecode&lt;br&gt;
&lt;strong&gt;方法2、&lt;/strong&gt;不配置globalization任何节点，在html端对将要拼接到uri后面的中文参数进行encodeURIComponent或者encodeURI编码处理，因为encodeURIComponent或者encodeURI就是utf-8的编码方法（永远不会变），然后再cs服务端Request.QueryString接收后，再用 HttpUtility.UrlDecode(“”, Encoding.Default)进行解码（或者用Server.UrlDecode（）解码，效果一样，Server.UrlDecode为使用当前操作系统的编码解码方式），如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;假设form method=get，当前环境ContentEncoding为gb2312&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;未做任何处理操作时要请求服务器的uri的一部分：&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
Default2.aspx?Button2=%B0%A2%B5%C0%B7%F2&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;在脚本端用encodeURIComponent对”阿道夫“进行编码后的将要请求服务器的uri的一部分：&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
Default2.aspx?Button2=%E9%98%BF%E9%81%93%E5%A4%AB&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;cs服务端:&lt;br&gt;
&lt;/em&gt;&lt;/strong&gt;string param1 = Request.QueryString[&quot;Button2&quot;];//param1的值为：%E9%98%BF%E9%81%93%E5%A4%AB，虽然Request.QueryString内部有utf-8解码操作，但是对于全是英文和符号等属于assic码的字符不会做任何解码操作（utf-8包含assic）&lt;br&gt;
string param2 = HttpUtility.UrlDecode(param1, Encoding.UTF8);//再针对性的用Encoding.UTF8对在脚本端用encodeURIComponent（编码方式为：utf-8）编码的param1进行对应解码，一切都安静了。值为“阿道夫”&lt;/p&gt;
&lt;p&gt;如果理解了编码解码的机制，那么如果仅仅是在cs服务端编码传递带有中文参数的url到另一个页面，也需要注意对应的编码解码问题，比如A页面的按钮点击后跳转到B页面，我举四种情况，大家判断哪种情况下在B页面接收时会有乱码出现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;备注： &lt;/em&gt;&lt;/strong&gt; HttpUtility.UrlDecode(param1)在没有第二个参数的情况下默认和HttpUtility.UrlDecode(param1, Encoding.UTF8)等效，除非你强制指定第二个参数比如：HttpUtility.UrlDecode(param1, Encoding.Default)&lt;br&gt;
第一种：没有配置任何globalization节点（&lt;strong&gt;正确&lt;/strong&gt;）&lt;br&gt;
A页面的按钮代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;protected void Button1_Click(object sender, EventArgs e)
         {
             string param = &quot;阿道夫&quot;;
             Response.Redirect(&quot;~/Default.aspx?param=&quot; + param);
         }&lt;/pre&gt;
&lt;p&gt;B页面的接收代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;string param1 = Request.QueryString[&quot;param&quot;];&lt;/pre&gt;
&lt;p&gt;第二种：配置了globalization节点&amp;lt;globalization requestEncoding=”gb2312″ responseEncoding=”gb2312″ fileEncoding=”gb2312″ culture=”zh-CN”/&amp;gt;（&lt;strong&gt;正确&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;A页面的按钮代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;protected void Button1_Click(object sender, EventArgs e)
         {
             string param = &quot;阿道夫&quot;;
             Response.Redirect(&quot;~/Default.aspx?param=&quot; + param);
         }&lt;/pre&gt;
&lt;p&gt;B页面的接收代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;string param1 = Request.QueryString[&quot;param&quot;];&lt;/pre&gt;
&lt;p&gt;第三种：没有配置任何globalization节点（&lt;strong&gt;正确&lt;/strong&gt;）&lt;br&gt;
A页面的按钮代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;protected void Button1_Click(object sender, EventArgs e)
         {
             string param = &quot;阿道夫&quot;;
             Response.Redirect(&quot;~/Default.aspx?param=&quot; + HttpUtility.UrlEncode(param));
         }&lt;/pre&gt;
&lt;p&gt;B页面的接收代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;string param1 = Request.QueryString[&quot;param&quot;];&lt;/pre&gt;
&lt;p&gt;第四种：配置了globalization节点&amp;lt;globalization requestEncoding=”gb2312″ responseEncoding=”gb2312″ fileEncoding=”gb2312″ culture=”zh-CN”/&amp;gt;（&lt;strong&gt;乱码&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;A页面的按钮代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;protected void Button1_Click(object sender, EventArgs e)
         {
             string param = &quot;阿道夫&quot;;
             Response.Redirect(&quot;~/Default.aspx?param=&quot; + HttpUtility.UrlEncode(param));
         }&lt;/pre&gt;
&lt;p&gt;B页面的接收代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;string param1 = Request.QueryString[&quot;param&quot;];&lt;/pre&gt;
&lt;p&gt;参考上面的解释，应该能理解为何第四种是乱码，这里不再做太多解释&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外在jquery被大行其道的现在，&lt;/strong&gt;$.ajax{}、$.post()、$.get()等函数使用时更是应该注意编码解码的问题，大致注意如下：&lt;br&gt;
如果你的页面使用的是gb2312编码，不要用jquery的$.get()或$.post()做ajax提交，因为这两个方法默认为utf-8，而且是无法指定修改contentType的，默认为：contentType:”pplication/x-www-form-urlencoded; charset=UTF-8″，为什么无法修改？因为$.post 和$.get()本身就只是 $.ajax 的 post 或者get方式的一种简写形式，既然是简写为了方便使用当然会固定死很多属性&lt;br&gt;
可以用$.ajax()并在其中加入：contentType:”application/x-www-form-urlencoded; charset=GB2312″;&lt;br&gt;
写成以下形式，可以在大多数情况避免乱码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$.ajax({ 
  type: &quot;POST&quot;,
 contentType:&quot;pplication/x-www-form-urlencoded; charset=GB2312&quot;, 
  url: &quot;XXX“, 
  data: {},
  success: function(msg){ alert( msg ); }
});&lt;/pre&gt;
&lt;p&gt;*****以上使用get提交form方式的介绍真的可以告一段落，我想我写的很臃肿，表达上会有很多冗余的地方******&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面介绍post提交form的方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在asp.net页面的form不做任何处理的时候，默认编译生成html时会自动加上method=”post” ，F12调试，发现Content-Type的值是：application/x-www-form-urlencoded，这也是我上面提到过的Form元素的EncType属性：表明提交数据的格式&lt;br&gt;
一般Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型。&lt;br&gt;
application/x-www-form-urlencoded： 窗体数据被编码为名称/值对。这是标准的编码格式。&lt;br&gt;
multipart/form-data： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。&lt;br&gt;
text/plain： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符&lt;/p&gt;
&lt;p&gt;那也就是说，假如我使用post方式提交，Enctype为application/x-www-form-urlencoded，那么那些需要提交服务器的值依然会被编码，只不过这次不是拼接在uri后面，而是存放在body里面，那么这样依然在不小心的情况下会带来上面描述的乱码问题，当然如果你是post提交，（或者你在asp.net页面不操作form任何属性，保持默认）那么在cs服务端请不要再用Request.QueryString获取值了，这是获取不到的，应该用Request.Form[&quot;&quot;]，请尽量少用Request[&quot;&quot;]或者Request.Params[&quot;&quot;]，这两个将加大你的遍历搜索你需要参数值的范围，Request可以访问的有QueryString、Form、Cookies 或 ServerVariables这4个集合的数据，get请求用Request.QueryString，post用Request.Form，而Request[&quot;&quot;]是依次访问这4个集合，找到就返回结果，而Request.Params[&quot;&quot;]是在访问时，先将4个集合的数据合并到一个新集合(集合不存在时创建)再去查找，效率可想而知&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;我现在手动将form改为：&amp;lt;form id=”form1″ enctype=”multipart/form-data” method=”post” runat=”server”&amp;gt; 注意multipart/form-data只能用于post&lt;/p&gt;
&lt;p&gt;浏览器会把整个表单以控件为单位分割，并为每个部分加上Content-Disposition(form-data或者file),Content-Type(默认为text/plain),name(控件name)等信息，并加上分割符&lt;br&gt;
&lt;strong&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/aa207300263aceddce82a73190123285.jpg&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/14392398024ed2438b738da2f602714f.jpg&quot;&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“boundary”是分隔符的意思，一般multipart/form-data用于文件上传，普通的传参或者提交form元素列表值还是使用默认的application/x-www-form-urlencoded吧&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Thu, 06 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-06-79424-c859d07eb.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-06-79424-c859d07eb.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的Git笔记</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;转眼间加入git的阵营已经快两年了，结识git，缘起github，2年前在寻找代码托管网站，当时还是用svn，起初使用google code，可是google的服务虽好，在天朝你懂得，后来发现了github，多亏了蒋鑫老师的《GotGitHub》将我带入github的大门，如果你是个github新手，那我强烈建议你阅读这篇文章，里面讲了很多东西。&lt;/p&gt;
&lt;p&gt;起初的时候我是用github for windows这个客户端，在切换到多分支的时候被，自动转换换行符坑的不浅，后来越来阅读了《&lt;a href=&quot;http://www.open-open.com/lib/view/open1328069609436.html&quot; target=&quot;_blank&quot;&gt;git详解&lt;/a&gt;》系列文章，对git的了解深入了一步，并开始转到命令行上来，如今我在github上开源了60几个库，借助git，可自由在这些项目之间穿梭，同时还维护了github家园的微博和Q群(193091696)，如果你想获取关于git和github的最新消息可以关注微博，如果你有什么疑问或者问题，欢迎加群一起讨论。&lt;/p&gt;
&lt;p&gt;这篇文章记录个人常用的一些命令，和记不住的一些命令。&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;在 Windows 上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;http://msysgit.github.io/&lt;/pre&gt;
&lt;p&gt;完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;首先是配置帐号信息&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git config --global user.name yanhaijing
git config --global user.email yanhaijing@yeah.net

git config --list#查看配置的信息

git help config#获取帮助信息&lt;/pre&gt;
&lt;p&gt;配置自动换行（自动转换坑太大）&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git config --global core.autocrlf input #提交到git是自动将换行符转换为lf&lt;/pre&gt;
&lt;p&gt;配置密钥&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;ssh-keygen -t rsa -C yanhaijing@yeah.net #生成密钥

ssh -T git@github.com #测试是否成功&lt;/pre&gt;
&lt;h2 id=&quot;section-2&quot;&gt;新建仓库&lt;/h2&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git init#初始化
git status#获取状态
git add file#.或*代表全部添加
git commit -m &quot;message&quot;#此处注意乱码
git remote add origin git@github.com:yanhaijing/test.git#添加源
git push -u origin master#push同事设置默认跟踪分支&lt;/pre&gt;
&lt;h2 id=&quot;section-3&quot;&gt;从现有仓库克隆&lt;/h2&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git clone git://github.com/yanhaijing/data.js.git	
git clone git://github.com/schacon/grit.git mypro#克隆到自定义文件夹&lt;/pre&gt;
&lt;h2 id=&quot;section-4&quot;&gt;本地&lt;/h2&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git add *#跟踪新文件

rm *&amp;amp;git rm *#移除文件
git rm -f *#移除文件
git rm --cached *#取消跟踪
git mv file_from file_to#重命名跟踪文件

git log#查看提交记录

git commit#提交更新
git commit -m &#39;message&#39;
git commit -a#跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交
git commit --amend#修改最后一次提交

git reset HEAD *#取消已经暂存的文件

git checkout -- file#取消对文件的修改（从暂存区去除file）
git checkout branch|tag|commit -- file_name#从仓库取出file覆盖当前分支
git checkout -- .#从暂存区去除文件覆盖工作区&lt;/pre&gt;
&lt;h2 id=&quot;section-5&quot;&gt;分支&lt;/h2&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git branch#列出本地分支
git branch -r#列出远端分支
git branch -a#列出所有分支
git branch -v#查看各个分支最后一个提交对象的信息
git branch --merge#查看已经合并到当前分支的分支
git branch --no-merge#查看为合并到当前分支的分支

git branch test#新建test分支
git checkout test#切换到test分支
git checkout -b test#新建+切换到test分支
git checkout -b test dev#基于dev新建test分支，并切换

git branch -d test#删除test分支
git branch -D test#强制删除test分支

git merge test#将test分支合并到当前分支
git rebase master#将master分之上超前的提交，变基到当前分支&lt;/pre&gt;
&lt;h2 id=&quot;section-6&quot;&gt;远端&lt;/h2&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git fetch originname branchname#拉去远端上指定分支
git merge originname branchname#合并远端上指定分支
git push originname branchname#推送到远端上指定分支
git push originname localbranch:serverbranch#推送到远端上指定分支

git checkout -b test origin/dev#基于远端dev新建test分支

git push origin :server#删除远端分支&lt;/pre&gt;
&lt;h2 id=&quot;section-7&quot;&gt;源&lt;/h2&gt;
&lt;p&gt;git是一个分布式代码管理工具，所以可以支持多个仓库，在git里，服务器上的仓库在本地称之为remote。&lt;/p&gt;
&lt;p&gt;个人开发时，多源用的可能不多，但多源其实非常有用。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git remote add origin1 git@github.com:yanhaijing/data.js.git

git remote#显示全部源
git remote -v#显示全部源+详细信息

git remote rename origin1 origin2#重命名

git remote rm origin1#删除

git remote show origin1#查看指定源的全部信息&lt;/pre&gt;
&lt;h2 id=&quot;section-8&quot;&gt;标签&lt;/h2&gt;
&lt;p&gt;当开发到一定阶段时，给程序打标签是非常棒的功能。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git tag#列出现有标签	

git tag v0.1#新建标签
git tag -a v0.1 -m &#39;my version 1.4&#39;#新建带注释标签

git checkout tagname#切换到标签

git push origin v1.5#推送分支到源上
git push origin --tags#一次性推送所有分支

git tag -d v0.1#删除标签
git push origin :refs/tags/v0.1#删除远程标签&lt;/pre&gt;
&lt;h2 id=&quot;section-9&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;啊哈！终于总结完了，以后不会的时候，再也不用到处去找了。&lt;/p&gt;
&lt;p&gt;其实还有两个最有用的命令还未提到。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git help *#获取命令的帮助信息
git status#获取当前的状态，非常有用，因为git会提示接下来的能做的事情&lt;/pre&gt;
&lt;h2 id=&quot;section-10&quot;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://gitref.org/zh/index.html&quot;&gt;Git参考手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mceiba.com/tool/git-cheat-sheet.html&quot;&gt;Git简明手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/&quot;&gt;Git Magic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gitbook.liuhui998.com/index.html&quot;&gt;Git Community Book 中文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git-scm.com/book/en/v2&quot;&gt;Pro Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://marklodato.github.io/visual-git-guide/index-zh-cn.html&quot;&gt;图解Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://rogerdudler.github.io/git-guide/index.zh.html&quot;&gt;git-简明指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pcottle.github.io/learnGitBranching/&quot;&gt;learnGitBranching&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Thu, 06 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-06-79417-b73b5e65d.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-06-79417-b73b5e65d.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>如何简单解释 MapReduce 算法</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在Hackbright做导师期间，我被要求向技术背景有限的学生解释&lt;a href=&quot;https://en.wikipedia.org/wiki/MapReduce&quot;&gt;MapReduce算法&lt;/a&gt;，于是我想出了一个有趣的例子，用以阐释它是如何工作的。&lt;/p&gt;
&lt;h2&gt;例子&lt;/h2&gt;
&lt;p&gt;你想数出一摞牌中有多少张黑桃。直观方式是一张一张检查并且数出有多少张是黑桃。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c97c630b70a357d86c6b14106640b8f5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;MapReduce方法则是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给在座的所有玩家中分配这摞牌&lt;/li&gt;
&lt;li&gt;让每个玩家数自己手中的牌有几张是黑桃，然后把这个数目汇报给你&lt;/li&gt;
&lt;li&gt;你把所有玩家告诉你的数字加起来，得到最后的结论&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;谷歌在2004年发表了可以分析大量数据的&lt;a href=&quot;http://research.google.com/archive/mapreduce.html&quot;&gt;MapReduce&lt;/a&gt;算法。每当你听到“大数据”这个词时，它指的是因为太大而让仅仅一台机器难以有效存储或分析的问题。MapReduce通过把计算量分配给不同的计算机群，能够解决大部分和大数据有关的分析问题。&lt;a href=&quot;https://en.wikipedia.org/wiki/Apache_Hadoop&quot;&gt;Hadoop&lt;/a&gt;提供了最受欢迎的利用MapReduce算法来管理大数据的开源方式。现今MapReduce是主流。&lt;/p&gt;
&lt;p&gt;所以通常来说，每当你听到“大数据”，那也许意味着Hadoop被用来存储数据，也通常意味着数据的抽取和检索是用的MapReduce。&lt;/p&gt;
&lt;h2&gt;拆分&lt;/h2&gt;
&lt;p&gt;MapReduce合并了两种经典函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;映射（Mapping）&lt;/strong&gt;对集合里的每个目标应用同一个操作。即，如果你想把表单里每个单元格乘以二，那么把这个函数单独地应用在每个单元格上的操作就属于mapping。&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;化简（Reducing ）&lt;/strong&gt;遍历集合中的元素来返回一个综合的结果。即，输出表单里一列数字的和这个任务属于reducing。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;重新审视上面的例子&lt;/h2&gt;
&lt;p&gt;重新审视我们原来那个分散纸牌的例子，我们有MapReduce数据分析的基本方法。友情提示：这不是个严谨的例子。在这个例子里，人代表计算机，因为他们同时工作，所以他们是个&lt;strong&gt;集群&lt;/strong&gt;。在大多数实际应用中，我们假设数据已经在每台计算机上了 – 也就是说把牌分发出去并不是MapReduce的一步。（事实上，在计算机集群中如何存储文件是Hadoop的真正核心。）&lt;/p&gt;
&lt;p&gt;通过把牌分给多个玩家并且让他们各自数数，你就在&lt;strong&gt;并行&lt;/strong&gt;执行运算，因为每个玩家都在同时计数。这同时把这项工作变成了&lt;strong&gt;分布式的&lt;/strong&gt;，因为多个不同的人在解决同一个问题的过程中并不需要知道他们的邻居在干什么。&lt;/p&gt;
&lt;p&gt;通过告诉每个人去数数，你对一项检查每张牌的任务进行了映射。 你不会让他们把黑桃牌递给你，而是让他们把你想要的东西化简为一个数字。&lt;/p&gt;
&lt;p&gt;另外一个有意思的情况是牌分配得有多均匀。MapReduce假设数据是&lt;strong&gt;洗过的&lt;/strong&gt;（&lt;strong&gt;shuffled&lt;/strong&gt;）- 如果所有黑桃都分到了一个人手上，那他数牌的过程可能比其他人要慢很多。&lt;/p&gt;
&lt;p&gt;如果有足够的人的话，问一些更有趣的问题就相当简单了 - 比如“一摞牌的平均值（二十一点算法）是什么”。你可以通过合并“所有牌的值的和是什么”及“我们有多少张牌”这两个问题来得到答案。用这个和除以牌的张数就得到了平均值。&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;MapReduce算法的机制要远比这复杂得多，但是主体思想是一致的 – 通过分散计算来分析大量数据。无论是Facebook、NASA，还是小创业公司，MapReduce都是目前分析互联网级别数据的主流方法。有趣的是，MapReduce在多于10PB数据时趋向于变慢，所以谷歌在他们今年的IO大会上报告称MapReduce已经不够他们用了，请参见这篇资讯《&lt;strong&gt;&lt;a href=&quot;../72145/&quot; target=&quot;_blank&quot;&gt;谷歌弃用 MapReduce, 推出替代品 Cloud Dataflow&lt;/a&gt;&lt;/strong&gt;》。&lt;/p&gt;
&lt;h3&gt;推荐阅读：《&lt;a href=&quot;../1321/&quot; target=&quot;_blank&quot;&gt;我是如何向老婆解释MapReduce的？&lt;/a&gt;》&lt;/h3&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Thu, 06 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-06-79255-b02567a57.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-06-79255-b02567a57.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>回收站功能在 Linux 中的实现</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;本文仿照 Windows 回收站的功能，运用 Bash 脚本在 Linux 上做了实现，创建 delete 脚本代替 rm 命令对文件或目录进行删除操做。该脚本实现了以下功能：对大于 2G 的文件或目录直接删除，否则放入$HOME/trash 目录下；恢复 trash 目录中的被删除文件到原目录下；文件存放在 trash 目录中超过七天被自动删除。&lt;/p&gt;
&lt;h2 id=&quot;2.概述 |outline&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;删除是危险系数很高的操作，一旦误删可能会造成难以估计的损失。在 Linux 系统中这种危险尤为明显，一条简单的语句：rm –rf /* 就会把整个系统全部删除，而 Linux 并不会因为这条语句的不合理而拒绝执行。 在 Windows 中，为了防止误删，系统提供了回收站功能。用户在执行删除操作后，文件并不会直接从硬盘中删除，而是被放到回收站中。在清空回收站前，如果发现有文件被误删，用户可以将回收站中的文件恢复到原来的位置。而 Linux 并没有提供类似功能，删除命令 rm 一旦确认执行，文件就会直接从系统中删除，很难恢复。&lt;/p&gt;
&lt;h2 id=&quot;3.回收站构成 |outline&quot;&gt;回收站构成&lt;/h2&gt;
&lt;p&gt;本文共用三个脚本实现了回收站的主要功能：Delete 脚本、logTrashDir 脚本和 restoreTrash 脚本。其中 Delete 脚本是核心脚本，其作用是重新封装 rm 命令。相对于 rm 的直接删除，该命令会先将文件或目录移动到$home/trash 目录下。如果用户想要将文件直接删除，可以用 -f 选项，delete 脚本会直接调用 rm –f 命令将文件从硬盘上删除。logTrashDir 脚本用于将被删除文件的信息记录到 trash 目录下的一个隐藏文件中。restoreTrash 脚本用来将放入 trash 中的文件或目录重新恢复到原路径下。在 Linux 系统中，只要将这三个脚本放到/bin/目录下，并用 chmod +X filename 赋予可执行权限，即可直接使用。下面将介绍每个脚本的主要部分&lt;/p&gt;
&lt;h2 id=&quot;4.Delete 脚本 |outline&quot;&gt;Delete 脚本&lt;/h2&gt;
&lt;h3 id=&quot;N1005A&quot;&gt;创建目录&lt;/h3&gt;
&lt;p&gt;首先要创建目录来存放被删除的文件，本文在用户根目录$HOME 下建立 trash 目录来存放文件。具体代码如下：&lt;/p&gt;
&lt;h5 id=&quot;N10063&quot;&gt;清单 1.创建回收站目录&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;realrm=&quot;/bin/rm&quot;
if [ ! -d ~/trash ]
 then
      mkdir -v ~/trash
      chmod 777 ~/trash
 fi&lt;/pre&gt;
&lt;p&gt;如上所示，先判断目录是否已建立，如未建立，即第一次运行该脚本，则创建 trash 目录。变量 realrm 存放了 Linux 的 rm 脚本位置，用于在特定条件下调用以直接删除文件或目录。&lt;/p&gt;
&lt;h3 id=&quot;N1006A&quot;&gt;输出帮助信息&lt;/h3&gt;
&lt;p&gt;该脚本在用户仅输入脚本名而未输入参数执行时，输出简要帮助信息，代码如下：&lt;/p&gt;
&lt;h5 id=&quot;N10073&quot;&gt;清单 2.输出帮助信息&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;if [ $# -eq 0 ]
  then
      echo &quot;Usage:delete file1 [file2 file3....]&quot;
      echo &quot;If the options contain -f,then the script will exec &#39;rm&#39; directly&quot;&lt;/pre&gt;
&lt;p&gt;如代码所示，该脚本的运用格式是 delete 后跟要删除的文件或目录的路径，中间用空格隔开。&lt;/p&gt;
&lt;h3 id=&quot;N1007A&quot;&gt;直接删除文件&lt;/h3&gt;
&lt;p&gt;有些用户确认失效并想直接删除的文件，不应放入回收站中，而应直接从硬盘中删除。Delete 脚本提供了-f 选项来执行这项操作：&lt;/p&gt;
&lt;h5 id=&quot;N10083&quot;&gt;清单 3.直接删除文件&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;while getopts &quot;dfiPRrvW&quot; opt
      do
        case $opt in
            f)
               exec $realrm &quot;$@&quot;
                ;;
            *)
               
               # do nothing     
                ;;
        esac
      done&lt;/pre&gt;
&lt;p&gt;如果用户在命令中加入了-f 选项，则 delete 脚本会直接调用 rm 命令将文件或目录直接删除。如代码中所示，所有的参数包括选项都会传递给 rm 命令。所以只要选项中包括选项-f 就等于调用 rm 命令，可以使用 rm 的所有功能。如：delete –rfv filename 等于 rm –rfv filename。&lt;/p&gt;
&lt;h3 id=&quot;N1008A&quot;&gt;用户交互&lt;/h3&gt;
&lt;p&gt;需要与用户确认是否将文件放入回收站。相当于 Windows 的弹窗提示，防止用户误操作。&lt;/p&gt;
&lt;h5 id=&quot;N10093&quot;&gt;清单 4.用户交互&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;echo -ne &quot;Are you sure you want to move the files to the trash?[Y/N]:\a&quot;
 read reply
if [ $reply = &quot;y&quot; -o $reply = &quot;Y&quot; ]
  then #####&lt;/pre&gt;
&lt;h3 id=&quot;N10098&quot;&gt;判断文件类型并直接删除大于 2G 文件&lt;/h3&gt;
&lt;p&gt;本脚本只对普通文件和目录做操作，其他类型文件不做处理。先对每个参数做循环，判断他们的类型，对于符合的类型再判断他们的大小是否超过 2G，如果是则直接从系统中删除，避免回收站占用太大的硬盘空间。&lt;/p&gt;
&lt;h5 id=&quot;N100A1&quot;&gt;清单 5.删除大于 2G 的文件&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;for file in $@
 do
if [ -f &quot;$file&quot; –o –d &quot;$file&quot; ]
then
if [ -f &quot;$file&quot; ] &amp;amp;&amp;amp; [ `ls –l $file|awk &#39;{print $5}&#39;` -gt 2147483648 ]
   then
      echo &quot;$file size is larger than 2G,will be deleted directly&quot;
        `rm –rf $file`
elif [ -d &quot;$file&quot; ] &amp;amp;&amp;amp; [ `du –sb $file|awk &#39;{print $1}&#39;` -gt 2147483648 ]
   then
      echo &quot;The directory:$file is larger than 2G,will be deleted directly&quot;
        `rm –rf $file`&lt;/pre&gt;
&lt;p&gt;如以上代码所示，该脚本用不同的命令分别判断目录和文件的大小。鉴于目录的大小应该是包含其中的文件以及子目录的总大小，所以运用了’du -sb’命令。两种情况都使用了 awk 来获取特定输出字段的值来作比较。&lt;/p&gt;
&lt;h3 id=&quot;N100A8&quot;&gt;移动文件到回收站并做记录&lt;/h3&gt;
&lt;p&gt;该部分是 Delete 脚本的主要部分，主要完成以下几个功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取参数的文件名。因为用户指定的参数中可能包含路径，所以要从中获取到文件名，用来生成 mv 操作的参数。该脚本中运用了字符串正则表达式’${file##*/}’来获取。&lt;/li&gt;
&lt;li&gt;生成新文件名。在原文件名中加上日期时间后缀以生成新的文件名，这样用户在浏览回收站时，对于每个文件的删除日期即可一目了然。&lt;/li&gt;
&lt;li&gt;生成被删文件的绝对路径。为了以后可能对被删文件进行的恢复操作，要从相对路径生成绝对路径并记录。用户输入的参数可能有三种情况：只包含文件名的相对路径，包含点号的相对路径以及绝对路径，脚本中用字符串处理对三种情况进行判断，并进行相应的处理。&lt;/li&gt;
&lt;li&gt;调用 logTrashDir 脚本，将回收站中的新文件名、原文件名、删除时间、原文件绝对路径记录到隐藏文件中&lt;/li&gt;
&lt;li&gt;将文件通过 mv 命令移动到 Trash 目录下。详细代码如下所示：&lt;br&gt;
&lt;h5 id=&quot;N100BE&quot;&gt;清单 6.移动文件到回收站并做记录&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;now=`date +%Y%m%d_%H_%M_%S`
filename=&quot;${file##*/}&quot;
newfilename=&quot;${file##*/}_${now}&quot;
mark1=&quot;.&quot;
mark2=&quot;/&quot;
if  [ &quot;$file&quot; = ${file/$mark2} ]
 then
  fullpath=&quot;$(pwd)/$file&quot;
elif [ &quot;$file&quot; != ${file/$mark1} ]
 then
  fullpath=&quot;$(pwd)${file/$mark1}&quot;
else
  fullpath=&quot;$file&quot;
fi	    
echo &quot;the full path of this file is :$fullpath&quot;
if mv -f $file ~/trash/$newfilename
 then
  $(/logTrashDir &quot;$newfilename $filename $now $fullpath&quot;)
   echo &quot;files: $file is deleted&quot;
 else
  echo &quot;the operation is failed&quot;
 fi&lt;/pre&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2 id=&quot;5.logTrashDir 脚本 |outline&quot;&gt;logTrashDir 脚本&lt;/h2&gt;
&lt;p&gt;该脚本较简单，仅是一个简单的文件写入操作，之所以单独作为一个脚本，是为了以后扩展的方便，具体代码如下：&lt;/p&gt;
&lt;h5 id=&quot;N100CC&quot;&gt;清单 7.logTrashDir 代码&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;if [ ! -f ~/trash/.log ]
  then
     touch ~/trash/.log
     chmod 700~/trash/.log
fi
   echo $1 $2 $3 $4&amp;gt;&amp;gt; ~/trash/.log&lt;/pre&gt;
&lt;p&gt;该脚本先建立.log 隐藏文件，然后往里添加删除文件的记录。&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2 id=&quot;6.restoreTrash 脚本 |outline&quot;&gt;restoreTrash 脚本&lt;/h2&gt;
&lt;p&gt;该脚本主要完成以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从.log 文件中找到用户想要恢复的文件对应的记录。此处依然使用 awk，通过正表达式匹配找到包含被删除文件名的一行&lt;/li&gt;
&lt;li&gt;从记录中找到记录原文件名的字段，以给用户提示&lt;/li&gt;
&lt;li&gt;将回收站中的文件移动到原来的位置，在这里运用了 mv –b 移动文件，之所以加入-b 选项是为了防止原位置有同名文件的情况。&lt;/li&gt;
&lt;li&gt;将.log 文件中与被恢复文件相对应的记录删除&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;N100E5&quot;&gt;清单 8.获取相应记录&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;originalPath=$(awk /$filename/&#39;{print $4}&#39; &quot;$HOME/trash/.log&quot;)&lt;/pre&gt;
&lt;h5 id=&quot;N100EC&quot;&gt;清单 9.查找原文件名及现文件名字段&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;filenameNow=$(awk /$filename/&#39;{print $1}&#39; ~/trash/.log)
filenamebefore=$(awk /$filename/&#39;{print $2}&#39; ~/trash/.log)
echo &quot;you are about to restore $filenameNow,original name is $filenamebefore&quot;
echo &quot;original path is $originalPath&quot;&lt;/pre&gt;
&lt;h5 id=&quot;N100F3&quot;&gt;清单 10.恢复文件到原来位置并删除相应记录&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;echo &quot;Are you sure to do that?[Y/N]&quot;
  read reply
  if [ $reply = &quot;y&quot; ] || [ $reply = &quot;Y&quot; ]
   then
$(mv -b &quot;$HOME/trash/$filename&quot; &quot;$originalPath&quot;)
$(sed -i /$filename/&#39;d&#39; &quot;$HOME/trash/.log&quot;)
  else
    echo &quot;no files restored&quot;
  fi&lt;/pre&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2 id=&quot;7.自动定期清理 trash 目录 |outline&quot;&gt;自动定期清理 trash 目录&lt;/h2&gt;
&lt;p&gt;因为 delete 操作并不是真正删除文件，而是移动操作，经过一段时间的积累，trash 目录可能会占用大量的硬盘空间，造成资源浪费，所以定期自动清理 trash 目录下的文件是必须得。本文的清理规则是：在回收站中存在 7 天以上的文件及目录将会被自动从硬盘中删除。运用的工具是 Linux 自带的 crontab。&lt;/p&gt;
&lt;p&gt;Crontab 是 Linux 用来定期执行程序的命令。当安装完成操作系统之后，默认便会启动此任务调度命令。Crontab 命令会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。而 Linux 任务调度的工作主要分为以下两类：&lt;/p&gt;
&lt;p&gt;1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存&lt;/p&gt;
&lt;p&gt;2、个人执行的工作：某个用户定期要做的工作，例如每隔 10 分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置。&lt;/p&gt;
&lt;p&gt;首先编写 crontab 执行时要调用的脚本 cleanTrashCan.如清单 10 所示，该脚本主要完成两项功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断回收站中的文件存放时间是否已超过 7 天，如果超过则从回收站中删除。&lt;/li&gt;
&lt;li&gt;将删除文件在.log 文件中相应的记录删除，保持其中数据的有效性，提高查找效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;N1010E&quot;&gt;清单 11.删除存在回收站超过 7 天的文件并删除.log 中相应记录&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;arrayA=($(find ~/trash/* -mtime +7 | awk &#39;{print $1}&#39;))
   for file in ${arrayA[@]}
    do
      $(rm -rf &quot;${file}&quot;)
      filename=&quot;${file##*/}&quot;
      echo $filename
      $(sed -i /$filename/&#39;d&#39; &quot;$HOME/trash/.log&quot;)
    done&lt;/pre&gt;
&lt;p&gt;脚本编写完成后通过 chmod 命令赋予其执行权限，然后运过 crontab –e 命令添加一条新的任务调度：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt; 10 18 * * * /bin/ cleanTrashCan&lt;/pre&gt;
&lt;p&gt;该语句的含义为，在每天的下午 6 点 10 分执行 cleanTrashCan 脚本&lt;/p&gt;
&lt;p&gt;通过这条任务调度，trash 的大小会得到有效的控制，不会持续增大以致影响用户的正常操作。&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2 id=&quot;8.实际应用 |outline&quot;&gt;实际应用&lt;/h2&gt;
&lt;p&gt;首先要将 delete 脚本，logTrashDir 脚本，restoreTrash 脚本和 cleanTrashCan 放到/bin 目录下，然后用 chmod +x delete restoreTrash logTrashDir cleanTrashCan 命令赋予这三个脚本可执行权限。&lt;/p&gt;
&lt;p&gt;运用 delete 脚本删除文件，例如要删除在/usr 目录下的 useless 文件。根据用户目前所在的位置，可以用相对路径或绝对路径来指定参数，如：delete useless，delete ./useless 或者 delete /usr/useless。执行过程如图 1 所示：&lt;/p&gt;
&lt;h5 id=&quot;N10127&quot;&gt;图 1.delete 脚本执行过程&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/1488ffe8dd392a8caf548028f6ee49ff.jpg&quot; rel=&quot;lightbox[79313]&quot; title=&quot;回收站功能在 Linux 中的实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-79397&quot; alt=&quot;image003&quot; src=&quot;/images/jobbole.com/9bf0193aaae730616666828d81018cfe.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;执行之后，useless 文件会从原目录中删除，被移动到$HOME/trash 下，并被重命名，如图 2.所示：&lt;/p&gt;
&lt;h5 id=&quot;N10135&quot;&gt;图 2.回收站目录&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/c62874c0b0fb36caec0c9c26d00f6301.jpg&quot; rel=&quot;lightbox[79313]&quot; title=&quot;回收站功能在 Linux 中的实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-79398&quot; alt=&quot;image005&quot; src=&quot;/images/jobbole.com/5e42f2c8e37cb677ed7962b7be5d6792.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/6df787e911e282b998946f932177ffaa.jpg&quot; rel=&quot;lightbox[79313]&quot; title=&quot;回收站功能在 Linux 中的实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-79399&quot; alt=&quot;image007&quot; src=&quot;/images/jobbole.com/5ed7d99913240815f1e8cb98a9482af3.jpg&quot;&gt;&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;生成的.log 记录如图 3.所示：&lt;/p&gt;
&lt;h5 id=&quot;N1014E&quot;&gt;图 3.log 记录&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/fb3cc01aca176dac4b8de5003863ba39.jpg&quot; rel=&quot;lightbox[79313]&quot; title=&quot;回收站功能在 Linux 中的实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-79400&quot; alt=&quot;image009&quot; src=&quot;/images/jobbole.com/4bad97bdbf03ecc07c57738085e6c2f7.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果用户在七天之内发现该文件还有使用价值，则可以使用 restoreTrash 命令将被删除文件恢复到原路径下：restoreTrash ~/trash/useless_20140923_06_28_57。具体执行情况如图 4 所示：&lt;/p&gt;
&lt;h5 id=&quot;N1015C&quot;&gt;图 4.restoreTrash 脚本执行情况&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/a647a44bbc8b903dec781d0417b2c587.jpg&quot; rel=&quot;lightbox[79313]&quot; title=&quot;回收站功能在 Linux 中的实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-79401&quot; alt=&quot;image011&quot; src=&quot;/images/jobbole.com/fd13b0000d0ab6c74919fb9cd121f79a.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看/usr 目录，可以发现 useless 文件已经被恢复至此。&lt;/p&gt;
&lt;h5 id=&quot;N1016A&quot;&gt;图 5.useless 文件被恢复&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/7b09d2a61e3388cf5918859e9f8197cc.jpg&quot; rel=&quot;lightbox[79313]&quot; title=&quot;回收站功能在 Linux 中的实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-79402&quot; alt=&quot;image013&quot; src=&quot;/images/jobbole.com/eeee368634807fbdf6270628e50ae8a8.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2 id=&quot;9.总结 |outline&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文仿照 Windows 中回收站的功能，在 Linux 中做了实现，可以有效的防止由于误删而造成的损失。读者只需要将四个脚本拷到/bin 目录下，并配置 crontab 即可使用 Linux 版回收站。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Wed, 05 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-05-79313-559cf949a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-05-79313-559cf949a.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>使用共享网口方式访问管理控制器</title>
        <description>

                &lt;p&gt;发现没有你的服务器会额外多出一个以太网口来，那个网口是专门用来访问管理控制器（BMC）的，当然也可以通过普通网口的共享模式访问BMC。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是共享网口方式？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里要简单地提到NC-SI（Network Controller – Sideband Interface）技术，即网络控制器边带接口技术。这一技术是用来实现BMC芯片和以太网控制器之间信息传递的，它使得BMC芯片能够像使用独立管理网口那样使用主板上的网络接口。以下是共享访问模式的实现结构图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://noops.me/wp-content/uploads/2014/11/NCSI.png&quot;&gt;&lt;img class=&quot;wp-image-1719 alignnone&quot; alt=&quot;NCSI&quot; src=&quot;/images/noops.me/e9e2dbaca60b8e9f6f7652441345c7ac.jpg&quot; width=&quot;363&quot; height=&quot;398&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单理解：&lt;/strong&gt;BMC其实是一个单片机，它有自己独立的IO设备，而独立网口就是其中之一。将BMC芯片和网络控制器互联，通过NC-SI技术使得BMC芯片能够使用网络控制器上的接口。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为何要使用共享网口访问管理控制器？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、减少物料成本：共享访问模式能够为单机节省一根网线；&lt;/p&gt;
&lt;p&gt;2、减少人力成本：如果业务网只需要接一根网线，共享方案可以减少一半的布线人力支出；&lt;/p&gt;
&lt;p&gt;3、减少交换机投入：独立网口会多占用一个交换机端口，增加交换机采购数量，使用共享模式减少了这部分的支出和额外的交换机运维成本；&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何实现共享网口模式？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、BIOS或者WEB bmc界面中将IPMI访问方式修改为share（共享模式）；&lt;/p&gt;
&lt;p&gt;2、为共享网口独立分配一个VLAN号和IP地址，以便和业务网剥离；&lt;/p&gt;
&lt;p&gt;3、在交换机端开启802.1q协议，并分配相同的VLAN号。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
            

</description>
        <pubDate>Wed, 05 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-05--p=1717-4732406e0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-05--p=1717-4732406e0.html</guid>
        
        
        <category>noops</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（12）：无向图相关算法基础</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;从这篇文章开始介绍图相关的算法，这也是&lt;a href=&quot;http://algs4.cs.princeton.edu/home/&quot; target=&quot;_blank&quot;&gt;Algorithms&lt;/a&gt;在线课程&lt;a href=&quot;https://www.coursera.org/#course/algs4partII?from_restricted_preview=1&amp;amp;course_id=971968&amp;amp;r=https%3A%2F%2Fclass.coursera.org%2Falgs4partII-003%2Fclass&quot; target=&quot;_blank&quot;&gt;第二部分&lt;/a&gt;的第一次课程笔记。 图的应用很广泛，也有很多非常有用的算法，当然也有很多待解决的问题，根据性质，图可以分为无向图和有向图。本文先介绍无向图，后文再介绍有向图。 之所以要研究图，是因为图在生活中应用比较广泛： &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/281a402386e50e0176a1b28df5bd6fe3.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;无向图&lt;/h1&gt;
&lt;p&gt;图是若干个顶点(Vertices)和边(Edges)相互连接组成的。边仅由两个顶点连接，并且没有方向的图称为无向图。 在研究图之前，有一些定义需要明确，下图中表示了图的一些基本属性的含义，这里就不多说明。 &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1d0f2fd14ae888242892157aa71b825d.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;图的API 表示&lt;/h1&gt;
&lt;p&gt;在研究图之前，我们需要选用适当的数据结构来表示图，有时候，我们常被我们的直觉欺骗,如下图，这两个其实是一样的，这其实也是一个研究问题，就是如何判断图的形态。 &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f3a626a25d4cd54d624731988722b5dc.jpg&quot;&gt; 要用计算机处理图，我们可以抽象出以下的表示图的API： &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/19981f4ad3e90b0558cff6bb0cfa20d0.jpg&quot;&gt;   Graph的API的实现可以由多种不同的数据结构来表示，最基本的是维护一系列边的集合，如下： &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e25bb88a24d263587cca56c2ef6b7af0.jpg&quot;&gt; 还可以使用邻接矩阵来表示： &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/eeff167cf0bd7ae3fb245b661110e0b1.jpg&quot;&gt; 也可以使用邻接列表来表示： &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f6177ca2f5abc5100f28de044d980f76.jpg&quot;&gt; 由于采用如上方式具有比较好的灵活性，采用邻接列表来表示的话，可以定义如下数据结构来表示一个Graph对象。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public class Graph
{
    private readonly int verticals;//顶点个数
    private int edges;//边的个数
    private List&amp;lt;int&amp;gt;[] adjacency;//顶点联接列表

    public Graph(int vertical)
    {
        this.verticals = vertical;
        this.edges = 0;
        adjacency=new List&amp;lt;int&amp;gt;[vertical];
        for (int v = 0; v &amp;lt; vertical; v++)
        {
            adjacency[v]=new List&amp;lt;int&amp;gt;();
        }
    }

    public int GetVerticals ()
    {
        return verticals;
    }

    public int GetEdges()
    {
        return edges;
    }

    public void AddEdge(int verticalStart, int verticalEnd)
    {
        adjacency[verticalStart].Add(verticalEnd);
        adjacency[verticalEnd].Add(verticalStart);
        edges++;
    }

    public List&amp;lt;int&amp;gt; GetAdjacency(int vetical)
    {
        return adjacency[vetical];
    }
}&lt;/pre&gt;
&lt;p&gt;图也分为稀疏图和稠密图两种，如下图： 在这两个图中，顶点个数均为50，但是稀疏图中只有200个边，稠密图中有1000个边。在现实生活中，大部分都是稀疏图，即顶点很多，但是顶点的平均度比较小。 &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c528c9c220f06d0f3c84be6a573a9ded.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;采用以上三种表示方式的效率如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a3251c7332283fc3944e2551158a2b49.jpg&quot;&gt; 在讨论完图的表示之后，我们来看下在图中比较重要的一种算法，即深度优先算法：&lt;/p&gt;
&lt;h1&gt;深度优先算法&lt;/h1&gt;
&lt;p&gt;在谈论深度优先算法之前，我们可以先看看迷宫探索问题。下面是一个迷宫和图之间的对应关系： 迷宫中的每一个交会点代表图中的一个顶点，每一条通道对应一个边。 &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/772ba6c055bcce743a46bbf68e238f62.jpg&quot;&gt; 迷宫探索可以采用Trémaux绳索探索法。即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在身后放一个绳子&lt;/li&gt;
&lt;li&gt;访问到的每一个地方放一个绳索标记访问到的交会点和通道&lt;/li&gt;
&lt;li&gt;当遇到已经访问过的地方，沿着绳索回退到之前没有访问过的地方：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d85748347edf8e7b27d1ad48a8a92477.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面是迷宫探索的一个小动画：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a15724ee425637bccfa97971e3e3dcbf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;深度优先搜索算法模拟迷宫探索。在实际的图处理算法中，我们通常将图的表示和图的处理逻辑分开来。所以算法的整体设计模式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个Graph对象&lt;/li&gt;
&lt;li&gt;将Graph对象传给图算法处理对象，如一个Paths对象&lt;/li&gt;
&lt;li&gt;然后查询处理后的结果来获取信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是深度优先的基本代码，我们可以看到，递归调用dfs方法，在调用之前判断该节点是否已经被访问过。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public class DepthFirstSearch
{
    private bool[] marked;//记录顶点是否被标记
    private int count;//记录查找次数

    private DepthFirstSearch(Graph g, int v)
    {
        marked = new bool[g.GetVerticals()];
        dfs(g, v);
    }

    private void dfs(Graph g, int v)
    {
        marked[v] = true;
        count++;
        foreach (int vertical in g.GetAdjacency(v))
        {
            if (!marked[vertical])
                dfs(g,vertical);
        }
    }

    public bool IsMarked(int vertical)
    {
        return marked[vertical];
    }

    public int Count()
    {
        return count;
    }
}&lt;/pre&gt;
&lt;p&gt;试验一个算法最简单的办法是找一个简单的例子来实现。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/67090c38f1ab5433d6518fa0202a8530.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;深度优先路径查询&lt;/h1&gt;
&lt;p&gt;有了这个基础，我们可以实现基于深度优先的路径查询，要实现路径查询，我们必须定义一个变量来记录所探索到的路径。 所以在上面的基础上定义一个edgesTo变量来后向记录所有到s的顶点的记录，和仅记录从当前节点到起始节点不同，我们记录图中的&lt;strong&gt;每一个节点到开始节点的路径&lt;/strong&gt;。为了完成这一日任务，通过设置edgesTo[w]=v，我们记录从v到w的边，换句话说，v-w是做后一条从s到达w的边。 edgesTo[]其实是一个指向其父节点的树。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public class DepthFirstPaths
{
    private bool[] marked;//记录是否被dfs访问过
    private int[] edgesTo;//记录最后一个到当前节点的顶点
    private int s;//搜索的起始点

    public DepthFirstPaths(Graph g, int s)
    {
        marked = new bool[g.GetVerticals()];
        edgesTo = new int[g.GetVerticals()];
        this.s = s;
        dfs(g, s);
    }

    private void dfs(Graph g, int v)
    {
        marked[v] = true;
        foreach (int w in g.GetAdjacency(v))
        {
            if (!marked[w])
            {
                edgesTo[w] = v;
                dfs(g,w);
            }
        }
    }

    public bool HasPathTo(int v)
    {
        return marked[v];
    }

    public Stack&amp;lt;int&amp;gt; PathTo(int v)
    {

        if (!HasPathTo(v)) return null;
        Stack&amp;lt;int&amp;gt; path = new Stack&amp;lt;int&amp;gt;();

        for (int x = v; x!=s; x=edgesTo[x])
        {
            path.Push(x);
        }
        path.Push(s);
        return path;
    }
}&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/15a5e0ed8a1fab0165648706de7b1f99.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图中是黑色线条表示 深度优先搜索中，所有定点到原点0的路径， 他是通过edgeTo[]这个变量记录的，可以从右边可以看出，他其实是一颗树，树根即是原点，每个子节点到树根的路径即是从原点到该子节点的路径。 下图是深度优先搜索算法的一个简单例子的追踪。 &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9ebef2022ae76b87c7232cd4a4116fea.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;广度优先算法&lt;/h1&gt;
&lt;p&gt;通常我们更关注的是一类单源最短路径的问题，那就是给定一个图和一个源S，是否存在一条从s到给定定点v的路径，如果存在，找出最短的那条(这里最短定义为边的条数最小) 深度优先算法是将未被访问的节点放到一个堆中(stack)，虽然在上面的代码中没有明确在代码中写stack，但是 递归 间接的利用递归堆实现了这一原理。 和深度优先算法不同， 广度优先是将所有未被访问的节点放到了队列中。其主要原理是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 s放到FIFO中，并且将s标记为已访问&lt;/li&gt;
&lt;li&gt;重复直到队列为空&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;移除最近最近添加的顶点v&lt;/li&gt;
&lt;li&gt;将v未被访问的节点添加到队列中&lt;/li&gt;
&lt;li&gt;标记他们为已经访问&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;广度优先是以距离递增的方式来搜索路径的。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;class BreadthFirstSearch
{
    private bool[] marked;
    private int[] edgeTo;
    private int sourceVetical;//Source vertical

    public BreadthFirstSearch(Graph g, int s)
    {
        marked=new bool[g.GetVerticals()];
        edgeTo=new int[g.GetVerticals()];
        this.sourceVetical = s;
        bfs(g, s);
    }

    private void bfs(Graph g, int s)
    {
        Queue&amp;lt;int&amp;gt; queue = new Queue&amp;lt;int&amp;gt;();
        marked[s] = true;
        queue.Enqueue(s);
        while (queue.Count()!=0)
        {
            int v = queue.Dequeue();
            foreach (int w in g.GetAdjacency(v))
            {
                if (!marked[w])
                {
                    edgeTo[w] = v;
                    marked[w] = true;
                    queue.Enqueue(w);
                }
            }
        }
    }

    public bool HasPathTo(int v)
    {
        return marked[v];
    }

    public Stack&amp;lt;int&amp;gt; PathTo(int v)
    {
        if (!HasPathTo(v)) return null;

        Stack&amp;lt;int&amp;gt; path = new Stack&amp;lt;int&amp;gt;();
        for (int x = v; x!=sourceVetical; x=edgeTo[x])
        {
            path.Push(x);
        }
        path.Push(sourceVetical);
        return path;
    }

}&lt;/pre&gt;
&lt;p&gt;广度优先算法的搜索步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e73dcd5baceb57c2e5f9e1c7674a283b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;广度优先搜索首先是在距离起始点为1的范围内的所有邻接点中查找有没有到达目标结点的对象，如果没有，继续前进在距离起始点为2的范围内查找，依次向前推进。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bf29793cf204df37d99cd2b7b31bce5e.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;本文简要介绍了无向图中的深度优先和广度优先算法，这两种算法时图处理算法中的最基础算法，也是后续更复杂算法的基础。其中图的表示，图算法与表示的分离这种思想在后续的算法介绍中会一直沿用，下文将讲解无向图中深度优先和广度优先的应用，以及利用这两种基本算法解决实际问题的应用。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79314-87f96d168.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79314-87f96d168.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（10）：平衡查找树之B树</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;前面讲解了平衡查找树中的&lt;a href=&quot;http://blog.jobbole.com/79307/&quot; target=&quot;_blank&quot;&gt;2-3树&lt;/a&gt;以及其实现&lt;a href=&quot;http://blog.jobbole.com/79309/&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。&lt;/p&gt;
&lt;p&gt;维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化&lt;strong&gt;大块数据的读和写操作&lt;/strong&gt;。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在&lt;strong&gt;数据库&lt;/strong&gt;和&lt;strong&gt;文件系统&lt;/strong&gt;。”&lt;/p&gt;
&lt;h1&gt;定义&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;B 树&lt;/strong&gt;可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点至少有两个子节点&lt;/li&gt;
&lt;li&gt;每个节点有M-1个key，并且以升序排列&lt;/li&gt;
&lt;li&gt;位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间&lt;/li&gt;
&lt;li&gt;其它节点至少有M/2个子节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图是一个M=4 阶的B树:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/45405cb08b86ee13196ebd8be311063b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。&lt;/p&gt;
&lt;p&gt;B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;的演示动画：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a282c705ffbdda75d8418d001e96acf2.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B+&lt;/strong&gt;树是对B树的一种变形树，它与B树的差异在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有k个子结点的结点必然有k个关键码；&lt;/li&gt;
&lt;li&gt;非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。&lt;/li&gt;
&lt;li&gt;树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图，是一个B+树:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/31957106a84f5266130e197e34b1db63.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图是B+树的插入动画：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/99ce9d77c0d1f06671a272d22172f100.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。&lt;/p&gt;
&lt;p&gt;B+ 树的优点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。&lt;/li&gt;
&lt;li&gt;B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。下面是B 树和B+树的区别图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8ce4d99d4e222c7d6547373d3dabae39.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;分析&lt;/h1&gt;
&lt;p&gt;对B树和B+树的分析和对前面讲解的2-3树的分析类似，&lt;/p&gt;
&lt;p&gt;对于一颗节点为N度为M的子树，查找和插入需要log&lt;sub&gt;M-1&lt;/sub&gt;N ~ log&lt;sub&gt;M/2&lt;/sub&gt;N次比较。这个很好证明，对于度为M的B树，每一个节点的子节点个数为M/2 到 M-1之间，所以树的高度在log&lt;sub&gt;M-1&lt;/sub&gt;N至log&lt;sub&gt;M/&lt;/sub&gt;2N之间。&lt;/p&gt;
&lt;p&gt;这种效率是很高的，对于N=62*1000000000个节点，如果度为1024，则log&lt;sub&gt;M/2&lt;/sub&gt;N &amp;lt;=4，即在620亿个元素中，如果这棵树的度为1024，则只需要小于4次即可定位到该节点，然后再采用二分查找即可找到要找的值。&lt;/p&gt;
&lt;h1&gt;应用&lt;/h1&gt;
&lt;p&gt;B树和B+广泛应用于文件存储系统以及数据库系统中，在讲解应用之前，我们看一下常见的存储结构：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/80f04c9de87ecb82347fb7b7e18a9e1e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们计算机的主存基本都是随机访问存储器(Random-Access Memory，RAM)，他分为两类：静态随机访问存储器（SRAM）和动态随机访问存储器（DRAM）。SRAM比DRAM快，但是也贵的多，一般作为CPU的高速缓存，DRAM通常作为内存。这类存储器他们的结构和存储原理比较复杂，基本是使用电信号来保存信息的，不存在机器操作，所以访问速度非常快，具体的访问原理可以查看CSAPP，另外，他们是易失的，即如果断电，保存DRAM和SRAM保存的信息就会丢失。&lt;/p&gt;
&lt;p&gt;我们使用的更多的是使用磁盘，磁盘能够保存大量的数据，从GB一直到TB级，但是 他的读取速度比较慢，因为涉及到机器操作，读取速度为毫秒级，从DRAM读速度比从磁盘度快10万倍，从SRAM读速度比从磁盘读快100万倍。下面来看下磁盘的结构：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5bfaa0a35335326691c55ccf7797c122.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图，磁盘由盘片构成,每个盘片有两面，又称为盘面(Surface)，这些盘面覆盖有磁性材料。盘片中央有一个可以旋转的主轴(spindle)，他使得盘片以固定的旋转速率旋转，通常是5400转每分钟(Revolution Per Minute,RPM)或者是7200RPM。磁盘包含一个多多个这样的盘片并封装在一个密封的容器内。上图左，展示了一个典型的磁盘表面结构。每个表面是由一组成为磁道(track)的同心圆组成的，每个磁道被划分为了一组扇区(sector).每个扇区包含相等数量的数据位，通常是（512）子节。扇区之间由一些间隔(gap)隔开,不存储数据。&lt;/p&gt;
&lt;p&gt;以上是磁盘的物理结构，现在来看下磁盘的读写操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/cced6145f7fdc77ed5a55f88bdf54997.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图，磁盘用读/写头来读写存储在磁性表面的位，而读写头连接到一个传动臂的一端。通过沿着半径轴前后移动传动臂，驱动器可以将读写头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到位的值，也可以修改值。对磁盘的访问时间分为 &lt;strong&gt;寻道时间&lt;/strong&gt;，&lt;strong&gt;旋转时间&lt;/strong&gt;，以及&lt;strong&gt;传送时间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘I/O，减少读写操作。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：&lt;/p&gt;
&lt;p&gt;当一个数据被用到时，其附近的数据也通常会马上被使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序运行期间所需要的数据通常比较集中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。&lt;/p&gt;
&lt;p&gt;预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。&lt;/p&gt;
&lt;p&gt;文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：&lt;/p&gt;
&lt;p&gt;每次新建一个节点的同时，直接申请一个页的空间( 512或者1024)，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。如，将B树的度M设置为1024，这样在前面的例子中，600亿个元素中只需要小于4次查找即可定位到某一存储位置。&lt;/p&gt;
&lt;p&gt;同时在B+树中，内节点只存储导航用到的key，并不存储具体值，这样内节点个数较少，能够全部读取到主存中，外接点存储key及值，并且顺序排列，具有良好的空间局部性。所以B及B+树比较适合与文件系统的数据结构。下面是一颗B树，用来进行内容存储。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2bcae2e929d78399ca504b86b717897b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;另外B/B+树也经常用做数据库的索引，这方面推荐您直接看张洋的&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot; target=&quot;_blank&quot;&gt;MySQL索引背后的数据结构及算法原理&lt;/a&gt; 这篇文章，这篇文章对MySQL中的如何使用B+树进行索引有比较详细的介绍，推荐阅读。&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;在前面两篇文章介绍了平衡查找树中的&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html&quot; target=&quot;_blank&quot;&gt;2-3树&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;之后，本文介绍了文件系统和数据库系统中常用的B/B+ 树，他通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。他广泛用于文件系统及数据库中，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows：HPFS文件系统&lt;/li&gt;
&lt;li&gt;Mac：HFS，HFS+文件系统&lt;/li&gt;
&lt;li&gt;Linux：ResiserFS，XFS，Ext3FS，JFS文件系统&lt;/li&gt;
&lt;li&gt;数据库：ORACLE，MYSQL，SQLSERVER等中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;希望本文对您了解B/B+ 树有所帮助。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79311-2c84273c9.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79311-2c84273c9.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（9）：平衡查找树之红黑树</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;前面一篇文章介绍了&lt;a href=&quot;http://blog.jobbole.com/79307/&quot; target=&quot;_blank&quot;&gt;2-3查找树&lt;/a&gt;，可以看到，2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgN，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，本文介绍一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）&lt;/p&gt;
&lt;h1&gt;定义&lt;/h1&gt;
&lt;p&gt;红黑树的主要是像是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/28aa41a637d1006eeab4a0d5646e8772.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据以上描述，红黑树定义如下：&lt;/p&gt;
&lt;p&gt;红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;红色节点向左倾斜&lt;/li&gt;
&lt;li&gt;一个节点不可能有两个红色链接&lt;/li&gt;
&lt;li&gt;整个书完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4bf7d2d9bb2125c80b18807fd67e6df7.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;表示&lt;/h1&gt;
&lt;p&gt;我们可以在二叉查找树的每一个节点上增加一个新的表示颜色的标记。该标记指示该节点指向其父节点的颜色。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private const bool RED = true;
private const bool BLACK = false;

private Node root;

class Node
{
    public Node Left { get; set; }
    public Node Right { get; set; }
    public TKey Key { get; set; }
    public TValue Value { get; set; }
    public int Number { get; set; }
    public bool Color { get; set; }

    public Node(TKey key, TValue value,int number, bool color)
    {
        this.Key = key;
        this.Value = value;
        this.Number = number;
        this.Color = color;
    }
}

private bool IsRed(Node node)
{
    if (node == null) return false;
    return node.Color == RED;
}&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2a47f60d785e94f98bff38bcfbfe186e.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;实现&lt;/h1&gt;
&lt;h2&gt;查找&lt;/h2&gt;
&lt;p&gt;红黑树是一种特殊的二叉查找树，他的查找方法也和二叉查找树一样，不需要做太多更改。&lt;/p&gt;
&lt;p&gt;但是由于红黑树比一般的二叉查找树具有更好的平衡，所以查找起来更快。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;//查找获取指定的值
public override TValue Get(TKey key)
{
    return GetValue(root, key);
}

private TValue GetValue(Node node, TKey key)
{
    if (node == null) return default(TValue);
    int cmp = key.CompareTo(node.Key);
    if (cmp == 0) return node.Value;
    else if (cmp &amp;gt; 0) return GetValue(node.Right, key);
    else return GetValue(node.Left, key);
}&lt;/pre&gt;
&lt;h2&gt;平衡化&lt;/h2&gt;
&lt;p&gt;在介绍插入之前，我们先介绍如何让红黑树保持平衡，因为一般的，我们插入完成之后，需要对树进行平衡化操作以使其满足平衡化。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;旋转&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;旋转又分为&lt;strong&gt;左旋&lt;/strong&gt;和&lt;strong&gt;右旋&lt;/strong&gt;。通常左旋操作用于将一个向右倾斜的红色链接旋转为向左链接。对比操作前后，可以看出，该操作实际上是将红线链接的两个节点中的一个较大的节点移动到根节点上。&lt;/p&gt;
&lt;p&gt;左旋操作如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c4cd388f923e4006f290a201ae0abea3.jpg&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5c53a9577f6ef26f85efd9a247c7810e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;//左旋转
private Node RotateLeft(Node h)
{
    Node x = h.Right;
    //将x的左节点复制给h右节点
    h.Right = x.Left;
    //将h复制给x右节点
    x.Left = h;
    x.Color = h.Color;
    h.Color = RED;
    return x;
}&lt;/pre&gt;
&lt;p&gt;左旋的动画效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/55da041aa81e6064285ac15780434d53.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;右旋&lt;/strong&gt;是左旋的逆操作，过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/deeb271473f65db02630ef9b33dbc18f.jpg&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/86c949f8f7744e2c9a65c1c67823c1d6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;//右旋转
private Node RotateRight(Node h)
{
    Node x = h.Left;
    h.Left = x.Right;
    x.Right = h;

    x.Color = h.Color;
    h.Color = RED;
    return x;
}&lt;/pre&gt;
&lt;p&gt;右旋的动画效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8ab520971ea5069cedb4e991ce176639.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;颜色反转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当出现一个临时的4-node的时候，即一个节点的两个子节点均为红色，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c55879bd093896d9e89bf07c37e76be1.jpg&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7676d3d76d32fac7130c612599628ef7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这其实是个A，E，S 4-node连接，我们需要将E提升至父节点，操作方法很简单，就是把E对子节点的连线设置为黑色，自己的颜色设置为红色。&lt;/p&gt;
&lt;p&gt;有了以上基本操作方法之后，我们现在对应之前对&lt;strong&gt;2-3树的平衡操作来对红黑树进行平衡操作，&lt;/strong&gt;这两者是可以一一对应的，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/373226b08bdeb834ea0051a6e363bbec.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在来讨论各种情况：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Case 1 &lt;/strong&gt;&lt;strong&gt;往一个2-node&lt;/strong&gt;&lt;strong&gt;节点底部插入新的节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先热身一下，首先我们看对于只有一个节点的红黑树，插入一个新的节点的操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a9938d92aaf6be1f971192bc7ad25ece.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种情况很简单，只需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准的二叉查找树遍历即可。新插入的节点标记为红色&lt;/li&gt;
&lt;li&gt;如果新插入的节点在父节点的右子节点，则需要进行左旋操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Case 2&lt;/strong&gt;&lt;strong&gt;往一个3-node&lt;/strong&gt;&lt;strong&gt;节点底部插入新的节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先热身一下，假设我们往一个只有两个节点的树中插入元素，如下图，根据待插入元素与已有元素的大小，又可以分为如下三种情况：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ffb7726e434b2804f5c6ca6693962f78.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果带插入的节点比现有的两个节点都大，这种情况最简单。我们只需要将新插入的节点连接到右边子树上即可，然后将中间的元素提升至根节点。这样根节点的左右子树都是红色的节点了，我们只需要调研FlipColor方法即可。其他情况经过反转操作后都会和这一样。&lt;/li&gt;
&lt;li&gt;如果插入的节点比最小的元素要小，那么将新节点添加到最左侧，这样就有两个连接红色的节点了，这是对中间节点进行右旋操作，使中间结点成为根节点。这是就转换到了第一种情况，这时候只需要再进行一次FlipColor操作即可。&lt;/li&gt;
&lt;li&gt;如果插入的节点的值位于两个节点之间，那么将新节点插入到左侧节点的右子节点。因为该节点的右子节点是红色的，所以需要进行左旋操作。操作完之后就变成第二种情况了，再进行一次右旋，然后再调用FlipColor操作即可完成平衡操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了以上基础，我们现在来总结一下往一个3-node节点底部插入新的节点的操作步骤，下面是一个典型的操作过程图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/18cc2768938907b0016a95c90ff53f70.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看出，操作步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行标准的二叉查找树插入操作，新插入的节点元素用红色标识。&lt;/li&gt;
&lt;li&gt;如果需要对4-node节点进行旋转操作&lt;/li&gt;
&lt;li&gt;如果需要，调用FlipColor方法将红色节点提升&lt;/li&gt;
&lt;li&gt;如果需要，左旋操作使红色节点左倾。&lt;/li&gt;
&lt;li&gt;在有些情况下，需要递归调用Case1 Case2，来进行递归操作。如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/39033694fa182478baef59a2a1ec384c.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;代码实现&lt;/h2&gt;
&lt;p&gt;经过上面的平衡化讨论，现在就来实现插入操作，一般地插入操作就是先执行标准的二叉查找树插入，然后再进行平衡化。对照2-3树，我们可以通过前面讨论的，左旋，右旋，FlipColor这三种操作来完成平衡化。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3f8b9da7561e25a5c6e86acbcdab5ac3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体操作方式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果节点的右子节点为红色，且左子节点位黑色，则进行左旋操作&lt;/li&gt;
&lt;li&gt;如果节点的左子节点为红色，并且左子节点的左子节点也为红色，则进行右旋操作&lt;/li&gt;
&lt;li&gt;如果节点的左右子节点均为红色，则执行FlipColor操作，提升中间结点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据这一逻辑，我们就可以实现插入的Put方法了。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public override void Put(TKey key, TValue value)
{
    root = Put(root, key, value);
    root.Color = BLACK;
}

private Node Put(Node h, TKey key, TValue value)
{
    if (h == null) return new Node(key, value, 1, RED);
    int cmp = key.CompareTo(h.Key);
    if (cmp &amp;lt; 0) h.Left = Put(h.Left, key, value);
    else if (cmp &amp;gt; 0) h.Right = Put(h.Right, key, value);
    else h.Value = value;

    //平衡化操作
    if (IsRed(h.Right) &amp;amp;&amp;amp; !IsRed(h.Left)) h = RotateLeft(h);
    if (IsRed(h.Right) &amp;amp;&amp;amp; IsRed(h.Left.Left)) h = RotateRight(h);
    if (IsRed(h.Left) &amp;amp;&amp;amp; IsRed(h.Right)) h = FlipColor(h);

    h.Number = Size(h.Left) + Size(h.Right) + 1;
    return h;
}

private int Size(Node node)
{
    if (node == null) return 0;
    return node.Number;
}&lt;/pre&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;对红黑树的分析其实就是对2-3查找树的分析，红黑树能够保证符号表的所有操作即使在最坏的情况下都能保证对数的时间复杂度，也就是树的高度。&lt;/p&gt;
&lt;p&gt;在分析之前，为了更加直观，下面是以升序，降序和随机构建一颗红黑树的动画：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以升序插入构建红黑树：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/220447ab4207dbbeb4f4bbd018f8308a.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以降序插入构建红黑树：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/de01067afe1c7d96b8d04b5555298fa6.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随机插入构建红黑树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8fe88b6bc08b80b835bd5f0d0daca65a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上面三张动画效果中，可以很直观的看出，红黑树在各种情况下都能维护良好的平衡性，从而能够保证最差情况下的查找，插入效率。&lt;/p&gt;
&lt;p&gt;下面来详细分析下红黑树的效率：&lt;/p&gt;
&lt;h2&gt;1. 在最坏的情况下，红黑树的高度不超过2lgN&lt;/h2&gt;
&lt;p&gt;最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即&lt;strong&gt;红黑相间的路径长度是全黑路径长度的&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;倍&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下图是一个典型的红黑树，从中可以看到最长的路径(红黑相间的路径)是最短路径的2倍：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f8dd64a41535dfe6de1b44332054c8a8.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;2. 红黑树的平均高度大约为lgN&lt;/h2&gt;
&lt;p&gt;下图是红黑树在各种情况下的时间复杂度，可以看出红黑树是2-3查找树的一种实现，他能保证最坏情况下仍然具有对数的时间复杂度。&lt;/p&gt;
&lt;p&gt;下图是红黑树各种操作的时间复杂度。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e7962e34bcc8c72e4ca43e4d4c1f0bed.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;应用&lt;/h1&gt;
&lt;p&gt;红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java中的java.util.TreeMap,java.util.TreeSet&lt;/li&gt;
&lt;li&gt;C++ STL中的：map,multimap,multiset&lt;/li&gt;
&lt;li&gt;.NET中的：&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/f7fta44c(v=vs.110).aspx&quot;&gt;SortedDictionary&lt;/a&gt;,&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/dd412070(v=vs.110).aspx&quot; target=&quot;_blank&quot;&gt;SortedSet&lt;/a&gt; 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面以.NET中为例，通过Reflector工具，我们可以看到SortedDictionary的Add方法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public void Add(T item)
{
    if (this.root == null)
    {
        this.root = new Node&amp;lt;T&amp;gt;(item, false);
        this.count = 1;
    }
    else
    {
        Node&amp;lt;T&amp;gt; root = this.root;
        Node&amp;lt;T&amp;gt; node = null;
        Node&amp;lt;T&amp;gt; grandParent = null;
        Node&amp;lt;T&amp;gt; greatGrandParent = null;
        int num = 0;
        while (root != null)
        {
            num = this.comparer.Compare(item, root.Item);
            if (num == 0)
            {
                this.root.IsRed = false;
                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);
            }
            if (TreeSet&amp;lt;T&amp;gt;.Is4Node(root))
            {
                TreeSet&amp;lt;T&amp;gt;.Split4Node(root);
                if (TreeSet&amp;lt;T&amp;gt;.IsRed(node))
                {
                    this.InsertionBalance(root, ref node, grandParent, greatGrandParent);
                }
            }
            greatGrandParent = grandParent;
            grandParent = node;
            node = root;
            root = (num &amp;lt; 0) ? root.Left : root.Right;
        }
        Node&amp;lt;T&amp;gt; current = new Node&amp;lt;T&amp;gt;(item);
        if (num &amp;gt; 0)
        {
            node.Right = current;
        }
        else
        {
            node.Left = current;
        }
        if (node.IsRed)
        {
            this.InsertionBalance(current, ref node, grandParent, greatGrandParent);
        }
        this.root.IsRed = false;
        this.count++;
        this.version++;
    }
}&lt;/pre&gt;
&lt;p&gt;可以看到，内部实现也是一个红黑树，其操作方法和本文将的大同小异，感兴趣的话，您可以使用Reflector工具跟进去查看源代码。&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/79307/&quot; target=&quot;_blank&quot;&gt;前文&lt;/a&gt;讲解了自平衡查找树中的&lt;a href=&quot;http://blog.jobbole.com/79307/&quot; target=&quot;_blank&quot;&gt;2-3查找树&lt;/a&gt;，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。&lt;/p&gt;
&lt;p&gt;希望本文对您了解红黑树有所帮助，下文将介绍在文件系统以及数据库系统中应用非常广泛的另外一种平衡树结构：B树。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79309-123b3cd4a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79309-123b3cd4a.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（8）：平衡查找树之2-3树</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;前面介绍了&lt;a href=&quot;http://blog.jobbole.com/79305/&quot; target=&quot;_blank&quot;&gt;二叉查找树&lt;/a&gt;(Binary Search Tree)，他对于大多数情况下的查找和插入在效率上来说是没有问题的，但是他在最差的情况下效率比较低。本文及后面文章介绍的平衡查找树的数据结构能够保证在最差的情况下也能达到lgN的效率，要实现这一目标我们需要保证树在插入完成之后始终保持平衡状态，这就是平衡查找树(Balanced Search Tree)。在一棵具有N 个节点的树中，我们希望该树的高度能够维持在lgN左右，这样我们就能保证只需要lgN次比较操作就可以查找到想要的值。不幸的是，每次插入元素之后维持树的平衡状态太昂贵。所以这里会介绍一些新的数据结构来保证在最坏的情况下插入和查找效率都能保证在对数的时间复杂度内完成。本文首先介绍2-3查找树(2-3 Search Tree)，后面会在此基础上介绍红黑树和B树。&lt;/p&gt;
&lt;h1&gt;定义&lt;/h1&gt;
&lt;p&gt;和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：&lt;/p&gt;
&lt;p&gt;1. 要么为空，要么：&lt;/p&gt;
&lt;p&gt;2. 对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key有效，有节点也是一个2-3节点，所有的值比key要大。&lt;/p&gt;
&lt;p&gt;3. 对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。&lt;/p&gt;
&lt;p&gt;如果中序遍历2-3查找树，就可以得到排好序的序列。在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1dae559238b660dc53506946a1d6455c.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;查找&lt;/h1&gt;
&lt;p&gt;在进行2-3树的平衡之前，我们先假设已经处于平衡状态，我们先看基本的查找操作。&lt;/p&gt;
&lt;p&gt;2-3树的查找和二叉查找树类似，要确定一个树是否属于2-3树，我们首先和其跟节点进行比较，如果相等，则查找成功；否则根据比较的条件，在其左中右子树中递归查找，如果找到的节点为空，则未找到，否则返回。查找过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f811368729b661c7432fc50c01ec3bea.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;插入&lt;/h1&gt;
&lt;h2&gt;往一个2-node节点插入&lt;/h2&gt;
&lt;p&gt;往2-3树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点上。2-3树之所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一个2-node节点，那么很容易，我们只需要将新的元素放到这个2-node节点里面使其变成一个3-node节点即可。但是如果查找的节点结束于一个3-node节点，那么可能有点麻烦。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8514a08fed0310d65f9eea43a9557766.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;往一个3-node节点插入&lt;/h2&gt;
&lt;p&gt;往一个3-node节点插入一个新的节点可能会遇到很多种不同的情况，下面首先从一个最简单的只包含一个3-node节点的树开始讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只包含一个3-node&lt;/strong&gt;&lt;strong&gt;节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f984feb6b40e299ba54d2676f7f9d1d3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;如上图，假设2-3树只包含一个3-node节点，这个节点有两个key，没有空间来插入第三个key了，最自然的方式是我们假设这个节点能存放三个元素，暂时使其变成一个4-node节点，同时他包含四个子节点。然后，我们将这个4-node节点的中间元素提升，左边的节点作为其左节点，右边的元素作为其右节点。插入完成，变为平衡2-3查找树，树的高度从0变为1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点是3-node&lt;/strong&gt;&lt;strong&gt;，父节点是2-node&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和第一种情况一样，我们也可以将新的元素插入到3-node节点中，使其成为一个临时的4-node节点，然后，将该节点中的中间元素提升到父节点即2-node节点中，使其父节点成为一个3-node节点，然后将左右节点分别挂在这个3-node节点的恰当位置。操作如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7d45989e4a87a1cd487287d5d1c5545a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点是3-node&lt;/strong&gt;&lt;strong&gt;，父节点也是3-node&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们插入的节点是3-node的时候，我们将该节点拆分，中间元素提升至父节点，但是此时父节点是一个3-node节点，插入之后，父节点变成了4-node节点，然后继续将中间元素提升至其父节点，直至遇到一个父节点是2-node节点，然后将其变为3-node，不需要继续进行拆分。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/23eaaea6f71e831e35fe5dc1170aef2b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根节点分裂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当根节点到字节点都是3-node节点的时候，这是如果我们要在字节点插入新的元素的时候，会一直查分到跟节点，在最后一步的时候，跟节点变成了一个4-node节点，这个时候，就需要将跟节点查分为两个2-node节点，树的高度加1，这个操作过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/50f65359375d741e528eeeb032a29d5e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将一个4-node拆分为2-3node涉及到6种可能的操作。这4-node可能在跟节点，也可能是2-node的左子节点或者右子节点。或者是一个3-node的左，中，右子节点。所有的这些改变都是本地的，不需要检查或者修改其他部分的节点。所以只需要常数次操作即可完成2-3树的平衡。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ca57f77f761dd476fc9cb88879de0157.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性质&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些本地操作保持了2-3树的平衡。对于4-node节点变形为2-3节点，变形前后树的高度没有发生变化。只有当跟节点是4-node节点，变形后树的高度才加一。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8773a457a44fc42a3aaecdbab8850b96.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h1&gt;分析&lt;/h1&gt;
&lt;p&gt;完全平衡的2-3查找树如下图，每个根节点到叶子节点的距离是相同的：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b53b2a71de190c5a5a6ad0cdee2e4954.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2-3树的查找效率与树的高度是息息相关的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN&lt;/li&gt;
&lt;li&gt;在最好的情况下，所有的节点都是3-node节点，查找效率为log&lt;sub&gt;3&lt;/sub&gt;N约等于0.631lgN&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。&lt;/p&gt;
&lt;p&gt;对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。下面是2-3查找树的效率：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0908b5e2c1cd5a6366715f827c73a459.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;实现&lt;/h1&gt;
&lt;p&gt;直接实现2-3树比较复杂，因为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要处理不同的节点类型，非常繁琐&lt;/li&gt;
&lt;li&gt;需要多次比较操作来将节点下移&lt;/li&gt;
&lt;li&gt;需要上移来拆分4-node节点&lt;/li&gt;
&lt;li&gt;拆分4-node节点的情况有很多种&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2-3查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。在2-3查找树基础上改进的红黑树不仅具有较高的效率，并且实现起来较2-3查找树简单。&lt;/p&gt;
&lt;p&gt;但是2-3查找树作为一种比较重要的概念和思路对于后文要讲到的红黑树和B树非常重要。希望本文对您了解2-3查找树有所帮助。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79307-715a10deb.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79307-715a10deb.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（7）：二叉查找树</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/79303/&quot; target=&quot;_blank&quot;&gt;前文&lt;/a&gt;介绍了符号表的两种实现，无序链表和有序数组，无序链表在插入的时候具有较高的灵活性，而有序数组在查找时具有较高的效率，本文介绍的二叉查找树(Binary Search Tree，BST)这一数据结构综合了以上两种数据结构的优点。&lt;/p&gt;
&lt;p&gt;二叉查找树具有很高的灵活性，对其优化可以生成平衡二叉树，红黑树等高效的查找和插入数据结构，后文会一一介绍。&lt;/p&gt;
&lt;h1&gt;一 定义&lt;/h1&gt;
&lt;p&gt;二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：&lt;/p&gt;
&lt;p&gt;1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；&lt;/p&gt;
&lt;p&gt;2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；&lt;/p&gt;
&lt;p&gt;3. 任意节点的左、右子树也分别为二叉查找树。&lt;/p&gt;
&lt;p&gt;4. 没有键值相等的节点（no duplicate nodes）。&lt;/p&gt;
&lt;p&gt;如下图，这个是普通的二叉树：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a66bbf9c00307aad82c461c62b7bd733.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在此基础上，加上节点之间的大小关系，就是二叉查找树：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/27f0746a9341b33e139fba8791525828.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;二 实现&lt;/h1&gt;
&lt;p&gt;在实现中，我们需要定义一个内部类Node，它包含两个分别指向左右节点的Node，一个用于排序的Key，以及该节点包含的值Value，还有一个记录该节点及所有子节点个数的值Number。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public class BinarySearchTreeSymbolTable&amp;lt;TKey, TValue&amp;gt; : SymbolTables&amp;lt;TKey, TValue&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt;, IEquatable&amp;lt;TValue&amp;gt;
{
    private Node root;
    private class Node
    {
        public Node Left { get; set; }
        public Node Right { get; set; }
        public int Number { get; set; }
        public TKey Key { get; set; }
        public TValue Value { get; set; }

        public Node(TKey key, TValue value, int number)
        {
            this.Key = key;
            this.Value = value;
            this.Number = number;
        }
    }
...
}&lt;/pre&gt;
&lt;h2&gt;查找&lt;/h2&gt;
&lt;p&gt;查找操作和二分查找类似，将key和节点的key比较，如果小于，那么就在Left Node节点查找,如果大于，则在Right Node节点查找，如果相等，直接返回Value。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/86343544d5f8b664890d863246a7394f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;该方法实现有迭代和递归两种。&lt;/p&gt;
&lt;p&gt;递归的方式实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public override TValue Get(TKey key)
{
    TValue result = default(TValue);
    Node node = root;
    while (node != null)
    {

        if (key.CompareTo(node.Key) &amp;gt; 0)
        {
            node = node.Right;
        }
        else if (key.CompareTo(node.Key) &amp;lt; 0)
        {
            node = node.Left;
        }
        else
        {
            result = node.Value;
            break;
        }
    }
    return result;
}&lt;/pre&gt;
&lt;p&gt;迭代的如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public TValue Get(TKey key)
{
    return GetValue(root, key);
}

private TValue GetValue(Node root, TKey key)
{
    if (root == null) return default(TValue);
    int cmp = key.CompareTo(root.Key);
    if (cmp &amp;gt; 0) return GetValue(root.Right, key);
    else if (cmp &amp;lt; 0) return GetValue(root.Left, key);
    else return root.Value;
}&lt;/pre&gt;
&lt;h2&gt;插入&lt;/h2&gt;
&lt;p&gt;插入和查找类似，首先查找有没有和key相同的，如果有，更新；如果没有找到，那么创建新的节点。并更新每个节点的Number值，代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public override void Put(TKey key, TValue value)
{
    root = Put(root, key, value);
}

private Node Put(Node x, TKey key, TValue value)
{
    //如果节点为空，则创建新的节点，并返回
    //否则比较根据大小判断是左节点还是右节点，然后继续查找左子树还是右子树
    //同时更新节点的Number的值
    if (x == null) return new Node(key, value, 1);
    int cmp = key.CompareTo(x.Key);
    if (cmp &amp;lt; 0) x.Left = Put(x.Left, key, value);
    else if (cmp &amp;gt; 0) x.Right = Put(x.Right, key, value);
    else x.Value = value;
    x.Number = Size(x.Left) + Size(x.Right) + 1;
    return x;
}

private int Size(Node node)
{
    if (node == null) return 0;
    else return node.Number;
}&lt;/pre&gt;
&lt;p&gt;插入操作图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d6285894101ea84ef776e0b8112fe790.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面是插入动画效果：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6527ae528666e9f85d4d80f4b080057b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;随机插入形成树的动画如下，可以看到，插入的时候树还是能够保持近似平衡状态：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e64a1ac9db0a8be1d19e5e43f396be99.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;最大最小值&lt;/h2&gt;
&lt;p&gt;如下图可以看出，二叉查找树的最大最小值是有规律的：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4ad01544a97a509336e45257d8bf970f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出，二叉查找树中，最左和最右节点即为最小值和最大值，所以我们只需迭代调用即可。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public override TKey GetMax()
{
    TKey maxItem = default(TKey);
    Node s = root;
    while (s.Right != null)
    {
        s = s.Right;
    }
    maxItem = s.Key;
    return maxItem;
}

public override TKey GetMin()
{
    TKey minItem = default(TKey);
    Node s = root;
    while (s.Left != null)
    {
        s = s.Left;
    }
    minItem = s.Key;
    return minItem;
}&lt;/pre&gt;
&lt;p&gt;以下是递归的版本：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public TKey GetMaxRecursive()
{
    return GetMaxRecursive(root);
}

private TKey GetMaxRecursive(Node root)
{
    if (root.Right == null) return root.Key;
    return GetMaxRecursive(root.Right);
}

public TKey GetMinRecursive()
{
    return GetMinRecursive(root);
}

private TKey GetMinRecursive(Node root)
{
    if (root.Left == null) return root.Key;
    return GetMinRecursive(root.Left);
}&lt;/pre&gt;
&lt;h2&gt;Floor和Ceiling&lt;/h2&gt;
&lt;p&gt;查找Floor(key)的值就是所有&amp;lt;=key的最大值，相反查找Ceiling的值就是所有&amp;gt;=key的最小值，下图是Floor函数的查找示意图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/89ef9bdc5db1c8abe8656f4011fadb8a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;以查找Floor为例，我们首先将key和root元素比较，如果key比root的key小，则floor值一定在左子树上；如果比root的key大，则有可能在右子树上，当且仅当其右子树有一个节点的key值要小于等于该key；如果和root的key相等，则floor值就是key。根据以上分析，Floor方法的代码如下，Ceiling方法的代码类似，只需要把符号换一下即可：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public TKey Floor(TKey key)
{
    Node x = Floor(root, key);
    if (x != null) return x.Key;
    else return default(TKey);
}

private Node Floor(Node x, TKey key)
{
    if (x == null) return null;
    int cmp = key.CompareTo(x.Key);
    if (cmp == 0) return x;
    if (cmp &amp;lt; 0) return Floor(x.Left, key);
    else
    {
        Node right = Floor(x.Right, key);
        if (right == null) return x;
        else return right;
    }
}&lt;/pre&gt;
&lt;h2&gt;删除&lt;/h2&gt;
&lt;p&gt;删除元素操作在二叉树的操作中应该是比较复杂的。首先来看下比较简单的删除最大最小值得方法。&lt;/p&gt;
&lt;p&gt;以删除最小值为例，我们首先找到最小值，及最左边左子树为空的节点，然后返回其右子树作为新的左子树。操作示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b3f61f765ae8aec1b115c56cd0afea1b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public void DelMin()
{
    root = DelMin(root);
}

private Node DelMin(Node root)
{
    if (root.Left == null) return root.Right;
    root.Left = DelMin(root.Left);
    root.Number = Size(root.Left) + Size(root.Right) + 1;
    return root;
}&lt;/pre&gt;
&lt;p&gt;删除最大值也是类似。&lt;/p&gt;
&lt;p&gt;现在来分析一般情况，假定我们要删除指定key的某一个节点。这个问题的难点在于：删除最大最小值的操作，删除的节点只有1个子节点或者没有子节点，这样比较简单。但是如果删除任意节点，就有可能出现删除的节点有0个，1 个，2个子节点的情况，现在来逐一分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当删除的节点没有子节点时&lt;/strong&gt;，直接将该父节点指向该节点的link设置为null。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7ec417dd5d32a175eb0088dfb506aefb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当删除的节点只有1个子节点时&lt;/strong&gt;，将该自己点替换为要删除的节点即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/db8c7aa31a92f7b30e71220e484a5492.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当删除的节点有2个子节点时，问题就变复杂了。&lt;/p&gt;
&lt;p&gt;假设我们删除的节点t具有两个子节点。因为t具有右子节点，所以我们需要找到其右子节点中的最小节点，替换t节点的位置。这里有四个步骤：&lt;/p&gt;
&lt;p&gt;1. 保存带删除的节点到临时变量t&lt;/p&gt;
&lt;p&gt;2. 将t的右节点的最小节点min(t.right)保存到临时节点x&lt;/p&gt;
&lt;p&gt;3. 将x的右节点设置为deleteMin(t.right)，该右节点是删除后，所有比x.key最大的节点。&lt;/p&gt;
&lt;p&gt;4. 将x的做节点设置为t的左节点。&lt;/p&gt;
&lt;p&gt;整个过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bc09c2af51c7324749963461f457e6de.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;对应代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public void Delete(TKey key)
{
    root =Delete(root, key);
        
}

private Node Delete(Node x, TKey key)
{
    int cmp = key.CompareTo(x.Key);
    if (cmp &amp;gt; 0) x.Right = Delete(x.Right, key);
    else if (cmp &amp;lt; 0) x.Left = Delete(x.Left, key);
    else
    {
        if (x.Left == null) return x.Right;
        else if (x.Right == null) return x.Left;
        else
        {
            Node t = x;
            x = GetMinNode(t.Right);
            x.Right = DelMin(t.Right);
            x.Left = t.Left;
        }
    }
    x.Number = Size(x.Left) + Size(x.Right) + 1;
    return x;
}

private Node GetMinNode(Node x)
{
    if (x.Left == null) return x;
    else return GetMinNode(x.Left); 
}&lt;/pre&gt;
&lt;p&gt;以上二叉查找树的删除节点的算法不是完美的，因为随着删除的进行，二叉树会变得不太平衡，下面是动画演示。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b3ea3ad453cd52a56643600521632111.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;三 分析&lt;/h1&gt;
&lt;p&gt;二叉查找树的运行时间和树的形状有关，树的形状又和插入元素的顺序有关。在最好的情况下，节点完全平衡，从根节点到最底层叶子节点只有lgN个节点。在最差的情况下，根节点到最底层叶子节点会有N各节点。在一般情况下，树的形状和最好的情况接近。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7d88c12fab625fbd9c21022856994301.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在分析二叉查找树的时候，我们通常会假设插入的元素顺序是随机的。对BST的分析类似与快速排序中的查找：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0eb0437b708913046b55b6e64bea33f0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;BST中位于顶部的元素就是快速排序中的第一个划分的元素，该元素左边的元素全部小于该元素，右边的元素均大于该元素。&lt;/p&gt;
&lt;p&gt;对于N个不同元素，随机插入的二叉查找树来说，其平均查找/插入的时间复杂度大约为2lnN，这个和快速排序的分析一样，具体的证明方法不再赘述，参照快速排序。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h1&gt;四 总结&lt;/h1&gt;
&lt;p&gt;有了前篇文章 &lt;a href=&quot;http://blog.jobbole.com/79303/&quot; target=&quot;_blank&quot;&gt;二分查找&lt;/a&gt;的分析，对二叉查找树的理解应该比较容易。下面是二叉查找树的时间复杂度：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/881e6bacd8fb405fe37a4e6d5f55d7f9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;它和二分查找一样，插入和查找的时间复杂度均为lgN，但是在最坏的情况下仍然会有N的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是后面要讲的平衡查找树的内容了。下文首先讲解平衡查找树的最简单的一种：2-3查找树。&lt;/p&gt;
&lt;p&gt;希望本文对您了解二叉查找树有所帮助。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79305-ecaa57b9e.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79305-ecaa57b9e.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（6）：符号表及其基本实现</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;前面几篇文章介绍了基本的排序算法，排序通常是查找的前奏操作。从本文开始介绍基本的查找算法。&lt;/p&gt;
&lt;p&gt;在介绍查找算法，首先需要了解符号表这一抽象数据结构，本文首先介绍了什么是符号表，以及这一抽象数据结构的的API，然后介绍了两种简单的符号表的实现方式。&lt;/p&gt;
&lt;h1&gt;一符号表&lt;/h1&gt;
&lt;p&gt;在开始介绍查找算法之前，我们需要定义一个名为符号表（Symbol Table）的抽象数据结构，该数据结构类似我们再C#中使用的Dictionary，他是对具有键值对元素的一种抽象，每一个元素都有一个key和value，我们可以往里面添加key，value键值对，也可以根据key来查找value。在现实的生活中，我们经常会遇到各种需要根据key来查找value的情况，比如DNS根据域名查找IP地址，图书馆根据索引号查找图书等等：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/473003421e1c4851991cf4fab26f2bf6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了实现这一功能，我们定义一个抽象数据结构，然后选用合适的数据结构来实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public class ST&amp;lt;Key, Value&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;ST()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;创建一个查找表对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;void Put(Key key, Value val)&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;往集合中插入一条键值对记录，如果value为空，不添加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;Value Get(Key key)&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;根据key查找value，如果没找到返回null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;void Delete(Key key)&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;删除键为key的记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;boolean Contains(Key key)&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;判断集合中是否存在键为key的记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;boolean IsEmpty()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;判断查找表是否为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;int Size()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;返回集合中键值对的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;Iterable&amp;lt;Key&amp;gt; Keys()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;返回集合中所有的键&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;二实现&lt;/h1&gt;
&lt;h2&gt;1 使用无序链表实现查找表&lt;/h2&gt;
&lt;p&gt;查找表的实现关键在于数据结构的选择，最简单的一种实现是使用无序链表来实现，每一个节点记录key值，value值以及指向下一个记录的对象。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fd72a641177de3b21c00aa5a9c4be9f2.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图，当我们往链表中插入元素的时候，从表头开始查找，如果找到，则更新value，否则，在表头插入新的节点元素。&lt;/p&gt;
&lt;p&gt;实现起来也很简单：&lt;/p&gt;
&lt;pre&gt;public class SequentSearchSymbolTable&amp;lt;TKey, TValue&amp;gt; : SymbolTables&amp;lt;TKey, TValue&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt;, IEquatable&amp;lt;TKey&amp;gt;
{
    private int length = 0;
    Node first;
    private class Node
    {
        public TKey key { get; set; }
        public TValue value { get; set; }
        public Node next { get; set; }

        public Node(TKey key, TValue value, Node next)
        {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public override TValue Get(TKey key)
    {
        TValue result = default(TValue);
        Node temp = first;
        while (temp != null)
        {
            if (temp.key.Equals(key))
            {
                result = temp.value;
                break;
            }
            temp = temp.next;
        }

        return result;
    }

    public override void Put(TKey key, TValue value)
    {
        Node temp = first;
        while (temp != null)
        {
            if (temp.key.Equals(key))
            {
                temp.value = value;
                return;
            }
            temp = temp.next;
        }
        first = new Node(key, value, first);
        length++;
    }

    ....
}&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从图或者代码中分析可知，插入的时候先要查找，如果存在则更新value，查找的时候需要从链表头进行查找，所以插入和查找的平均时间复杂度均为O(n)。那么有没有效率更好的方法呢，下面就介绍二分查找。&lt;/p&gt;
&lt;h2&gt;2 使用二分查找实现查找表&lt;/h2&gt;
&lt;p&gt;和采用无序链表实现不同，二分查找的思想是在内部维护一个按照key排好序的二维数组，每一次查找的时候，跟中间元素进行比较，如果该元素小，则继续左半部分递归查找，否则继续右半部分递归查找。整个实现代码如下：&lt;/p&gt;
&lt;pre&gt;class BinarySearchSymbolTable&amp;lt;TKey, TValue&amp;gt; : SymbolTables&amp;lt;TKey, TValue&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt;, IEquatable&amp;lt;TKey&amp;gt;
{
    private TKey[] keys;
    private TValue[] values;
    private int length;
    private static readonly int INIT_CAPACITY = 2;
    public BinarySearchSymbolTable(int capacity)
    {
        keys = new TKey[capacity];
        values = new TValue[capacity];
        length = capacity;
    }
    public BinarySearchSymbolTable() : this(INIT_CAPACITY)
    {
    }
    /// &amp;lt;summary&amp;gt;
    /// 根据key查找value。
    /// 首先查找key在keys中所处的位置，如果在length范围内，且存在该位置的值等于key，则返回值
    /// 否则，不存在
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public override TValue Get(TKey key)
    {
        int i = Rank(key);
        if (i &amp;lt; length &amp;amp;&amp;amp; keys[i].Equals(key))
            return values[i];
        else
            return default(TValue);
    }

    /// &amp;lt;summary&amp;gt;
    /// 向符号表中插入key，value键值对。
    /// 如果存在相等的key，则直接更新value，否则将该key，value插入到合适的位置
    ///  1.首先将该位置往后的元素都往后移以为
    ///  2.然后再讲该元素放到为i的位置上
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public override void Put(TKey key, TValue value)
    {
        int i = Rank(key);
        if (i &amp;lt; length &amp;amp;&amp;amp; keys[i].Equals(key))
        {
            values[i] = value;
            return;
        }
        //如果长度相等，则扩容
        if (length == keys.Length) Resize(2 * keys.Length);

        for (int j = length; j &amp;gt; i; j--)
        {
            keys[j] = keys[j - 1];
            values[j] = values[j - 1];
        }

        keys[i] = key;
        values[i] = value;
        length++;
    }

    /// &amp;lt;summary&amp;gt;
    /// 返回key在数组中的位置
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private int Rank(TKey key)
    {
        int lo = 0;
        int hi = length - 1;
        while (lo &amp;lt;= hi)
        {
            int mid = lo + (hi - lo) / 2;
            if (key.CompareTo(keys[mid]) &amp;gt; 0) lo = mid + 1;
            else if (key.CompareTo(keys[mid]) &amp;lt; 0) hi = mid - 1;
            else return mid;
        }
        return lo;
    }
    。。。
}&lt;/pre&gt;
&lt;p&gt;这里面重点是Rank方法，我们可以看到首先获取mid位置，然后将当前元素和mid位置元素比较，然后更新lo或者hi的位置用mid来替换，如果找到相等的，则直接返回mid，否则返回该元素在集合中应该插入的合适位置。上面是使用迭代的方式来实现的，也可以改写为递归：&lt;/p&gt;
&lt;pre&gt;private int Rank(TKey key, int lo, int hi)
{
    if (lo &amp;gt;= hi) return lo;

    int mid = lo + (hi - lo) / 2;
    if (key.CompareTo(keys[mid]) &amp;gt; 0)
        return Rank(key, mid + 1, hi);
    else if (key.CompareTo(keys[mid]) &amp;lt; 0)
        return Rank(key, lo, hi - 1);
    else
        return mid;
}&lt;/pre&gt;
&lt;p&gt;二分查找的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6685d34476ebf804e5d0a5e5c1ee127f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用有序的二维数组来实现查找表可以看出，采用二分查找只需要最多lgN+1次的比较即可找到对应元素，所以查找效率比较高。&lt;/p&gt;
&lt;p&gt;但是对于插入元素来说，每一次插入不存在的元素，需要将该元素放到指定的位置，然后，将他后面的元素依次后移，所以平均时间复杂度O(n)，对于插入来说效率仍然比较低。&lt;/p&gt;
&lt;h1&gt;三 总结&lt;/h1&gt;
&lt;p&gt;本文介绍了符号表这一抽象数据结构，然后介绍了两种基本实现：基于无序链表的实现和基于有序数组的实现，两种实现的时间复杂度如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4652ed9a0a74bed42b99a42950f2bcec.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，使用有序数组的二分查找法提高了符号表的查找速度，但是插入效率仍旧没有得到提高，而且在要维护数组有序，还需要进行排序操作。这两种实现方式简单直观，但是无法同时达到较高查找和插入效率。那么有没有一种数据结构既能够在查找的时候有较高的效率，在插入的时候也有较好的效率呢，本文只是一个引子，后面的系列文章将会介绍二叉查找树，平衡查找树以及哈希表。&lt;/p&gt;
&lt;p&gt;希望本文对您了解查找表的基本概念以及两种基本实现有所帮助。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79303-6eeba4ca4.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79303-6eeba4ca4.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（5）：优先级队列与堆排序</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在很多应用中，我们通常需要按照优先级情况对待处理对象进行处理，比如首先处理优先级最高的对象，然后处理次高的对象。最简单的一个例子就是，在手机上玩游戏的时候，如果有来电，那么系统应该优先处理打进来的电话。&lt;/p&gt;
&lt;p&gt;在这种情况下，我们的数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新的对象。这种数据结构就是优先级队列(Priority Queue) 。&lt;/p&gt;
&lt;p&gt;本文首先介绍优先级队列的定义，有序和无序数组以及堆数据结构实现优先级队列，最后介绍了基于优先级队列的堆排序(Heap Sort)&lt;/p&gt;
&lt;h1&gt;一 定义&lt;/h1&gt;
&lt;p&gt;优先级队列和通常的栈和队列一样，只不过里面的每一个元素都有一个”优先级”，在处理的时候，首先处理优先级最高的。如果两个元素具有相同的优先级，则按照他们插入到队列中的先后顺序处理。&lt;/p&gt;
&lt;p&gt;优先级队列可以通过链表，数组，堆或者其他数据结构实现。&lt;/p&gt;
&lt;h1&gt;二 实现&lt;/h1&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;p&gt;最简单的优先级队列可以通过有序或者无序数组来实现，当要获取最大值的时候，对数组进行查找返回即可。代码实现起来也比较简单，这里就不列出来了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/91f309ae855ca5194d788e000f5b1f5a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图：&lt;/p&gt;
&lt;p&gt;· 如果使用无序数组，那么每一次插入的时候，直接在数组末尾插入即可，时间复杂度为O(1)，但是如果要获取最大值，或者最小值返回的话，则需要进行查找，这时时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;· 如果使用有序数组，那么每一次插入的时候，通过插入排序将元素放到正确的位置，时间复杂度为O(n)，但是如果要获取最大值的话，由于元阿苏已经有序，直接返回数组末尾的 元素即可，所以时间复杂度为O(1).&lt;/p&gt;
&lt;p&gt;所以采用普通的数组或者链表实现，无法使得插入和排序都达到比较好的时间复杂度。所以我们需要采用新的数据结构来实现。下面就开始介绍如何采用二叉堆(binary heap)来实现优先级队列&lt;/p&gt;
&lt;h2&gt;二叉堆&lt;/h2&gt;
&lt;p&gt;二叉堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 有了这一性质，那么二叉堆上最大值就是根节点了。&lt;/p&gt;
&lt;p&gt;二叉堆的表现形式：我们可以使用数组的索引来表示元素在二叉堆中的位置。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images.cnitblog.com/blog/94031/201403/022349560186587.png&quot; rel=&quot;lightbox[79300]&quot; title=&quot;Heap representation&quot;&gt;&lt;img title=&quot;Heap representation&quot; alt=&quot;Heap representation&quot; src=&quot;/images/jobbole.com/abb7339d8fdffb01b32e6c0fe45d471d.jpg&quot; width=&quot;515&quot; height=&quot;458&quot; border=&quot;0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从二叉堆中，我们可以得出：&lt;/p&gt;
&lt;p&gt;· 元素k的父节点所在的位置为[k/2]&lt;/p&gt;
&lt;p&gt;· 元素k的子节点所在的位置为2k和2k+1&lt;/p&gt;
&lt;p&gt;跟据以上规则，我们可以使用二维数组的索引来表示二叉堆。通过二叉堆，我们可以实现插入和删除最大值都达到O(nlogn)的时间复杂度。&lt;/p&gt;
&lt;p&gt;对于堆来说，最大元素已经位于根节点，那么删除操作就是移除并返回根节点元素，这时候二叉堆就需要重新排列；当插入新的元素的时候，也需要重新排列二叉堆以满足二叉堆的定义。现在就来看这两种操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从下至上的重新建堆&lt;/strong&gt;操作: 如果一个节点的值大于其父节点的值，那么该节点就需要上移，一直到满足该节点大于其两个子节点，而小于其根节点为止，从而达到使整个堆实现二叉堆的要求。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e61f2bba269f8acd641b6f1a6f5ce7bb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看到，我们只需要将该元素k和其父元素k/2进行比较，如果比父元素大，则交换，然后迭代，一直到比父元素小为止。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Swim(int k)
{
    //如果元素比其父元素大，则交换
    while (k &amp;gt; 1 &amp;amp;&amp;amp; pq[k].CompareTo(pq[k / 2]) &amp;gt; 0)
    {
        Swap(pq, k, k / 2);
        k = k / 2;
    }
}&lt;/pre&gt;
&lt;p&gt;这样，往堆中插入新元素的操作变成了，将该元素从下往上重新建堆操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dcb09d1b1fc75143f1956505c55a080c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public static void Insert(T s)
{
    //将元素添加到数组末尾
    pq[++N] = s;
    //然后让该元素从下至上重建堆
    Swim(N);
}&lt;/pre&gt;
&lt;p&gt;动画如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7c1c4dfbb9aae2eca806b9d0f8ccba57.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由上至下的重新建堆操作：&lt;/strong&gt;当某一节点比其子节点要小的时候，就违反了二叉堆的定义，需要和其子节点进行交换以重新建堆，直到该节点都大于其子节点为止：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0a4a45b9afe1ef2f5ad550d2db2d4040.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码实现如下:&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Sink(int k)
{
    while (2 * k &amp;lt; N)
    {
        int j = 2 * k;
        //去左右子节点中，稍大的那个元素做比较
        if (pq[j].CompareTo(pq[j + 1]) &amp;lt; 0) j++;
        //如果父节点比这个较大的元素还大，表示满足要求，退出
        if (pq[k].CompareTo(pq[j]) &amp;gt; 0) break;
        //否则，与子节点进行交换
        Swap(pq, k, j);
        k = j;
    }
}&lt;/pre&gt;
&lt;p&gt;这样，移除并返回最大元素操作DelMax可以变为：&lt;/p&gt;
&lt;p&gt;1. 移除二叉堆根节点元素，并返回&lt;/p&gt;
&lt;p&gt;2. 将数组中最后一个元素放到根节点位置&lt;/p&gt;
&lt;p&gt;3. 然后对新的根节点元素进行Sink操作，直到满足二叉堆要求。&lt;/p&gt;
&lt;p&gt;移除最大值并返回的操作如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/91c38a3809ebb8b683932b182e7d81d4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上操作的实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public static T DelMax()
{
    //根元素从1开始，0不存放值
    T max = pq[1];
    //将最后一个元素和根节点元素进行交换
    Swap(pq, 1, N--);
    //对根节点从上至下重新建堆
    Sink(1);
    //将最后一个元素置为空
    pq[N + 1] = default(T);
    return max;
}&lt;/pre&gt;
&lt;p&gt;动画如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9099b6078d5a1f463cde85262b7f2fe7.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;三 堆排序&lt;/h1&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/698df477bd913a53dba46cb4ad6b1941.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;概念&lt;/h2&gt;
&lt;p&gt;运用二叉堆的性质，可以利用它来进行一种就地排序，该排序的步骤为：&lt;/p&gt;
&lt;p&gt;1. 使用序列的所有元素，创建一个最大堆。&lt;/p&gt;
&lt;p&gt;2. 然后重复删除最大元素。&lt;/p&gt;
&lt;p&gt;如下图，以对S O R T E X A M P L E 排序为例，首先本地构造一个最大堆，即对节点进行Sink操作，使其符合二叉堆的性质。&lt;/p&gt;
&lt;p&gt;然后再重复删除根节点，也就是最大的元素，操作方法与之前的二叉堆的删除元素类似。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/05228c8c0bbcd8216512b2b83dbfb4d7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建最大二叉堆&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;使用至下而上的方法创建二叉堆的方法为，分别对叶子结点的上一级节点以重上之下的方式重建堆。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;for (int k = N / 2; k &amp;gt;= 1; k--)
{
    Sink(pq, k, N);
}&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b235c9f9745fdf744dcf07cc2b9a4666.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用二叉堆排序其实就是循环移除顶部元素到数组末尾，然后利用Sink重建堆的操作。如下图，实现代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;while (N &amp;gt; 1)
{
    Swap(pq, 1, N--);
    Sink(pq, 1, N);
}&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e6bf5bc88e4aec9e316665194d7a9847.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;堆排序的动画如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2462a354605cbda295eaa1c8cf6d9d9f.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;1. 在构建最大堆的时候，最多需要2N次比较和交换&lt;/p&gt;
&lt;p&gt;2. 堆排序最多需要2NlgN次比较和交换操作&lt;/p&gt;
&lt;p&gt;优点：堆排序最显著的优点是，他是就地排序，并且其最坏情况下时间复杂度为NlogN。经典的合并排序不是就地排序，它需要线性长度的额外空间，而快速排序其最坏时间复杂度为N&lt;sup&gt;2&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bebc1cc802723e67d821dde0c821c5d4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;缺点：堆排序对时间和空间都进行了优化，但是：&lt;/p&gt;
&lt;p&gt;1. 其内部循环要比快速排序要长。&lt;/p&gt;
&lt;p&gt;2. 并且其操作在N和N/2之间进行比较和交换，当数组长度比较大的时候，对CPU缓存利用效率比较低。&lt;/p&gt;
&lt;p&gt;3. 非稳定性排序。&lt;/p&gt;
&lt;h1&gt;四 排序算法的小结&lt;/h1&gt;
&lt;p&gt;本文及前面文章介绍了&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduction-Insertion-and-Selection-and-Shell-Sort.html&quot; target=&quot;_blank&quot;&gt;选择排序&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduction-Insertion-and-Selection-and-Shell-Sort.html&quot; target=&quot;_blank&quot;&gt;插入排序&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduction-Insertion-and-Selection-and-Shell-Sort.html&quot; target=&quot;_blank&quot;&gt;希尔排序&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Merge-Sort.html&quot; target=&quot;_blank&quot;&gt;合并排序&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Quick-Sort.html&quot; target=&quot;_blank&quot;&gt;快速排序&lt;/a&gt;以及本文介绍的堆排序。各排序的稳定性，平均，最坏，最好的时间复杂度如下表：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/77829d78f3e260b750759f4c4ac94994.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，不同的排序方法有不同的特征，有的速度快，但是不稳定，有的稳定，但是不是就地排序，有的是就地排序，但是最坏情况下时间复杂度不好。那么有没有一种排序能够集合以上所有的需求呢?&lt;/p&gt;
&lt;h1&gt;五 结语&lt;/h1&gt;
&lt;p&gt;本文介绍了二叉堆，以及基于二叉堆的堆排序，他是一种就地的非稳定排序，其最好和平均时间复杂度和快速排序相当，但是最坏情况下的时间复杂度要优于快速排序。但是由于他对元素的操作通常在N和N/2之间进行，所以对于大的序列来说，两个操作数之间间隔比较远，对CPU缓存利用不太好，故速度没有快速排序快。&lt;/p&gt;
&lt;p&gt;下文将开始介绍查找算法，并介绍二叉查找树。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79300-fdfad903b.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79300-fdfad903b.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（4）：快速排序</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;上篇文章介绍了时间复杂度为O(nlgn)的合并排序，本篇文章介绍时间复杂度同样为O(nlgn)但是排序速度比合并排序更快的快速排序(Quick Sort)。&lt;/p&gt;
&lt;p&gt;快速排序是&lt;a href=&quot;http://www.siam.org/pdf/news/637.pdf&quot; target=&quot;_blank&quot;&gt;20世纪科技领域的十大算法之一&lt;/a&gt; ，他由&lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare&quot; target=&quot;_blank&quot;&gt;C. A. R. Hoare&lt;/a&gt;于1960年提出的一种划分交换排序。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d935cb65339153442501ddbf340c0a08.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;快速排序也是一种采用分治法解决问题的一个典型应用。在很多编程语言中，对数组，列表进行的非稳定排序在内部实现中都使用的是快速排序。而且快速排序在面试中经常会遇到。&lt;/p&gt;
&lt;p&gt;本文首先介绍快速排序的思路，算法的实现、分析、优化及改进，最后分析了.NET 中列表排序的内部实现。&lt;/p&gt;
&lt;h1&gt;一 原理&lt;/h1&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/35c7307cbbc2497295a8f5830583ceff.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;快速排序的基本思想如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对数组进行随机化。&lt;/li&gt;
&lt;li&gt;从数列中取出一个数作为中轴数(pivot)。&lt;/li&gt;
&lt;li&gt;将比这个数大的数放到它的右边，小于或等于它的数放到它的左边。&lt;/li&gt;
&lt;li&gt;再对左右区间重复第三步，直到各区间只有一个数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3cc32516c98cefe540b70cd7573dd297.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示快速排序的一个重要步骤是对序列进行以中轴数进行划分，左边都小于这个中轴数，右边都大于该中轴数，然后对左右的子序列继续这一步骤直到子序列长度为1。&lt;/p&gt;
&lt;p&gt;下面来看某一次划分的步骤，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6c6d8af6e8c29e81d14dcbc2b57170ef.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图中的划分操作可以分为以下5个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取中轴元素&lt;/li&gt;
&lt;li&gt;i从左至右扫描，如果小于基准元素，则i自增，否则记下a[i]&lt;/li&gt;
&lt;li&gt;j从右至左扫描，如果大于基准元素，则i自减，否则记下a[j]&lt;/li&gt;
&lt;li&gt;交换a[i]和a[j]&lt;/li&gt;
&lt;li&gt;重复这一步骤直至i和j交错，然后和基准元素比较，然后交换。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;划分过程的代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 快速排序中的划分过程
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;array&quot;&amp;gt;待划分的数组&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;lo&quot;&amp;gt;最左侧位置&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;hi&quot;&amp;gt;最右侧位置&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;中间元素位置&amp;lt;/returns&amp;gt;
private static int Partition(T[] array, int lo, int hi)
{
    int i = lo, j = hi + 1;
    while (true)
    {
        //从左至右扫描，如果碰到比基准元素array[lo]小，则该元素已经位于正确的分区，i自增，继续比较i+1；
        //否则，退出循环，准备交换
        while (array[++i].CompareTo(array[lo]) &amp;lt; 0)
        {
            //如果扫描到了最右端，退出循环
            if (i == hi) break;
        }

        //从右自左扫描，如果碰到比基准元素array[lo]大，则该元素已经位于正确的分区，j自减，继续比较j-1
        //否则，退出循环，准备交换
        while (array[--j].CompareTo(array[lo]) &amp;gt; 0)
        {
            //如果扫描到了最左端，退出循环
            if (j == lo) break;
        }

        //如果相遇，退出循环
        if (i &amp;gt;= j) break;

        //交换左a[i],a[j]右两个元素，交换完后他们都位于正确的分区
        Swap(array, i, j);
    }
    //经过相遇后，最后一次a[i]和a[j]的交换
    //a[j]比a[lo]小，a[i]比a[lo]大，所以将基准元素与a[j]交换
    Swap(array, lo, j);
    //返回扫描相遇的位置点
    return j;
}&lt;/pre&gt;
&lt;p&gt;划分前后，元素在序列中的分布如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/00014a047728a750923a530152e28117.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;二 实现&lt;/h1&gt;
&lt;p&gt;与合并算法基于合并这一过程一样，快速排序基于分割(Partition)这一过程。只需要递归调用Partition这一操作，每一次以Partition返回的元素位置来划分为左右两个子序列，然后继续这一过程直到子序列长度为1，代码的实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public class QuickSort&amp;lt;T&amp;gt; where T : IComparable&amp;lt;T&amp;gt;
{
    public static void Sort(T[] array)
    {
        Sort(array, 0, array.Length - 1);
    }

    private static void Sort(T[] array, int lo, int hi)
    {
        //如果子序列为1，则直接返回
        if (lo &amp;gt;= hi) return;
        //划分，划分完成之后，分为左右序列，左边所有元素小于array[index]，右边所有元素大于array[index]
        int index = Partition(array, lo, hi);

       //对左右子序列进行排序完成之后，整个序列就有序了
        //对左边序列进行递归排序
        Sort(array, lo, index - 1);
        //对右边序列进行递归排序
        Sort(array, index + 1, hi);
    }
}&lt;/pre&gt;
&lt;p&gt;下图说明了快速排序中，每一次划分之后的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3d72ba13c788fdd4241ed0809ed5cf73.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;一般快速排序的动画如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/321b865ecac4ef38c4ac3d39d7ed7161.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;三 分析&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;在最好的情况下，快速排序只需要大约nlgn次比较操作，在最坏的情况下需要大约1/2 n&lt;sup&gt;2 &lt;/sup&gt;次比较操作。在最好的情况下，每次的划分都会恰好从中间将序列划分开来，那么只需要lgn次划分即可划分完成，是一个标准的分治算法Cn=2Cn/2+N，每一次划分都需要比较N次，大家可以回想下我们是如何证明合并排序的时间复杂度的。
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6ee4f64ac2f8f98d9b0cde65acc6d307.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在最坏的情况下，即序列已经排好序的情况下，每次划分都恰好把数组划分成了0，n两部分，那么需要n次划分，但是比较的次数则变成了n, n-1, n-2,….1, 所以整个比较次数约为n(n-1)/2~n&lt;sup&gt;2&lt;/sup&gt;/2.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;快速排序平均需要大约2NlnN次比较，来对长度为n的排序关键字唯一的序列进行排序。 证明也比较简单：假设C&lt;sub&gt;N&lt;/sub&gt;为快速排序平均花在比较上的时间，初始C&lt;sub&gt;0&lt;/sub&gt;=C&lt;sub&gt;1&lt;/sub&gt;=0，对于N&amp;gt;1的情况，有：&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/74da1f49a1d53ce5741f1df4548567e2.jpg&quot;&gt;
&lt;p&gt;其中N+1是分割时的比较次数，&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5b161b304ade8da0f2b0118f913e0d33.jpg&quot;&gt; 表示将序列分割为0，和N-1左右两部分的概率为1/N, 划分为1，N-2左右两部分的概率也为1/N，都是等概率的。&lt;/p&gt;
&lt;p&gt;然后对上式左右两边同时乘以N，整理得到：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/df2c192117e078b3e2485a1f2cb000b0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后，对于N为N-1的情况：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c10fd6c8b225ac2955fd8bc8d619dc14.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;两式相减，然后整理得到：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/460257636e7efafdb1b852131e3b61a5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后左右两边同时除以N(N+1)，得到:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4b1987b05a0b2298259d4179b889795e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这是一个递归式，我们将&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e660704b5b32193bef39a2a6fb36b583.jpg&quot;&gt; 递归展开得到：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3c170538abf537886904603a86ae2826.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后处理一下得到：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;平均情况下，快速排序需要大约1.39NlgN次比较，这比合并排序多了39%的比较，但是由于涉及了较少的数据交换和移动操作，他要比合并排序更快。&lt;/li&gt;
&lt;li&gt;为了避免出现最坏的情况，导致序列划分不均，我们可以首先对序列进行随机化排列然后再进行排序就可以避免这一情况的出现。&lt;/li&gt;
&lt;li&gt;快速排序是一种就地(in-place)排序算法。在分割操作中只需要常数个额外的空间。在递归中，也只需要对数个额外空间。&lt;/li&gt;
&lt;li&gt;另外，快速排序是非稳定性排序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/342d3315291ed3f2432d7a22437830f3.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;四 改进&lt;/h1&gt;
&lt;p&gt;对一般快速排序进行一些改进可以提高其效率。&lt;/p&gt;
&lt;p&gt;1. 当划分到较小的子序列时，通常可以使用插入排序替代快速排序&lt;/p&gt;
&lt;p&gt;对于较小的子序列（通常序列元素个数为10个左右），我们就可以采用插入排序直接进行排序而不用继续递归，算法改造如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private const int CUTTOFF = 10;
private static void Sort(T[] array, int lo, int hi)
{
    //如果子序列为1，则直接返回
    if (lo &amp;gt;= hi) return;
    //对于小序列，直接采用插入排序替代
    if (hi - lo &amp;lt;= CUTTOFF - 1) 
    {
        Sort&amp;lt;int&amp;gt;.InsertionSort(array, lo, hi);
        return;
    }
    //划分，划分完成之后，分为左右序列，左边所有元素小于array[index]，右边所有元素大于array[index]
    int index = Partition(array, lo, hi);

    //对左右子序列进行排序完成之后，整个序列就有序了

    //对左边序列进行递归排序
    Sort(array, lo, index - 1);
    //对右边序列进行递归排序
    Sort(array, index + 1, hi);
}&lt;/pre&gt;
&lt;p&gt;2. 三平均分区法(Median of three partitioning)&lt;/p&gt;
&lt;p&gt;在一般的的快速排序中，选择的是第一个元素作为中轴(pivot),这会出现某些分区严重不均的极端情况，比如划分为了1和n-1两个序列，从而导致出现最坏的情况。三平均分区法与一般的快速排序方法不同，它并不是选择待排数组的第一个数作为中轴，而是选用待排数组最左边、最右边和最中间的三个元素的中间值作为中轴。这一改进对于原来的快速排序算法来说，主要有两点优势：&lt;/p&gt;
&lt;p&gt;（1） 首先，它使得最坏情况发生的几率减小了。&lt;/p&gt;
&lt;p&gt;（2） 其次，未改进的快速排序算法为了防止比较时数组越界，在最后要设置一个哨点。如果在分区排序时，中间的这个元素（也即中轴）是与最右边数过来第二个元素进行交换的话，那么就可以省略与这一哨点值的比较。&lt;/p&gt;
&lt;p&gt;对于三平均分区法还可以进一步扩展，在选取中轴值时，可以从由左中右三个中选取扩大到五个元素中或者更多元素中选取，一般的，会有（2t＋1）平均分区法（median-of-(2t+1)。常用的一个改进是，当序列元素小于某个阈值N时，采用三平均分区，当大于时采用5平均分区。&lt;/p&gt;
&lt;p&gt;采用三平均分区法对快速排序的改进如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Sort(T[] array, int lo, int hi)
{
    //对于小序列，直接采用插入排序替代
    if (hi - lo &amp;lt;= CUTTOFF - 1) 
    {
        //Sort&amp;lt;int&amp;gt;.InsertionSort(array, lo, hi);
        return;
    }
    //采用三平均分区法查找中轴
    int m = MedianOf3(array, lo, lo + (hi - lo) / 2, hi);
    Swap(array, lo, m);
    //划分，划分完成之后，分为左右序列，左边所有元素小于array[index]，右边所有元素大于array[index]
    int index = Partition(array, lo, hi);

    //对左右子序列进行排序完成之后，整个序列就有序了

    //对左边序列进行递归排序
    Sort(array, lo, index - 1);
    //对右边序列进行递归排序
    Sort(array, index + 1, hi);
}

/// &amp;lt;summary&amp;gt;
/// 查找三个元素中位于中间的那个元素
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;array&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;lo&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;center&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;hi&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
private static int MedianOf3(T[] array, int lo, int center, int hi)
{
    return (Less(array[lo], array[center]) ?
           (Less(array[center], array[hi]) ? center : Less(array[lo], array[hi]) ? hi : lo) :
           (Less(array[hi], array[center]) ? center : Less(array[hi], array[lo]) ? hi : lo));
}

private static bool Less(T t1, T t2)
{
    return t1.CompareTo(t2) &amp;lt; 0;
}&lt;/pre&gt;
&lt;p&gt;使用插入排序对小序列进行排序以及使用三平均分区法对一般快速排序进行改进后运行结果示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bea7a3ee1344088671686ee8caf747a5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 三分区(3-way partitioning) 快速排序&lt;/p&gt;
&lt;p&gt;通常，我们的待排序的序列关键字中会有很多重复的值，比如我们想对所有的学生按照年龄进行排序，按照性别进行排序等，这样每一类别中会有很多的重复的值。理论上，这些重复的值只需要处理一次就行了。但是一般的快速排序会递归进行划分，因为一般的快速排序只是将序列划分为了两部分，小于或者大于等于这两部分。&lt;/p&gt;
&lt;p&gt;既然要利用连续、相等的元素不需要再参与排序这个事实，一个直接的想法就是通过划分让相等的元素连续地摆放：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/01eecd8a247b351703c03b642ed483cf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后只对左侧小于V的序列和右侧大于V对的序列进行排序。这种三路划分与计算机科学中无处不在，它与Dijkstra提出的“荷兰国旗问题”(&lt;a href=&quot;http://www.iis.sinica.edu.tw/~scm/ncs/2010/10/dutch-national-flag-problem/&quot;&gt;The Dutch National Flag Problem&lt;/a&gt;)非常相似。&lt;/p&gt;
&lt;p&gt;Dijkstra的方法如上图：&lt;/p&gt;
&lt;p&gt;从左至右扫描数组，维护一个指针lt使得[lo…lt-1]中的元素都比v小，一个指针gt使得所有[gt+1….hi]的元素都大于v，以及一个指针i，使得所有[lt…i-1]的元素都和v相等。元素[i…gt]之间是还没有处理到的元素，i从lo开始，从左至右开始扫描：&lt;/p&gt;
&lt;p&gt;· 如果a[i]&amp;lt;v: 交换a[lt]和a[i],lt和i自增&lt;/p&gt;
&lt;p&gt;· 如果a[i]&amp;gt;v:交换a[i]和a[gt], gt自减&lt;/p&gt;
&lt;p&gt;· 如果a[i]=v: i自增&lt;/p&gt;
&lt;p&gt;下面是使用Dijkstra的三分区快速排序代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Sort(T[] array, int lo, int hi)
{
    //对于小序列，直接采用插入排序替代
    if (hi - lo &amp;lt;= CUTTOFF - 1)
    {
        Sort&amp;lt;int&amp;gt;.InsertionSort(array, lo, hi);
        return;
    }
    //三分区
    int lt = lo, i = lo + 1, gt = hi;
    T v = array[lo];
    while (i&amp;lt;=gt)
    {
        int cmp = array[i].CompareTo(v);
        if (cmp &amp;lt; 0) Swap(array, lt++, i++);
        else if (cmp &amp;gt; 0) Swap(array, i, gt--);
        else i++;
    }

    //对左边序列进行递归排序
    Sort(array, lo, lt - 1);
    //对右边序列进行递归排序
    Sort(array, gt + 1, hi);
}&lt;/pre&gt;
&lt;p&gt;三分区快速排序的每一步如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d299a5969c55fa3358cf40dade233218.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;三分区快速排序的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/14e24fbcac1855e930f401ffb3a4b878.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;Dijkstra的三分区快速排序虽然在快速排序发现不久后就提出来了，但是对于序列中重复值不多的情况下，它比传统的2分区快速排序需要更多的交换次数。&lt;/p&gt;
&lt;p&gt;Bentley 和D. McIlroy在普通的三分区快速排序的基础上，对一般的快速排序进行了改进。在划分过程中，i遇到的与v相等的元素交换到最左边，j遇到的与v相等的元素交换到最右边，i与j相遇后再把数组两端与v相等的元素交换到中间&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d7b1bbbd5645aa59f93215949850239f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个方法不能完全满足只扫描一次的要求，但它有两个好处：首先，如果数据中没有重复的值，那么该方法几乎没有额外的开销；其次，如果有重复值，那么这些重复的值不会参与下一趟排序，减少了无用的划分。&lt;/p&gt;
&lt;p&gt;下面是采用 Bentley&amp;amp;D. McIlroy 三分区快速排序的算法改进：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Sort(T[] array, int lo, int hi)
{
    //对于小序列，直接采用插入排序替代
    if (hi - lo &amp;lt;= CUTTOFF - 1)
    {
        Sort&amp;lt;int&amp;gt;.InsertionSort(array, lo, hi);
        return;
    }
    // Bentley-McIlroy 3-way partitioning
    int i = lo, j = hi + 1;
    int p = lo, q = hi + 1;
    T v = array[lo];
    while (true)
    {
        while (Less(array[++i], v))
            if (i == hi) break;
        while (Less(v, array[--j]))
            if (j == lo) break;

        // pointers cross
        if (i == j &amp;amp;&amp;amp; Equal(array[i], v))
            Swap(array, ++p, i);
        if (i &amp;gt;= j) break;

        Swap(array, i, j);
        if (Equal(array[i], v)) Swap(array, ++p, i);
        if (Equal(array[j], v)) Swap(array, --q, j);
    }

    //将相等的元素交换到中间
    i = j + 1;
    for (int k = lo; k &amp;lt;= p; k++) Swap(array, k, j--);
    for (int k = hi; k &amp;gt;= q; k--) Swap(array, k, i++);

    Sort(array, lo, j);
    Sort(array, i, hi);
}&lt;/pre&gt;
&lt;p&gt;三分区快速排序的动画如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dff16aa526ebc2a2cd259152f15f35f4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;4.并行化&lt;/p&gt;
&lt;p&gt;和前面讨论对合并排序的改进一样，对所有使用分治法解决问题的算法其实都可以进行并行化，快速排序的并行化改进我在之前的&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Something-about-Concurrent-and-Parallel-Programming.html&quot; target=&quot;_blank&quot;&gt;浅谈并发与并行&lt;/a&gt;这篇文章中已经有过介绍，这里不再赘述。&lt;/p&gt;
&lt;h1&gt;五 .NET 中元素排序的内部实现&lt;/h1&gt;
&lt;p&gt;快速排序作为一种优秀的排序算法，在很多编程语言的元素内部排序中均有实现，比如Java中对基本数据类型(primitive type)的排序,C++，Matlab，Python，FireFox Javascript等语言中均将快速排序作为其内部元素排序的算法。同样.NET中亦是如此。&lt;/p&gt;
&lt;p&gt;.NET这种对List&amp;lt;T&amp;gt;数组元素进行排序是通过调用Sort方法实现的，其内部则又是通过Array.Sort实现，MSDN上说在&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/b0zbh7b6(v=vs.100).aspx&quot; target=&quot;_blank&quot;&gt;.NET 4.0及之前的版本&lt;/a&gt;，Array.Sort采用的是快速排序，然而在&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/b0zbh7b6(v=vs.110).aspx&quot; target=&quot;_blank&quot;&gt;.NET 4.5&lt;/a&gt;中，则对这一算法进行了改进，采用了名为&lt;a href=&quot;http://en.wikipedia.org/wiki/Introsort&quot; target=&quot;_blank&quot;&gt;Introspective sort&lt;/a&gt; 的算法，即保证在一般情况下达到最快排序速度，又能保证能够在出现最差情况是进行优化。他其实是一种混合算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当待分区的元素个数小于16个时，采用插入排序&lt;/li&gt;
&lt;li&gt;当分区次数超过2*logN，N是输入数组的区间大小，则使用堆排序(Heapsort)&lt;/li&gt;
&lt;li&gt;否则，使用快速排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了Reflector这一神器，我们可以查看.NET中的ArraySort的具体实现:&lt;/p&gt;
&lt;p&gt;Array.Sort这一方法在mscorlib这一程序集中，具体的实现方法有分别针对泛型和普通类型的SortedGenericArray和SortedObjectArray，里面的实现大同小异，我们以SortedGenericArray这个类来作为例子看:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3e0e104b96e27175301547c8616fcc88.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先要看的是Sort方法，其实现如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ab589de170f1ef1fde592fddba686b3a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;该方法中，首先判断运行的.NET对的版本，如果是4.5及以上版本，则用IntrospectiveSort算法，否则采用限定深度的快速排序算法DepthLimitedQuickSort。先看IntrospectiveSort：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/529a6e89c21c0c842a1777bd92b5c93d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;该方法第一个元素为数组的最左边元素位置，第二个参数为最右边元素位置，第三个参数为2*log&lt;sub&gt;2&lt;/sub&gt;N，继续看方法内部：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d76d814acd660d0f83baaa92cd7cd48f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，当num&amp;lt;=16时，如果元素个数为1,2,3，则直接调用SwapIfGreaterWithItem进行排序了。否则直接调用InsertSort进行插入排序。&lt;/p&gt;
&lt;p&gt;这里面也是一个循环，每循环一下depthLimit就减小1个，如果为0表示划分的次数超过了2logN，则直接调用基排序(HeapSort)，这里面的划分方法PickPivortAndPartitin的实现如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/990eb3ac466db2e76cd6c1e76db1b3a5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;它其实是一个标准的三平均快速排序。可以看到在.NET 4.5中对Quick进行优化的部分主要是在元素个数比较少的时候采用选择插入，并且在递归深度超过2logN的时候，采用基排序。&lt;/p&gt;
&lt;p&gt;下面再来看下在.NET 4.0及以下平台下排序DepthLimitedQuickSort方法的实现：&lt;/p&gt;
&lt;p&gt;从名称中可以看出这是限定深度的快速排序，在第三个参数传进去的是0×20，也就是32。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a12cc44e5cde66e8db48d5c418c836aa.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，当划分的次数大于固定的32次的时候，采用了基排序，其他的部分是普通的快速排序。&lt;/p&gt;
&lt;h1&gt;六 总结&lt;/h1&gt;
&lt;p&gt;由于快速排序在排序算法中具有排序速度快，而且是就地排序等优点，使得在许多编程语言的内部元素排序实现中采用的就是快速排序，本问首先介绍了一般的快速排序，分析了快速排序的时间复杂度，然后就分析了对快速排序的几点改进，包括对小序列采用插入排序替代，三平均划分，三分区划分等改进方法。最后介绍了.NET不同版本下的对元素内部排序的实现。&lt;/p&gt;
&lt;p&gt;快速排序很重要，希望本文对您了解快速排序有所帮助。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79298-f84dd203d.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79298-f84dd203d.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（3）：合并排序</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;合并排序，顾名思义，就是通过将两个有序的序列合并为一个大的有序的序列的方式来实现排序。合并排序是一种典型的分治算法：首先将序列分为两部分，然后对每一部分进行循环递归的排序，然后逐个将结果进行合并。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ef06ab6f3727fa0cac92c29b56d4a97a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;合并排序最大的优点是它的时间复杂度为O(nlgn)，这个是我们之前的选择排序和插入排序所达不到的。他还是一种稳定性排序，也就是相等的元素在序列中的相对位置在排序前后不会发生变化。他的唯一缺点是，需要利用额外的N的空间来进行排序。&lt;/p&gt;
&lt;h1&gt;一 原理&lt;/h1&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c7e68ec4106cd05782cdc4382a0f1c80.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;合并排序依赖于合并操作，即将两个已经排序的序列合并成一个序列，具体的过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;申请空间，使其大小为两个已经排序序列之和，然后将待排序数组复制到该数组中。&lt;/li&gt;
&lt;li&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/li&gt;
&lt;li&gt;比较复制数组中两个指针所指向的元素，选择相对小的元素放入到原始待排序数组中，并移动指针到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3直到某一指针达到序列尾&lt;/li&gt;
&lt;li&gt;将另一序列剩下的所有元素直接复制到原始数组末尾&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该过程实现如下，注释比较清楚：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Merge(T[] array, int lo, int mid, int hi)
{
    int i = lo, j = mid + 1;
    //把元素拷贝到辅助数组中
    for (int k = lo; k &amp;lt;= hi; k++)
    {
        aux[k] = array[k];
    }
    //然后按照规则将数据从辅助数组中拷贝回原始的array中
    for (int k = lo; k &amp;lt;= hi; k++)
    {
        //如果左边元素没了， 直接将右边的剩余元素都合并到到原数组中
        if (i &amp;gt; mid)
        {
            array[k] = aux[j++];
        }//如果右边元素没有了，直接将所有左边剩余元素都合并到原数组中
        else if (j &amp;gt; hi)
        {
            array[k] = aux[i++];
        }//如果左边右边小，则将左边的元素拷贝到原数组中
        else if (aux[i].CompareTo(aux[j]) &amp;lt; 0)
        {
            array[k] = aux[i++];
        }
        else
        {
            array[k] = aux[j++];
        }
    }
}&lt;/pre&gt;
&lt;p&gt;下图是使用以上方法将ＥＥＧＭＲ和ＡＣＥＲＴ这两个有序序列合并为一个大的序列的过程演示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2a103137bb585aa2c3c13bdeab551941.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;二 实现&lt;/h1&gt;
&lt;p&gt;合并排序有两种实现，一种是至上而下(Top-Down)合并，一种是至下而上 (Bottom-Up)合并，两者算法思想差不多，这里仅介绍至上而下的合并排序。&lt;/p&gt;
&lt;p&gt;至上而下的合并是一种典型的分治算法(Divide-and-Conquer)，如果两个序列已经排好序了，那么采用合并算法，将这两个序列合并为一个大的序列也就是对大的序列进行了排序。&lt;/p&gt;
&lt;p&gt;首先我们将待排序的元素均分为左右两个序列，然后分别对其进去排序，然后对这个排好序的序列进行合并，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public class MergeSort&amp;lt;T&amp;gt; where T : IComparable&amp;lt;T&amp;gt;
{
    private static T[] aux; // 用于排序的辅助数组
    public static void Sort(T[] array)
    {
        aux = new T[array.Length]; // 仅分配一次
        Sort(array, 0, array.Length - 1);
    }
    private static void Sort(T[] array, int lo, int hi)
    {
        if (lo &amp;gt;= hi) return; //如果下标大于上标，则返回
        int mid = lo + (hi - lo) / 2;//平分数组
        Sort(array, lo, mid);//循环对左侧元素排序
        Sort(array, mid + 1, hi);//循环对右侧元素排序
        Merge(array, lo, mid, hi);//对左右排好的序列进行合并
    }
    ...
}&lt;/pre&gt;
&lt;p&gt;以排序一个具有15个元素的数组为例，其调用堆栈为：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/453fadd4224adc75a1b59855e7d48a70.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们单独将Merge步骤拿出来，可以看到合并的过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b78a9a3c29e118684b30c0dbd2159e31.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;三 图示及动画&lt;/h1&gt;
&lt;p&gt;如果以排序38,27,43,3,9,82,10为例，将合并排序画出来的话，可以看到如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/970e639deb85e6250a2e48c60115bfaf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图是合并排序的可视化效果图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6743e85ecf9cb686663fbb92cbe02cca.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;对6 5 3 1 8 7 24 进行合并排序的动画效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8ffe489ec7890cc127cc60e0e5e6b925.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图演示了合并排序在不同的情况下的效率：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/666e11db508e5f15bcea4e3003df2de9.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;四 分析&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;/strong&gt;&lt;strong&gt;合并排序的平均时间复杂度为&lt;/strong&gt;&lt;strong&gt;O(nlgn)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;证明：合并排序是目前我们遇到的第一个时间复杂度不为n&lt;sup&gt;2&lt;/sup&gt;的时间复杂度为nlgn(这里lgn代表log&lt;sub&gt;2&lt;/sub&gt;n)的排序算法，下面给出对合并排序的时间复杂度分析的证明：&lt;/p&gt;
&lt;p&gt;假设D(N)为对整个序列进行合并排序所用的时间，那么一个合并排序又可以二分为两个D(N/2)进行排序，再加上与N相关的比较和计算中间数所用的时间。整个合并排序可以用如下递归式表示：&lt;/p&gt;
&lt;p&gt;D(N)=2D(N/2)+N,N&amp;gt;1;&lt;/p&gt;
&lt;p&gt;D(N)=0,N=1; (当N=1时，数组只有1个元素，已排好序，时间为0)&lt;/p&gt;
&lt;p&gt;因为在分治算法中经常会用到递归式，所以在&lt;a href=&quot;http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844&quot; target=&quot;_blank&quot;&gt;CLRS&lt;/a&gt;中有一章专门讲解递归式的求解和证明，使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Master_theorem&quot; target=&quot;_blank&quot;&gt;主定理(master theorem)&lt;/a&gt;可以直接求解出该递归式的值，后面我会简单介绍。这里简单的列举两种证明该递归式时间复杂度为O(nlgn)的方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prof1&lt;/strong&gt;：处于方便性考虑，我们假设数组N为2的整数幂，这样根据递归式我们可以画出一棵树：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0c78ab7b84d4f83312f7de75e50c90e0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们对数组N进行MergeSort的时候，是逐级划分的，这样就形成了一个&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;满二叉树&lt;/a&gt;，树的每一及子节点都为N，树的深度即为层数lgN+1，满二叉树的深度的计算可以查阅相关资料，上图中最后一层子节点没有画出来。这样，这棵树有lgN+1层，每一层有N个节点，所以&lt;/p&gt;
&lt;p&gt;D(N)=(lgN+1)N=NlgN+N=NlgN&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prof2&lt;/strong&gt;：我们在为递归表达式求解的时候，还有一种常用的方法就是数学归纳法，&lt;/p&gt;
&lt;p&gt;首先根据我们的递归表达式的初始值以及观察，我们猜想D(N)=NlgN.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当N=1 时，D(1)=0,满足初始条件。&lt;/li&gt;
&lt;li&gt;为便于推导，假设N是2的整数次幂N=2&lt;sup&gt;k&lt;/sup&gt;, 即D(2&lt;sup&gt;k&lt;/sup&gt;)=2&lt;sup&gt;k&lt;/sup&gt;lg2&lt;sup&gt;k&lt;/sup&gt; = k*2&lt;sup&gt;k&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;在N+1 的情况下D(N+1)=D(2&lt;sup&gt;k+1&lt;/sup&gt;)=2&lt;sup&gt;k+1&lt;/sup&gt;lg2&lt;sup&gt;k+1&lt;/sup&gt;=(k+1) * 2&lt;sup&gt;k+1&lt;/sup&gt;,所以假设成立，D(N)=NlgN.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;strong&gt;合并排序需要额外的长度为&lt;/strong&gt;&lt;strong&gt;N&lt;/strong&gt;&lt;strong&gt;的辅助空间来完成排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果对长度为N的序列进行排序需要&amp;lt;=clogN 的额外空间，认为就是&lt;a href=&quot;http://en.wikipedia.org/wiki/In-place_algorithm&quot; target=&quot;_blank&quot;&gt;就地排序&lt;/a&gt;(in place排序)也就是完成该排序操作需要较小的，固定数量的额外辅助内存空间。之前学习过的选择排序，插入排序，希尔排序都是原地排序。&lt;/p&gt;
&lt;p&gt;但是在合并排序中，我们要创建一个大小为N的辅助排序数组来存放初始的数组或者存放合并好的数组，所以需要长度为N的额外辅助空间。当然也有前人已经将合并排序改造为了&lt;a href=&quot;http://www.diku.dk/hjemmesider/ansatte/jyrki/Paper/mergesort_NJC.ps&quot; target=&quot;_blank&quot;&gt;就地合并排序&lt;/a&gt;，但是算法的实现变得比较复杂。&lt;/p&gt;
&lt;p&gt;需要额外N的空间来辅助排序是合并排序的最大缺点，如果在内存比较关心的环境中可能需要采用其他算法。&lt;/p&gt;
&lt;h1&gt;五 几点改进&lt;/h1&gt;
&lt;p&gt;对合并排序进行一些改进可以提高合并排序的效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 当划分到较小的子序列时，通常可以使用插入排序替代合并排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于较小的子序列（通常序列元素个数为7个左右），我们就可以采用插入排序直接进行排序而不用继续递归了），算法改造如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private const int CUTOFF = 7;//采用插入排序的阈值
private static void Sort(T[] array, int lo, int hi)
{
    if (lo &amp;gt;= hi) return; //如果下标大于上标，则返回
    if (hi &amp;lt;= lo + CUTOFF - 1) Sort&amp;lt;T&amp;gt;.SelectionSort(array, lo, hi);
    int mid = lo + (hi - lo) / 2;//平分数组
    Sort(array, lo, mid);//循环对左侧元素排序
    Sort(array, mid + 1, hi);//循环对右侧元素排序
    Merge(array, lo, mid, hi);//对左右排好的序列进行合并
}&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 如果已经排好序了就不用合并了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当已排好序的左侧的序列的最大值&amp;lt;=右侧序列的最小值的时候，表示整个序列已经排好序了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0c647e875f5dfc7bc7855e2d8cba9eff.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;算法改动如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Sort(T[] array, int lo, int hi)
{
    if (lo &amp;gt;= hi) return; //如果下标大于上标，则返回
    if (hi &amp;lt;= lo + CUTOFF - 1) Sort&amp;lt;T&amp;gt;.SelectionSort(array, lo, hi);
    int mid = lo + (hi - lo) / 2;//平分数组
    Sort(array, lo, mid);//循环对左侧元素排序
    Sort(array, mid + 1, hi);//循环对右侧元素排序
   if (array[mid].CompareTo(array[mid + 1]) &amp;lt;= 0) return;
    Merge(array, lo, mid, hi);//对左右排好的序列进行合并
}&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. 并行化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分治算法通常比较容易进行并行化，在&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Something-about-Concurrent-and-Parallel-Programming.html&quot; target=&quot;_blank&quot;&gt;浅谈并发与并行&lt;/a&gt;这篇文章中已经展示了如何对快速排序进行并行化（快速排序在下一篇文章中讲解），合并排序一样，因为我们均分的左右两侧的序列是独立的，所以可以进行并行，值得注意的是，并行化也有一个阈值，当序列长度小于某个阈值的时候，停止并行化能够提高效率，这些详细的讨论在&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Something-about-Concurrent-and-Parallel-Programming.html&quot; target=&quot;_blank&quot;&gt;浅谈并发与并行&lt;/a&gt;这篇文章中有详细的介绍了，这里不再赘述。&lt;/p&gt;
&lt;h1&gt;六 用途&lt;/h1&gt;
&lt;p&gt;合并排序和快速排序一样都是时间复杂度为nlgn的算法，但是和快速排序相比，合并排序是一种稳定性排序，也就是说排序关键字相等的两个元素在整个序列排序的前后，相对位置不会发生变化，这一特性使得合并排序是稳定性排序中效率最高的一个。在Java中对引用对象进行排序，Perl、C++、Python的稳定性排序的内部实现中，都是使用的合并排序。&lt;/p&gt;
&lt;h1&gt;七 结语&lt;/h1&gt;
&lt;p&gt;本文介绍了分治算法中比较典型的一个合并排序算法，这也是我们遇到的第一个时间复杂度为nlgn的排序算法，并简要对算法的复杂度进行的分析，希望本文对您理解合并排序有所帮助，下文将介绍快速排序算法。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79293-2f987b0c8.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79293-2f987b0c8.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（2）：基本排序算法</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;本篇开始学习排序算法。排序与我们日常生活中息息相关，比如，我们要从电话簿中找到某个联系人首先会按照姓氏排序、买火车票会按照出发时间或者时长排序、买东西会按照销量或者好评度排序、查找文件会按照修改时间排序等等。在计算机程序设计中，排序和查找也是最基本的算法，很多其他的算法都是以排序算法为基础，在一般的数据处理或分析中，通常第一步就是进行排序，比如说二分查找，首先要对数据进行排序。在&lt;a href=&quot;http://en.wikipedia.org/wiki/Donald_Knuth&quot; target=&quot;_blank&quot;&gt;Donald Knuth&lt;/a&gt; 的计算机程序设计的艺术这四卷书中，有一卷是专门介绍排序和查找的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dfcc0fe327ef69021acb3ff031b376b4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;排序的算法有很多，在&lt;a href=&quot;http://en.wikipedia.org/wiki/Sorting_algorithm&quot; target=&quot;_blank&quot;&gt;维基百科&lt;/a&gt;上有这么一个分类，另外大家有兴趣也可以直接上维基百科上看相关算法，本文也参考了上面的内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e3e02a709bc9d290332dd5e7846f56c0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先来看比较简单的选择排序(Selection sort)，插入排序(Insertion sort)，然后在分析插入排序的特征和缺点的基础上，介绍在插入排序基础上改进的希尔排序(Shell sort)。&lt;/p&gt;
&lt;h1&gt;一 选择排序&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;选择排序很简单，他的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从左至右遍历，找到最小(大)的元素，然后与第一个元素交换。&lt;/li&gt;
&lt;li&gt;从剩余未排序元素中继续寻找最小（大）元素，然后与第二个元素进行交换。&lt;/li&gt;
&lt;li&gt;以此类推，直到所有元素均排序完毕。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之所以称之为选择排序，是因为每一次遍历未排序的序列我们总是从中选择出最小的元素。下面是选择排序的动画演示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6bf544d3d0c3b54ab88a7b53adf41e8b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法实现起来也很简单，我们新建一个Sort泛型类，让该类型必须实现IComparable接口，然后我们定义SelectionSort方法，方法传入T数组，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 排序算法泛型类，要求类型实现IComparable接口
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
public class Sort&amp;lt;T&amp;gt; where T : IComparable&amp;lt;T&amp;gt;
{
    /// &amp;lt;summary&amp;gt;
    /// 选择排序
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;array&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public static void SelectionSort(T[] array)
    {
        int n = array.Length;

        for (int i = 0; i &amp;lt; n; i++)
        {
            int min = i;
            //从第i+1个元素开始，找最小值
            for (int j = i + 1; j &amp;lt; n; j++)
            {
                if (array[min].CompareTo(array[j]) &amp;gt; 0)
                    min = j;
            }
            //找到之后和第i个元素交换
            Swap(array, i, min);
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 元素交换
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;array&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;i&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;min&quot;&amp;gt;&amp;lt;/param&amp;gt;
    private static void Swap(T[] array, int i, int min)
    {
        T temp = array[i];
        array[i] = array[min];
        array[min] = temp;
    }
}&lt;/pre&gt;
&lt;p&gt;下图分析了选择排序中每一次排序的过程，您可以对照图中右边的柱状图来看。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c9f438f44f7a41aa5d94b9c3ca45afa1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;测试如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;static void Main(string[] args)
{
    Int32[] array = new Int32[] { 1, 3, 1, 4, 2, 4, 2, 3, 2, 4, 7, 6, 6, 7, 5, 5, 7, 7 };
    Console.WriteLine(&quot;Before SelectionSort:&quot;);
    PrintArray(array);
    Sort&amp;lt;Int32&amp;gt;.SelectionSort(array);
    Console.WriteLine(&quot;After SelectionSort:&quot;);
    PrintArray(array);
    Console.ReadKey();
}&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3896b34497f475f7e1cddd8b789c1ebe.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择排序的在各种初始条件下的排序效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c28e613ff76dfa5bc6c92416043a4aef.jpg&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择排序需要花费 (N – 1) + (N – 2) + … + 1 + 0 = N(N- 1) / 2 ~ N&lt;sup&gt;2&lt;/sup&gt;/2次比较 和 N-1次交换操作。&lt;/li&gt;
&lt;li&gt;对初始数据不敏感，不管初始的数据有没有排好序，都需要经历N&lt;sup&gt;2&lt;/sup&gt;/2次比较，这对于一些原本排好序，或者近似排好序的序列来说并不具有优势。在最好的情况下，即所有的排好序，需要0次交换，最差的情况，倒序，需要N-1次交换。&lt;/li&gt;
&lt;li&gt;数据交换的次数较少，如果某个元素位于正确的最终位置上，则它不会被移动。在最差情况下也只需要进行N-1次数据交换，在所有的完全依靠交换去移动元素的排序方法中，选择排序属于比较好的一种。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;二 插入排序&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;插入排序也是一种比较直观的排序方式。可以以我们平常打扑克牌为例来说明，假设我们那在手上的牌都是排好序的，那么插入排序可以理解为我们每一次将摸到的牌，和手中的牌从左到右依次进行对比，如果找到合适的位置则直接插入。具体的步骤为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从第一个元素开始，该元素可以认为已经被排序&lt;/li&gt;
&lt;li&gt;取出下一个元素，在已经排序的元素序列中从后向前扫描&lt;/li&gt;
&lt;li&gt;如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则交换，直到找到大于该元素的就则停止；&lt;/li&gt;
&lt;li&gt;如果该元素大于前面的元素（已排序），则重复步骤2&lt;/li&gt;
&lt;li&gt;重复步骤2~4 直到所有元素都排好序 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是插入排序的动画演示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c71212ec56390ce57c6d277088748ca6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Sort泛型方法中，我们添加如下方法，下面的方法和上面的定义一样&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 插入排序
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;array&quot;&amp;gt;&amp;lt;/param&amp;gt;
public static void InsertionSort(T[] array)
{
    int n = array.Length;
    //从第二个元素开始
    for (int i = 1; i &amp;lt; n; i++)
    {
        //从第i个元素开始，一次和前面已经排好序的i-1个元素比较，如果小于，则交换
        for (int j = i; j &amp;gt; 0; j--)
        {
            if (array[j].CompareTo(array[j - 1]) &amp;lt; 0)
            {
                Swap(array, j, j - 1);
            }
            else//如果大于，则不用继续往前比较了，因为前面的元素已经排好序，比较大的大就是教大的了。
                break;
        }
    }
}&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e8741432bb3553e0f9075e4e19e28740.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;测试如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;Int32[] array1 = new Int32[] { 1, 3, 1, 4, 2, 4, 2, 3, 2, 4, 7, 6, 6, 7, 5, 5, 7, 7 };
Console.WriteLine(&quot;Before InsertionSort:&quot;);
PrintArray(array1);
Sort&amp;lt;Int32&amp;gt;.InsertionSort(array1);
Console.WriteLine(&quot;After InsertionSort:&quot;);
PrintArray(array1);
Console.ReadKey();&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;br&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9d1d216c620eae27e0fd55e6e624d0ef.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插入排序的在各种初始条件下的排序效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c70712254dc5e5d51cc420126fdc35d5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;1. 插入排序平均需要N&lt;sup&gt;2&lt;/sup&gt;/4次比较和N&lt;sup&gt;2&lt;/sup&gt;/4 次交换。在最坏的情况下需要N&lt;sup&gt;2&lt;/sup&gt;/2 次比较和交换；在最好的情况下只需要N-1次比较和0次交换。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0b084a2ab011c31ea5bc30d1876212b6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;先考虑最坏情况，那就是所有的元素逆序排列，那么第i个元素需要与前面的i-1个元素进行i-1次比较和交换，所有的加起来大概等于N(N- 1) / 2 ~ N&lt;sup&gt;2&lt;/sup&gt; / 2，在数组随机排列的情况下，只需要和前面一半的元素进行比较和交换，所以平均需要N&lt;sup&gt;2&lt;/sup&gt;/4次比较和N&lt;sup&gt;2&lt;/sup&gt;/4 次交换。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1d234dc81be48ea29e6744fdf5598cab.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在最好的情况下，所有元素都排好序，只需要从第二个元素开始都和前面的元素比较一次即可，不需要交换，所以为N-1次比较和0次交换。&lt;/p&gt;
&lt;p&gt;2. 插入排序中，元素交换的次数等于序列中逆序元素的对数。元素比较的次数最少为元素逆序元素的对数，最多为元素逆序的对数 加上数组的个数减1。&lt;/p&gt;
&lt;p&gt;3.总体来说，插入排序对于部分有序序列以及元素个数比较小的序列是一种比较有效的方式。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/22f4f0bcc670367435e39094a7521b22.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图中，序列AEELMOTRXPS，中逆序的对数为T-R，T-P，T-S，R-P，X-S 6对。典型的部分有序队列的特征有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组中每个元素离最终排好序后的位置不太远&lt;/li&gt;
&lt;li&gt;小的未排序的数组添加到大的已排好序的数组后面&lt;/li&gt;
&lt;li&gt;数组中只有个别元素未排好序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于部分有序数组，插入排序是比较有效的。当数组中逆元素的对数越低，插入排序要比其他排序方法要高效的多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择排序和插入排序的比较&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/02644f03587d522fa176cbe0a2e4be94.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图展示了插入排序和选择排序的动画效果。图中灰色的柱子是不用动的，黑色的是需要参与到比较中的，红色的是参与交换的。图中可以看出：&lt;/p&gt;
&lt;p&gt;插入排序不会动右边的元素，选择排序不会动左边的元素；由于插入排序涉及到的未触及的元素要比插入的元素要少，涉及到的比较操作平均要比选择排序少一半。&lt;/p&gt;
&lt;h1&gt;三 希尔排序(Shell Sort)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;希尔排序也称之为递减增量排序，他是对插入排序的改进。在第二部插入排序中，我们知道，插入排序对于近似已排好序的序列来说，效率很高，可以达到线性排序的效率。但是插入排序效率也是比较低的，他一次只能将数据向前移一位。比如如果一个长度为N的序列，最小的元素如果恰巧在末尾，那么使用插入排序仍需一步一步的向前移动和比较，要N-1次比较和交换。&lt;/p&gt;
&lt;p&gt;希尔排序通过将待比较的元素划分为几个区域来提升插入排序的效率。这样可以让元素可以一次性的朝最终位置迈进一大步，然后算法再取越来越小的步长进行排序，最后一步就是步长为1的普通的插入排序的，但是这个时候，整个序列已经是近似排好序的，所以效率高。&lt;/p&gt;
&lt;p&gt;如下图，我们对下面数组进行排序的时候，首先以4为步长，这是元素分为了LMPT，EHSS，ELOX，AELR几个序列，我们对这几个独立的序列进行插入排序，排序完成之后，我们减小步长继续排序，最后直到步长为1，步长为1即为一般的插入排序，他保证了元素一定会被排序。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/157c6b828e5387aed88ee16e26a80ef7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;希尔排序的增量递减算法可以随意指定，可以以N/2递减，只要保证最后的步长为1即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 希尔排序
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;array&quot;&amp;gt;&amp;lt;/param&amp;gt;
public static void ShellSort(T[] array)
{
    int n = array.Length;
    int h = 1;
    //初始最大步长
    while (h &amp;lt; n / 3) h = h * 3 + 1;
    while (h &amp;gt;= 1)
    {
        //从第二个元素开始
        for (int i = 1; i &amp;lt; n; i++)
        {
            //从第i个元素开始，依次次和前面已经排好序的i-h个元素比较，如果小于，则交换
            for (int j = i; j &amp;gt;= h; j = j - h)
            {
                if (array[j].CompareTo(array[j - h]) &amp;lt; 0)
                {
                    Swap(array, j, j - h);
                }
                else//如果大于，则不用继续往前比较了，因为前面的元素已经排好序，比较大的大就是教大的了。
                    break;
            }
        }
        //步长除3递减
        h = h / 3;
    }
}&lt;/pre&gt;
&lt;p&gt;可以看到，希尔排序的实现是在插入排序的基础上改进的，插入排序的步长为1，每一次递减1，希尔排序的步长为我们定义的h，然后每一次和前面的-h位置上的元素进行比较。算法中，我们首先获取小于N/3 的最大的步长，然后逐步长递减至步长为1的一般的插入排序。&lt;/p&gt;
&lt;p&gt;下面是希尔排序在各种情况下的排序动画：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6e21e9e8a23da4f07b8a62b6fbac7b97.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 希尔排序的关键在于步长递减序列的确定，任何递减至1步长的序列都可以，目前已知的&lt;a href=&quot;http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Weiss/L12-ShellSort.htm#increments&quot; target=&quot;_blank&quot;&gt;比较好的序列有&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shell’s 序列: N/2 , N/4 , …, 1 (重复除以2);&lt;/li&gt;
&lt;li&gt;Hibbard’s 序列: 1, 3, 7, …, 2&lt;sup&gt;k&lt;/sup&gt; - 1 ;&lt;/li&gt;
&lt;li&gt;Knuth’s 序列: 1, 4, 13, …, (3&lt;sup&gt;k&lt;/sup&gt; - 1) / 2 ;该序列是本文代码中使用的序列。&lt;/li&gt;
&lt;li&gt;已知最好的序列是 Sedgewick’s (Knuth的学生，Algorithems的作者)的序列: 1, 5, 19, 41, 109, ….&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该序列由下面两个表达式交互获得:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1, 19, 109, 505, 2161,….., 9(4&lt;sup&gt;k&lt;/sup&gt; – 2&lt;sup&gt;k&lt;/sup&gt;) + 1, k = 0, 1, 2, 3,…&lt;/li&gt;
&lt;li&gt;5, 41, 209, 929, 3905,…..2&lt;sup&gt;k+2&lt;/sup&gt; (2&lt;sup&gt;k+2&lt;/sup&gt; – 3 ) + 1, k = 0, 1, 2, 3, …&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。&lt;/p&gt;
&lt;p&gt;2. 希尔排序的分析&lt;a href=&quot;http://www.iti.fh-flensburg.de/lang/algorithmen/sortieren/shell/shellen.htm&quot; target=&quot;_blank&quot;&gt;比较复杂&lt;/a&gt;，使用Hibbard’s 递减步长序列的时间复杂度为O(N&lt;sup&gt;3/2&lt;/sup&gt;)，平均时间复杂度大约为O(N&lt;sup&gt;5/4&lt;/sup&gt;) ,具体的复杂度目前仍存在争议。&lt;/p&gt;
&lt;p&gt;3. 实验表明，对于中型的序列( 万)，希尔排序的时间复杂度接近最快的排序算法的时间复杂度nlogn。&lt;/p&gt;
&lt;h1&gt;四 总结&lt;/h1&gt;
&lt;p&gt;最后总结一下本文介绍的三种排序算法的最好最坏和平均时间复杂度。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;86&quot;&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;59&quot;&gt;&lt;strong&gt;最好&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;82&quot;&gt;&lt;strong&gt;平均&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;209&quot;&gt;&lt;strong&gt;最坏&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;87&quot;&gt;&lt;strong&gt;内存占用&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;93&quot;&gt;&lt;strong&gt;稳定排序&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;86&quot;&gt;插入排序&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;59&quot;&gt;n&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;82&quot;&gt;n&lt;sup&gt;2&lt;/sup&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;209&quot;&gt;n&lt;sup&gt;2&lt;/sup&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;87&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;93&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;86&quot;&gt;选择排序&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;59&quot;&gt;n&lt;sup&gt;2&lt;/sup&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;82&quot;&gt;n&lt;sup&gt;2&lt;/sup&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;209&quot;&gt;n&lt;sup&gt;2&lt;/sup&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;87&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;93&quot;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;86&quot;&gt;希尔排序&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;59&quot;&gt;n&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;82&quot;&gt;nlog&lt;sup&gt;2&lt;/sup&gt;n&lt;br&gt;
或&lt;br&gt;
n&lt;sup&gt;3/2&lt;/sup&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;209&quot;&gt;依赖于增量递减序列目前最好的是 nlog&lt;sup&gt;2&lt;/sup&gt;n&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;87&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;93&quot;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;希望本文对您了解以上三个基本的排序算法有所帮助，后面将会介绍合并排序和快速排序。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79288-60084624e.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79288-60084624e.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（1）：栈和队列</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;最近晚上在家里看&lt;a href=&quot;http://algs4.cs.princeton.edu/home/&quot; target=&quot;_blank&quot;&gt;Algorithems，4th Edition&lt;/a&gt;，我买的&lt;a href=&quot;http://item.jd.com/10944102.html&quot;&gt;英文版&lt;/a&gt;，觉得这本书写的比较浅显易懂，而且“图码并茂”，趁着这次机会打算好好学习做做笔记，这样也会印象深刻，这也是写这一系列文章的原因。另外普林斯顿大学在&lt;a href=&quot;https://www.coursera.org/princeton&quot; target=&quot;_blank&quot;&gt;Coursera&lt;/a&gt; 上也有这本书同步的公开课，还有另外一门&lt;a href=&quot;http://aofa.cs.princeton.edu/home/&quot; target=&quot;_blank&quot;&gt;算法分析&lt;/a&gt;课，这门课程的作者也是这本书的作者，两门课都挺不错的。&lt;/p&gt;
&lt;p&gt;计算机程序离不开算法和数据结构，本文简单介绍栈(Stack)和队列(Queue)的实现，.NET中与之相关的数据结构，典型应用等，希望能加深自己对这两个简单数据结构的理解。&lt;/p&gt;
&lt;h1&gt;
&lt;strong&gt;1. &lt;/strong&gt;&lt;strong&gt;基本概念&lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;概念很简单，栈 (Stack)是一种后进先出(last in first off，LIFO)的数据结构，而队列(Queue)则是一种先进先出 (fisrt in first out，FIFO)的结构，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/95672adc43f35eddbb2c60da8731f061.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;
&lt;strong&gt;2. &lt;/strong&gt;&lt;strong&gt;实现&lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;现在来看如何实现以上的两个数据结构。在动手之前，&lt;a href=&quot;http://www.amazon.com/Framework-Design-Guidelines-Conventions-Libraries/dp/0321545613/ref=dp_ob_title_bk&quot; target=&quot;_blank&quot;&gt;Framework Design Guidelines&lt;/a&gt;这本书告诉我们，在设计API或者实体类的时候，应当围绕场景编写API规格说明书。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1 &lt;/strong&gt;&lt;strong&gt;Stack&lt;/strong&gt;&lt;strong&gt;的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;栈是一种后进先出的数据结构，对于Stack 我们希望至少要对外提供以下几个方法：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a4f023dfc8ecf7cf68f59b1352dfe06a.jpg&quot;&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;251&quot;&gt;&lt;strong&gt;Stack&amp;lt;T&amp;gt;()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;325&quot;&gt;&lt;strong&gt;创建一个空的栈&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;251&quot;&gt;&lt;strong&gt;void Push(T s)&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;325&quot;&gt;往栈中添加一个新的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;251&quot;&gt;&lt;strong&gt;T Pop()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;325&quot;&gt;移除并返回最近添加的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;251&quot;&gt;&lt;strong&gt;boolean IsEmpty()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;325&quot;&gt;栈是否为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;251&quot;&gt;&lt;strong&gt;int Size()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;325&quot;&gt;栈中元素的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;要实现这些功能，我们有两中方法，数组和链表，先看链表实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈的链表实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们首先定义一个内部类来保存每个链表的节点，该节点包括当前的值以及指向下一个的值，然后建立一个节点保存位于栈顶的值以及记录栈的元素个数;&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;class Node
{
    public T Item{get;set;}
    public Node Next { get; set; }
}&lt;/pre&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;private Node first = null;
private int number = 0;&lt;/pre&gt;
&lt;p&gt;现在来实现Push方法，即向栈顶压入一个元素，首先保存原先的位于栈顶的元素，然后新建一个新的栈顶元素，然后将该元素的下一个指向原先的栈顶元素。整个Pop过程如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/62251c6475e509dfb8d4790b229b16de.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;实现代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;void Push(T node)
{
    Node oldFirst = first;
    first = new Node();
    first.Item= node;
    first.Next = oldFirst;
    number++;
}&lt;/pre&gt;
&lt;p&gt;Pop方法也很简单，首先保存栈顶元素的值，然后将栈顶元素设置为下一个元素：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c15c5b486660618914ae3d25494ef642.jpg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;T Pop()
{
    T item = first.Item;
    first = first.Next;
    number--;
    return item;
}&lt;/pre&gt;
&lt;p&gt;基于链表的Stack实现，在最坏的情况下只需要常量的时间来进行Push和Pop操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈的数组实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用数组来存储栈中的元素Push的时候，直接添加一个元素S[N]到数组中，Pop的时候直接返回S[N-1].&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0457872639565d4d1d7c730ed7670010.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先，我们定义一个数组，然后在构造函数中给定初始化大小，Push方法实现如下，就是集合里添加一个元素：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;T[] item;
int number = 0;

public StackImplementByArray(int capacity)
{
    item = new T[capacity];
}&lt;/pre&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;public void Push(T _item)
{
    if (number == item.Length) Resize(2 * item.Length);
    item[number++] = _item;
}&lt;/pre&gt;
&lt;p&gt;Pop方法：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;public T Pop()
{
    T temp = item[--number];
    item[number] = default(T);
    if (number &amp;gt; 0 &amp;amp;&amp;amp; number == item.Length / 4) Resize(item.Length / 2);
    return temp;
}&lt;/pre&gt;
&lt;p&gt;在Push和Pop方法中，为了节省内存空间，我们会对数组进行整理。Push的时候，当元素的个数达到数组的Capacity的时候，我们开辟2倍于当前元素的新数组，然后将原数组中的元素拷贝到新数组中。Pop的时候，当元素的个数小于当前容量的1/4的时候，我们将原数组的大小容量减少1/2。&lt;/p&gt;
&lt;p&gt;Resize方法基本就是数组复制：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;private void Resize(int capacity)
{
    T[] temp = new T[capacity];
    for (int i = 0; i &amp;lt; item.Length; i++)
    {
        temp[i] = item[i];
    }
    item = temp;
}&lt;/pre&gt;
&lt;p&gt;当我们缩小数组的时候，采用的是判断1/4的情况，这样效率要比1/2要高，因为可以有效避免在1/2附件插入，删除，插入，删除，从而频繁的扩大和缩小数组的情况。下图展示了在插入和删除的情况下数组中的元素以及数组大小的变化情况：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/eba639d8b3b043b96011953e3b79dea0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;分析：1. Pop和Push操作在最坏的情况下与元素个数成比例的N的时间，时间主要花费在扩大或者缩小数组的个数时，数组拷贝上。&lt;/p&gt;
&lt;p&gt;2. 元素在内存中分布紧凑，密度高，便于利用内存的时间和空间局部性，便于CPU进行缓存，较LinkList内存占用小，效率高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 Queue&lt;/strong&gt;&lt;strong&gt;的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Queue是一种先进先出的数据结构，和Stack一样，他也有链表和数组两种实现，理解了Stack的实现后，Queue的实现就比较简单了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8f6832c36a07960a3192f8954bb7ef1b.jpg&quot;&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;216&quot;&gt;&lt;strong&gt;Stack&amp;lt;T&amp;gt;()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;360&quot;&gt;&lt;strong&gt;创建一个空的队列&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;216&quot;&gt;&lt;strong&gt;void Enqueue(T s)&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;360&quot;&gt;往队列中添加一个新的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;216&quot;&gt;&lt;strong&gt;T Dequeue()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;360&quot;&gt;移除队列中最早添加的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;216&quot;&gt;&lt;strong&gt;boolean IsEmpty()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;360&quot;&gt;队列是否为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;216&quot;&gt;&lt;strong&gt;int Size()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;360&quot;&gt;队列中元素的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;首先看链表的实现：&lt;/p&gt;
&lt;p&gt;Dequeue方法就是返回链表中的第一个元素，这个和Stack中的Pop方法相似：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;public T Dequeue()
{
    T temp = first.Item;
    first = first.Next;
    number--;
    if (IsEmpety())
        last = null;
    return temp;
}&lt;/pre&gt;
&lt;p&gt;Enqueue和Stack的Push方法不同，他是在链表的末尾增加新的元素：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;public void Enqueue(T item)
{
    Node oldLast = last;
    last = new Node();
    last.Item = item;
    if (IsEmpety())
    {
        first = last;
    }
    else
    {
        oldLast.Next = last;
    }
    number++;
}&lt;/pre&gt;
&lt;p&gt;同样地，现在再来看如何使用数组来实现Queue，首先我们使用数组来保存数据，并定义变量head和tail来记录Queue的首尾元素。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/09d660a87b0bf9822e2812d3118b7ad9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;和Stack的实现方式不同，在Queue中，我们定义了head和tail来记录头元素和尾元素。当enqueue的时候，tial加1，将元素放在尾部，当dequeue的时候，head减1，并返回。&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;public void Enqueue(T _item)
{
    if ((head - tail + 1) == item.Length) Resize(2 * item.Length);
    item[tail++] = _item;
}

public T Dequeue()
{
    T temp = item[--head];
    item[head] = default(T);
    if (head &amp;gt; 0 &amp;amp;&amp;amp; (tail - head + 1) == item.Length / 4) Resize(item.Length / 2);
    return temp;
}

private void Resize(int capacity)
{
    T[] temp = new T[capacity];
    int index = 0;
    for (int i = head; i &amp;lt; tail; i++)
    {
        temp[++index] = item[i];
    }
    item = temp;
}&lt;/pre&gt;
&lt;h1&gt;
&lt;strong&gt;3. &lt;/strong&gt;&lt;strong&gt;.NET&lt;/strong&gt;&lt;strong&gt;中的&lt;/strong&gt;&lt;strong&gt;Stack&lt;/strong&gt;&lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;Queue&lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;在.NET中有Stack和Queue泛型类，使用Reflector工具可以查看其具体实现。先看Stack的实现，下面是截取的部分代码，仅列出了Push，Pop方法，其他的方法希望大家自己使用Reflector查看：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fd1162b4a720ad16ed2190e2afdf3ccc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到.NET中的Stack的实现和我们之前写的差不多，也是使用数组来实现的。.NET中Stack的初始容量为4，在Push方法中，可以看到当元素个数达到数组长度时，扩充2倍容量，然后将原数组拷贝到新的数组中。Pop方法和我们之前实现的基本上相同，下面是具体代码，只截取了部分：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;[Serializable, ComVisible(false), DebuggerTypeProxy(typeof(System_StackDebugView&amp;lt;&amp;gt;)), DebuggerDisplay(&quot;Count = {Count}&quot;), __DynamicallyInvokable]
public class Stack&amp;lt;T&amp;gt; : IEnumerable&amp;lt;T&amp;gt;, ICollection, IEnumerable
{
    // Fields
    private T[] _array;
    private const int _defaultCapacity = 4;
    private static T[] _emptyArray;
    private int _size;
    private int _version;

    // Methods
    static Stack()
    {
        Stack&amp;lt;T&amp;gt;._emptyArray = new T[0];
    }

    [__DynamicallyInvokable]
    public Stack()
    {
        this._array = Stack&amp;lt;T&amp;gt;._emptyArray;
        this._size = 0;
        this._version = 0;
    }

    [__DynamicallyInvokable]
    public Stack(int capacity)
    {
        if (capacity &amp;lt; 0)
        {
            ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNumRequired);
        }
        this._array = new T[capacity];
        this._size = 0;
        this._version = 0;
    }

    [__DynamicallyInvokable]
    public void CopyTo(T[] array, int arrayIndex)
    {
        if (array == null)
        {
            ThrowHelper.ThrowArgumentNullException(ExceptionArgument.array);
        }
        if ((arrayIndex &amp;lt; 0) || (arrayIndex &amp;gt; array.Length))
        {
            ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.arrayIndex, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);
        }
        if ((array.Length - arrayIndex) &amp;lt; this._size)
        {
            ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_InvalidOffLen);
        }
        Array.Copy(this._array, 0, array, arrayIndex, this._size);
        Array.Reverse(array, arrayIndex, this._size);
    }

    [__DynamicallyInvokable]
    public T Pop()
    {
        if (this._size == 0)
        {
            ThrowHelper.ThrowInvalidOperationException(ExceptionResource.InvalidOperation_EmptyStack);
        }
        this._version++;
        T local = this._array[--this._size];
        this._array[this._size] = default(T);
        return local;
    }

    [__DynamicallyInvokable]
    public void Push(T item)
    {
        if (this._size == this._array.Length)
        {
            T[] destinationArray = new T[(this._array.Length == 0) ? 4 : (2 * this._array.Length)];
            Array.Copy(this._array, 0, destinationArray, 0, this._size);
            this._array = destinationArray;
        }
        this._array[this._size++] = item;
        this._version++;
    }

    // Properties
    [__DynamicallyInvokable]
    public int Count
    {
        [__DynamicallyInvokable, TargetedPatchingOptOut(&quot;Performance critical to inline this type of method across NGen image boundaries&quot;)]
        get
        {
            return this._size;
        }
    }

}&lt;/pre&gt;
&lt;p&gt;下面再看看Queue的实现：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;  [Serializable, DebuggerDisplay(&quot;Count = {Count}&quot;), ComVisible(false), DebuggerTypeProxy(typeof(System_QueueDebugView&amp;lt;&amp;gt;)), __DynamicallyInvokable]
    public class Queue&amp;lt;T&amp;gt; : IEnumerable&amp;lt;T&amp;gt;, ICollection, IEnumerable
    {
        // Fields
        private T[] _array;
        private const int _DefaultCapacity = 4;
        private static T[] _emptyArray;
        private int _head;
        private int _size;
        private int _tail;
        private int _version;
        // Methods
        static Queue()
        {
            Queue&amp;lt;T&amp;gt;._emptyArray = new T[0];
        }

        public Queue()
        {
            this._array = Queue&amp;lt;T&amp;gt;._emptyArray;
        }

        public Queue(int capacity)
        {
            if (capacity &amp;lt; 0)
            {
                ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNumRequired);
            }
            this._array = new T[capacity];
            this._head = 0;
            this._tail = 0;
            this._size = 0;
        }

        public T Dequeue()
        {
            if (this._size == 0)
            {
                ThrowHelper.ThrowInvalidOperationException(ExceptionResource.InvalidOperation_EmptyQueue);
            }
            T local = this._array[this._head];
            this._array[this._head] = default(T);
            this._head = (this._head + 1) % this._array.Length;
            this._size--;
            this._version++;
            return local;
        }

        public void Enqueue(T item)
        {
            if (this._size == this._array.Length)
            {
                int capacity = (int)((this._array.Length * 200L) / 100L);
                if (capacity &amp;lt; (this._array.Length + 4))
                {
                    capacity = this._array.Length + 4;
                }
                this.SetCapacity(capacity);
            }
            this._array[this._tail] = item;
            this._tail = (this._tail + 1) % this._array.Length;
            this._size++;
            this._version++;
        }

        private void SetCapacity(int capacity)
        {
            T[] destinationArray = new T[capacity];
            if (this._size &amp;gt; 0)
            {
                if (this._head &amp;lt; this._tail)
                {
                    Array.Copy(this._array, this._head, destinationArray, 0, this._size);
                }
                else
                {
                    Array.Copy(this._array, this._head, destinationArray, 0, this._array.Length - this._head);
                    Array.Copy(this._array, 0, destinationArray, this._array.Length - this._head, this._tail);
                }
            }
            this._array = destinationArray;
            this._head = 0;
            this._tail = (this._size == capacity) ? 0 : this._size;
            this._version++;
        }

        public int Count
        {
            [__DynamicallyInvokable, TargetedPatchingOptOut(&quot;Performance critical to inline this type of method across NGen image boundaries&quot;)]
            get
            {
                return this._size;
            }
        }
    }&lt;/pre&gt;
&lt;p&gt;可以看到.NET中Queue的实现也是基于数组的，定义了head和tail，当长度达到数组的容量的时候，使用了SetCapacity方法来进行扩容和拷贝。&lt;/p&gt;
&lt;h1&gt;
&lt;strong&gt;4. &lt;/strong&gt;&lt;strong&gt;Stack&lt;/strong&gt;&lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;Queue&lt;/strong&gt;&lt;strong&gt;的应用&lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;Stack这种数据结构用途很广泛，比如编译器中的词法分析器、Java虚拟机、软件中的撤销操作、浏览器中的回退操作，编译器中的函数调用实现等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1 线程堆 (Thread Stack)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap?rq=1&quot; target=&quot;_blank&quot;&gt;线程堆&lt;/a&gt;是操作系型系统分配的一块内存区域。通常CPU上有一个特殊的称之为堆指针的寄存器 (stack pointer) 。在程序初始化时，该指针指向栈顶，栈顶的地址最大。CPU有特殊的指令可以将值Push到线程堆上，以及将值Pop出堆栈。每一次Push操作都将值存放到堆指针指向的地方，并将堆指针递减。每一次Pop都将堆指针指向的值从堆中移除，然后堆指针递增，堆是向下增长的。Push到线程堆，以及从线程堆中Pop的值都存放到CPU的寄存器中。&lt;/p&gt;
&lt;p&gt;当发起函数调用的时候，CPU使用特殊的指令将当前的指令指针(instruction pointer)，如当前执行的代码的地址压入到堆上。然后CPU通过设置指令指针到函数调用的地址来跳转到被调用的函数去执行。当函数返回值时，旧的指令指针从堆中Pop出来，然后从该指令地址之后继续执行。&lt;/p&gt;
&lt;p&gt;当进入到被调用的函数中时，堆指针减小来在堆上为函数中的局部变量分配更多的空间。如果函数中有一个32位的变量分配到了堆中，当函数返回时，堆指针就返回到之前的函数调用处，分配的空间就会被释放。&lt;/p&gt;
&lt;p&gt;如果函数有参数，这些参数会在函数调用之前就被分配在堆上，函数中的代码可以从当前堆往上访问到这些参数。&lt;/p&gt;
&lt;p&gt;线程堆是一块有一定限制的内存空间，如果调用了过多的嵌套函数，或者局部变量分配了过多的内存空间，就会产生堆栈溢出的错误。&lt;/p&gt;
&lt;p&gt;下图简单显示了线程堆的变化情况。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/69e607b82f585a161bae8b77c7d2ef70.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2 算术表达式的求值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Stack使用的一个最经典的例子就是算术表达式的求值了，这其中还包括前缀表达式和后缀表达式的求值。&lt;a href=&quot;http://en.wikipedia.org/wiki/Edsger_Dijkstra&quot; target=&quot;_blank&quot;&gt;E. W. Dijkstra&lt;/a&gt;发明了使用&lt;a href=&quot;http://heracleia.uta.edu/~vangelis/CSE2320_FALL13/Lectures/Lecture04-DemoDijkstraTwoStack.pdf&quot; target=&quot;_blank&quot;&gt;两个Stack&lt;/a&gt;，一个保存操作值，一个保存操作符的方法来实现表达式的求值，具体步骤如下：&lt;/p&gt;
&lt;p&gt;1) 当输入的是值的时候Push到属于值的栈中。&lt;/p&gt;
&lt;p&gt;2) 当输入的是运算符的时候，Push到运算符的栈中。&lt;/p&gt;
&lt;p&gt;3) 当遇到左括号的时候，忽略&lt;/p&gt;
&lt;p&gt;4) 当遇到右括号的时候，Pop一个运算符，Pop两个值，然后将计算结果Push到值的栈中。&lt;/p&gt;
&lt;p&gt;下面是在C#中的一个简单的括号表达式的求值：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 一个简单的表达式运算
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;args&quot;&amp;gt;&amp;lt;/param&amp;gt;
static void Main(string[] args)
{
    Stack&amp;lt;char&amp;gt; operation = new Stack&amp;lt;char&amp;gt;();
    Stack&amp;lt;Double&amp;gt; values = new Stack&amp;lt;double&amp;gt;();
    //为方便，直接使用ToChar对于两位数的数组问题
    Char[] charArray = Console.ReadLine().ToCharArray();

    foreach (char s in charArray)
    {
        if (s.Equals(&#39;(&#39;)) { }
        else if (s.Equals(&#39;+&#39;)) operation.Push(s);
        else if (s.Equals(&#39;*&#39;)) operation.Push(s);
        else if (s.Equals(&#39;)&#39;))
        {
            char op = operation.Pop();
            if (op.Equals(&#39;+&#39;))
                values.Push(values.Pop() + values.Pop());
            else if (op.Equals(&#39;*&#39;))
                values.Push(values.Pop() * values.Pop());
        }
        else values.Push(Double.Parse(s.ToString()));
    }
    Console.WriteLine(values.Pop());
    Console.ReadKey();
}&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/78789226dbfeb09554169ec8444eb597.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图演示了操作栈和数据栈的变化。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/af472fa9cce5029223a07cdb9c14aa99.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在编译器技术中，前缀表达式，后缀表达式的求值都会用到堆。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.3 Object-C中以及OpenGL中的图形绘制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Object-C以及OpenGL中都存在”绘图上下文”，有时候我们对局部对象的绘图不希望影响到全局的设置，所以需要保存上一次的绘图状态。下面是Object-C中绘制一个圆形的典型代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;- (void)drawGreenCircle:(CGContextRef)ctxt {
    UIGraphicsPushContext(ctxt);
    [[UIColor greenColor] setFill];
    // draw my circle
    UIGraphicsPopContext();
}

- (void)drawRect:(CGRect)aRect {
    CGContextRef context = UIGraphicsGetCurrentContext();
    [[UIColor redColor] setFill];
    // do some stuff
    [self drawGreenCircle:context];
    // do more stuff and expect fill color to be red
}&lt;/pre&gt;
&lt;p&gt;可以看到，在drawGreenCircle方法中，在设置填充颜色之前，我们Push保存了绘图上下文的信息，然后在设置当前操作的一些环境变量，绘制图形，绘制完成之后，我们Pop出之前保存的绘图上下文信息，从而不影响后面的绘图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.4 一些其他场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一个场景是利用stack 处理多余无效的请求，比如用户长按键盘，或者在很短的时间内连续按某一个功能键，我们需要过滤到这些无效的请求。一个通常的做法是将所有的请求都压入到堆中，然后要处理的时候Pop出来一个，这个就是最新的一次请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Queue的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在现实生活中Queue的应用也很广泛，最广泛的就是排队了，”先来后到” First come first service ，以及Queue这个单词就有排队的意思。&lt;/p&gt;
&lt;p&gt;还有，比如我们的播放器上的播放列表，我们的数据流对象，异步的数据传输结构(文件IO，管道通讯，套接字等)&lt;/p&gt;
&lt;p&gt;还有一些解决对共享资源的冲突访问，比如打印机的打印队列等。消息队列等。交通状况模拟，呼叫中心用户等待的时间的模拟等等。&lt;/p&gt;
&lt;h1&gt;
&lt;strong&gt;5. &lt;/strong&gt;&lt;strong&gt;一点点感悟&lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;本文简单介绍了Stack和Queue的原理及实现，并介绍了一些应用。&lt;/p&gt;
&lt;p&gt;最后一点点感悟就是不要为了使用数据结构而使用数据结构。举个例子，之前看到过一个&lt;a href=&quot;http://blog.zhaojie.me/2009/05/1491052.html&quot; target=&quot;_blank&quot;&gt;数组反转&lt;/a&gt;的问题，刚学过Stack可能会想，这个简单啊，直接将字符串挨个的Push进去，然后Pop出来就可以了，完美的解决方案。但是，这是不是最有效地呢，其实有更有效地方法，那就是以中间为对折，然后左右两边替换。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public static void Reverse(int[] array, int begin, int end)
{
    while (end &amp;gt; begin)
    {
        int temp = array[begin];
        array[begin] = array[end];
        array[end] = temp;

        begin++;
        end--;
    }
}&lt;/pre&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79267-ab4b1396e.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79267-ab4b1396e.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（11）：哈希表</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在前面的系列文章中，依次介绍了基于无序列表的&lt;a href=&quot;http://blog.jobbole.com/79267/&quot; target=&quot;_blank&quot;&gt;顺序查找&lt;/a&gt;，&lt;a href=&quot;http://blog.jobbole.com/79305/&quot; target=&quot;_blank&quot;&gt;基于有序数组的二分查找&lt;/a&gt;，&lt;a href=&quot;http://blog.jobbole.com/79307/&quot; target=&quot;_blank&quot;&gt;平衡查找树&lt;/a&gt;，以及&lt;a href=&quot;http://blog.jobbole.com/79309/&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;，下图是它们在平均以及最差情况下的时间复杂度：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/24490d2d4d28caa6941025f435b2f78b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到在时间复杂度上，红黑树在平均情况下插入，查找以及删除上都达到了lgN的时间复杂度。&lt;/p&gt;
&lt;p&gt;那么有没有查找效率更高的数据结构呢，答案就是本文接下来要介绍了散列表，也叫哈希表(Hash Table)&lt;/p&gt;
&lt;h1&gt;什么是哈希表&lt;/h1&gt;
&lt;p&gt;哈希表就是一种以 键-值(key-indexed) 存储数据的结构，我们只要输入待查找的值即key，即可查找到其对应的值。&lt;/p&gt;
&lt;p&gt;哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。&lt;/p&gt;
&lt;p&gt;使用哈希查找有两个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突&lt;/li&gt;
&lt;li&gt;处理哈希碰撞冲突。有很多处理哈希碰撞冲突的方法，本文后面会介绍拉链法和线性探测法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。&lt;/p&gt;
&lt;h1&gt;哈希函数&lt;/h1&gt;
&lt;p&gt;哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。如果我们有一个保存0-M数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。比如举个简单的例子，使用手机号码后三位就比前三位作为key更好，因为前三位手机号码的重复率很高。再比如使用身份证号码出生年月位数要比使用前几位数要更好。&lt;/p&gt;
&lt;p&gt;在实际中，我们的键并不都是数字，有可能是字符串，还有可能是几个值的组合等，所以我们需要实现自己的哈希函数。&lt;/p&gt;
&lt;h2&gt;1. 正整数&lt;/h2&gt;
&lt;p&gt;获取正整数哈希值最常用的方法是使用除留余数法。即对于大小为素数M的数组，对于任意正整数k，计算k除以M的余数。M一般取素数。&lt;/p&gt;
&lt;h2&gt;2. 字符串&lt;/h2&gt;
&lt;p&gt;将字符串作为键的时候，我们也可以将他作为一个大的整数，采用保留除余法。我们可以将组成字符串的每一个字符取值然后进行哈希，比如&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;public int GetHashCode(string str)
{
    char[] s = str.ToCharArray();
    int hash = 0;
    for (int i = 0; i &amp;lt; s.Length; i++)
    {
        hash = s[i] + (31 * hash); 
    }
    return hash;
}&lt;/pre&gt;
&lt;p&gt;上面的哈希值是Horner计算字符串哈希值的方法，公式为:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;   &lt;/strong&gt;h = s[0] · 31&lt;sup&gt;L–1&lt;/sup&gt; + … + s[L – 3] · 31&lt;sup&gt;2&lt;/sup&gt; + s[L – 2] · 31&lt;sup&gt;1&lt;/sup&gt; + s[L – 1] · 31&lt;sup&gt;0&lt;/sup&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;举个例子，比如要获取”call”的哈希值，字符串c对应的unicode为99，a对应的unicode为97，L对应的unicode为108，所以字符串”call”的哈希值为 3045982 = 99·31&lt;sup&gt;3&lt;/sup&gt; + 97·31&lt;sup&gt;2&lt;/sup&gt; + 108·31&lt;sup&gt;1&lt;/sup&gt; + 108·31&lt;sup&gt;0 &lt;/sup&gt;= 108 + 31· (108 + 31 · (97 + 31 · (99)))&lt;/p&gt;
&lt;p&gt;如果对每个字符去哈希值可能会比较耗时，所以可以通过间隔取N个字符来获取哈西值来节省时间，比如，可以 获取每8-9个字符来获取哈希值：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;public int GetHashCode(string str)
{
    char[] s = str.ToCharArray();
    int hash = 0;
    int skip = Math.Max(1, s.Length / 8);
    for (int i = 0; i &amp;lt; s.Length; i+=skip)
    {
        hash = s[i] + (31 * hash);
    }
    return hash;
}&lt;/pre&gt;
&lt;p&gt;但是，对于某些情况，不同的字符串会产生相同的哈希值，这就是前面说到的哈希冲突（Hash Collisions），比如下面的四个字符串：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f6a0e00e48270b1bcfcfbc43513b5933.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果我们按照每8个字符取哈希的话，就会得到一样的哈希值。所以下面来讲解如何解决哈希碰撞：&lt;/p&gt;
&lt;h1&gt;避免哈希冲突&lt;/h1&gt;
&lt;h2&gt;拉链法 (&lt;a href=&quot;http://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists&quot; target=&quot;_blank&quot;&gt;Separate chaining with linked lists&lt;/a&gt;)&lt;/h2&gt;
&lt;p&gt;通过哈希函数，我们可以将键转换为数组的索引(0-M-1)，但是对于两个或者多个键具有相同索引值的情况，我们需要有一种方法来处理这种冲突。&lt;/p&gt;
&lt;p&gt;一种比较直接的办法就是，将大小为M 的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的键值对，这就是拉链法。下图很清楚的描述了什么是&lt;a href=&quot;http://en.wikipedia.org/wiki/Hash_table&quot; target=&quot;_blank&quot;&gt;拉链法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0dda838f10365368624ce5e73e2d104f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中，”John Smith”和”Sandra Dee” 通过哈希函数都指向了152 这个索引，该索引又指向了一个链表， 在链表中依次存储了这两个字符串。&lt;/p&gt;
&lt;p&gt;该方法的基本思想就是选择足够大的M，使得所有的链表都尽可能的短小，以保证查找的效率。对采用拉链法的哈希实现的查找分为两步，首先是根据散列值找到等一应的链表，然后沿着链表顺序找到相应的键。 我们现在使用我们之前介绍符号表中的使用无序链表实现的查找表&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Symbol-Table-and-Elementary-Implementations.html&quot; target=&quot;_blank&quot;&gt;SequentSearchSymbolTable&lt;/a&gt; 来实现我们这里的哈希表。当然，您也可以使用.NET里面内置的LinkList。&lt;/p&gt;
&lt;p&gt;首先我们需要定义一个链表的总数，在内部我们定义一个&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Symbol-Table-and-Elementary-Implementations.html&quot; target=&quot;_blank&quot;&gt;SequentSearchSymbolTable&lt;/a&gt;的数组。然后每一个映射到索引的地方保存一个这样的数组。&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;public class SeperateChainingHashSet&amp;lt;TKey, TValue&amp;gt; : SymbolTables&amp;lt;TKey, TValue&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt;, IEquatable&amp;lt;TKey&amp;gt;
{
    private int M;//散列表大小
    private SequentSearchSymbolTable&amp;lt;TKey, TValue&amp;gt;[] st;//

    public SeperateChainingHashSet()
        : this(997)
    {

    }

    public SeperateChainingHashSet(int m)
    {
        this.M = m;
        st = new SequentSearchSymbolTable&amp;lt;TKey, TValue&amp;gt;[m];
        for (int i = 0; i &amp;lt; m; i++)
        {
            st[i] = new SequentSearchSymbolTable&amp;lt;TKey, TValue&amp;gt;();
        }
    }

    private int hash(TKey key)
    {
        return (key.GetHashCode() &amp;amp; 0x7fffffff) % M;
    }

    public override TValue Get(TKey key)
    {
        return st[hash(key)].Get(key);
    }

    public override void Put(TKey key, TValue value)
    {
        st[hash(key)].Put(key, value);
    }

}&lt;/pre&gt;
&lt;p&gt;可以看到，该实现中使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Get方法来获取指定key的Value值，我们首先通过hash方法来找到key对应的索引值，即找到SequentSearchSymbolTable数组中存储该元素的查找表，然后调用查找表的Get方法，根据key找到对应的Value。&lt;/li&gt;
&lt;li&gt;Put方法用来存储键值对，首先通过hash方法找到改key对应的哈希值，然后找到SequentSearchSymbolTable数组中存储该元素的查找表，然后调用查找表的Put方法，将键值对存储起来。&lt;/li&gt;
&lt;li&gt;hash方法来计算key的哈希值， 这里首先通过取与&amp;amp;操作，将符号位去除，然后采用除留余数法将key应到到0-M-1的范围，这也是我们的查找表数组索引的范围。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现基于拉链表的散列表，目标是选择适当的数组大小M，使得既不会因为空链表而浪费内存空间，也不会因为链表太而在查找上浪费太多时间。拉链表的优点在于，这种数组大小M的选择不是关键性的，如果存入的键多于预期，那么查找的时间只会比选择更大的数组稍长，另外，我们也可以使用更高效的结构来代替链表存储。如果存入的键少于预期，索然有些浪费空间，但是查找速度就会很快。所以当内存不紧张时，我们可以选择足够大的M，可以使得查找时间变为常数，如果内存紧张时，选择尽量大的M仍能够将性能提高M倍。&lt;/p&gt;
&lt;h2&gt;线性探测法&lt;/h2&gt;
&lt;p&gt;线性探测法是&lt;a href=&quot;http://en.wikipedia.org/wiki/Hash_table&quot; target=&quot;_blank&quot;&gt;开放寻址法&lt;/a&gt;解决哈希冲突的一种方法，基本原理为，使用大小为M的数组来保存N个键值对，其中M&amp;gt;N，我们需要使用数组中的空位解决碰撞冲突。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/32f8a55df0c8da31dd0b980ed2353664.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;对照前面的拉链法，在该图中，”Ted Baker” 是有唯一的哈希值153的，但是由于153被”Sandra Dee”占用了。而原先”Snadra Dee”和”John Smith”的哈希值都是152的，但是在对”Sandra Dee”进行哈希的时候发现152已经被占用了，所以往下找发现153没有被占用，所以存放在153上，然后”Ted Baker”哈希到153上，发现已经被占用了，所以往下找，发现154没有被占用，所以值存到了154上。&lt;/p&gt;
&lt;p&gt;开放寻址法中最简单的是线性探测法：当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加1，这样的线性探测会出现三种结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命中，该位置的键和被查找的键相同&lt;/li&gt;
&lt;li&gt;未命中，键为空&lt;/li&gt;
&lt;li&gt;继续查找，该位置和键被查找的键不同。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实现线性探测法也很简单，我们只需要两个大小相同的数组分别记录key和value。&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;public class LinearProbingHashSet&amp;lt;TKey, TValue&amp;gt; : SymbolTables&amp;lt;TKey, TValue&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt;, IEquatable&amp;lt;TKey&amp;gt;
{
    private int N;//符号表中键值对的总数
    private int M = 16;//线性探测表的大小
    private TKey[] keys;
    private TValue[] values;

    public LinearProbingHashSet()
    {
        keys = new TKey[M];
        values = new TValue[M];
    }

    private int hash(TKey key)
    {
        return (key.GetHashCode() &amp;amp; 0xFFFFFFF) % M;
    }

    public override TValue Get(TKey key)
    {
        for (int i = hash(key); keys[i] != null; i = (i + 1) % M)
        {
            if (key.Equals(keys[i])) { return values[i]; }
        }
        return default(TValue);
    }

    public override void Put(TKey key, TValue value)
    {
        int hashCode = hash(key);
        for (int i = hashCode; keys[i] != null; i = (i + 1) % M)
        {
            if (keys[i].Equals(key))//如果和已有的key相等，则用新值覆盖
            {
                values[i] = value;
                return;
            }
            //插入
            keys[i] = key;
            values[i] = value;
        }
    }
}&lt;/pre&gt;
&lt;p&gt;线性探查（Linear Probing）方式虽然简单，但是有一些问题，它会导致同类哈希的聚集。在存入的时候存在冲突，在查找的时候冲突依然存在。&lt;/p&gt;
&lt;h2&gt;性能分析&lt;/h2&gt;
&lt;p&gt;我们可以看到，哈希表存储和查找数据的时候分为两步，第一步为将键通过哈希函数映射为数组中的索引， 这个过程可以认为是只需要常数时间的。第二步是，如果出现哈希值冲突，如何解决，前面介绍了拉链法和线性探测法下面就这两种方法进行讨论：&lt;/p&gt;
&lt;p&gt;对于拉链法，查找的效率在于链表的长度，一般的我们应该保证长度在M/8~M/2之间，如果链表的长度大于M/2，我们可以扩充链表长度。如果长度在0~M/8时，我们可以缩小链表。&lt;/p&gt;
&lt;p&gt;对于线性探测法，也是如此，但是动态调整数组的大小需要对所有的值从新进行重新散列并插入新的表中。&lt;/p&gt;
&lt;p&gt;不管是拉链法还是散列法，这种动态调整链表或者数组的大小以提高查询效率的同时，还应该考虑动态改变链表或者数组大小的成本。散列表长度加倍的插入需要进行大量的探测， 这种均摊成本在很多时候需要考虑。&lt;/p&gt;
&lt;h1&gt;哈希碰撞攻击&lt;/h1&gt;
&lt;p&gt;我们知道如果哈希函数选择不当会使得大量的键都会映射到相同的索引上，不管是采用拉链法还是开放寻址法解决冲突，在后面查找的时候都需要进行多次探测或者查找， 在很多时候会使得哈希表的查找效率退化，而不再是常数时间。下图清楚的描述了退化后的哈希表：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f23d41ad908b9319573c80affd0ab31e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;哈希表攻击就是通过精心构造哈希函数，使得所有的键经过哈希函数后都映射到同一个或者几个索引上，将哈希表退化为了一个单链表，这样哈希表的各种操作，比如插入，查找都从O(1)退化到了链表的查找操作，这样就会消耗大量的CPU资源，导致系统无法响应，从而达到拒绝服务供给(Denial of Service, Dos)的目的。之前由于多种编程语言的哈希算法的“非随机”而出现了&lt;a href=&quot;http://coolshell.cn/articles/6424.html#comment-122061&quot; target=&quot;_blank&quot;&gt;Hash碰撞的DoS安全漏洞&lt;/a&gt;，在&lt;a href=&quot;http://www.securityweek.com/hash-table-collision-attacks-could-trigger-ddos-massive-scale&quot; target=&quot;_blank&quot;&gt;ASP.NET&lt;/a&gt;中也曾出现过&lt;a href=&quot;https://technet.microsoft.com/library/security/ms11-100&quot; target=&quot;_blank&quot;&gt;这一问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在.NET中String的哈希值内部实现中，通过使用哈希值随机化来对这种问题进行了限制，通过对碰撞次数设置阈值，超过该阈值就对哈希函数进行随机化，这也是防止哈希表退化的一种做法。下面是BCL中string类型的GetHashCode方法的实现，可以看到，当碰撞超过一定次数的时候，就会开启条件编译，对哈希函数进行随机化。&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail), SecuritySafeCritical, __DynamicallyInvokable]
public override unsafe int GetHashCode()
{
    if (HashHelpers.s_UseRandomizedStringHashing)
    {
        return InternalMarvin32HashString(this, this.Length, 0L);
    }
    fixed (char* str = ((char*) this))
    {
        char* chPtr = str;
        int num = 0x15051505;
        int num2 = num;
        int* numPtr = (int*) chPtr;
        int length = this.Length;
        while (length &amp;gt; 2)
        {
            num = (((num &amp;lt;&amp;lt; 5) + num) + (num &amp;gt;&amp;gt; 0x1b)) ^ numPtr[0];
            num2 = (((num2 &amp;lt;&amp;lt; 5) + num2) + (num2 &amp;gt;&amp;gt; 0x1b)) ^ numPtr[1];
            numPtr += 2;
            length -= 4;
        }
        if (length &amp;gt; 0)
        {
            num = (((num &amp;lt;&amp;lt; 5) + num) + (num &amp;gt;&amp;gt; 0x1b)) ^ numPtr[0];
        }
        return (num + (num2 * 0x5d588b65));
    }
}&lt;/pre&gt;
&lt;h1&gt;.NET中哈希的实现&lt;/h1&gt;
&lt;p&gt;我们可以通过在线源码查看.NET 中&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs&quot; target=&quot;_blank&quot;&gt;Dictionary&lt;/a&gt;，类型的实现，我们知道任何作为key的值添加到Dictionary中时，首先会获取key的hashcode，然后将其映射到不同的bucket中去：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;public Dictionary(int capacity, IEqualityComparer&amp;lt;TKey&amp;gt; comparer) {
    if (capacity &amp;lt; 0) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity);
    if (capacity &amp;gt; 0) Initialize(capacity);
    this.comparer = comparer ?? EqualityComparer&amp;lt;TKey&amp;gt;.Default;
}&lt;/pre&gt;
&lt;p&gt;在Dictionary初始化的时候，会如果传入了大小，会初始化bucket 就是调用Initialize方法：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;private void Initialize(int capacity) {
    int size = HashHelpers.GetPrime(capacity);
    buckets = new int[size];
    for (int i = 0; i &amp;lt; buckets.Length; i++) buckets[i] = -1;
    entries = new Entry[size];
    freeList = -1;
}&lt;/pre&gt;
&lt;p&gt;我们可以看看Dictonary的Add方法，Add方法在内部调用了Insert方法：&lt;/p&gt;
&lt;pre class=&quot;brush: java; gutter: true&quot;&gt;private void Insert(TKey key, TValue value, bool add) 
{
        if( key == null ) {
            ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);
        }

        if (buckets == null) Initialize(0);
        int hashCode = comparer.GetHashCode(key) &amp;amp; 0x7FFFFFFF;
        int targetBucket = hashCode % buckets.Length;

#if FEATURE_RANDOMIZED_STRING_HASHING
        int collisionCount = 0;
#endif

        for (int i = buckets[targetBucket]; i &amp;gt;= 0; i = entries[i].next) {
            if (entries[i].hashCode == hashCode &amp;amp;&amp;amp; comparer.Equals(entries[i].key, key)) {
                if (add) { 
                    ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);
                }
                entries[i].value = value;
                version++;
                return;
            } 

#if FEATURE_RANDOMIZED_STRING_HASHING
            collisionCount++;
#endif
        }
        int index;
        if (freeCount &amp;gt; 0) {
            index = freeList;
            freeList = entries[index].next;
            freeCount--;
        }
        else {
            if (count == entries.Length)
            {
                Resize();
                targetBucket = hashCode % buckets.Length;
            }
            index = count;
            count++;
        }

        entries[index].hashCode = hashCode;
        entries[index].next = buckets[targetBucket];
        entries[index].key = key;
        entries[index].value = value;
        buckets[targetBucket] = index;
        version++;

#if FEATURE_RANDOMIZED_STRING_HASHING
        if(collisionCount &amp;gt; HashHelpers.HashCollisionThreshold &amp;amp;&amp;amp; HashHelpers.IsWellKnownEqualityComparer(comparer)) 
        {
            comparer = (IEqualityComparer&amp;lt;TKey&amp;gt;) HashHelpers.GetRandomizedEqualityComparer(comparer);
            Resize(entries.Length, true);
        }
#endif

    }&lt;/pre&gt;
&lt;p&gt;首先，根据key获取其hashcode，然后将hashcode除以backet的大小取余映射到目标backet中，然后遍历该bucket存储的链表，如果找到和key相同的值，如果不允许后添加的键与存在的键相同替换值(add)，则抛出异常，如果允许，则替换之前的值，然后返回。&lt;/p&gt;
&lt;p&gt;如果没有找到，则将新添加的值放到新的bucket中，当空余空间不足的时候，会进行扩容操作(Resize)，然后重新hash到目标bucket。这里面需要注意的是Resize操作比较消耗资源。&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;前面几篇文章先后介绍了基于无序列表的&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduction-Stack-and-Queue.html&quot; target=&quot;_blank&quot;&gt;顺序查找&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html&quot; target=&quot;_blank&quot;&gt;基于有序数组的二分查找&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html&quot; target=&quot;_blank&quot;&gt;平衡查找树&lt;/a&gt;，以及&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;，本篇文章最后介绍了查找算法中的最后一类即符号表又称哈希表,并介绍了哈希函数以及处理哈希冲突的两种方法：拉链法和线性探测法。各种查找算法的最坏和平均条件下各种操作的时间复杂度如下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1f267cfbb17b19127ada80a9542e7820.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在实际编写代码中，如何选择合适的数据结构需要根据具体的数据规模，查找效率要求，时间和空间局限来做出合适的选择。希望本文以及前面的几篇文章对您有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.codinglabs.org/articles/hash-collisions-attack-on-php.html&quot; target=&quot;_blank&quot;&gt;PHP哈希表碰撞攻击原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.zhaojie.me/2013/01/think-in-detail-why-its-o-1.html&quot; target=&quot;_blank&quot;&gt;真是O(1)吗？想清楚了没？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.string.gethashcode.aspx&quot; target=&quot;_blank&quot;&gt;String.GetHashCode Method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs&quot; target=&quot;_blank&quot;&gt;.NET Dictionary Source Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79261-99f62516d.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79261-99f62516d.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>10分钟掌握XML、JSON及其解析</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;h1&gt;引言&lt;/h1&gt;
&lt;p&gt;NOKIA 有句著名的广告语：“&lt;strong&gt;&lt;em&gt;科技以人为本&lt;/em&gt;&lt;/strong&gt;”。任何技术都是为了满足人的生产生活需要而产生的。具体到小小的一个手机，里面蕴含的技术也是浩如烟海，是几千年来人类科技的结晶，单个人穷其一生也未必能掌握其一角。不过个人一直认为基本的技术和思想是放之四海而皆准的，许多技术未必需要我们从头到尾再研究一遍，我们要做的就是站在巨人的肩膀上，利用其成果来为人们的需求服务。&lt;/p&gt;
&lt;p&gt;随着移动互联网时代的大潮，越来越多的App&lt;strong&gt;不光是需要和网络服务器进行数据传输和交互，也需要和其他 App 进行数据传递&lt;/strong&gt;。承担App与网络来进行传输和存储数据的一般是XML或者JSON。在移动互联网时代，XML和JSON很重要。&lt;/p&gt;
&lt;p&gt;最近一段时间，个人综合了之前对XML、JSON的一些了解，参考了相关资料，再结合视频的代码，把自己的一些思考融入了这篇总结文档中，同时尝试用通俗诙谐的语言风格来阐述，期望能给感兴趣的读者带来帮助。&lt;/p&gt;
&lt;p&gt;为了不和时代落伍，我们必须要学习 XML 和 JSON，但同时它们也很容易学习，Let’s start:–)&lt;/p&gt;
&lt;h1&gt;一、XML&lt;/h1&gt;
&lt;p&gt;XML即&lt;strong&gt;可扩展标记语言&lt;/strong&gt;(&lt;strong&gt;&lt;em&gt;eXtensible Markup Language&lt;/em&gt;&lt;/strong&gt;)。标记是指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。如何定义这些标记，既可以选择国际通用的标记语言，比如HTML，也可以使用象XML这样由相关人士自由决定的标记语言，这就是语言的可扩展性。XML是从SGML中简化修改出来的。它主要用到的有XML、XSL和XPath等。&lt;/p&gt;
&lt;p&gt;上面这段是对XML的一个基本定义，一个被广泛接受的说明。简单说，XML就是一种数据的描述语言，虽然它是语言，但是通常情况下，它并不具备常见语言的基本功能——被计算机识别并运行。只有依靠另一种语言，来解释它，使它达到你想要的效果或被计算机所接受。&lt;/p&gt;
&lt;p&gt;记住以下几点就行了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XML是一种标记语言，很类似HTML&lt;/li&gt;
&lt;li&gt;XML的设计宗旨是传输数据，而非显示数据&lt;/li&gt;
&lt;li&gt;XML标签没有被预定义。您需要自行定义标签。&lt;/li&gt;
&lt;li&gt;XML被设计为具有自我描述性。&lt;/li&gt;
&lt;li&gt;XML是W3C的推荐标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;XML是独立于软件和硬件的信息传输工具。 目前，XML在Web中起到的作用不会亚于一直作为 Web 基石的 HTML。 &lt;strong&gt;XML无所不在&lt;/strong&gt;。XML是各种应用程序之间进行&lt;strong&gt;数据传输的最常用的工具&lt;/strong&gt;，并且在信息存储和描述领域变得越来越流行。&lt;/p&gt;
&lt;h2&gt;1.1 XML属性&lt;/h2&gt;
&lt;h3&gt;1.1.1 XML与HTML的主要差异&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;XML不是HTML的替代。&lt;/li&gt;
&lt;li&gt;XML和HTML为不同的目的而设计。&lt;/li&gt;
&lt;li&gt;XML被设计为传输和存储数据，其焦点是数据的内容。&lt;/li&gt;
&lt;li&gt;HTML被设计用来显示数据，其焦点是数据的外观。&lt;/li&gt;
&lt;li&gt;HTML旨在显示信息，而 XML 旨在传输信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.1.2 XML是不作为的。&lt;/h3&gt;
&lt;p&gt;也许这有点难以理解，但是XML不会做任何事情。XML被设计用来&lt;strong&gt;结构化、存储以及传输信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面是John写给George的便签，存储为XML：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;note&amp;gt;
&amp;lt;to&amp;gt;George&amp;lt;/to&amp;gt;
&amp;lt;from&amp;gt;John&amp;lt;/from&amp;gt;
&amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt;
&amp;lt;body&amp;gt;Don&#39;t forget the meeting!&amp;lt;/body&amp;gt;
&amp;lt;/note&amp;gt;&lt;/pre&gt;
&lt;p&gt;上面的这条便签具有自我描述性。它拥有标题以及留言，同时包含了发送者和接受者的信息。但是，这个 XML 文档仍然没有做任何事情。它仅仅是包装在XML标签中的纯粹的信息。我们需要编写软件或者程序，才能传送、接收和显示出这个文档。&lt;/p&gt;
&lt;h3&gt;1.1.3 XML仅仅是纯文本&lt;/h3&gt;
&lt;p&gt;XML没什么特别的。它仅仅是纯文本而已。有能力处理纯文本的软件都可以处理XML。 不过，能够读懂 XML 的应用程序可以有针对性地处理 XML 的标签。标签的功能性意义依赖于应用程序的特性。&lt;/p&gt;
&lt;h3&gt;1.1.4 XML允许自定义标签&lt;/h3&gt;
&lt;p&gt;上例中的标签没有在任何XML标准中定义过（比如和）。这些标签是由文档的创作者发明的。这是因为XML没有预定义的标签。&lt;/p&gt;
&lt;p&gt;在HTML中使用的标签（以及HTML的结构）是预定义的。HTML文档只使用在HTML标准中定义过的标签（比如&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 等等）。&lt;/p&gt;
&lt;p&gt;XML允许创作者定义自己的标签和自己的文档结构。&lt;/p&gt;
&lt;h3&gt;1.1.5 XML不是对HTML的替代&lt;/h3&gt;
&lt;p&gt;XML是对HTML的补充。&lt;/p&gt;
&lt;p&gt;XML不会替代HTML，理解这一点很重要。在大多数 web 应用程序中，XML用于传输数据，而HTML用于格式化并显示数据。&lt;/p&gt;
&lt;h2&gt;1.2 XML的语法&lt;/h2&gt;
&lt;p&gt;XML的语法规则很简单，且很有逻辑。这些规则很容易学习，也很容易使用。&lt;/p&gt;
&lt;h4&gt;1.2.1 所有元素都必须有关闭标签&lt;/h4&gt;
&lt;p&gt;在XML中，省略关闭标签是非法的。所有元素都&lt;strong&gt;必须有关闭标签&lt;/strong&gt;。 在HTML，经常会看到没有关闭标签的元素：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;p&amp;gt;This is a paragraph
&amp;lt;p&amp;gt;This is another paragraph&lt;/pre&gt;
&lt;p&gt;在XML中，省略关闭标签是非法的。所有元素都必须有关闭标签：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;&amp;lt;p&amp;gt;This is a paragraph&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;This is another paragraph&amp;lt;/p&amp;gt;&lt;/pre&gt;
&lt;p&gt;注释：您也许已经注意到XML声明没有关闭标签。这不是错误。声明不属于XML本身的组成部分。它不是XML元素，也不需要关闭标签。&lt;/p&gt;
&lt;h4&gt;1.2.2 XML标签对大小写敏感&lt;/h4&gt;
&lt;p&gt;XML元素使用XML标签进行定义。&lt;/p&gt;
&lt;p&gt;XML标签对大小写敏感。在XML中，标签与标签是不同的。&lt;/p&gt;
&lt;p&gt;必须使用相同的大小写来编写打开标签和关闭标签：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;Message&amp;gt;这是错误的。&amp;lt;/message&amp;gt;
&amp;lt;message&amp;gt;这是正确的。&amp;lt;/message&amp;gt;&lt;/pre&gt;
&lt;h4&gt;1.2.3 XML标签对大小写敏感&lt;/h4&gt;
&lt;p&gt;在 HTML 中，常会看到没有正确嵌套的元素：&lt;/p&gt;
&lt;pre class=&quot;brush: html; gutter: true&quot;&gt;&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;This text is bold and italic&amp;lt;/b&amp;gt;&amp;lt;/i&amp;gt;&lt;/pre&gt;
&lt;p&gt;在 XML中，所有元素都必须彼此正确地嵌套：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;This text is bold and italic&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt;&lt;/pre&gt;
&lt;p&gt;在上例中，正确嵌套的意思是：由于&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;元素是在&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;元素内打开的，那么它必须在&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;元素内关闭。&lt;/p&gt;
&lt;h4&gt;1.2.4 XML文档必须有根元素&lt;/h4&gt;
&lt;p&gt;XML文档必须有一个元素是所有其他元素的父元素。该元素称为根元素。&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;root&amp;gt;
  &amp;lt;child&amp;gt;
    &amp;lt;subchild&amp;gt;.....&amp;lt;/subchild&amp;gt;
  &amp;lt;/child&amp;gt;
&amp;lt;/root&amp;gt;&lt;/pre&gt;
&lt;h4&gt;1.2.5 XML的属性值须加引号&lt;/h4&gt;
&lt;p&gt;与 HTML 类似，XML 也可拥有属性（名称/值的对）。 在 XML 中，XML 的属性值须加引号。请研究下面的两个 XML 文档。第一个是错误的，第二个是正确的：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;note date=08/08/2008&amp;gt;
&amp;lt;to&amp;gt;George&amp;lt;/to&amp;gt;
&amp;lt;from&amp;gt;John&amp;lt;/from&amp;gt;
&amp;lt;/note&amp;gt; 

&amp;lt;note date=&quot;08/08/2008&quot;&amp;gt;
&amp;lt;to&amp;gt;George&amp;lt;/to&amp;gt;
&amp;lt;from&amp;gt;John&amp;lt;/from&amp;gt;
&amp;lt;/note&amp;gt;&lt;/pre&gt;
&lt;h4&gt;1.2.6 实体引用&lt;/h4&gt;
&lt;p&gt;在 XML 中，一些字符拥有特殊的意义。 如果你把字符 “&amp;lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。 这样会产生 XML 错误：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;message&amp;gt;if salary &amp;lt; 1000 then&amp;lt;/message&amp;gt;&lt;/pre&gt;
&lt;p&gt;为了避免这个错误，请用实体引用来代替 “&amp;lt;” 字符：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;message&amp;gt;if salary &amp;amp;lt; 1000 then&amp;lt;/message&amp;gt;&lt;/pre&gt;
&lt;p&gt;在 XML 中，有 5 个预定义的实体引用：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;amp;lt;    &amp;lt;   小于
&amp;amp;gt;    &amp;gt;   大于
&amp;amp;amp;   &amp;amp;   和号
&#39;  &#39;   单引号
&amp;amp;quot;  &quot;   引号&lt;/pre&gt;
&lt;p&gt;注释：在 XML 中，只有字符 “&amp;lt;” 和 “&amp;amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。&lt;/p&gt;
&lt;h4&gt;1.2.7 XML中的注释&lt;/h4&gt;
&lt;p&gt;在 XML 中编写注释的语法与 HTML 的语法很相似：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;!-- This is a comment --&amp;gt;&lt;/pre&gt;
&lt;p&gt;在 XML 中，空格会被保留 HTML 会把多个连续的空格字符裁减（合并）为一个：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;HTML:   Hello           my name is David.&lt;/pre&gt;
&lt;p&gt;输出: Hello my name is David. 在 XML 中，文档中的空格不会被删节。&lt;/p&gt;
&lt;h4&gt;1.2.8 以 LF 存储换行&lt;/h4&gt;
&lt;p&gt;在 Windows 应用程序中，换行通常以一对字符来存储：回车符 (CR) 和换行符 (LF)。这对字符与打字机设置新行的动作有相似之处。在 Unix 应用程序中，新行以 LF 字符存储。而 Macintosh 应用程序使用CR来存储新行。&lt;/p&gt;
&lt;h3&gt;1.3 XML CDATA&lt;/h3&gt;
&lt;p&gt;所有XML文档中的文本均会被解析器解析。&lt;/p&gt;
&lt;p&gt;只有CDATA区段（CDATA section）中的文本会被解析器忽略。&lt;/p&gt;
&lt;h4&gt;1.3.1 PCDATA&lt;/h4&gt;
&lt;p&gt;PCDATA指的是被解析的字符数据（Parsed Character Data）。&lt;/p&gt;
&lt;p&gt;XML解析器通常会解析XML文档中所有的文本。 当某个XML元素被解析时，其标签之间的文本也会被解析：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;message&amp;gt;此文本也会被解析&amp;lt;/message&amp;gt;&lt;/pre&gt;
&lt;p&gt;解析器之所以这么做是因为 XML 元素可包含其他元素，就像这个例子中，其中的元素包含着另外的两个元素(first和last)：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;&amp;lt;name&amp;gt;&amp;lt;first&amp;gt;Bill&amp;lt;/first&amp;gt;&amp;lt;last&amp;gt;Gates&amp;lt;/last&amp;gt;&amp;lt;/name&amp;gt;&lt;/pre&gt;
&lt;p&gt;而解析器会把它分解为像这样的子元素：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;&amp;lt;name&amp;gt;
   &amp;lt;first&amp;gt;Bill&amp;lt;/first&amp;gt;
   &amp;lt;last&amp;gt;Gates&amp;lt;/last&amp;gt;
&amp;lt;/name&amp;gt;&lt;/pre&gt;
&lt;h4&gt;1.3.2 转义字符&lt;/h4&gt;
&lt;p&gt;非法的XML字符必须被替换为实体引用（entity reference）。&lt;/p&gt;
&lt;p&gt;假如您在XML文档中放置了一个类似 “&amp;lt;” 字符，那么这个文档会产生一个错误，这是因为解析器会把它解释为新元素的开始。因此你不能这样写：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;message&amp;gt;if salary &amp;lt; 1000 then&amp;lt;/message&amp;gt;&lt;/pre&gt;
&lt;p&gt;为了避免此类错误，需要把字符 “&amp;lt;” 替换为实体引用，就像这样：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;message&amp;gt;if salary &amp;amp;lt; 1000 then&amp;lt;/message&amp;gt;&lt;/pre&gt;
&lt;p&gt;在 XML 中有 5 个预定义的实体引用：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;amp;lt;    &amp;lt;   小于
&amp;amp;gt;    &amp;gt;   大于
&amp;amp;amp;   &amp;amp;   和号
&#39;  &#39;   省略号
&amp;amp;quot;  &quot;   引号&lt;/pre&gt;
&lt;p&gt;注释：严格地讲，在XML中仅有字符”&amp;lt;“和”&amp;amp;“是非法的。省略号、引号和大于号是合法的，但是把它们替换为实体引用是个好的习惯。&lt;/p&gt;
&lt;h4&gt;1.3.3 CDATA&lt;/h4&gt;
&lt;p&gt;术语CDATA指的是不应由XML解析器进行解析的文本数据（Unparsed Character Data）。&lt;/p&gt;
&lt;p&gt;在 XML 元素中，”&amp;lt;“ 和 ”&amp;amp;“ 是非法的。&lt;/p&gt;
&lt;p&gt;“&amp;lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。 “&amp;amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。&lt;/p&gt;
&lt;p&gt;某些文本，比如 JavaScript 代码，包含大量 “&amp;lt;” 或 “&amp;amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。 CDATA 部分中的所有内容都会被解析器忽略。 CDATA 部分由 “&amp;lt;![CDATA[” 开始，由 “]]&amp;gt;” 结束：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;response&amp;gt; 
  &amp;lt;header&amp;gt; 
    &amp;lt;respcode&amp;gt;0&amp;lt;/respcode&amp;gt;  
    &amp;lt;total&amp;gt;1736&amp;lt;/total&amp;gt; 
  &amp;lt;/header&amp;gt;  
  &amp;lt;result&amp;gt; 
    &amp;lt;album&amp;gt; 
      &amp;lt;album_id&amp;gt;320305900&amp;lt;/album_id&amp;gt;  
      &amp;lt;title&amp;gt; &amp;lt;![CDATA[ 电影侃侃之初恋永不早 ]]&amp;gt; &amp;lt;/title&amp;gt;  
      &amp;lt;tag&amp;gt; &amp;lt;![CDATA[ 18岁以上 当代 暧昧 华语 ]]&amp;gt; &amp;lt;/tag&amp;gt;  
      &amp;lt;img&amp;gt;http://pic9.qiyipic.com/image/20141016/ec/e0/v_108639906_m_601_120_160.jpg&amp;lt;/img&amp;gt;  
      &amp;lt;img180236&amp;gt;http://pic9.qiyipic.com/image/20141016/ec/e0/v_108639906_m_601_180_236.jpg&amp;lt;/img180236&amp;gt;  
      &amp;lt;img11577&amp;gt;http://pic9.qiyipic.com/image/20141016/ec/e0/v_108639906_m_601_115_77.jpg&amp;lt;/img11577&amp;gt;  
      &amp;lt;img220124&amp;gt;http://pic9.qiyipic.com/image/20141016/ec/e0/v_108639906_m_601_284_160.jpg&amp;lt;/img220124&amp;gt;  
      &amp;lt;category_id&amp;gt;1&amp;lt;/category_id&amp;gt;  
      &amp;lt;score&amp;gt;0.0&amp;lt;/score&amp;gt;  
      &amp;lt;voters&amp;gt;0&amp;lt;/voters&amp;gt;  
      &amp;lt;tv_sets&amp;gt;0&amp;lt;/tv_sets&amp;gt;  
      &amp;lt;duration&amp;gt;00:38:57&amp;lt;/duration&amp;gt;  
      &amp;lt;year&amp;gt; &amp;lt;![CDATA[ 2014 ]]&amp;gt; &amp;lt;/year&amp;gt;  
      &amp;lt;tv_focus&amp;gt;跟爱情片学把妹心经&amp;lt;/tv_focus&amp;gt;  
      &amp;lt;episode_count&amp;gt;1&amp;lt;/episode_count&amp;gt;  
      &amp;lt;directors&amp;gt; &amp;lt;![CDATA[ 关雅荻 ]]&amp;gt; &amp;lt;/directors&amp;gt;  
      &amp;lt;mainactors&amp;gt; &amp;lt;![CDATA[ 关雅荻 ]]&amp;gt; &amp;lt;/mainactors&amp;gt;  
      &amp;lt;actors&amp;gt; &amp;lt;![CDATA[ ]]&amp;gt; &amp;lt;/actors&amp;gt;  
      &amp;lt;vv2&amp;gt; &amp;lt;![CDATA[ 15 ]]&amp;gt; &amp;lt;/vv2&amp;gt;  
      &amp;lt;timeText&amp;gt; &amp;lt;![CDATA[ 今天 ]]&amp;gt; &amp;lt;/timeText&amp;gt;  
      &amp;lt;first_issue_time&amp;gt; &amp;lt;![CDATA[ 2014-10-16 ]]&amp;gt; &amp;lt;/first_issue_time&amp;gt;  
      &amp;lt;up&amp;gt;0&amp;lt;/up&amp;gt;  
      &amp;lt;down&amp;gt;0&amp;lt;/down&amp;gt;  
      &amp;lt;download&amp;gt;1&amp;lt;/download&amp;gt;  
      &amp;lt;purchase_type&amp;gt;0&amp;lt;/purchase_type&amp;gt;  
      &amp;lt;hot_or_new&amp;gt;0&amp;lt;/hot_or_new&amp;gt;  
      &amp;lt;createtime&amp;gt;2014-10-16 12:25:08&amp;lt;/createtime&amp;gt;  
      &amp;lt;purchase&amp;gt;0&amp;lt;/purchase&amp;gt;  
      &amp;lt;desc&amp;gt; &amp;lt;![CDATA[
本期节目主持人介绍新近上映的口碑爱情片，。主持人轻松幽默的罗列出胡鳄鱼导演拍摄的爱情片越来越接地气，博得观众的认同和追捧，更提出“初恋永远不嫌早”的口号。观众可以跟着爱情片学习把妹心经。
]]&amp;gt; &amp;lt;/desc&amp;gt;  
      &amp;lt;ip_limit&amp;gt;1&amp;lt;/ip_limit&amp;gt;  
      &amp;lt;episodes/&amp;gt; 
    &amp;lt;/album&amp;gt; 
  &amp;lt;/result&amp;gt; 
&amp;lt;/response&amp;gt;&lt;/pre&gt;
&lt;h6&gt;这是展示一部电影的具体数据，包括标题、介绍、内容、导演、演员、时长、上映年份等很多内容。&lt;/h6&gt;
&lt;h2&gt;1.5 XML树结构&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;XML文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;1.5.1 一个XML文档实例&lt;/h3&gt;
&lt;p&gt;XML使用简单的具有自我描述性的语法：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt;
&amp;lt;note&amp;gt;
&amp;lt;to&amp;gt;George&amp;lt;/to&amp;gt;
&amp;lt;from&amp;gt;John&amp;lt;/from&amp;gt;
&amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt;
&amp;lt;body&amp;gt;Don&#39;t forget the meeting!&amp;lt;/body&amp;gt;
&amp;lt;/note&amp;gt;&lt;/pre&gt;
&lt;p&gt;第一行是XML声明。它定义XML的版本(1.0)和所使用的编码(ISO-8859-1=Latin-1/西欧字符集)。&lt;/p&gt;
&lt;p&gt;下一行描述文档的根元素（像在说：“本文档是一个便签”）：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;note&amp;gt;&lt;/pre&gt;
&lt;p&gt;接下来 4 行描述根的 4 个子元素（to, from, heading 以及 body）：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;to&amp;gt;George&amp;lt;/to&amp;gt;
&amp;lt;from&amp;gt;John&amp;lt;/from&amp;gt;
&amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt;
&amp;lt;body&amp;gt;Don&#39;t forget the meeting!&amp;lt;/body&amp;gt;&lt;/pre&gt;
&lt;p&gt;最后一行定义根元素的结尾：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;/note&amp;gt;&lt;/pre&gt;
&lt;p&gt;从本例可以设想，该XML文档包含了John给George的一张便签。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XML具有出色的自我描述性，你同意吗？&lt;/li&gt;
&lt;li&gt;XML文档形成一种树结构&lt;/li&gt;
&lt;li&gt;XML文档必须包含根元素。该元素是所有其他元素的父元素。&lt;/li&gt;
&lt;li&gt;XML文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有元素均可拥有子元素：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;root&amp;gt;
  &amp;lt;child&amp;gt;
    &amp;lt;subchild&amp;gt;.....&amp;lt;/subchild&amp;gt;
  &amp;lt;/child&amp;gt;
&amp;lt;/root&amp;gt;&lt;/pre&gt;
&lt;p&gt;父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）。&lt;/p&gt;
&lt;p&gt;所有元素均可拥有文本内容和属性（类似HTML中）。&lt;/p&gt;
&lt;h2&gt;1.6 XML DOM&lt;/h2&gt;
&lt;p&gt;想到这里，大家都有点迫不及待了，XML 文件到底如何解析呢？&lt;/p&gt;
&lt;p&gt;但是，别急，让子弹先飞会儿:–)&lt;/p&gt;
&lt;p&gt;在XML解析之前，我们必须系统性的学习一下 XML DOM 知识：&lt;/p&gt;
&lt;h3&gt;1.6.1 定义&lt;/h3&gt;
&lt;p&gt;XML DOM(&lt;strong&gt;XML Document Object Model&lt;/strong&gt;) 定义了访问和操作XML文档的标准方法。&lt;/p&gt;
&lt;p&gt;DOM把XML文档作为树结构来查看。能够通过DOM树来访问所有元素。可以修改或删除它们的内容，并创建新的元素。元素，它们的文本，以及它们的属性，都被认为是节点。&lt;/p&gt;
&lt;p&gt;XML DOM是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于XML的标准对象模型&lt;/li&gt;
&lt;li&gt;用于XML的标准编程接口&lt;/li&gt;
&lt;li&gt;中立于平台和语言&lt;/li&gt;
&lt;li&gt;W3C的标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XML DOM定义了所有XML元素的对象和属性，以及访问它们的方法（接口）。&lt;/p&gt;
&lt;p&gt;换句话说：&lt;/p&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;XML DOM是用于获取、更改、添加或删除XML元素的标准&lt;/pre&gt;
&lt;h5&gt;DOM将XML文档作为一个树形结构，而树叶被定义为节点。&lt;/h5&gt;
&lt;h3&gt;1.6.2 总结&lt;/h3&gt;
&lt;p&gt;XML DOM其实比较复杂，在这么短的篇幅里也无法一一进行讲解。想详细了解XML DOM可以好好去学习下&lt;/p&gt;
&lt;h2&gt;1.7 XML如何解析？&lt;/h2&gt;
&lt;p&gt;上面讲了这么多关于XML的东西，那么XML文件应该如何解析呢？&lt;/p&gt;
&lt;p&gt;终于到了我们的重头戏了&lt;/p&gt;
&lt;p&gt;下面以视频项目为例，展示如何解析XML文件：&lt;/p&gt;
&lt;h3&gt;1.7.1 Step 1&lt;/h3&gt;
&lt;h5&gt;XML文件是一棵树，首先需要找到对应的节点，然后从节点开始解析，比如搜索找到的就是result/weights/weight 和result/weights/weight 2个节点，分别从这个开始解析：&lt;/h5&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;public ResultInfo onParser(Element rootElement) {
    int resp = -1;
    try {
        String elName = &quot;header/respcode&quot;;
        resp = Integer.parseInt(selectNodeString(rootElement, elName));
    } catch (NumberFormatException e) {
        e.printStackTrace();
    }

    Log.d(TAG, &quot;resp= &quot; + resp);

    if (resp != 0) {
        return null;
    }

    ResultInfo searchResultInfo = new ResultInfo();

    // Parse Search Weight
    @SuppressWarnings(&quot;rawtypes&quot;)
    final List weights = rootElement.selectNodes(rootElement.getPath() + &quot;/&quot;
            + &quot;result/weights/weight&quot;);

    ResultInfo[] resultFilterInfos = parseVideos(weights);
    if (resultFilterInfos != null) {
        ResultInfo weight = new ResultInfo();
        weight.putResultInfoArray(ResultInfo.KEY_VIDEOS, resultFilterInfos);
        searchResultInfo.putResultInfo(ResultInfo.KEY_WEIGHT, weight);
    }

    // Parse Albums
    @SuppressWarnings(&quot;rawtypes&quot;)
    final List albums = rootElement.selectNodes(rootElement.getPath() + &quot;/&quot;
            + &quot;result/albums/album&quot;);

    ResultInfo[] resultInfos = parseVideos(albums);
    if (resultInfos != null) {
        ResultInfo album = new ResultInfo();
        album.putResultInfoArray(ResultInfo.KEY_VIDEOS, resultInfos);
        searchResultInfo.putResultInfo(ResultInfo.KEY_SEARCH, album);
    }

    return searchResultInfo;
}&lt;/pre&gt;
&lt;h3&gt;1.7.2 Step 2&lt;/h3&gt;
&lt;h5&gt;　找到了对应的Node，即从对应的Node开始递归的查找，直到找到最小的节点，也就是最基本的单元Element。再对每一个Element进行解析：&lt;/h5&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;private ResultInfo[] parseVideos(final List nodes) {
    if (nodes != null &amp;amp;&amp;amp; nodes.size() &amp;gt; 0) {
        final int size = nodes.size();
        final ResultInfo[] vis = new ResultInfo[size];
        int i = 0;
        for (Object o : nodes) {
            if (o instanceof Element) {
                final Element videoElement = (Element) o;
                ResultInfo vi = parseVideo(videoElement);
                vis[i] = vi;
            }
            i++;
        }
        return vis;
    }
    return null;
}&lt;/pre&gt;
&lt;h3&gt;1.7.3 Step 3&lt;/h3&gt;
&lt;h5&gt;　针对获取到的Element，解析出对应的String将数据传递给VideoInfo这个类：&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private ResultInfo parseVideo(final Element videoElement) {
    final String id = videoElement.elementText(&quot;album_id&quot;);
    final String title = videoElement.elementText(&quot;title&quot;);
    final String categoryId = videoElement.elementText(&quot;category_id&quot;);
    final String categoryName = videoElement.elementText(&quot;category_name&quot;);
    final String count = videoElement.elementText(&quot;count&quot;);
    final String imgUrl = videoElement.elementText(&quot;img180236&quot;);
    final String duration = videoElement.elementText(&quot;duration&quot;);
    final String mainactors = videoElement.elementText(&quot;mainactors&quot;);
    final String sitename = videoElement.elementText(&quot;site_name&quot;);
    final String videourl = videoElement.elementText(&quot;vedio_url&quot;);
    final String sort = videoElement.elementText(&quot;sort&quot;);
    final String tv_id = videoElement.elementText(&quot;tv_id&quot;);
    ResultInfo vi = new ResultInfo();
    vi.putString(VideoInfo.ID, id);
    vi.putString(VideoInfo.TITLE, title);
    vi.putString(VideoInfo.CATEGORY_ID, categoryId);
    vi.putString(VideoInfo.CATEGORY_NAME, categoryName);
    vi.putString(VideoInfo.COUNT, count);
    vi.putString(VideoInfo.IMG_URL, imgUrl);
    vi.putString(VideoInfo.DURATION, duration);
    vi.putString(VideoInfo.MAINACTORS, mainactors);
    vi.putString(VideoInfo.SITENAME, sitename);
    vi.putString(VideoInfo.VIDEOURL, videourl);
    vi.putString(VideoInfo.SORT, sort);
    vi.putString(VideoInfo.TV_ID, tv_id);
    return vi;
}&lt;/pre&gt;
&lt;h3&gt;1.7.4 Step 4&lt;/h3&gt;
&lt;h5&gt;　当使用XML解析器将XML数据解析出来之后。需要将这些数据提取出来，也是通过连续2层提取，将数据定位到每个video， 将每个video里的数据传递给SearchVideoInfo这个ArrayList，然后将ArrayList中的数据和对应的Adapter数据关联起来：&lt;/h5&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;public static ArrayList&amp;lt;SearchVideoInfo&amp;gt; getSearchVideoInfo(ResultInfo searchResultInfo) {

    ResultInfo resultInfo = null;
    ResultInfo[] videos = null;
    ArrayList&amp;lt;SearchVideoInfo&amp;gt; searchVideoInfos = null;

    if (searchResultInfo != null) {
        resultInfo = searchResultInfo.getResultInfo(ResultInfo.KEY_SEARCH);
    }

    if (resultInfo != null) {
        videos = resultInfo.getResultInfoArray(ResultInfo.KEY_VIDEOS);
    }

    if (videos != null &amp;amp;&amp;amp; videos.length &amp;gt; 0) {

        searchVideoInfos = new ArrayList&amp;lt;SearchVideoInfo&amp;gt;(videos.length);

        for (ResultInfo video : videos) {
            SearchVideoInfo searchInfo = new SearchVideoInfo();

            searchInfo.setAlbum_id(video.getString(VideoInfo.ID));
            searchInfo.setTitle(video.getString(VideoInfo.TITLE));
            searchInfo.setChannel_id(video.getString(VideoInfo.CATEGORY_ID));
            searchInfo.setImgUrl(video.getString(VideoInfo.IMG_URL));
            searchInfo.setDuration(video.getString(VideoInfo.DURATION));
            searchInfo.setMainActors(video.getString(VideoInfo.MAINACTORS));
            searchInfo.setSiteName(video.getString(VideoInfo.SITENAME));
            searchInfo.setVideo_url(video.getString(VideoInfo.VIDEOURL));
            searchInfo.setOrder(video.getString(VideoInfo.SORT));
            searchInfo.setTv_id(video.getString(VideoInfo.TV_ID));
            // searchInfo.setContinueType(video.getString(VideoInfo.CONTINUETYPE));

            searchVideoInfos.add(searchInfo);
        }
    }

    if (searchVideoInfos == null) {
        MyLog.e(TAG, &quot;error, getSearchVideoInfo, can not get info&quot;);
    }

    return searchVideoInfos;
}&lt;/pre&gt;
&lt;h5&gt;以上就是搜索数据的XML的解析和数据展示过程。&lt;/h5&gt;
&lt;h1&gt;二、JSON&lt;/h1&gt;
&lt;p&gt;XML很好很强大，但是最近有另外一个时代弄潮儿，这就是JSON。现在JSON的光环已经逐渐超越了XML，各大网站提供的数据接口一般都是JSON。下面我们就来学习下JSON。&lt;/p&gt;
&lt;h2&gt;2.1 JSON是什么？&lt;/h2&gt;
&lt;p&gt;JSON：JavaScript对象表示法(&lt;strong&gt;&lt;em&gt;JavaScript Object Notation&lt;/em&gt;&lt;/strong&gt;）, 是一种轻量级的数据交换格式, 易于人阅读和编写, 同时也易于机器解析和生成。&lt;/p&gt;
&lt;p&gt;JSON是存储和交换文本信息的语法，类似XML。&lt;/p&gt;
&lt;p&gt;JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言&lt;/p&gt;
&lt;h2&gt;2.2 JSON格式&lt;/h2&gt;
&lt;h4&gt;
&lt;strong&gt;&lt;em&gt;JSON&lt;/em&gt;&lt;/strong&gt;构建于两种结构：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;strong&gt;“名称/值”对的集合&lt;/strong&gt;(A collection of name/value pairs)。不同的语言中，它被理解为对象（object），纪录（record），结构(struct)，字典(dictionary)，哈希表（hash table），有键列表(keyed list)，或者关联数组(associative array)。&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;值的有序列表&lt;/strong&gt;(An ordered list of values)。在大多数语言中，它被理解为数组(array)、矢量(vector), 列表(list)或者是序列(sequence)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;
&lt;strong&gt;&lt;em&gt;JSON&lt;/em&gt;&lt;/strong&gt;具有以下这些形式：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对象是一个无序的“’名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;JSON Object&quot; src=&quot;/images/jobbole.com/c9ad1666ec7757894267a425571a1fb7.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组是值(value)的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。&lt;/li&gt;
&lt;li&gt;
&lt;img alt=&quot;JSON Array&quot; src=&quot;/images/jobbole.com/c70c6ca644c516f658b7af3b4b4b8c62.jpg&quot;&gt;
&lt;ul&gt;
&lt;li&gt;值(value)可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array）。这些结构可以嵌套。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;JSON Value&quot; src=&quot;/images/jobbole.com/a2f95101e87c1b73dd03f51a0ee652d1.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串（string）是由0到多个Unicode字符组成的序列，封装在双引号（”“）中, 可以使用反斜杠（‘\’）来进行转义。一个字符可以表示为一个单一字符的字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;JSON String&quot; src=&quot;/images/jobbole.com/96ef2fbd5fc54ed48b78fbb50d0dcab0.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字(number)类似C或者Java里面的数，没有用到的8进制和16进制数除外。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;JSON Number&quot; src=&quot;/images/jobbole.com/8cecf451dcc2bf3bb7bb9d901f0402ce.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;2.3 举个栗子&lt;/h2&gt;
&lt;p&gt;上面关于JSON讲了这么多，大家都表示一头雾水了吧？&lt;/p&gt;
&lt;p&gt;没关系，我们来举个栗子，让大家有个直观的感受:–)&lt;/p&gt;
&lt;p&gt;以目前视频使用的iQiyi提供的频道接口为例：&lt;/p&gt;
&lt;h5&gt;iQiyi提供的电影频道的JSON电影数据如下：&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;&quot;code&quot;: 1, 
    &quot;data&quot;: 0, 
    &quot;albumIdList&quot;: [
            {
                    &quot;totalidnum&quot;: 2000, 
                    &quot;idlist&quot;: [
                            &quot;319281600&quot;
                    ]
            }
    ], 
    &quot;albumArray&quot;: {
            &quot;319281600&quot;: {
                    &quot;_as&quot;: &quot;&quot;, 
                    &quot;_blk&quot;: 0, 
                    &quot;_cid&quot;: 1, 
                    &quot;_ct&quot;: &quot;2014-10-10 17:55:06&quot;, 
                    &quot;_da&quot;: &quot;&quot;, 
                    &quot;_dl&quot;: 0, 
                    &quot;_dn&quot;: &quot;7296&quot;, 
                    &quot;_id&quot;: 319281600, 
                    &quot;_img&quot;: &quot;http://pic2.qiyipic.com/image/20141016/19/ca/v_108628048_m_601_m1_120_160.jpg&quot;, 
                    &quot;_ip&quot;: 1, 
                    &quot;_ma&quot;: &quot;&quot;, 
                    &quot;_pc&quot;: 2, 
                    &quot;_pid&quot;: 0, 
                    &quot;_reseftv&quot;: 959, 
                    &quot;_t&quot;: &quot;末代独裁&quot;, 
                    &quot;_tvct&quot;: 1, 
                    &quot;_tvs&quot;: 1, 
                    &quot;_vt&quot;: 0, 
                    &quot;a_av&quot;: 1, 
                    &quot;a_pro&quot;: &quot;&quot;, 
                    &quot;bpt&quot;: &quot;0&quot;, 
                    &quot;clm&quot;: &quot;&quot;, 
                    &quot;cn_year&quot;: &quot;0&quot;, 
                    &quot;co_album_id&quot;: &quot;0&quot;, 
                    &quot;ctype&quot;: 0, 
                    &quot;desc&quot;: &quot;&quot;, 
                    &quot;down&quot;: 0, 
                    &quot;down2&quot;: &quot;0&quot;, 
                    &quot;drm&quot;: 0, 
                    &quot;fst_time&quot;: &quot;2014-10-16&quot;, 
                    &quot;h1_img&quot;: &quot;http://pic2.qiyipic.com/image/20141016/19/ca/v_108628048_m_601_m1_180_236.jpg&quot;, 
                    &quot;h2_img&quot;: &quot;http://pic2.qiyipic.com/image/20141016/19/ca/v_108628048_m_601_m1_195_260.jpg&quot;, 
                    &quot;is_h&quot;: 0, 
                    &quot;is_n&quot;: 0, 
                    &quot;is_zb&quot;: 0, 
                    &quot;k_word&quot;: &quot;&quot;, 
                    &quot;language&quot;: 0, 
                    &quot;live_center&quot;: 0, 
                    &quot;live_start_time&quot;: 0, 
                    &quot;live_stop_time&quot;: 0, 
                    &quot;logo&quot;: 1, 
                    &quot;m_av&quot;: 1, 
                    &quot;p_av&quot;: 1, 
                    &quot;p_s&quot;: 0, 
                    &quot;p_s_1&quot;: 0, 
                    &quot;p_s_4&quot;: 0, 
                    &quot;p_s_8&quot;: 0, 
                    &quot;qiyi_pro&quot;: 0, 
                    &quot;qiyi_year&quot;: &quot;0&quot;, 
                    &quot;qt_id&quot;: &quot;1005722&quot;, 
                    &quot;s_TT&quot;: &quot;&quot;, 
                    &quot;songname&quot;: &quot;&quot;, 
                    &quot;t_pc&quot;: 1, 
                    &quot;tag&quot;: &quot;当代 美国 乡村 大片&quot;, 
                    &quot;tv_eftv&quot;: 1, 
                    &quot;tv_pha&quot;: &quot;&quot;, 
                    &quot;tv_pro&quot;: &quot;&quot;, 
                    &quot;tv_ss&quot;: &quot;&quot;, 
                    &quot;tvfcs&quot;: &quot;雄心壮志背后的真相&quot;, 
                    &quot;up&quot;: 0, 
                    &quot;up2&quot;: &quot;0&quot;, 
                    &quot;upcl&quot;: &quot;&quot;, 
                    &quot;v2_img&quot;: &quot;http://pic2.qiyipic.com/image/20141016/19/ca/v_108628048_m_601_m1_284_160.jpg&quot;, 
                    &quot;v3_img&quot;: &quot;http://pic2.qiyipic.com/image/20141016/19/ca/v_108628048_m_601_m1_480_270.jpg&quot;, 
                    &quot;vv&quot;: &quot;1&quot;, 
                    &quot;year&quot;: &quot;2007&quot;, 
                    &quot;tv_id&quot;: &quot;0&quot;, 
                    &quot;vv_p&quot;: 0, 
                    &quot;vv_f&quot;: 2, 
                    &quot;vv_m&quot;: 0, 
                    &quot;_sc&quot;: 8
            }
    }, 
    &quot;changeAlbum&quot;: null, 
    &quot;category&quot;: null, 
    &quot;before&quot;: &quot;2~4~1~7~3&quot;, 
    &quot;latest_push_id&quot;: &quot;655&quot;, 
    &quot;up_tm&quot;: &quot;1413441370874&quot;, 
    &quot;recommend_attach&quot;: &quot;&quot;, 
    &quot;preset_keys&quot;: null, 
    &quot;category_group&quot;: null, 
    &quot;exp_ts&quot;: 120, 
    &quot;stfile_path&quot;: &quot;/data/view/online5/0/1/2.1.8.5.1.txt&quot;
}&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;从上面的例子可以很清晰的看出JSON是如何展示一个电影的数据的，当然这是JSON格式化之后的数据。JSON的元数据是不便于阅读的。&lt;/h6&gt;
&lt;h2&gt;2.4 如何解析JSON？&lt;/h2&gt;
&lt;p&gt;Android JSON所有相关类，都在org.json包下。&lt;/p&gt;
&lt;p&gt;包括JSONObject、JSONArray、JSONStringer、JSONTokener、JSONWriter、JSONException。&lt;/p&gt;
&lt;h3&gt;&amp;lt;1&amp;gt;. 常见方法&lt;/h3&gt;
&lt;p&gt;目前JSON解析有2种方法，分别是get和opt方法，可以使用JSON&lt;/p&gt;
&lt;p&gt;那么使用get方法与使用opt方法的区别是？&lt;/p&gt;
&lt;p&gt;JsonObject方法，opt与get建议使用opt方法，因为&lt;strong&gt;get方法如果其内容为空会直接抛出异常&lt;/strong&gt;。不过JsonArray.opt(index)会有越界问题需要特别注意。&lt;/p&gt;
&lt;p&gt;opt、optBoolean、optDouble、optInt、optLong、optString、optJSONArray、optJSONObject get、getBoolean、getDouble、getInt、getLong、getString、getJSONArray、getJSONObject&lt;/p&gt;
&lt;h3&gt;&amp;lt;2&amp;gt;. Android中如何创建JSON？&lt;/h3&gt;
&lt;p&gt;在Android中应该如何创建JSON呢？&lt;/p&gt;
&lt;p&gt;下面展示了一个如何创建JSON的例子：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;private String createJson() throws JSONException {
    JSONObject jsonObject = new JSONObject();
    jsonObject.put(&quot;intKey&quot;, 123);
    jsonObject.put(&quot;doubleKey&quot;, 10.1);
    jsonObject.put(&quot;longKey&quot;, 666666666);
    jsonObject.put(&quot;stringKey&quot;, &quot;lalala&quot;);
    jsonObject.put(&quot;booleanKey&quot;, true);

    JSONArray jsonArray = new JSONArray();
    jsonArray.put(0, 111);
    jsonArray.put(&quot;second&quot;);
    jsonObject.put(&quot;arrayKey&quot;, jsonArray);

    JSONObject innerJsonObject = new JSONObject();
    innerJsonObject.put(&quot;innerStr&quot;, &quot;inner&quot;);
    jsonObject.put(&quot;innerObjectKey&quot;, innerJsonObject);

    Log.e(&quot;Json&quot;, jsonObject.toString());

    return jsonObject.toString();
}&lt;/pre&gt;
&lt;p&gt;其输出结果如下所示：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;{&quot;intKey&quot;:123, &quot;doubleKey&quot;:10.1, &quot;longKey&quot;:666666666, &quot;stringKey&quot;:&quot;lalala&quot;, &quot;booleanKey&quot;:true, &quot;arrayKey&quot;:[111,&quot;second&quot;], &quot;innerObjectKey&quot;:{&quot;innerStr&quot;:&quot;inner&quot;}}&lt;/pre&gt;
&lt;h3&gt;&amp;lt;3&amp;gt;. 如何解析JSON？&lt;/h3&gt;
&lt;p&gt;下面以视频中解析iQiyi的每个视频album数据为例来说明如何解析JSON：&lt;/p&gt;
&lt;p&gt;第一步，需要从网络服务器上发起请求，获取到JSON数据：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;JsonObjectRequest jsonObjRequest = new JsonObjectRequest(Request.Method.GET, url, null,
        new Response.Listener&amp;lt;JSONObject&amp;gt;() {
            @Override
            public void onResponse(JSONObject response) {
                try {
                    MyLog.d(TAG, &quot;response=&quot; + response);
                    parseiQiyiInterfaceResponse(response);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
                /*
                 * if (error instanceof NetworkError) { } else if (error
                 * instanceof ClientError) { } else if (error instanceof
                 * ServerError) { } else if (error instanceof
                 * AuthFailureError) { } else if (error instanceof
                 * ParseError) { } else if (error instanceof
                 * NoConnectionError) { } else if (error instanceof
                 * TimeoutError) { }
                 */
                MyLog.e(TAG, &quot;onErrorResponse, error=&quot; + error);
            }
        }) {
    @Override
    public Map&amp;lt;String, String&amp;gt; getHeaders() throws AuthFailureError {
        HashMap&amp;lt;String, String&amp;gt; headers = new HashMap&amp;lt;String, String&amp;gt;();
        headers.put(&quot;t&quot;, iQiyiInterface.getEncryptTimestamp());
        headers.put(&quot;sign&quot;, iQiyiInterface.getSign());

        return headers;
    }
};&lt;/pre&gt;
&lt;p&gt;第二步，获取到对应的对应的JSONObject数据：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;public void getJsonObjectString(String url) {
    mQueue = VideoApplication.getInstance().getRequestQueue();

    JsonObjectRequest jsObjRequest = new JsonObjectRequest(Request.Method.GET, url, null,

    new Response.Listener&amp;lt;JSONObject&amp;gt;() {

        @Override
        public void onResponse(JSONObject response) {
            MyLog.e(TAG, &quot;response = &quot; + response.toString());

            JSONArray jsonArray = null;
            JSONObject jsonObject = null;
            try {
                jsonObject = response.getJSONObject(&quot;response&quot;);
                jsonArray = jsonObject.getJSONObject(&quot;result&quot;).getJSONArray(&quot;album&quot;);
            } catch (JSONException e) {
                e.printStackTrace();
            }

            if (jsonArray == null) {
                return;
            }

            mChannelList = VideoUtils.parseVideoJsonArray(jsonArray);

            if (isLoading) {
                isLoading = false;
                if (mIsGrid) {
                    mChannelGridAdapter.appendChannelVideoInfo(mChannelList);
                } else {
                    mChannelListAdapter.appendChannelVideoInfo(mChannelList);
                }

            } else {
                if (mIsGrid) {
                    mChannelGridAdapter.setChannelVideoInfo(mChannelList);
                    showOppoGrid();
                } else {
                    mChannelListAdapter.setChannelVideoInfo(mChannelList);
                    showOppoList();
                }
            }
        }
    }, new Response.ErrorListener() {

        @Override
        public void onErrorResponse(VolleyError error) {
            MyLog.e(TAG, &quot;error = &quot; + error);
        }
    });

    jsObjRequest.setTag(TAG);
    jsObjRequest.setShouldCache(true);
    mQueue.add(jsObjRequest);
    mQueue.start();
}&lt;/pre&gt;
&lt;p&gt;获取到JSON Object之后，就对这个JSONObject进行解析：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;private ArrayList&amp;lt;VideoConstant&amp;gt; parseVideoAlbumJsonObject(JSONObject albumJSONObject,  ArrayList&amp;lt;Integer&amp;gt; albumIdJSONArrayList) {
    MyLog.d(TAG, &quot;parseVideoAlbumJsonObject, length=&quot; + albumJSONObject.length());
    if (albumJSONObject.length() &amp;lt; 1) {
        return null;
    }

    ArrayList&amp;lt;VideoConstant&amp;gt; videos = new ArrayList&amp;lt;VideoConstant&amp;gt;();

    try {
        for (int index = 0; index &amp;lt; albumJSONObject.length(); index++) {
            VideoConstant video = new VideoConstant();

            JSONObject itemJsonObject;

            itemJsonObject = albumJSONObject.getJSONObject(albumIdJSONArrayList.get(index)
                    .toString());

            MyLog.d(TAG, &quot;string=&quot; + albumIdJSONArrayList.get(index).toString());

            video.mAlbumId = itemJsonObject.optString(InterfaceParameterName.ID);
            video.mAtitle = itemJsonObject.optString(InterfaceParameterName.TITLE);
            video.mEpisodeCount = itemJsonObject.optString(InterfaceParameterName.UPDATE_SET);
            video.mTvSets = itemJsonObject.optString(InterfaceParameterName.TV_SETS);
            video.mDesc = itemJsonObject.optString(InterfaceParameterName.DESCRIPTION);
            video.mCid = itemJsonObject.optString(InterfaceParameterName.CATEGORY_ID);

            video.mImg = itemJsonObject.optString(InterfaceParameterName.IMG);
            video.mHighimg = itemJsonObject
                    .optString(InterfaceParameterName.HIGH_RESO_PORT_IMG);
            video.mHoriImg = itemJsonObject
                    .optString(InterfaceParameterName.HIGH_RESO_HORI_IMG);

            video.mScore = itemJsonObject.optString(InterfaceParameterName.SCORE);
            video.mMainActors = itemJsonObject.optString(InterfaceParameterName.MAIN_ACTOR);

            video.mCreateTime = itemJsonObject.optString(InterfaceParameterName.CREATE_TIME);

            video.mDuration = itemJsonObject.optString(InterfaceParameterName.DURATION);

            video.mTag = itemJsonObject.optString(InterfaceParameterName.TAG);

            MyLog.d(TAG, &quot;id=&quot; + video.mAlbumId + &quot;,title=&quot; + video.mAlbumTitle + &quot;,img=&quot;
                    + video.mHighimg + &quot;,tvsets=&quot; + video.mTvSets);

            videos.add(video);
        }
    } catch (JSONException e) {
        e.printStackTrace();
    }

    return videos;
}&lt;/pre&gt;
&lt;h3&gt;&amp;lt;4&amp;gt;. Android JSON解析库&lt;/h3&gt;
&lt;p&gt;上面介绍都是使用Android提供的原生类解析JSON，最大的好处是项目不需要引入第三方库，但是如果比较注重开发效率而且不在意应用大小增加几百K的话，有以下JSON可供选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://jackson.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Jackson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://code.google.com/p/google-gson/&quot; target=&quot;_blank&quot;&gt;google-gson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sourceforge.net/projects/json-lib/&quot; target=&quot;_blank&quot;&gt;Json-lib&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大家可以去对应的官网下载并学习:)&lt;/p&gt;
&lt;h1&gt;三、 JSON vs. XML&lt;/h1&gt;
&lt;p&gt;JSON和XML就像武林界的屠龙刀和倚天剑，那么他们孰强孰弱？&lt;/p&gt;
&lt;p&gt;XML长期执数据传输界之牛耳，而JSON作为后起之秀，已经盟主发起了挑战。&lt;/p&gt;
&lt;p&gt;那就让他们来进行PK一下：&lt;/p&gt;
&lt;h3&gt;&amp;lt;1&amp;gt;. JSON相比XML的不同之处&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;没有结束标签&lt;/li&gt;
&lt;li&gt;更短&lt;/li&gt;
&lt;li&gt;读写的速度更快&lt;/li&gt;
&lt;li&gt;能够使用内建的 JavaScript eval() 方法进行解析&lt;/li&gt;
&lt;li&gt;使用数组&lt;/li&gt;
&lt;li&gt;不使用保留字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之： JSON 比 XML 更小、更快，更易解析。&lt;/p&gt;
&lt;h3&gt;&amp;lt;2&amp;gt;. XML和JSON的区别：&lt;/h3&gt;
&lt;p&gt;XML的主要组成成分：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;XML是element、attribute和element content。&lt;/pre&gt;
&lt;p&gt;JSON的主要组成成分：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;JSON是object、array、string、number、boolean(true/false)和null。&lt;/pre&gt;
&lt;p&gt;XML要表示一个object(指name-value pair的集合)，最初可能会使用element作为object，每个key-value pair 用 attribute 表示：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;&amp;lt;student name=&quot;John&quot; age=&quot;10&quot;/&amp;gt;&lt;/pre&gt;
&lt;p&gt;但如个某个 value 也是 object，那么就不可以当作attribute:&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;&amp;lt;student name=&quot;John&quot; age=&quot;10&quot;&amp;gt;
    &amp;lt;address&amp;gt;
        &amp;lt;country&amp;gt;China&amp;lt;/country&amp;gt;
        &amp;lt;province&amp;gt;Guang Dong&amp;lt;/province&amp;gt;
        &amp;lt;city&amp;gt;...&amp;lt;/city&amp;gt;
        &amp;lt;district&amp;gt;...&amp;lt;/district&amp;gt;
        ...
    &amp;lt;/address&amp;gt;
&amp;lt;/student&amp;gt;&lt;/pre&gt;
&lt;p&gt;那么，什么时候用element，什么时候用attribute，就已经是一个问题了。&lt;/p&gt;
&lt;p&gt;而JSON因为有object这种类型，可以自然地映射，不需考虑上述的问题，自然地得到以下的格式。&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;{
    &quot;name&quot;: &quot;John&quot;,
    &quot;age&quot; : 10,
    &quot;address&quot; : {
        &quot;country&quot; : &quot;China&quot;,
        &quot;province&quot; : &quot;Guang Dong&quot;,
        &quot;city&quot; : &quot;..&quot;,
        &quot;district&quot; : &quot;..&quot;,
        ...
    }
}&lt;/pre&gt;
&lt;h5&gt;One More Thing…&lt;/h5&gt;
&lt;p&gt;XML需要选择怎么处理element content的换行，而JSON string则不须作这个选择。&lt;/p&gt;
&lt;p&gt;XML只有文字，没有预设的数字格式，而JSON则有明确的number格式，这样在locale上也安全。&lt;/p&gt;
&lt;p&gt;XML映射数组没大问题，就是数组元素tag比较重复冗余。JSON 比较易读。&lt;/p&gt;
&lt;p&gt;JSON的true/false/null也能容易统一至一般编程语言的对应语义。&lt;/p&gt;
&lt;p&gt;XML文档可以附上DTD、Schema，还有一堆的诸如XPath之类规范，使用自定义XML元素或属性，能很方便地给数据附加各种约束条件和关联额外信息，从数据表达能力上看，XML强于Json，但是很多场景并不需要这么复杂的重量级的东西，轻便灵活的Json就显得很受欢迎了。&lt;/p&gt;
&lt;p&gt;打个比方，如果完成某件事有两种方式：一种简单的，一个复杂的。你选哪个？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我只想杀只鸡罢了，用得着牛刀？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JSON与XML相比就是这样的。&lt;/p&gt;
&lt;h1&gt;四、总结&lt;/h1&gt;
&lt;p&gt;这篇文章只是对XML和JSON这2种目前主流使用的数据格式进行了解释，并系统的学习了其中的语法及如何进行解析，同时在最好针对XML和JSON做了对比，了解其不同点和各自的优势。&lt;/p&gt;
&lt;p&gt;期望有需要的朋友有所帮助:–)&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79252-ea7eb2e7a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79252-ea7eb2e7a.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>编写最简单的内核：HelloWorld</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;内核是操作系统最核心的内容，主要提供硬件抽象层、磁盘及文件系统控制、多任务等功能，由于其涉及非常广泛的计算机知识，很少被人们所熟悉，因而披上了一层神秘的面纱。&lt;/p&gt;
&lt;p&gt;本文将从零开始实现一个最简单的内核，其可以通过x86系统的GRUB引导启动，并向屏幕输出“Hello World!“字符串。该内核代码非常简短，并且在本人的Debian 7系统中可以正常运行。&lt;/p&gt;
&lt;h2&gt;x86机器启动过程&lt;/h2&gt;
&lt;p&gt;在具体实现这个内核之前，我们先看看机器具体是怎么启动并且把控制权交给内核的。&lt;/p&gt;
&lt;p&gt;x86的CPU固定地在物理地址为[0xFFFFFFF0]的地方开始运行，这是32位地址空间的最后16个字节。这里只包含了一个跳转指令，跳转到BIOS把它自己拷贝到的内存区域的地址。&lt;/p&gt;
&lt;p&gt;然后，BIOS开始执行。它首先根据配置的设备启动顺序依次寻找可启动的设备（根据一个特定的魔数可以决定一个设备是否启动）。一旦找到一个可启动的设备，它就把该设备第一个扇区的内容复制到RAM中物理地址从[0x7C00]开始的地方，然后跳转到该地址并且开始执行那里加载的代码。这段代码称为启动引导装载程序(bootloader)。Bootloader然后在物理地址为[0x100000]的地方加载内核，地址[0x100000]就是x86机器上内核的起始地址。&lt;/p&gt;
&lt;h2&gt;需要的工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一台x86电脑&lt;/li&gt;
&lt;li&gt;Linux&lt;/li&gt;
&lt;li&gt;NASM汇编器&lt;/li&gt;
&lt;li&gt;gcc&lt;/li&gt;
&lt;li&gt;ld（GNU链接器）&lt;/li&gt;
&lt;li&gt;grub&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;汇编入口点&lt;/h2&gt;
&lt;p&gt;我们希望用C来写所有的代码，但免不了要写一点汇编代码。我们会写一个x86汇编语言的小文件来作为内核的起始点，这段汇编所做的事情就是调用一个我们用C写的外部函数，然后停止程序运行。&lt;/p&gt;
&lt;p&gt;怎么确定这段汇编代码会作为内核的起始点呢？&lt;br&gt;
我们会使用一个链接脚本来链接所有的目标文件来产生一个最终的内核可执行映像。在这个链接脚本中，我们会显式指明二进制文件要加载在地址为[0x100000]的地方，这就是内核所在的地方。于是，bootloader会负责触发这个内核的入口点。&lt;/p&gt;
&lt;p&gt;以下是汇编代码：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;;;kernel.asm，内核汇编代码
bits 32         ;nasm伪指令
section .text   ;代码段

global start    ;全局变量
extern kmain    ;kmain定义在C文件中

start:
    cli         ;禁止中断
    call kmain  ;调用kmain函数
    hlt         ;终止CPU运行&lt;/pre&gt;
&lt;p&gt;第一条指令中的bit 32不是x86汇编指令，而是NASM汇编器的伪指令，表明将会产生一段运行在32位处理器上代码。这句代码不是必须的，但显示加上会是一个好的编程实践。&lt;/p&gt;
&lt;p&gt;第二行开始就是代码段，即放置代码的地方。&lt;br&gt;
global也是NASM的伪指令，表示把源代码中的一个符号设置成全局符号。于是链接器知道start符号在哪里，其实这就是我们的入口点。&lt;br&gt;
kmain是将会在kernel.c中实现的一个函数，extern表明这个函数会在其他地方定义。&lt;/p&gt;
&lt;p&gt;于是，我们有了start函数，它会调用kmain函数，然后通过hlt指令停止CPU。由于中断会从hlt指令中唤醒CPU，所以我们事先使用cli（意为clear interrupts）指令禁止中断。&lt;/p&gt;
&lt;h2&gt;C语言内核&lt;/h2&gt;
&lt;p&gt;我们在kernel.asm中调用kmain()函数，所以C代码会从kmain()开始执行。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;//kernel.c文件
void kmain(void)
{
	char *str = &quot;Hello World！&quot;;
	char *vidptr = (char*)0xb8000; //显存开始地址
	unsigned int i = 0;
	unsigned int j = 0;
	//清空屏幕，共25行，每行80个字符，每个字符2字节
	while(j &amp;lt; 80 * 25 * 2) {
		//空白字符
		vidptr[j] = &#39; &#39;;
		//属性字节：黑色背景，灰色前景
		vidptr[j+1] = 0x07; 		
		j = j + 2;
	}
	j = 0;
	while(str[j] != &#39;&#39;) {
		vidptr[i] = str[j];
		vidptr[i+1] = 0x07;
		++j;
		i = i + 2;
	}
	return;
}&lt;/pre&gt;
&lt;p&gt;这里内核所做的事情就是：清空屏幕，打印字符串“Hello World!”。&lt;/p&gt;
&lt;p&gt;首先是指针vidptr指向地址[0xb8000]，这是保护模式下显存的开始地址。屏幕的文本内存只是地址空间的一连串内存区域，它从[0xb8000]开始映射屏幕的输入输出，支持25行，每行80个ASCII字符，每个字符用16位（2字节）表示，而不是我们熟悉的8位（1字节）。2字节中第1个字节是该字符的ASCII表示，第2个字节是属性字节，描述字符的包括颜色在内的属性。如果要让背景为黑色而字体为绿色，可以在第1个字节保存字符的ASCII值，在第2个字节保存值[0x02]：0代表黑色背景，2代表绿色前景。&lt;/p&gt;
&lt;p&gt;其它颜色属性定义如下：&lt;/p&gt;
&lt;table width=&quot;350&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Black&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Blue&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Green&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Cyan&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Red&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Magenta&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Brown&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Light Grey&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;9&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;10&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;11&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;12&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;13&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;14&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Dark Grey&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Light Blue&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Light Green&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Light Cyan&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Light Red&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Light Magenta&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;Light Brown&lt;/td&gt;
&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;White&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们的内核使用了黑色背景以及灰色字体，所以属性字节为[0x07]。&lt;/p&gt;
&lt;p&gt;在第一个while循环中，程序在所有的25行80列中写入空字符和[0x07]属性，从而清空了屏幕。&lt;br&gt;
在第二个while循环中，字符串”Hello World!“被写到了显存的开始区域，每个字符仍是拥有[0x07]属性。这就在屏幕上打印了该字符串。&lt;/p&gt;
&lt;h2&gt;链接部分&lt;/h2&gt;
&lt;p&gt;使用NASM把kernel.asm编译成目标文件，再使用GCC把kernel.c编译成另一个目标文件，然后需要把这两个目标文件链接成一个可以启动的内核映像。&lt;br&gt;
我们使用链接脚本来达到这个目的，链接脚本可以作为参数传递进链接器ld中以控制链接的过程。&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;//link.ld文件
OUTPUT_FORMAT(elf32-i386)
ENTRY(start)
SECTIONS
{
    . = 0x100000;
    .text : { *(.text) }
    .data : { *(.data) }
    .bss  : { *(.bss)  }
}&lt;/pre&gt;
&lt;p&gt;OUTPUT_FORMAT设置输出的可执行文件为32位的ELF文件，ELF是x86架构上类Unix系统的标准二进制文件格式。&lt;/p&gt;
&lt;p&gt;ENTRY接受一个参数，指定其为最终可执行文件的入口点。&lt;/p&gt;
&lt;p&gt;SECTION是这里最关键的部分，它指定不同的段怎么合并以及放在什么地方，从而定义最终可执行文件的布局。&lt;br&gt;
大括号内就是SECTION的语句，句点(.)为位置计数器，一般被初始化为SECTIONS块开始的地方[0x0]，但可以任意修改。因为内核代码需要在地址[0x100000]处开始，所以设置位置计数器为[0x100000]。&lt;br&gt;
第二行中的星号是通配符，可以匹配任何文件名，*(.text)即表示匹配所有输入文件的代码段。于是，链接器合并所有目标文件的代码段到可执行文件的代码段中，具体地址由位置计数器决定，这里即为[0x100000]。链接器产生代码段后，位置计数器会变成：0×100000 + 输出代码段的大小。&lt;br&gt;
同样地，数据段和bss段会被合并，并放置在位置计数器指定的地方。&lt;/p&gt;
&lt;h2&gt;Grub和多重引导&lt;/h2&gt;
&lt;p&gt;现在已经准备好了构建内核的所有文件了，但要用GRUB进行引导还需要最后一个步骤。&lt;/p&gt;
&lt;p&gt;多重引导规范(Multiboot specification)是一个使用bootloader加载不同X86内核的标准，GRUB只会加载满足这个规范的内核。根据这个规范，内核必须在它的前8KB字节中包含头信息（Multiboot header）。这个头信息包含4字节对齐的3个域，分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;魔数域：包含魔数[0x1BADB002]。&lt;/li&gt;
&lt;li&gt;标志域：这里不关心这个域，置为0。&lt;/li&gt;
&lt;li&gt;校验和域：检验和域和前面两个域相加之后的结果必须为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是kernel.asm应该修改为，代码中的dd表示定义一个4字节的双字：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;;;kernel.asm，内核汇编代码

bits 32         ;nasm伪指令
section .text   ;代码段
        ;多重引导规范
        align 4
        dd 0x1BADB002            ;魔数
        dd 0x00                  ;标志
        dd - (0x1BADB002 + 0x00) ;校验和

global start    ;全局变量
extern kmain    ;kmain定义在C文件中

start:
    cli         ;禁止中断
    call kmain  ;调用kmain函数
    hlt         ;终止CPU运行&lt;/pre&gt;
&lt;h2&gt;构建内核&lt;/h2&gt;
&lt;p&gt;现在可以从kernel.asm和kernel.c生成目标文件，然后使用连接脚本进行链接。&lt;/p&gt;
&lt;p&gt;使用汇编器nasm产生ELF-32格式的目标文件kasm.o：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;nasm -f elf32 kernel.asm -o kasm.o&lt;/pre&gt;
&lt;p&gt;使用编译器gcc产生目标文件kc.o，”-c”参数保证只编译，不进行链接：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;gcc -m32 -c kernel.c -o kc.o&lt;/pre&gt;
&lt;p&gt;使用链接器ld根据链接控制脚本产生可执行映像文件kernel：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;ld -m elf_i386 -T link.ld -o kernel kasm.o kc.o&lt;/pre&gt;
&lt;h2&gt;配置GRUB并运行内核&lt;/h2&gt;
&lt;p&gt;GRUB需要内核以kernel-&amp;lt;version&amp;gt;形式命名，于是把内核kernel重命名为kernel-701，并利用超级管理员权限放到/boot目录下。&lt;/p&gt;
&lt;p&gt;对于bootloader为GRUB的发行版，修改配置文件/boot/grub/grub.cfg，添加以下条目：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;title myKernel
	root (hd0,0)
	kernel /boot/kernel-701 ro&lt;/pre&gt;
&lt;p&gt;对于bootloader为GRUB2的发行版，添加的配置应该为：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;menuentry &#39;kernel 701&#39; {
	set root=&#39;hd0,msdos1&#39;
	multiboot /boot/kernel-701 ro
}&lt;/pre&gt;
&lt;p&gt;重启电脑，选择GRUB列表中新增加的kernel-701内核选项，这时可以看到屏幕上显示”Hello World!“。&lt;br&gt;
这就是你的内核！&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79249-b3546a20d.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79249-b3546a20d.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Catching Your CPUs Napping</title>
        <description>

&lt;p&gt;When you see high CPU usage, you may be forgiven for believing that your CPUs must be furiously executing software, like obedient robots that never rest. In reality, you don&#39;t know what&#39;s happening from the CPU utilization alone. Your CPUs might be napping, during an instruction, while they wait for some resource.&lt;/p&gt;

&lt;p&gt;Understanding what the CPUs are really doing helps direct performance tuning. The simplest way is to measure the average cycles-per-instruction (CPI) ratio: higher values mean it takes more cycles to complete instructions (often &quot;stalled cycles&quot; waiting on memory I/O). This is usually studied as a system-wide metric.&lt;/p&gt;

&lt;p&gt;The following new visualization takes a &lt;a href=&quot;/FlameGraphs/cpuflamegraphs.html&quot;&gt;CPU flame graph&lt;/a&gt; and then assigns colors relative to CPI:&lt;/p&gt;

&lt;p&gt;&lt;object data=&quot;/images/brendangregg.com/d037142ed9a1f3c9ad42491b303e4962.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;720&quot; height=&quot;475&quot;&gt;
&lt;img src=&quot;/images/brendangregg.com/d037142ed9a1f3c9ad42491b303e4962.jpg&quot; width=&quot;720&quot;&gt;
&lt;/object&gt;&lt;/p&gt;

&lt;p&gt;Wow! For the first time I can &lt;em&gt;see&lt;/em&gt; where the stall cycles are, providing a clear visualization of CPU efficiency by function.&lt;/p&gt;

&lt;p&gt;The width of each frame shows the time a function (or its children) was on-CPU, as with a normal CPU flame graph. The color now shows what that function was doing when it was on-CPU: running or stalled.&lt;/p&gt;

&lt;p&gt;The color range in this example has been scaled to color the highest CPI blue (slowest instructions), and lowest CPI red (fastest instructions). Flame graphs also now do click to zoom (thanks Adrien Mahieux), as well as mouse-overs. (Direct &lt;a href=&quot;/blog/images/2014/cpi-freebsd-kernel.svg&quot;&gt;SVG&lt;/a&gt; link.)&lt;/p&gt;

&lt;p&gt;This example is showing a FreeBSD kernel. The vm_* (virtual memory) functions have the slowest instructions, which is expected as they involve memory I/O to walk page tables, which may not cache as well as other workloads. The fastest instructions were in __mtx_lock_sleep, which is also expected as it is a spin loop.&lt;/p&gt;

&lt;p&gt;The most color saturated frames on the left (vm_page_alloc-&amp;gt;__mtx_lock_sleep) are being worked on by a fellow engineer in our OCA development team. Had that not already been the case, this CPI flame graph should have prompted their study and development.&lt;/p&gt;

&lt;p&gt;There are two parts that make this possible: differential flame graphs, and measuring stacks on instructions and stall cycles. I&#39;ll briefly summarize these, with the latter using pmcstat(8) on FreeBSD (this approach is also possible on Linux, provided you have PMC access, which my current cloud instances don&#39;t!).&lt;/p&gt;

&lt;h2&gt;Differential Flame Graphs&lt;/h2&gt;

&lt;p&gt;This is a new feature which I&#39;ll explain in a separate post (I also want to add some more options first). In summary, flamegraph.pl usually takes input like the following:&lt;/p&gt;

&lt;pre&gt;
func_a;func_b;func_c 31
...
&lt;/pre&gt;

&lt;p&gt;These are single line entries with a semi-colon delimited stack followed by a sample count.&lt;/p&gt;

&lt;p&gt;A differential flame graph will be generated if you provide the following input:&lt;/p&gt;

&lt;pre&gt;
func_a;func_b;func_c 31 35
...
&lt;/pre&gt;

&lt;p&gt;This now has two value columns, which are intended to show before and after counts. The flame graph is sized using the second column (the &quot;after&quot;, or &quot;now&quot;), and then colored using the delta of 2 - 1: positive is red, negative is blue. The difffolded.pl tool takes two folded-style profiles (generated using the stackcollapse scripts) and emits this two-column output.&lt;/p&gt;

&lt;p&gt;For CPI flame graphs, the two value columns are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stall cycle count&lt;/li&gt;
&lt;li&gt;unhalted cycle count&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first is scaled so that its average is the same as the second column, and the full blue-red range is used. Otherwise, there&#39;s always more unhalted cycles, and the differential flame graph is just red.&lt;/p&gt;

&lt;h2&gt;FreeBSD pmcstat&lt;/h2&gt;

&lt;p&gt;The data in this example was collected using FreeBSD&#39;s &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=pmcstat&quot;&gt;pmcstat(8)&lt;/a&gt; using the following (on Intel):&lt;/p&gt;

&lt;pre&gt;
# &lt;b&gt;pmcstat -n 1000000 -S RESOURCE_STALLS.ANY -S CPU_CLK_UNHALTED.THREAD_P -O out.pmclog_cpi01 sleep 10&lt;/b&gt;
# &lt;b&gt;pmcstat -R out.pmclog_cpi01 -z 32 -G out.pmcstat_cpi01&lt;/b&gt;
CONVERSION STATISTICS:
 #exec/elf                                12
 #samples/total                           123464
 #samples/unknown-function                2059
 #callchain/dubious-frames                4723
# &lt;b&gt;ls -lh *cpi01&lt;/b&gt;
-rw-r--r--  1 root  wheel    14M Oct 29 04:24 out.pmclog_cpi01
-rw-r--r--  1 root  wheel   7.2M Oct 29 04:24 out.pmcstat_cpi01
&lt;/pre&gt;

&lt;p&gt;Be careful with pmcstat(8): you can generate a lot of output quickly, which in turn can perturb the performance of what you are measuring. I only measured for 10 seconds (sleep 10), and only one event every million (-n 1000000). Despite this, the raw output file is 14 Mbytes.&lt;/p&gt;

&lt;p&gt;In this example I measured kernel stacks (-S), and up to 32 frames deep. Note that I did need to set kern.hwpmc.callchaindepth=32 in /boot/loader.conf and reboot, as my stacks were at first always being truncated to 8 frames.&lt;/p&gt;

&lt;p&gt;pmstat -G was used to create a callchain text file. It looks like this:&lt;/p&gt;

&lt;pre&gt;
# &lt;b&gt;more out.pmcstat_cpi01&lt;/b&gt;
@ CPU_CLK_UNHALTED.THREAD_P [10867 samples]

07.86%  [854]      __mtx_lock_sleep @ /boot/kernel/kernel
 48.95%  [418]       vm_page_alloc
  99.76%  [417]        vm_page_grab
   99.04%  [413]         allocbuf
    100.0%  [413]          getblk
     95.16%  [393]           cluster_rbuild
      100.0%  [393]            cluster_read
       100.0%  [393]             ffs_read
        100.0%  [393]              VOP_READ_APV
         100.0%  [393]               vn_read
          100.0%  [393]                vn_io_fault
           100.0%  [393]                 aio_daemon
            100.0%  [393]                  fork_exit
     04.84%  [20]            cluster_read
      100.0%  [20]             ffs_read
[...]
@ CPU_CLK_UNHALTED.THREAD_P [10856 samples]
[...]
@ RESOURCE_STALLS.ANY [3462 samples]

06.15%  [213]      sf_buf_mext @ /boot/kernel/kernel
 100.0%  [213]       mb_free_ext
  100.0%  [213]        m_freem
   54.46%  [116]         reclaim_tx_descs
    100.0%  [116]          t4_eth_tx
[...]
&lt;/pre&gt;

&lt;p&gt;For each counter, and then each CPU, the samples are printed as call chains. &lt;/p&gt;

&lt;h2&gt;CPI Flame Graph&lt;/h2&gt;

&lt;p&gt;To make a CPI flame graph from this call chain output, I needed to separate out the counters into separate files. I did this in about 60 seconds using vi, creating:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;out.pmcstat_cycles: all the sections titled CPU_CLK_UNHALTED.THREAD_P&lt;/li&gt;
&lt;li&gt;out.pmcstat_stalls: all the sections titled RESOURCE_STALLS.ANY&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Yes, I should just write some Perl/awk to do this. I will next time.&lt;/p&gt;

&lt;p&gt;I then converted these to the folded format, using stackcollapse-pmc.pl (by Ed Maste):&lt;/p&gt;

&lt;pre&gt;
$ &lt;b&gt;cat out.pmcstat_cycles | ./stackcollapse-pmc.pl &amp;gt; out.pmcstat_cycles.folded&lt;/b&gt;
$ &lt;b&gt;cat out.pmcstat_stalls | ./stackcollapse-pmc.pl &amp;gt; out.pmcstat_stalls.folded&lt;/b&gt;
&lt;/pre&gt;

&lt;p&gt;Finally, making the CPI flame graph:&lt;/p&gt;

&lt;pre&gt;
$ &lt;b&gt;./difffolded.pl -n out.pmcstat_stall.folded out.pmcstat_cycles.folded | \
    ./flamegraph.pl --title &quot;CPI Flame Graph: blue=stalls, red=instructions&quot; --width=900 &amp;gt; cpi.svg&lt;/b&gt;
&lt;/pre&gt;

&lt;p&gt;That&#39;s the &lt;a href=&quot;/blog/images/2014/cpi-freebsd-kernel.svg&quot;&gt;SVG&lt;/a&gt; at the top of this page.&lt;/p&gt;

&lt;p&gt;All the flame graph software (flamegraph.pl, stackcollapse-pmc.pl, difffolded.pl) can be found in the &lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;Flame Graph&lt;/a&gt; collection on github.&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;There is much you can do as either a software developer or system administrator once you know that CPU is either memory-bound or instruction-bound, resulting in small to large performance improvements. CPU flame graphs are already a great way to visualize how your software is using the CPUs. CPI flame graphs use color to show what the CPUs are really doing: their efficiency by function.&lt;/p&gt;

&lt;p&gt;PS. This weekend I&#39;m speaking at &lt;a href=&quot;https://www.meetbsd.com/&quot;&gt;MeetBSD&lt;/a&gt; on performance analysis. I will be sure to mention pmcstat(8), which can do a lot more than just stalls and cycles.&lt;/p&gt;


</description>
        <pubDate>Fri, 31 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-10-31-cpi-flame-graphs.html-4930d6376.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-10-31-cpi-flame-graphs.html-4930d6376.html</guid>
        
        
        <category>brendangregg</category>
        
      </item>
    
      <item>
        <title>用 perl6-bench 做 perl6 性能对比</title>
        <description>

  
  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;Perl6 成员上周在奥地利大会上做了一次大聚集，写了不少博客讲过去几个月的优化以及未来几个月的优化。但是我发现似乎从8月以来就一直没有正式的 perl6-bench 的图表报告了。于是想：干脆自己跑一把吧。&lt;/p&gt;
&lt;p&gt;perl6-bench 项目地址见：&lt;a href=&quot;https://github.com/japhb/perl6-bench&quot;&gt;https://github.com/japhb/perl6-bench&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;项目的主程序 &lt;code&gt;bench&lt;/code&gt; 本身是用 Perl6 写的。所以运行前，得先安装好 Rakudo Star：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget http://rakudo.org/downloads/star/rakudo-star-2014.09.tar.gz
tar zxvf rakudo-star-2014.09.tar.gz
cd rakudo-star-2014.09
perl Configure.pl --backend=moar --gen-moar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译完成后，会在 rakudo-star 目录下创建一个 &lt;code&gt;install&lt;/code&gt; 子目录，里面有 &lt;code&gt;bin&lt;/code&gt;，&lt;code&gt;lib&lt;/code&gt; 等编译完成的文件，把这个 bin 加入到你的 $PATH 里去。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed -i &#39;s!\(PATH=.*\)$!\1:~/download/rakudo-star-2014.09/install/bin!&#39; ~/.bash_profile
source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;项目的测试程序 &lt;code&gt;timeall&lt;/code&gt; 是用 Perl5 写的。运行前，也得安装几个 CPAN 模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cpanm Capture::Tiny Data::Alias DateTime JSON JSON::XS List::MoreUtils
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就可以开始测试了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./bench setup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会在 &lt;code&gt;components&lt;/code&gt; 子目录下逐一 clone 下来各种可以测试的 perl6 实现的源代码 git 库，包括有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arane   niecza  nqp-jvm   nqp-parrot  perl5    rakudo-jvm   rakudo-parrot
moarvm  nqp-js  nqp-moar  parrot      perlito  rakudo-moar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面就开始正式测试了。用时同样会比较长，和上面 git clone 一样，都建议放在 screen 里运行。&lt;/p&gt;
&lt;p&gt;然后设定本次测试你打算对比哪些：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export CHECKOUTS=&#39;perl5/v5.20.1 rakudo-jvm/2014.10 rakudo-moar/2014.10 rakudo-moar/2014.09&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个写法规范是：git 库名/git tag名&lt;/p&gt;
&lt;p&gt;然后运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./bench extract $CHECKOUTS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一步会分别 checkout 具体的 tag 到同级的新目录里，然后开始编译：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./bench build   $CHECKOUTS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后运行测试程序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./bench time    $CHECKOUTS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一共有 65 个测试，测试项在 &lt;code&gt;microbenchworks.pl&lt;/code&gt; 文件的大数组里定义了。
我在测试中发现，第 15/65 测试用例，在 &lt;code&gt;nqp-moar&lt;/code&gt; 时会死循环运行，无法正常完成测试，已回报给作者。&lt;/p&gt;
&lt;p&gt;最后运行结果对比评分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./bench compare $CHECKOUTS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果显示，moar 比 jvm 领先一些，比 perl5 还差着呢：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;==&amp;gt; perl6-bench version 997c920 (ignoring startup time and compile time)
--- showing PEAK RATE (/s), TIMES SLOWER THAN FASTEST (x), and SUMMARY SCORES (skipping incomplete data)
                                - Perl 5 -   -------------- Perl 6 --------------
                                 v5.20.1      2014.10      2014.09      2014.10  
                                   perl5       rakudo       rakudo       rakudo  
TEST                               perl5          jvm       moarvm       moarvm  
                                -------------------------------------------------
empty                                --             0/s          4/s          4/s
                                    FAIL         34.0x         1.0x         1.1x 
zero                                 --             0/s          4/s          4/s
                                    FAIL         33.3x         1.0x         1.1x 
hello                                --             0/s          4/s          4/s
                                    FAIL         33.2x         1.0x         1.1x 
while_empty                     26678545/s     223006/s    1730328/s    3403743/s
                                     1.0x       119.6x        15.4x         7.8x 
while_empty_native              26800035/s   1291144447/s   27583644/s   168949423/s
                                    48.2x         1.0x        46.8x         7.6x 
while_bind                           --        249216/s    1682441/s    3381083/s
                                    FAIL         13.6x         2.0x         1.0x 
while_concat                    13404147/s      26589/s     166714/s     206047/s
                                     1.0x       504.1x        80.4x        65.1x 
while_concat_native             13400671/s      65891/s    4138382/s    5216637/s
                                     1.0x       203.4x         3.2x         2.6x 
while_int2str                    6026835/s      57112/s     364208/s     455797/s
                                     1.0x       105.5x        16.5x        13.2x 
while_int2str_native             6283498/s     111754/s     543142/s     671402/s
                                     1.0x        56.2x        11.6x         9.4x 
while_int2str_concat             8711901/s       7006/s      89566/s      93480/s
                                     1.0x      1243.5x        97.3x        93.2x 
while_int2str_concat_native      8403097/s      13824/s     153347/s     167585/s
                                     1.0x       607.9x        54.8x        50.1x 
while_push_join                  3656434/s      15223/s      18917/s     111952/s
                                     1.0x       240.2x       193.3x        32.7x 
while_push                       7821809/s      90685/s      21289/s     239678/s
                                     1.0x        86.3x       367.4x        32.6x 
while_pushme                    14440088/s    3184098/s    1225845/s    1560029/s
                                     1.0x         4.5x        11.8x         9.3x 
while_array_set                  6171761/s     112655/s     276032/s     335751/s
                                     1.0x        54.8x        22.4x        18.4x 
while_hash_set                   1525235/s      58647/s     158810/s     171691/s
                                     1.0x        26.0x         9.6x         8.9x 
postwhile_nil                   36412794/s     515093/s    2939870/s    4147168/s
                                     1.0x        70.7x        12.4x         8.8x 
postwhile_nil_native            36083908/s   1676476937/s   34716639/s   167547820/s
                                    46.5x         1.0x        48.3x        10.0x 
loop_empty                      24051967/s     257307/s    1686547/s    3321511/s
                                     1.0x        93.5x        14.3x         7.2x 
loop_empty_native               24181034/s   2276716196/s   28050857/s   193967640/s
                                    94.2x         1.0x        81.2x        11.7x 
for_empty                       33943008/s     894886/s    2315939/s    2515590/s
                                     1.0x        37.9x        14.7x        13.5x 
for_bind                             --       1571035/s    2331450/s    2586230/s
                                    FAIL          1.6x         1.1x         1.0x 
for_assign                      17713024/s    1532922/s    2006784/s    2391570/s
                                     1.0x        11.6x         8.8x         7.4x 
for_assign_native               17765094/s    1658168/s    1895988/s    2006162/s
                                     1.0x        10.7x         9.4x         8.9x 
for_postinc                     16640609/s     386218/s    1398445/s    1802886/s
                                     1.0x        43.1x        11.9x         9.2x 
for_postinc_native              16670507/s    1037555/s    1859233/s    1994065/s
                                     1.0x        16.1x         9.0x         8.4x 
for_concat                      14998496/s      29144/s     182410/s     205988/s
                                     1.0x       514.6x        82.2x        72.8x 
for_concat_native               15053529/s      49506/s    1353377/s    1465293/s
                                     1.0x       304.1x        11.1x        10.3x 
for_concat_2                     8646049/s      15854/s     107213/s     117943/s
                                     1.0x       545.4x        80.6x        73.3x 
for_concat_2_native              8659225/s      23751/s     791213/s     986208/s
                                     1.0x       364.6x        10.9x         8.8x 
for_push                         8496867/s     122034/s      25166/s     333166/s
                                     1.0x        69.6x       337.6x        25.5x 
for_array_set                    7810807/s      57463/s     286036/s     388650/s
                                     1.0x       135.9x        27.3x        20.1x 
for_hash_set                     1567864/s      32265/s     168643/s     171446/s
                                     1.0x        48.6x         9.3x         9.1x 
reduce_range                     4964114/s     181283/s     318258/s     345797/s
                                     1.0x        27.4x        15.6x        14.4x 
reduce_int_comb_range             470778/s       1495/s       3355/s       3406/s
                                     1.0x       314.8x       140.3x       138.2x 
any_equals                       2646212/s      15684/s      61867/s      81787/s
                                     1.0x       168.7x        42.8x        32.4x 
trim_string                     13660958/s   33565139/s    9291330/s   17910365/s
                                     2.5x         1.0x         3.6x         1.9x 
split_string_constant            5615519/s     100014/s     133572/s     171231/s
                                     1.0x        56.1x        42.0x        32.8x 
split_string_regex               2017912/s       4137/s      12573/s      16553/s
                                     1.0x       487.8x       160.5x       121.9x 
charrange                         363103/s       3416/s      19831/s      24667/s
                                     1.0x       106.3x        18.3x        14.7x 
charrange_ignorecase              363529/s       3788/s      14433/s      17899/s
                                     1.0x        96.0x        25.2x        20.3x 
visit_2d_indices_while           7276084/s     152635/s     746903/s    1484712/s
                                     1.0x        47.7x         9.7x         4.9x 
visit_2d_indices_while_native   11180261/s     553619/s    1177498/s    1451682/s
                                     1.0x        20.2x         9.5x         7.7x 
visit_2d_indices_loop           10123295/s     177783/s     834515/s    1843586/s
                                     1.0x        56.9x        12.1x         5.5x 
visit_2d_indices_loop_native    12457926/s   440172780/s    1227550/s    1431680/s
                                    35.3x         1.0x       358.6x       307.5x 
visit_2d_indices_for             8548538/s     255887/s     675743/s     847728/s
                                     1.0x        33.4x        12.7x        10.1x 
visit_2d_indices_cross           1367865/s       4685/s      31407/s      40470/s
                                     1.0x       292.0x        43.6x        33.8x 
create_and_copy_2d_grid_cross     541914/s       2230/s      11564/s      13778/s
                                     1.0x       243.0x        46.9x        39.3x 
create_and_iterate_hash_kv           --          1564/s      12248/s      12651/s
                                    FAIL          8.1x         1.0x         1.0x 
rat_mul_div_cancel                  7439/s       4852/s      33910/s      40614/s
                                     5.5x         8.4x         1.2x         1.0x 
rat_harmonic                        1080/s       1732/s      11089/s      11678/s
                                    10.8x         6.7x         1.1x         1.0x 
rand                            10885068/s     230938/s     183511/s     213786/s
                                     1.0x        47.1x        59.3x        50.9x 
array_set_xx                    13585287/s    1533694/s     545243/s     597926/s
                                     1.0x         8.9x        24.9x        22.7x 
parse-json                            23/s          1/s          1/s          1/s
                                     1.0x        29.6x        37.0x        22.8x 
parse-json-no-obj-creation           --             1/s          1/s          1/s
                                    SKIP          1.4x         1.9x         1.0x 
rc-forest-fire                      1374/s          2/s          9/s          9/s
                                     1.0x       588.4x       155.8x       146.7x 
rc-man-or-boy-test                187464/s        --         41252/s      39966/s
                                     1.0x        FAIL          4.5x         4.7x 
rc-self-describing-numbers        219156/s        571/s        775/s        782/s
                                     1.0x       383.9x       282.9x       280.1x 
rc-dragon-curve                   149131/s       1704/s       5937/s       6260/s
                                     1.0x        87.5x        25.1x        23.8x 
rc-9-billion-names                  1821/s         93/s        216/s        500/s
                                     1.0x        19.7x         8.4x         3.6x 
rc-mandelbrot                       1168/s        702/s       1440/s       1519/s
                                     1.3x         2.2x         1.1x         1.0x 
spinner                              971/s          4/s          5/s          5/s
                                     1.0x       228.7x       193.1x       182.9x 
rc-forest-fire-stringify           11162/s         25/s         35/s         41/s
                                     1.0x       438.8x       314.7x       275.2x 
string-escape                    1448636/s        --           --           --   
                                     1.0x        FAIL         FAIL         FAIL  
                                =================================================
SUMMARY SCORE                     2253.9         40.5        100.0        139.6  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何把数据用图的形式展示，我还没有找到办法。&lt;/p&gt;
    &lt;hr&gt;
    
    &lt;hr&gt;
  &lt;!-- JiaThis Button BEGIN --&gt;
&lt;div class=&quot;jiathis_style&quot;&gt;
&lt;span class=&quot;jiathis_txt&quot;&gt;分享到：&lt;/span&gt;
&lt;a class=&quot;jiathis_button_tsina&quot;&gt;新浪微博&lt;/a&gt;
&lt;a class=&quot;jiathis_button_weixin&quot;&gt;微信&lt;/a&gt;
&lt;a class=&quot;jiathis_button_renren&quot;&gt;人人网&lt;/a&gt;
&lt;a class=&quot;jiathis_button_ydnote&quot;&gt;有道云笔记&lt;/a&gt;
&lt;a class=&quot;jiathis_button_gmail&quot;&gt;Gmail邮箱&lt;/a&gt;
&lt;a class=&quot;jiathis_button_twitter&quot;&gt;Twitter&lt;/a&gt;
&lt;a class=&quot;jiathis_button_googleplus&quot;&gt;Google+&lt;/a&gt;
&lt;a class=&quot;jiathis_button_hi&quot;&gt;百度空间&lt;/a&gt;
&lt;a class=&quot;jiathis_button_fb&quot;&gt;Facebook&lt;/a&gt;
&lt;a class=&quot;jiathis_button_douban&quot;&gt;豆瓣&lt;/a&gt;
&lt;a href=&quot;http://www.jiathis.com/share?uid=1589850&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;更多&lt;/a&gt;
&lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var jiathis_config={
	data_track_clickback:true,
	summary:&quot;&quot;,
	ralateuid:{
		&quot;tsina&quot;:&quot;1035836154&quot;
	},
	shortUrl:false,
	hideMore:false
}
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://v3.jiathis.com/code/jia.js?uid=1589850&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;!-- JiaThis Button END --&gt;
&lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;
  &lt;/div&gt;

</description>
        <pubDate>Tue, 28 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-10-28-perl6-bench-4806c8a78.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-10-28-perl6-bench-4806c8a78.html</guid>
        
        
        <category>chenlinux</category>
        
      </item>
    
      <item>
        <title>超酷算法：喷泉码</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;是的，是更新这个十分罕见的超酷算法系列新的一集的时候了。如果你不熟悉这个系列，你可以看看之前的&lt;a title=&quot;超酷算法：基数估计&quot; href=&quot;http://blog.jobbole.com/?s=%E8%B6%85%E9%85%B7%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;一些文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;今天的主题是&lt;a title=&quot;Fountain code&quot; href=&quot;http://en.wikipedia.org/wiki/Fountain_code&quot; target=&quot;_blank&quot;&gt;喷泉码&lt;/a&gt;，或者称为“无率码”。喷泉码是将一些数据，例如文件，转化为一个有效的任意数量的编码包的方法，这样只要你接收到稍大于信源数据包数量的编码包的子集，就可以恢复信源数据。换句话说，你创建了一个编码数据的“喷泉”，只要接收端接收到足够的“水滴”，就可以恢复文件，而不管它们接到哪一个遗漏了哪一个。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;让喷泉码如此知名的原因是，它允许你在有损连接（比如说因特网）的情况下传输文件，而且传输过程不依赖于你是否知道丢包率，也不需要接收端反馈哪些数据包丢失了。可以看到在很多场景，从通过广播媒介传送一个静态文件，比如点播电视，到在多源并行下载中传播文件包，像BitTorrent那样，喷泉码都得到了很好的应用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;虽然从根本上喷泉码惊人地简单。它有许多种类，但是在本文中我们只介绍最简单的——LT码，或者&lt;a title=&quot;Luby transform code&quot; href=&quot;http://en.wikipedia.org/wiki/Luby_transform_code&quot; target=&quot;_blank&quot;&gt;Luby变换码&lt;/a&gt;。LT码生成编码包的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 l 和 k 的之间随机选取一个数字 d，d 代表文件中块的数量。我们将会在后面的内容中讨论如何选取最佳的d。&lt;/li&gt;
&lt;li&gt;从文件中随机选取 d 块，并把它们组合起来。这里我们可以用异或运算来组合这些块。&lt;/li&gt;
&lt;li&gt;传送合并的块，同时发送它由哪些块构成的信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;这些非常简单是不是？主要依赖于我们怎么选取块的数量并组合起来（叫做度分布），在接下来我们会简短的介绍一下。你可以从上面的描述中看到有些编码块最后只由单一源码块组成，而大部分将由多个源码块组成。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;另外一个可能不是立刻显现的事情是，虽然我们确实不得不让接收端知道输出码块由哪些码块合并产生的，我们不需要详细地发送那个列表。如果发送端和接收端使用相同的伪随机数生成器（pseudo-random number generator，PRNG），我们可以用一个随机选择的种子来生成PRNG，并且用这个来选择度和该组源码块。然后我们只需要在发送编码块的同时发送种子，我们的接收端可以用相同的过程来重建我们使用过的源码块列表。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;解码的过程有一点复杂，但是没有很复杂：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重建用于生成编码块的源码块列表。&lt;/li&gt;
&lt;li&gt;对于列表中的每一个源码块，如果已经解码了，将它和编码块做异或运算，并且把它从源码块列表中移除。&lt;/li&gt;
&lt;li&gt;如果在列表剩下至少两个源码块，将编码块加入到一个等候区。&lt;/li&gt;
&lt;li&gt;如果在列表中只剩下一个源码块，我们已经成功的把另一个源码块解码了，那么把它加入到已解码文件中，迭代等候列表，重复以上过程直到有编码块包含它。&lt;/li&gt;
&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;让我们通过一个译码实例来更清晰说明这个过程。假设我们收到5个编码块，每个长度是一个字节，并且我们知道每个源码块由哪些构成。我们可以用图来表示数据，如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b90295de29726f604d4f040ac1797f99.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;左边的结点代表我们收到的编码块，右边的节点代表源码块。我们收到的第一结点0×48只由一个源码块（第一个源码块）构成，所以已经知道是哪个块。沿着指向第一个源码块箭头的反向，可以看到第二个和第三个编码块都只依赖于第一个源码块和另外一个源码块，由于我们知道第一个源码块，我们可以对它们做异或运算，如下图所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1684ccccd712f551c06dc59fb6a4c459.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;重复以上过程，我们可以看到我们现在有了足够的信息来解码第四个编码块，它依赖于第二个和第三个源码块，而这两个我们现在都知道了。对它们做异或运算，可以得到第五个也是最后一个源码块，如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b94c8c179a2d5899a2d1fe32bea0d9b7.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;最后，我们可以解码最后剩下的源码块，得到剩余的信息：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/68fe24c85d05f9146f275eb946651a4e.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;应该承认的是这是一个非常特殊的例子，这个例子刚好接收到我们在译码这个信息时需要的块，没有剩余的，并且是一个非常简单的顺序，但是这个例子很好的演示算法的原理。我确定你可以看到这个算法应用到大规模码块和大规模文件中会相当简单。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在前面我提到选择每个编码块都需要的源码块的数量，即度分布，是很重要的，它确实重要。理想情况下，我们需要生成一些只包含一个源码块的编码块，然后可以开始译码了，大多数编码块依赖很少的其他编码块。这种理想的分布是存在的，叫做&lt;a title=&quot;Soliton distribution&quot; href=&quot;http://en.wikipedia.org/wiki/Soliton_distribution&quot; target=&quot;_blank&quot;&gt;理想孤波分布&lt;/a&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;不幸的是，理想孤波分布在实际情况中并没有这么理想，正如随机变量使得有些源码块不被任何编码块包含，或者当所有知道的块用完之后译码停止了。理想孤波分布的一个变形，叫做稳健孤波分布，在这方面进行了改进，用非常少的源码块生成更多的码块，也通过合并所有的或几乎所有的源码块生成一些码块，来帮助破译最后一些源码块。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;简而言之，这就是喷泉码的，更确切的说是LT码的，工作原理。LT码是已知的喷泉码中效率最低的，但是最易解释的。如果你想进一步学习，我强烈推荐读这篇&lt;a href=&quot;http://switzernet.com/people/emin-gabrielyan/060112-capillary-references/ref/MacKay05.pdf&quot; target=&quot;_blank&quot;&gt;关于喷泉码的技术论文&lt;/a&gt;，也可以读&lt;a title=&quot;Raptor code&quot; href=&quot;http://en.wikipedia.org/wiki/Raptor_code&quot; target=&quot;_blank&quot;&gt;Raptor码&lt;/a&gt;，Raptor码只比LT码增加了一点复杂度，但是在传输开销和计算上都显著的提高了它们的效率。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在我们总结之前有一个进一步的思考问题。对于系统来说喷泉码可能看起来很理想，比如说比特流，它允许种子生成和散布几乎无限制数量的码块，或多或少的消除了稀疏种子流“最后一块”的问题，而且确保两个随机选择的并行端几乎总有有用信息相互交换。但是它面临一个重大的问题：验证从并行端接收到的数据将会很难。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;像比特流这样的协议使用安全散列函数，比如说SHA1，和一个可信任中心（最初的上传者），向所有的并行端发送一个权威散列表。每个并行然后可以验证他们下载的散列块的文件包，并且和权威散列进行对比。但是对于喷泉码，这个是很难的。根本没有方法在编码块上计算SHA1散列，更不要说单独块上的散列。我们不能相信我们的并行端计算的结果，因为它们可以对我们撒谎。我们可以等到我们得到全部文件，然后从无效码块列表出发，尝试推断什么样的编码块是无效的，但这是困难的也是不可靠的，而且信息来的时候可能已经为时已晚。一个可供选择的方法是让最初发布者公布一个公共密钥，并且标注所有的生成块。然后我们就可以验证编码块了，但代价是：现在只有最初发布者可以生成有效的编码块了，并且我们失去了最初使用喷泉码的很多好处。似乎我们被困住了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;还有另一种选择，而且已经证明是一个非常聪明的方案，叫做同态哈希，尽管它有自己的注意事项和缺点。我们将会在下一版的超酷算法中讨论。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Tue, 28 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-10-28-78841-72bab084e.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-10-28-78841-72bab084e.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>服务器到底用双电源还是单电源？</title>
        <description>

                &lt;p&gt;&lt;strong&gt;因为电源故障导致服务器掉电所产生的风险有哪些？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单点类业务（开发、测试和办公平台等）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、业务中断：业务无法继续向用户提供服务，影响用户体验；&lt;/p&gt;
&lt;p&gt;2、数据恢复：掉电引发数据丢失，需要数据恢复，产生运维成本；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集群类业务（WEB前端、缓存、数据库等）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;掉电引发数据丢失，根据业务的不同分类可能需要数据恢复（比如缓存型业务就不需要数据恢复），有一定的运维成本发生；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式存储（hadoop、分布式文件系统等）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储类业务遇到单机断电掉线都将被作为一个节点的故障处理，因此数据恢复可能会占去大量的时间（自动化数据恢复除外）；&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过数据评估两种方案的价值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设服务器总数为W万台，单电源服务器年故障率为x%，电源仅占到所有故障总数的y%，那么电源的年故障率应该在xy/10000，一年内电源故障次数为：Wxy。可以根据这个公式去评估一个集群一年内的断电次数：假设一年内允许的断电次数为Z，那么只要让Wxy &amp;lt; Z就可以达到期望目标。&lt;/p&gt;
&lt;p&gt;当Wxy值远大于Z时，在x、y不变的情况下，通常是因为W基数较大引起的。这个时候要满足Wxy &amp;lt; Z就只能通过双电去实现：&lt;/p&gt;
&lt;p&gt;双电方案下服务器年断电概率为：xxyy/10^8，断电次数为：Wxxyy/10000，它是单电方案故障次数的xy/10000，足够满足小于Z的条件了。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;总结：&lt;/strong&gt;在使用单电方案的前提下，如果要满足Z&amp;gt;Wxy，就要尽量控制整个集群的服务器规模；服务器基数较大时，为了避免基数问题带来过多的服务器断电，建议使用双电方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何强化单电方案的可用性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、插头绑线规范化提高电源插头稳固性，防止服务器电源因误碰而掉线。&lt;/p&gt;
&lt;p&gt;2、保持良好的机房散热条件，防止电源因为过热而导致故障；&lt;/p&gt;
&lt;p&gt;3、尽量选用标号更高的电源（比如白金电源、黄金电源），提高转换效率减少谐波干扰；&lt;/p&gt;
            

</description>
        <pubDate>Mon, 27 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-10-27--p=1681-18a5f191f.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-10-27--p=1681-18a5f191f.html</guid>
        
        
        <category>noops</category>
        
      </item>
    
      <item>
        <title>推荐！手把手教你使用Git</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;一：Git是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       Git是目前世界上最先进的分布式版本控制系统。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;二：SVN与Git的最主要的区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;三：在windows上如何安装Git？&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      msysgit是 windows版的Git,如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b4b7dc26364f9d268e4a922da05cca06.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git –&amp;gt; Git Bash”,如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a9b40a83f613fbbc96eb7388d2314440.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b1a6b09e067e97493c02707edb29a7af.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;安装完成后，还需要最后一步设置，在命令行输入如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0d4a6ee808cb38d320a0ad1323bcaf5b.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;   注意：&lt;/strong&gt;git config  –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;四：如何操作？&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     一：创建版本库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    所以创建一个版本库也非常简单，如下我是D盘 –&amp;gt; www下 目录下新建一个testgit版本库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/91f76932274924bbc7a4c4e4bb4a656a.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;pwd 命令是用于显示当前的目录。&lt;/p&gt;
&lt;p&gt;      1. 通过命令 git init 把这个目录变成git可以管理的仓库，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e4b829c7dd8f4913c6166b581b7771dd.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/22d9fa49f8e7054a9c19a35e88e77f7b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;      2. 把文件添加到版本库中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;          首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;    下面先看下&lt;/strong&gt;&lt;strong&gt;demo&lt;/strong&gt;&lt;strong&gt;如下演示：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e5a850579327b85b3a0252eaf0053e29.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   如果和上面一样，没有任何提示，说明已经添加成功了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   第二步：用命令 git commit告诉Git，把文件提交到仓库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/101da3538fd6189e184fefcef5702d13.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fe21abbb86461ca9a68a53e2305b7f87.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2ee9058a597f94683e16e41d94573b12.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;git diff readme.txt 如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a37f4665b5b4c5a99ec85252418d0b8c.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add  第二步是：git commit)。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/740b39285145a27f10bc21ab64b6ea58.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;二：版本回退：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;内容为33333333333333.继续执行命令如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/50c7e12acd98d3bd52eb46e46188d0b7.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/62d0cac09dc09b7621fe829d11b94e5a.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d47b71cbaeb91b2a5ceba5f7f8d2b6ae.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset  –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset  –hard HEAD~100 即可。未回退之前的readme.txt内容如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c2fa3bfecab328d41795d07fcb3a6405.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果想回退到上一个版本的命令如下操作：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/329c3df3f0dc9bc02eb0035d754ec286.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;再来查看下 readme.txt内容如下：通过命令cat readme.txt查看&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3b51ff025f4ddfa20a4e8a42f3352313.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/37a45c570be523c08055538bf106e8ac.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;git reset  –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog  演示如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/356c04fc63e71504e2f0497b5ca4e9b5.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;git reset  –hard 6fcfc89来恢复了。演示如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/cf5af4eb9674d0693db384dcfbb56833.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;可以看到 目前已经是最新的版本了。&lt;/p&gt;
&lt;p&gt;三：理解工作区与暂存区的区别？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     &lt;strong&gt;工作区：&lt;/strong&gt;就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      版本库&lt;/strong&gt;&lt;strong&gt;(Repository)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们前面说过使用Git提交文件到版本库有两步：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们继续使用demo来演示下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/188b714b022b66805d76cb9f1732a4ee.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/923003241dc50a3207a8248839d0f01b.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;接着我们可以使用git commit一次性提交到分支上，如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/aa30768351d7a08bf41342a270fb69b8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;四：Git撤销修改和删除文件操作。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;一：撤销修改：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e777e43af3f3ebdb9b6f5aa0a53627a5.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset  –hard HEAD^&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/16fa574b55c0e189683cfd24a0b41f87.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;可以发现，Git会告诉你，git checkout  — file 可以丢弃工作区的修改，如下命令：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;git checkout  –  readme.txt,如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a920d5bc3352e1b39743089b15d91385.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;命令 git checkout –readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。&lt;/li&gt;
&lt;li&gt;另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/17f23c54cc406d27cc5abb763e62b673.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;命令git checkout — readme.txt 中的 — 很重要，如果没有 — 的话，那么命令变成创建分支了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;二：删除文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9ef66b511ff331b9f19730b666a617e0.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e6d7a93b35da3996f14333282fe43a28.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;可以使用如下命令 git checkout  — b.txt，如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/47e8103002fcebc5c73d55502cecba7b.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;再来看看我们testgit目录，添加了3个文件了。如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e1075f4c6e6e596a517a94a29210aec6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;五：远程仓库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;ssh-keygen  -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/340b727b7bc17ef35461dd1cb683e87a.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2e33983198d14be8c2b0e962a540fbb0.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;点击 Add Key，你就应该可以看到已经添加的key。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ec4c23f239d32b2ae157951142cb0487.jpg&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何添加远程库？&lt;/li&gt;
&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;         现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/61500f2a525ec3e00ede1cbf3277d0a3.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在Repository name填入&lt;code&gt;testgit&lt;/code&gt;，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7364a75f2eaa9e5953fd66df53d55683.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;    目前，在GitHub上的这个&lt;code&gt;testgit&lt;/code&gt;仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。&lt;/p&gt;
&lt;p&gt;现在，我们根据GitHub的提示，在本地的&lt;code&gt;testgit&lt;/code&gt;仓库下运行命令：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;git remote add origin https://github.com/tugenhua0707/testgit.git&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;所有的如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ceb3437be4fccbdf6ff69a9734865644.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。&lt;/p&gt;
&lt;p&gt;由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a3ae3feebcdfc12a9b638f0bce644339.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;从现在起，只要本地作了提交，就可以通过如下命令：&lt;/p&gt;
&lt;p&gt;git push origin master&lt;/p&gt;
&lt;p&gt;把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。&lt;/p&gt;
&lt;p&gt;2. 如何从远程库克隆？&lt;/p&gt;
&lt;p&gt;上面我们了解了先有本地库，后有远程库时候，如何关联远程库。&lt;/p&gt;
&lt;p&gt;现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？&lt;/p&gt;
&lt;p&gt;首先，登录github，创建一个新的仓库，名字叫testgit2.如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4cda4a5ce0d671cfd92061dcec124be1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如下，我们看到：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2390cc3840805828315c93976b6e70a6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/62fde5d8401f1c0d51d27ebb07182f5b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;接着在我本地目录下 生成testgit2目录了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a82b9a1c910e172a3db4036363a21842.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;六：创建与合并分支。&lt;/p&gt;
&lt;p&gt;在  版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。&lt;/p&gt;
&lt;p&gt;首先，我们来创建dev分支，然后切换到dev分支上。如下操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8e45f7e939c20b50e70192c1c819de83.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;git branch dev&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;git checkout dev&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/cb06e411072191e7feb74f27bc341a87.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0265d6035d2362f07a61d296cab66856.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9851e31bd3c8a945cf1eef4c46c27caf.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注意到上面的&lt;em&gt;Fast-forward&lt;/em&gt;信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;合并完成后，我们可以接着删除dev分支了，操作如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d5a3f99179880bf7eff503789e8d5dd2.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;总结创建与合并分支命令如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   查看分支：git branch&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   创建分支：git branch name&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   切换分支：git checkout name&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;创建+切换分支：git checkout –b name&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;合并某分支到当前分支：git merge name&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;删除分支：git branch –d name&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何解决冲突？&lt;/li&gt;
&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/428677f46597ac79855cff95ecd14037.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/900c3040f9a88d61d21a2cb0ce1e1e2e.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在我们需要在master分支上来合并fenzhi1，如下操作：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e30111c6d51ee62b6271d01059482db8.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Git用&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;，=======，&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;标记出不同分支的内容，其中&amp;lt;&amp;lt;&amp;lt;HEAD是指主分支修改的内容，&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c5af58a505c5ed2ec83770b0f5ee4423.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f6abe88499131cfa4f5a53bcd72f30e1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;    3.分支管理策略。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个dev分支。&lt;/li&gt;
&lt;li&gt;修改readme.txt内容。&lt;/li&gt;
&lt;li&gt;添加到暂存区。&lt;/li&gt;
&lt;li&gt;切换回主分支(master)。&lt;/li&gt;
&lt;li&gt;合并dev分支，使用命令 git merge –no-ff  -m “注释” dev&lt;/li&gt;
&lt;li&gt;查看历史记录&lt;/li&gt;
&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;截图如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8d6772c1184221c9cb11c98982a0189e.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;分支策略：&lt;/strong&gt;首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。&lt;/p&gt;
&lt;p&gt;七：bug分支：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/cf374ae693bb4e51ee54d57fcf2b58d4.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5f4f5fddaa103ef38976ad3fdf99b3d0.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   所以现在我可以通过创建issue-404分支来修复bug了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/20a7920ad201f026e7248eba8d3eaf8a.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/24244e9c94a094ffd8ca478e4fbb73e6.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在，我们回到dev分支上干活了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4c2a62f17cf06073fa6eb4e2a4a24316.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/00fd582e45ef0013bda4223625648992.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。&lt;/li&gt;
&lt;li&gt;另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;         演示如下&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/241b26f50a58ccd03c37646698f8a6d1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;八：多人协作。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要查看远程库的信息 使用 git remote&lt;/li&gt;
&lt;li&gt;要查看远程库的详细信息 使用 git remote –v&lt;/li&gt;
&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;如下演示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/09e3d8139b0a3328f08e8e73791a26e0.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;一：推送分支：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      使用命令 git push origin master&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;比如我现在的github上的readme.txt代码如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/210dbbc4b381034455c6d1242eff0ee2.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;本地的readme.txt代码如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8ae8e59757569c42a3bc71c7e6b259a6.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3883c4d176657bcc2bd87b87bc54bbe4.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/072344dd69183379c0b7df0fb1a209cf.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;那么一般情况下，那些分支要推送呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;master分支是主分支，因此要时刻与远程同步。&lt;/li&gt;
&lt;li&gt;一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。&lt;/li&gt;
&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;二：抓取分支：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;但是我首先要把dev分支也要推送到远程去，如下&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/03ad741faba9cd49c905c572a672427c.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;接着进入testgit2目录，进行克隆远程的库到本地来，如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/93cca90da95a4a821b0f095b83b2c71a.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在目录下生成有如下所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/baffc93c3f32f5cb783017bd66cfdf94.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：git checkout  –b dev origin/dev&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5b3077c250904c39b5e5c65b07bf17c7.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4243c0d67abeb546710482139fabae66.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/736337ac8bca926c5559b144fd26db84.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;git pull&lt;/em&gt;也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/672177b77e06a5fbcf6214de7e32f843.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这回&lt;em&gt;git pull&lt;/em&gt;成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们可以先来看看readme.txt内容了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/04a6b016aa35df0fef0d93843f24abfe.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：&lt;br&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fb738de063d3e921ed84ad1f04f2a680.jpg&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;因此：多人协作工作模式一般是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，可以试图用git push origin branch-name推送自己的修改.&lt;/li&gt;
&lt;li&gt;如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。&lt;/li&gt;
&lt;li&gt;如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。&lt;/li&gt;
&lt;/ol&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Git&lt;/strong&gt;&lt;strong&gt;基本常用命令如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   mkdir：         XX (创建一个空目录 XX指目录名)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   pwd：          显示当前目录的路径。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git init          把当前的目录变成可以管理的git仓库，生成隐藏.git文件。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git add XX       把xx文件添加到暂存区去。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git commit –m “XX”  提交文件 –m 后面的是注释。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git status        查看仓库状态&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git diff  XX      查看XX文件修改了那些内容&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git log          查看历史记录&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git reset  –hard HEAD^ 或者 git reset  –hard HEAD~ 回退到上一个版本&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                        (如果想回退到100个版本，使用git reset –hard HEAD~100 )&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   cat XX         查看XX文件内容&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git reflog       查看历史记录的版本号id&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git checkout — XX  把XX文件在工作区的修改全部撤销。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git rm XX          删除XX文件&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git remote add origin &lt;a href=&quot;https://github.com/tugenhua0707/testgit&quot;&gt;https://github.com/tugenhua0707/testgit&lt;/a&gt; 关联一个远程库&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git clone &lt;a href=&quot;https://github.com/tugenhua0707/testgit&quot;&gt;https://github.com/tugenhua0707/testgit&lt;/a&gt;  从远程库中克隆&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git checkout –b dev  创建dev分支 并切换到dev分支上&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git branch  查看当前所有的分支&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git checkout master 切换回master分支&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git merge dev    在当前的分支上合并dev分支&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git branch –d dev 删除dev分支&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git branch name  创建分支&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git stash list 查看所有被隐藏的文件列表&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git stash apply 恢复被隐藏的文件，但是内容不删除&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git stash drop 删除文件&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git stash pop 恢复文件的同时 也删除文件&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git remote 查看远程库的信息&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git remote –v 查看远程库的详细信息&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   git push origin master  Git会把master分支推送到远程库对应的远程分支上&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Sun, 26 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-10-26-78960-8be2a3995.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-10-26-78960-8be2a3995.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>实现键值对存储（三）：Kyoto Cabinet和LevelDB的架构比较分析</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在本文中，我将会逐组件地把Kyoto Cabinet 和 LevelDB的架构过一遍。目标和本系列第二部分讲的差不多，通过分析现有键值对存储的架构来思考我应该如何建立我自己键值对存储的架构。本文将包括：&lt;/p&gt;
&lt;p&gt;1. 本架构分析的意图和方法&lt;br&gt;
2. 键值对存储组件概览&lt;br&gt;
3. Kyoto Cabinet 和LevelDB在结构和概念上的分析&lt;br&gt;
3.1 用Doxygen建立代码地图&lt;br&gt;
3.2 整体架构&lt;br&gt;
3.3 接口&lt;br&gt;
3.4 参数化&lt;br&gt;
3.5 字符串&lt;br&gt;
3.6 错误管理&lt;br&gt;
3.7 内存管理&lt;br&gt;
3.8 数据存储&lt;br&gt;
4. 代码审查&lt;br&gt;
4.1 声明和定义的组织&lt;br&gt;
4.2 命名&lt;br&gt;
4.3 代码重复&lt;br&gt;
5. 参考文献&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e1081ce03f341a5a4b71fbbf3e3f70cd.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;1. 本架构分析的意图和方法&lt;b&gt;&lt;/b&gt;
&lt;/h3&gt;
&lt;p&gt;我曾经想过是应该写两篇独立的文章，一篇写LevelDB另一篇写Kyoto Cabinet，还是应该写一篇综合的文章。我相信软件架构是一门很需要决策的技艺，就如同建筑师需要考虑并选择每个部分的设计一样。方案不能孤立的评估，而应该与其他方案之间进行权衡。软件系统架构的分析只能根据其背景在评价，并与其他架构比较。因此我将把键值对存储中遇到的主要组件过一遍，并比较现有键值对系统的方案。我将会为Kyoto Cabinet 和 LevelDB使用我自己的分析，但其他项目我会使用现有的分析。这里是我选用的其他人的分析：&lt;/p&gt;
&lt;p&gt;- BerkeleyDB, Chapter 4 in The Architecture of Open Source Applications, by Margo Seltzer and Keith Bostic (Seltzer being one of the two original authors of BerkeleyDB) &lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_1&quot;&gt;[1]&lt;/a&gt;&lt;br&gt;
- Memcached for dummies, by Tinou Bao &lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_2&quot;&gt;[2]&lt;/a&gt;&lt;br&gt;
- Memcached Internals &lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_3&quot;&gt;[3]&lt;/a&gt;&lt;br&gt;
- MongoDB Architecture, by Ricky Ho &lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_4&quot;&gt;[4]&lt;/a&gt;&lt;br&gt;
- Couchbase Architecture, by Ricky Ho &lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_5&quot;&gt;[5]&lt;/a&gt;&lt;br&gt;
- The Architecture of SQLite &lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_6&quot;&gt;[6]&lt;/a&gt;&lt;br&gt;
- Redis Documentation &lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_7&quot;&gt;[7]&lt;/a&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2. 键值对存储组件概述&lt;b&gt;&lt;/b&gt;
&lt;/h3&gt;
&lt;p&gt;尽管键值对存储的内部架构有很大不同，但总有相似的组件。下面列出了大部分键值对存储中遇到的主要组件及其功能的简述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口：&lt;/strong&gt;键值对存储暴露给用户的一组方法和类，使用户可以与之互动。也叫做API。键值对存储的最小API包括Get(),、Put() 和Delete()方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数系统：&lt;/strong&gt;选项设置并传递给整个系统的其他组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据存储：&lt;/strong&gt;接口是用来访问内存中数据（也就是键和值）的。如果数据必须&lt;i&gt;维护&lt;/i&gt;在持久性存储器中，例如硬盘或闪存，那么可能会出现&lt;i&gt;同步性&lt;/i&gt;问题和&lt;i&gt;并发性&lt;/i&gt;问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据结构：&lt;/strong&gt;用算法和方法来组织数据，并允许高效的存储的检索。通常使用哈希表或者B+树。LevelDB中则是日志结构合并树。数据结构的选择基于数据的内部结构和底层数据存储方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存管理：&lt;/strong&gt;系统中用来管理内存的算法和技术。内存相当重要，如果数据存储用错误的内存管理技术来访问，会极大地影响性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;遍历：&lt;/strong&gt;对数据库中所有键和值进行枚举和顺序访问的方法。解决方案大多是迭代器和游标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串：&lt;/strong&gt;数据结构是用来访问字符串的。把字符串单独拿出来说或许看起来有些过分详细了，但对于键值对存储来说，大量的时间都用来传递和处理字符串，STL的std::string可能不是最佳方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁管理：&lt;/strong&gt;所有关系到并发访问（带有信号灯和互斥的）内存区锁的机制，以及当数据存储是文件系统时的文件锁。同时处理关于多线程的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误管理：&lt;/strong&gt;用来拦截和处理系统中遇到的错误的技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日志：&lt;/strong&gt;记录系统中发生的事件的机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事务管理：&lt;/strong&gt;能够确保所有操作正常执行的一系列操作的机制，并且在出现错误时，确保没有操作被执行且数据库也没有更改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;压缩：&lt;/strong&gt;用来压缩数据的算法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较器：&lt;/strong&gt;用来比较两个键是否相同的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;校验和：&lt;/strong&gt;用了测试并确保数据的完整性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快照：&lt;/strong&gt;快照提供其创建时全部数据库的只读镜像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分区：&lt;/strong&gt;也被称为分片，其包括将整套数据分配到多个数据存储中，可能是网络中的多个节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据备份：&lt;/strong&gt;为了防止系统或者硬件错误，确保持久性，一些键值对存储允许数据（或者数据分区）有数个同时维护的拷贝，最好是在多个节点上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试框架：&lt;/strong&gt;用来测试系统的框架，包括单元测试和整体测试。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;3. Kyoto Cabinet和LevelDB结构和概念的分析&lt;b&gt;&lt;/b&gt;
&lt;/h3&gt;
&lt;p&gt;下述关于LevelDB和Kyoto Cabinet的分析将集中在下列组件：参数系统、数据存储、字符串和错误管理。关于接口、数据结构、内存管理、日志和测试框架这些组件将包含在IKVS系列之后的文章中。至于其他的组件，我目前不打算讲。其他系统，例如关系型数据库，有其他的诸如命令处理器、请求处理器、以及计划/优化器之类的组件，但它们已经超出了IKVS系列的内容。&lt;/p&gt;
&lt;p&gt;在我开始分析之前，请注意我认为Kyoto Cabinet 和 LevelDB是很出色的软件部分，我也很尊敬它们的作者。即便我说了关于他们的设计的坏话，要记得的是他们的代码仍然很出色，而我并没有像他们那样的才华。这就是说，下边的文章是我对于Kyoto Cabinet 和 LevelDB代码的一点意见。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;3.1 用Doxygen建立代码图&lt;b&gt;&lt;/b&gt;
&lt;/h4&gt;
&lt;p&gt;为了理解Kyoto Cabinet 和LevelDB的架构，我需要挖掘它们的代码。但是我也用Doxygen，一个用来浏览应用模块结构和类的非常强大的工具。 Doxygen是一个适用于多个编程语言的文档系统，它可以直接从源代码中创建报告文档或者HTML网站格式的文档。然而Doxygen同样可以用在没有注释的代码中，并创建基于系统组织方式（文件、命名空间、类和方法）的接口。&lt;/p&gt;
&lt;p&gt;你可以从官网上获得Doxygen &lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_8&quot;&gt;[8]&lt;/a&gt;。在你机器上安装好Doxygen之后，只需要打开shell界面，到包含所有你需要分析的源代码的目录下。然后输入如下命令即可创建默认设置文件。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ doxygen -g&lt;/pre&gt;
&lt;p&gt;这将创建一个叫“Doxygen”的文件。打开这个文件，确认下述所有设置都设置为“yes”:EXTRACT_ALL, EXTRACT_PRIVATE, RECURSIVE, HAVE_DOT, CALL_GRAPH, CALLER_GRAPH。这些选项会保证从代码中抽取所有对象，包括子目录，并创建调用图。所有可用设置的描述可以在Doxygen的在线文档中找到&lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_9&quot;&gt;[9]&lt;/a&gt;。只需要输入下面的命令即可用已选好的设置来创建文档。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ doxygen Doxygen&lt;/pre&gt;
&lt;p&gt;文档将在“html”文件夹中创建，你可以用任何web浏览器打开“index.html”文件来访问文档。你可以浏览代码，查看类之间的继承关系，并通过图来查看每个方法由其它哪个方法调用。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;3.2 整体架构&lt;b&gt;&lt;/b&gt;
&lt;/h4&gt;
&lt;p&gt;图3.1和3.1分别是Kyoto Cabinet v1.2.76 和LevelDB 1.7.0的架构。类以UML类图标准表示。组件以圆角矩形表示，黑箭头表示其它实体调用了这个实体。从A到B的黑箭头表示A使用或者访问了B的元素。&lt;/p&gt;
&lt;p&gt;这些图示表示的功能架构和结构架构基本相同。以图3.1为例，很多组件出现在HashDB类内部，因其这些组件的代码被定义为HashDB类的一部分。&lt;/p&gt;
&lt;p&gt;依据内部组件的组织方式来比较，LevelDB是大赢家。原因是Kyoto Cabinet中，遍历、参数设置、内存管理和错误管理的组件都作为内核/接口组件的一部分，如图3.1所示。这使得这些组件和内核之间形成了强耦合，并局限了系统的模块化和功能扩展性。与之相反，LevelDB是以一种非常模块化的方法建立的，只有内存管理才是内核组件的一部分。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/be550881a02dba0464593ebed00b3995.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt; 图3.1&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/723ddd253b4d2eccaaa8bf003999eb8f.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;图3.2&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;3.3 接口&lt;b&gt;&lt;/b&gt;
&lt;/h4&gt;
&lt;p&gt;Kyoto Cabinet 的HashDB类暴露出来至少50个方法，与之相比的是LevelDB的DBImpl类只有15个方法（其中4个还是测试用的）。这是Kyoto Cabinet的Core/Interface组件强耦合的直接结果。&lt;/p&gt;
&lt;p&gt;API设计将会在将来的IKVS系列中详细讨论。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;3.4 参数设置&lt;b&gt;&lt;/b&gt;
&lt;/h4&gt;
&lt;p&gt;在Kyoto Cabine中，参数是通过调用HashDB类的方法来调节的。有15个以“tune_”开头的方法来完成这个工作。&lt;/p&gt;
&lt;p&gt;在LevelDB中，参数被定义在特定的对象中。“Options”对象中是通用参数，“ReadOptions”和“WriteOptions”中是Get()和Put()分别需要的参数，如图3.2中所示。种子解耦提供了比较好的选项的扩展性，而不必像Kyoto Cabinet中调用Core中乱七八糟的公共接口。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;3.5 字符串&lt;b&gt;&lt;/b&gt;
&lt;/h4&gt;
&lt;p&gt;在键值对存储中，随时都有大量的字符串处理。字符串被迭代、哈希、压缩、传递和返回。因此，巧妙的实现字符串类相当重要，每个对象节省一点，在大规模的运用上将会在全局造成引人注目的影响。&lt;/p&gt;
&lt;p&gt;LevelDB使用一个特殊的类，称为“Slice” &lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_10&quot;&gt;[10]&lt;/a&gt;。一个Slice包含一个字节数组以及数组的长度。这可以在O(1)的时间内获取字符串的长度，&lt;span style=&quot;text-decoration: line-through;&quot;&gt;而不是&lt;/span&gt;&lt;span style=&quot;text-decoration: line-through;&quot;&gt;std::string&lt;/span&gt;&lt;span style=&quot;text-decoration: line-through;&quot;&gt;所需的&lt;/span&gt;&lt;span style=&quot;text-decoration: line-through;&quot;&gt;O(n)&lt;/span&gt;而不是对C的字符串调用strlen()时所需的O(n)。独立保存字符串长度也可以允许保存字符‘’，这表示键和值可以是真正的字节数组而非由null终结的字符串。最后且最重要的是，Slice处理拷贝是通过创建一个浅拷贝，而非深拷贝。这表示它只简单地拷贝字节数组的指针，而不像std::string那样拷贝全部的字节数组。这避免了拷贝有可能出现的非常大的键或值。&lt;/p&gt;
&lt;p&gt;像LevelDB一样，Redis使用他自己的数据结构来处理字符串。其目标同样是避免取字符串长度的时候避免使用O(n)操作&lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_11&quot;&gt;[11]&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Kyoto Cabinet使用std::string作为字符串对象。&lt;/p&gt;
&lt;p&gt;我的意见是，一个字符串类的实现适应于键值对存储的需求是非常必要的。如果能够避免，为什么要花费时间来拷贝字符串并分配内存呢？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3.6 错误管理&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;在我看过的键值对存储的所有C++源代码中，我没有见过一个将异常作为全局的错误管理系统使用。在Kyoto Cabinet中，kcthread.cc文件中的线程组件使用了异常，但我认为这个选择与其说是通用架构倒不如说是只是在处理线程而已。异常十分危险，并应该尽可能的避免。&lt;/p&gt;
&lt;p&gt;BerkeleyDB有很好的C风格的方法来处理错误。错误信息和代码集中在一个文件中。所有返回错误代码的函数都有一个叫“ret”的整型本地变量，这个变量将会在处理过程中赋值并在最后返回。这种方法贯穿在所有的文件和模块中：相当优雅和标准化的错误管理。在一些函数中使用了向前跳转的goto语句——一种在如Linux内核那样的纯C系统中广泛使用的技巧&lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_12&quot;&gt;[12]&lt;/a&gt;。虽然这种方法十分简洁和干净，但C风格的错误管理方法不太适合C++应用。&lt;/p&gt;
&lt;p&gt;Kyoto Cabinet中，错误对象存储在每个诸如HashDB的数据库对象中。在数据库类中，各个方法在出现错误的时候调用set_error()来设置错误对象，然后以很符合C风格的返回true或者false。不会像BerkeleyDB那样在方法末尾返回本地变量，返回语句出现在错误出现的地方。&lt;/p&gt;
&lt;p&gt;LevelDB完全不使用异常，而是使用一个叫做Status的类。这个类有错误值和错误信息。每个方法都返回这个对象，这样错误状态既可以就地处理也可以传递给调用栈中更高的其他方法。这个Status类错误码存储在字符串中，也是一种非常的聪明的实现。我对于这种设计方法的理解是，在大部分时间里，方法将会返回一个“OK”的状态（Status）对象，以表示没有出现任何错误。这样，错误信息字符串是NULL，而这个Status对象的处理是相当轻量的。如果Status对象增加一个属性来保存错误码，那么即便在“OK”状态的Status对象中仍需要给这个属性赋值，这即表示在每次调用方法的时候都要用更多的空间。所有的组件都使用这个Status类，并且没必要像Kyoto Cabinet那样总要调用一个方法，如图 3.1 and 3.2所示。&lt;/p&gt;
&lt;p&gt;错误管理的所有方案都在上文中讲过了，我个人比较推荐LevelDB使用的方案。这个方案避免使用了异常，也不是一个我看来相当局限的单纯的C风格的错误管理，并且其避免了像Kyoto Cabinet那样与核心组件任何不必要的耦合。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;3.7 内存管理&lt;b&gt;&lt;/b&gt;
&lt;/h4&gt;
&lt;p&gt;Kyoto Cabinet 和LevelDB都在内核组件中定义了内存管理。对于Kyoto Cabinet，内存管理一来可以跟踪数据库文件中临近的空块，二来当数据项保存的时候可以选择足够大小的块。而文件本身只是用mmap()函数映射出来的内存空间。另外MongoDB也使用内存映射文件&lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_13&quot;&gt;[13]&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;而LevelDB使用的是一个日志结构合并树，其不像保存在硬盘上的哈希表那样文件中有未使用的空间。内存空间管理也包括一旦日志文件大小超过某值后，压缩这些文件的功能&lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_14&quot;&gt;[14]&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其它如Redis之类的键值对存储，用malloc()来分配内存——在Redis的例子中，内存分配算法不是操作系统提供的dlmalloc或者ptmalloc3，而是jemalloc&lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/#ref_15&quot;&gt;[15]&lt;/a&gt; 。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;3.8 数据存储&lt;b&gt;&lt;/b&gt;
&lt;/h4&gt;
&lt;p&gt;Kyoto Cabinet, LevelDB, BerkeleyDB, MongoDB 和Redis使用文件系统来存储数据。与之相反Memcached 则是在内存中保存数据。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4. 代码审查&lt;b&gt;&lt;/b&gt;
&lt;/h3&gt;
&lt;p&gt;本节是对Kyoto Cabinet 和LevelDB的一个简单的代码审查。这个代码审查并不全面，并只包含了我在阅读源代码时觉得比较出色的元素。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;4.1  声明和定义的组织&lt;b&gt;&lt;/b&gt;
&lt;/h4&gt;
&lt;p&gt;如果代码都像LevelDB那样正常的组织，声明都在.h头文件中，而定义都在.cc文件中。但我在Kyoto Cabinet中发现了一些令人震惊的事情。实际上，很多类中.cc文件并没有包含任何定义，而方法都直接在.h文件中定义。在其他文件中，一些方法在.h中定义另一些在.cc文件中定义。虽然我理解这样做的背后可能有一些原因，但我仍认为在C++应用中不遵守这些惯例根本是错误的。之所以说是错的是因为一来它让我像那样惊讶，二来我必须在两种不同的文件中找定义。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;4.2 命名&lt;b&gt;&lt;/b&gt;
&lt;/h4&gt;
&lt;p&gt;首先，Kyoto Cabinet相对于Tokyo Cabinet.有了显著的改进。整体架构和命名规则都大幅改进了。尽管如此，我仍然发现Kyoto Cabinet中的很多名字都很晦涩，譬如属性和方法叫做embcomp、trhard、fmtver()、fpow()。这让人觉得C++代码中混进了一些C代码。另一方面，LevelDB中的命名相当清晰，除了诸如mem、imm和in的一些临时变量。但这些不清晰的密码相当微量而代码可读性相当强。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;4.3 代码重复&lt;b&gt;&lt;/b&gt;
&lt;/h4&gt;
&lt;p&gt;我在Kyoto Cabinet中确实看到了一些代码重复。这些用来文件碎片整理的代码至少重复了3次，而所有需要分为Unix和Windows两个版本的方法都显示出大量的重复。我没有在LevelDB看到明显的代码重复，我相信应该也有一些，但需要挖掘的更深才能找到。这证明LevelDB的代码重复问题确实比Kyoto Cabinet要小。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;5. 参考文献&lt;b&gt;&lt;/b&gt;
&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;[1] &lt;a href=&quot;http://www.aosabook.org/en/bdb.html&quot; target=&quot;_blank&quot;&gt;http://www.aosabook.org/en/bdb.html&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&quot;http://work.tinou.com/2011/04/memcached-for-dummies.html&quot; target=&quot;_blank&quot;&gt;http://work.tinou.com/2011/04/memcached-for-dummies.html&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&quot;http://code.google.com/p/memcached/wiki/NewUserInternals&quot; target=&quot;_blank&quot;&gt;http://code.google.com/p/memcached/wiki/NewUserInternals&lt;/a&gt;&lt;br&gt;
[4] &lt;a href=&quot;http://horicky.blogspot.com/2012/04/mongodb-architecture.html&quot; target=&quot;_blank&quot;&gt;http://horicky.blogspot.com/2012/04/mongodb-architecture.html&lt;/a&gt;&lt;br&gt;
[5] &lt;a href=&quot;http://horicky.blogspot.com/2012/07/couchbase-architecture.html&quot; target=&quot;_blank&quot;&gt;http://horicky.blogspot.com/2012/07/couchbase-architecture.html&lt;/a&gt;&lt;br&gt;
[6] &lt;a href=&quot;http://www.sqlite.org/arch.html&quot; target=&quot;_blank&quot;&gt;http://www.sqlite.org/arch.html&lt;/a&gt;&lt;br&gt;
[7] &lt;a href=&quot;http://redis.io/documentation&quot; target=&quot;_blank&quot;&gt;http://redis.io/documentation&lt;/a&gt;&lt;br&gt;
[8] &lt;a href=&quot;http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/:/doxygen.org&quot; target=&quot;_blank&quot;&gt;http:://doxygen.org&lt;/a&gt;&lt;br&gt;
[9] &lt;a href=&quot;http://www.stack.nl/~dimitri/doxygen/config.html&quot; target=&quot;_blank&quot;&gt;http://www.stack.nl/~dimitri/doxygen/config.html&lt;/a&gt;&lt;br&gt;
[10] &lt;a href=&quot;http://leveldb.googlecode.com/svn/trunk/doc/index.html&quot; target=&quot;_blank&quot;&gt;http://leveldb.googlecode.com/svn/trunk/doc/index.html&lt;/a&gt;&lt;br&gt;
[11] &lt;a href=&quot;http://redis.io/topics/internals-sds&quot; target=&quot;_blank&quot;&gt;http://redis.io/topics/internals-sds&lt;/a&gt;&lt;br&gt;
[12] &lt;a href=&quot;http://news.ycombinator.com/item?id=3883310&quot; target=&quot;_blank&quot;&gt;http://news.ycombinator.com/item?id=3883310&lt;/a&gt;&lt;br&gt;
[13] &lt;a href=&quot;http://www.briancarpio.com/2012/05/03/mongodb-memory-management/&quot; target=&quot;_blank&quot;&gt;http://www.briancarpio.com/2012/05/03/mongodb-memory-management/&lt;/a&gt;&lt;br&gt;
[14] &lt;a href=&quot;http://leveldb.googlecode.com/svn/trunk/doc/impl.html&quot; target=&quot;_blank&quot;&gt;http://leveldb.googlecode.com/svn/trunk/doc/impl.html&lt;/a&gt;&lt;br&gt;
[15] &lt;a href=&quot;http://oldblog.antirez.com/post/everything-about-redis-24.html&quot; target=&quot;_blank&quot;&gt;http://oldblog.antirez.com/post/everything-about-redis-24.html&lt;/a&gt;&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Fri, 24 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-10-24-78869-cb93de670.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-10-24-78869-cb93de670.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
  </channel>
</rss>
