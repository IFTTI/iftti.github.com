<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IT技术干货</title>
    <description>[IT技术干货iftti.com] @KernelHacks</description>
    <link>http://iftti.com/</link>
    <atom:link href="http://iftti.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 31 Jul 2014 19:43:17 +0800</pubDate>
    <lastBuildDate>Thu, 31 Jul 2014 19:43:17 +0800</lastBuildDate>
    <generator>Jekyll v2.1.0</generator>
    
      <item>
        <title>数字证书原理</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;文中首先解释了加密解密的一些基础知识和概念，然后通过一个加密通信过程的例子说明了加密算法的作用，以及数字证书的出现所起的作用。接着对数字证书做一个详细的解释，并讨论一下windows中数字证书的管理，最后演示使用makecert生成数字证书。如果发现文中有错误的地方，或者有什么地方说得不够清楚，欢迎指出！&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h5&gt;1、基础知识&lt;/h5&gt;
&lt;p&gt;这部分内容主要解释一些概念和术语，最好是先理解这部分内容。&lt;/p&gt;
&lt;h6&gt;1.1、公钥密码体制(public-key cryptography)&lt;/h6&gt;
&lt;p&gt;公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。&lt;/li&gt;
&lt;li&gt;解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;1.2、对称加密算法(symmetric key algorithms)&lt;/h6&gt;
&lt;p&gt;在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;// 密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥。&lt;/p&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h6&gt;1.3、非对称加密算法(asymmetric key algorithms)&lt;/h6&gt;
&lt;p&gt;在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。前面所说的公钥密码体制就是一种非对称加密算法，他的公钥和是私钥是不能相同的，也就是说加密使用的密钥和解密使用的密钥不同，因此它是一个非对称加密算法。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;1.4、RSA简介&lt;/h6&gt;
&lt;p&gt;RSA是一种公钥密码体制，现在使用得很广泛。如果对RSA本身有兴趣的，后面看我有没有时间写个RSA的具体介绍。&lt;/p&gt;
&lt;p&gt;RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，&lt;strong&gt;RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;1.5、签名和加密&lt;/h6&gt;
&lt;p&gt;我们说加密，是指对某个内容加密，加密后的内容还可以通过解密进行还原。 比如我们把一封邮件进行加密，加密后的内容在网络上进行传输，接收者在收到后，通过解密可以还原邮件的真实内容。&lt;/p&gt;
&lt;p&gt;这里主要解释一下签名，签名就是在&lt;strong&gt;信息&lt;/strong&gt;的后面再加上一段内容，可以证明&lt;strong&gt;信息&lt;/strong&gt;没有被修改过，怎么样可以达到这个效果呢？一般是对&lt;strong&gt;信息&lt;/strong&gt;做一个hash计算得到一个hash值，注意，这个过程是不可逆的，也就是说无法通过hash值得出原来的&lt;strong&gt;信息&lt;/strong&gt;内容。在把&lt;strong&gt;信息&lt;/strong&gt;发送出去时，把这个hash值加密后做为一个签名和&lt;strong&gt;信息&lt;/strong&gt;一起发出去。 接收方在收到&lt;strong&gt;信息&lt;/strong&gt;后，会重新计算&lt;strong&gt;信息&lt;/strong&gt;的hash值，并和&lt;strong&gt;信息&lt;/strong&gt;所附带的hash值(解密后)进行对比，如果一致，就说明信息的内容没有被修改过，因为这里hash计算可以保证不同的内容一定会得到不同的hash值，所以只要内容一被修改，根据&lt;strong&gt;信息&lt;/strong&gt;内容计算的hash值就会变化。当然，不怀好意的人也可以修改&lt;strong&gt;信息&lt;/strong&gt;内容的同时也修改hash值，从而让它们可以相匹配，为了防止这种情况，hash值一般都会加密后(也就是签名)再和&lt;strong&gt;信息&lt;/strong&gt;一起发送，以保证这个hash值不被修改。至于如何让别人可以解密这个签名，这个过程涉及到数字证书等概念，我们后面在说到数字证书时再详细说明，这里您先只需先理解签名的这个概念。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h5&gt;2、一个加密通信过程的演化&lt;/h5&gt;
&lt;p&gt;我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;2.1 第一回合：&lt;/h6&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：？？？？&lt;/p&gt;
&lt;p&gt;因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“客户”-&amp;gt;“黑客”：你好&lt;/strong&gt;        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;2.2 第二回合：&lt;/h6&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;// &lt;strong&gt;注&lt;/strong&gt;意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的&lt;/strong&gt; {你好，我是服务器}[私钥|RSA]&lt;strong&gt;  就表示用私钥对&lt;/strong&gt;“你好，我是服务器”&lt;strong&gt;进行加密后的结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。&lt;/p&gt;
&lt;p&gt;“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，&lt;strong&gt;由并且只能由&lt;/strong&gt;公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。&lt;/p&gt;
&lt;p&gt;假设“黑客”想冒充“服务器”：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“客户”-&amp;gt;“黑客”：向我证明你就是服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]&lt;/strong&gt;    //这里黑客无法冒充，因为他不知道&lt;strong&gt;私钥&lt;/strong&gt;，无法用&lt;strong&gt;私钥&lt;/strong&gt;加密某个字符串后发送给客户去验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“客户”-&amp;gt;“黑客”：？？？？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！&lt;/p&gt;
&lt;p&gt;到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;2.3 第三回合：&lt;/h6&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：{你的余额是100元}[私钥|RSA]&lt;/p&gt;
&lt;p&gt;注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。&lt;/p&gt;
&lt;p&gt;这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;2.4 第四回合：&lt;/h6&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：{OK，收到！}[密钥|对称加密算法]&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：{你的余额是100元}[密钥|对称加密算法]&lt;/p&gt;
&lt;p&gt;在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。&lt;/p&gt;
&lt;p&gt;由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)&lt;/p&gt;
&lt;p&gt;到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：&lt;/p&gt;
&lt;p&gt;a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。&lt;/p&gt;
&lt;p&gt;b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。&lt;/p&gt;
&lt;p&gt;但是这个两个方法都有一定的问题，&lt;/p&gt;
&lt;p&gt;对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。&lt;/p&gt;
&lt;p&gt;对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“黑客”：你好           //黑客截获“客户”发给“服务器”的消息&lt;/p&gt;
&lt;p&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“黑客”：向我证明你就是服务器&lt;/p&gt;
&lt;p&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”&lt;/p&gt;
&lt;p&gt;因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。&lt;strong&gt;这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 &lt;/strong&gt;如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;证书的发布机构&lt;/li&gt;
&lt;li&gt;证书的有效期&lt;/li&gt;
&lt;li&gt;公钥&lt;/li&gt;
&lt;li&gt;证书所有者（Subject）&lt;/li&gt;
&lt;li&gt;签名所使用的算法&lt;/li&gt;
&lt;li&gt;指纹以及指纹算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，&lt;strong&gt;数字证书可以保证&lt;strong&gt;数字&lt;/strong&gt;证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份&lt;/strong&gt;。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;2.5 第五回合：&lt;/h6&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]&lt;/p&gt;
&lt;p&gt;注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;2.6 完整过程：&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;step1&lt;/strong&gt;： “客户”向服务端发送一个通信请求&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step2&lt;/strong&gt;： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器，这里是我的数字证书&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step3&lt;/strong&gt;： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：{一个随机字符串}[私钥|RSA]&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step4&lt;/strong&gt;： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]&lt;/p&gt;
&lt;p&gt;…… //继续其它的通信&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;&lt;strong&gt;2.7 其它问题：&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;上面的过程已经十分接近HTTPS的真实通信过程了，完全可以按照这个过程去理解HTTPS的工作原理。但是我为了方便解释，上面有些细节没有说到，有兴趣的人可以看下这部分的内容。可以跳过不看，无关紧要。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;【问题1】&lt;/p&gt;
&lt;p&gt;上面的通信过程中说到，在检查完证书后，“客户”发送一个随机的字符串给“服务器”去用私钥加密，以便判断对方是否真的持有私钥。但是有一个问题，“黑客”也可以发送一个字符串给“服务器”去加密并且得到加密后的内容，这样对于“服务器”来说是不安全的，因为黑客可以发送一些简单的有规律的字符串给“服务器”加密，从而寻找加密的规律，有可能威胁到私钥的安全。所以说，“服务器”随随便便用私钥去加密一个来路不明的字符串并把结果发送给对方是不安全的。&lt;/p&gt;
&lt;p&gt;〖解决方法〗&lt;/p&gt;
&lt;p&gt;每次收到“客户”发来的要加密的的字符串时，“服务器”并不是真正的加密这个字符串本身，而是把这个字符串进行一个hash计算，加密这个字符串的hash值(不加密原来的字符串)后发送给“客户”，“客户”收到后解密这个hash值并自己计算字符串的hash值然后进行对比是否一致。也就是说，“服务器”不直接加密收到的字符串，而是加密这个字符串的一个hash值，这样就避免了加密那些有规律的字符串，从而降低被破解的机率。“客户”自己发送的字符串，因此它自己可以计算字符串的hash值，然后再把“服务器”发送过来的加密的hash值和自己计算的进行对比，同样也能确定对方是否是“服务器”。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;【问题2】&lt;/p&gt;
&lt;p&gt;在双方的通信过程中，“黑客”可以截获发送的加密了的内容，虽然他无法解密这个内容，但是他可以捣乱，例如把信息原封不动的发送多次，扰乱通信过程。&lt;/p&gt;
&lt;p&gt;〖解决方法〗&lt;/p&gt;
&lt;p&gt;可以给通信的内容加上一个序号或者一个随机的值，如果“客户”或者“服务器”接收到的信息中有之前出现过的序号或者随机值，那么说明有人在通信过程中重发信息内容进行捣乱，双方会立刻停止通信。有人可能会问，如果有人一直这么捣乱怎么办？那不是无法通信了？ 答案是的确是这样的，例如有人控制了你连接互联网的路由器，他的确可以针对你。但是一些重要的应用，例如军队或者政府的内部网络，它们都不使用我们平时使用的公网，因此一般人不会破坏到他们的通信。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;【问题3】&lt;/p&gt;
&lt;p&gt;在双方的通信过程中，“黑客”除了简单的重复发送截获的消息之外，还可以修改截获后的密文修改后再发送，因为修改的是密文，虽然不能完全控制消息解密后的内容，但是仍然会破坏解密后的密文。因此发送过程如果黑客对密文进行了修改，“客户”和“服务器”是无法判断密文是否被修改的。虽然不一定能达到目的，但是“黑客”可以一直这样碰碰运气。&lt;/p&gt;
&lt;p&gt;〖解决方法〗&lt;/p&gt;
&lt;p&gt;在每次发送信息时，先对信息的内容进行一个hash计算得出一个hash值，将信息的内容和这个hash值一起加密后发送。接收方在收到后进行解密得到明文的内容和hash值，然后接收方再自己对收到信息内容做一次hash计算，与收到的hash值进行对比看是否匹配，如果匹配就说明信息在传输过程中没有被修改过。如果不匹配说明中途有人故意对加密数据进行了修改，立刻中断通话过程后做其它处理。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h5&gt;3. 证书的构成和原理&lt;/h5&gt;
&lt;h6&gt;3.1 证书的构成和原理&lt;/h6&gt;
&lt;p&gt;之前已经大概说了一个证书由什么构成，但是没有仔细进行介绍，这里对证书的内容做一个详细的介绍。先看下一个证书到底是个什么东西，在windows下查看一个证书时，界面是这样的，我们主要关注一下Details Tab页，其中的内容比较长，我滚动内容后后抓了三个图，把完整的信息显示出来：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/149c3cd31576c0abfd982423eaff8aab.png&quot; rel=&quot;lightbox[74614]&quot; title=&quot;数字证书原理&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-74615&quot; alt=&quot;certificateDetails_thumb&quot; src=&quot;/images/jobbole.com/9979e5d6c6d6217908596b4e50bc790c.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;文中首先解释了加密解密的一些基础知识和概念，然后通过一个加密通信过程的例子说明了加密算法的作用，以及数字证书的出现所起的作用。接着对数字证书做一个详细的解释，并讨论一下windows中数字证书的管理，最后演示使用makecert生成数字证书。如果发现文中有错误的地方，或者有什么地方说得不够清楚，欢迎指出！&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h5&gt;1、基础知识&lt;/h5&gt;
&lt;p&gt;这部分内容主要解释一些概念和术语，最好是先理解这部分内容。&lt;/p&gt;
&lt;h6&gt;1.1、公钥密码体制(public-key cryptography)&lt;/h6&gt;
&lt;p&gt;公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。&lt;/li&gt;
&lt;li&gt;解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;1.2、对称加密算法(symmetric key algorithms)&lt;/h6&gt;
&lt;p&gt;在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;// 密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥。&lt;/p&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h6&gt;1.3、非对称加密算法(asymmetric key algorithms)&lt;/h6&gt;
&lt;p&gt;在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。前面所说的公钥密码体制就是一种非对称加密算法，他的公钥和是私钥是不能相同的，也就是说加密使用的密钥和解密使用的密钥不同，因此它是一个非对称加密算法。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;1.4、RSA简介&lt;/h6&gt;
&lt;p&gt;RSA是一种公钥密码体制，现在使用得很广泛。如果对RSA本身有兴趣的，后面看我有没有时间写个RSA的具体介绍。&lt;/p&gt;
&lt;p&gt;RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，&lt;strong&gt;RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;1.5、签名和加密&lt;/h6&gt;
&lt;p&gt;我们说加密，是指对某个内容加密，加密后的内容还可以通过解密进行还原。 比如我们把一封邮件进行加密，加密后的内容在网络上进行传输，接收者在收到后，通过解密可以还原邮件的真实内容。&lt;/p&gt;
&lt;p&gt;这里主要解释一下签名，签名就是在&lt;strong&gt;信息&lt;/strong&gt;的后面再加上一段内容，可以证明&lt;strong&gt;信息&lt;/strong&gt;没有被修改过，怎么样可以达到这个效果呢？一般是对&lt;strong&gt;信息&lt;/strong&gt;做一个hash计算得到一个hash值，注意，这个过程是不可逆的，也就是说无法通过hash值得出原来的&lt;strong&gt;信息&lt;/strong&gt;内容。在把&lt;strong&gt;信息&lt;/strong&gt;发送出去时，把这个hash值加密后做为一个签名和&lt;strong&gt;信息&lt;/strong&gt;一起发出去。 接收方在收到&lt;strong&gt;信息&lt;/strong&gt;后，会重新计算&lt;strong&gt;信息&lt;/strong&gt;的hash值，并和&lt;strong&gt;信息&lt;/strong&gt;所附带的hash值(解密后)进行对比，如果一致，就说明信息的内容没有被修改过，因为这里hash计算可以保证不同的内容一定会得到不同的hash值，所以只要内容一被修改，根据&lt;strong&gt;信息&lt;/strong&gt;内容计算的hash值就会变化。当然，不怀好意的人也可以修改&lt;strong&gt;信息&lt;/strong&gt;内容的同时也修改hash值，从而让它们可以相匹配，为了防止这种情况，hash值一般都会加密后(也就是签名)再和&lt;strong&gt;信息&lt;/strong&gt;一起发送，以保证这个hash值不被修改。至于如何让别人可以解密这个签名，这个过程涉及到数字证书等概念，我们后面在说到数字证书时再详细说明，这里您先只需先理解签名的这个概念。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h5&gt;2、一个加密通信过程的演化&lt;/h5&gt;
&lt;p&gt;我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;2.1 第一回合：&lt;/h6&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：？？？？&lt;/p&gt;
&lt;p&gt;因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“客户”-&amp;gt;“黑客”：你好&lt;/strong&gt;        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;2.2 第二回合：&lt;/h6&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;// &lt;strong&gt;注&lt;/strong&gt;意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的&lt;/strong&gt; {你好，我是服务器}[私钥|RSA]&lt;strong&gt;  就表示用私钥对&lt;/strong&gt;“你好，我是服务器”&lt;strong&gt;进行加密后的结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。&lt;/p&gt;
&lt;p&gt;“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，&lt;strong&gt;由并且只能由&lt;/strong&gt;公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。&lt;/p&gt;
&lt;p&gt;假设“黑客”想冒充“服务器”：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“客户”-&amp;gt;“黑客”：向我证明你就是服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]&lt;/strong&gt;    //这里黑客无法冒充，因为他不知道&lt;strong&gt;私钥&lt;/strong&gt;，无法用&lt;strong&gt;私钥&lt;/strong&gt;加密某个字符串后发送给客户去验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“客户”-&amp;gt;“黑客”：？？？？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！&lt;/p&gt;
&lt;p&gt;到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;2.3 第三回合：&lt;/h6&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：{你的余额是100元}[私钥|RSA]&lt;/p&gt;
&lt;p&gt;注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。&lt;/p&gt;
&lt;p&gt;这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;2.4 第四回合：&lt;/h6&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：{OK，收到！}[密钥|对称加密算法]&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：{你的余额是100元}[密钥|对称加密算法]&lt;/p&gt;
&lt;p&gt;在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。&lt;/p&gt;
&lt;p&gt;由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)&lt;/p&gt;
&lt;p&gt;到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：&lt;/p&gt;
&lt;p&gt;a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。&lt;/p&gt;
&lt;p&gt;b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。&lt;/p&gt;
&lt;p&gt;但是这个两个方法都有一定的问题，&lt;/p&gt;
&lt;p&gt;对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。&lt;/p&gt;
&lt;p&gt;对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“黑客”：你好           //黑客截获“客户”发给“服务器”的消息&lt;/p&gt;
&lt;p&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“黑客”：向我证明你就是服务器&lt;/p&gt;
&lt;p&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”&lt;/p&gt;
&lt;p&gt;因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。&lt;strong&gt;这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 &lt;/strong&gt;如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;证书的发布机构&lt;/li&gt;
&lt;li&gt;证书的有效期&lt;/li&gt;
&lt;li&gt;公钥&lt;/li&gt;
&lt;li&gt;证书所有者（Subject）&lt;/li&gt;
&lt;li&gt;签名所使用的算法&lt;/li&gt;
&lt;li&gt;指纹以及指纹算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，&lt;strong&gt;数字证书可以保证&lt;strong&gt;数字&lt;/strong&gt;证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份&lt;/strong&gt;。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;2.5 第五回合：&lt;/h6&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]&lt;/p&gt;
&lt;p&gt;注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;2.6 完整过程：&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;step1&lt;/strong&gt;： “客户”向服务端发送一个通信请求&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：你好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step2&lt;/strong&gt;： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器，这里是我的数字证书&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step3&lt;/strong&gt;： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：{一个随机字符串}[私钥|RSA]&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step4&lt;/strong&gt;： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]&lt;/p&gt;
&lt;p&gt;“客户”-&amp;gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]&lt;/p&gt;
&lt;p&gt;“服务器”-&amp;gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]&lt;/p&gt;
&lt;p&gt;…… //继续其它的通信&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h6&gt;&lt;strong&gt;2.7 其它问题：&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;上面的过程已经十分接近HTTPS的真实通信过程了，完全可以按照这个过程去理解HTTPS的工作原理。但是我为了方便解释，上面有些细节没有说到，有兴趣的人可以看下这部分的内容。可以跳过不看，无关紧要。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;【问题1】&lt;/p&gt;
&lt;p&gt;上面的通信过程中说到，在检查完证书后，“客户”发送一个随机的字符串给“服务器”去用私钥加密，以便判断对方是否真的持有私钥。但是有一个问题，“黑客”也可以发送一个字符串给“服务器”去加密并且得到加密后的内容，这样对于“服务器”来说是不安全的，因为黑客可以发送一些简单的有规律的字符串给“服务器”加密，从而寻找加密的规律，有可能威胁到私钥的安全。所以说，“服务器”随随便便用私钥去加密一个来路不明的字符串并把结果发送给对方是不安全的。&lt;/p&gt;
&lt;p&gt;〖解决方法〗&lt;/p&gt;
&lt;p&gt;每次收到“客户”发来的要加密的的字符串时，“服务器”并不是真正的加密这个字符串本身，而是把这个字符串进行一个hash计算，加密这个字符串的hash值(不加密原来的字符串)后发送给“客户”，“客户”收到后解密这个hash值并自己计算字符串的hash值然后进行对比是否一致。也就是说，“服务器”不直接加密收到的字符串，而是加密这个字符串的一个hash值，这样就避免了加密那些有规律的字符串，从而降低被破解的机率。“客户”自己发送的字符串，因此它自己可以计算字符串的hash值，然后再把“服务器”发送过来的加密的hash值和自己计算的进行对比，同样也能确定对方是否是“服务器”。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;【问题2】&lt;/p&gt;
&lt;p&gt;在双方的通信过程中，“黑客”可以截获发送的加密了的内容，虽然他无法解密这个内容，但是他可以捣乱，例如把信息原封不动的发送多次，扰乱通信过程。&lt;/p&gt;
&lt;p&gt;〖解决方法〗&lt;/p&gt;
&lt;p&gt;可以给通信的内容加上一个序号或者一个随机的值，如果“客户”或者“服务器”接收到的信息中有之前出现过的序号或者随机值，那么说明有人在通信过程中重发信息内容进行捣乱，双方会立刻停止通信。有人可能会问，如果有人一直这么捣乱怎么办？那不是无法通信了？ 答案是的确是这样的，例如有人控制了你连接互联网的路由器，他的确可以针对你。但是一些重要的应用，例如军队或者政府的内部网络，它们都不使用我们平时使用的公网，因此一般人不会破坏到他们的通信。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;【问题3】&lt;/p&gt;
&lt;p&gt;在双方的通信过程中，“黑客”除了简单的重复发送截获的消息之外，还可以修改截获后的密文修改后再发送，因为修改的是密文，虽然不能完全控制消息解密后的内容，但是仍然会破坏解密后的密文。因此发送过程如果黑客对密文进行了修改，“客户”和“服务器”是无法判断密文是否被修改的。虽然不一定能达到目的，但是“黑客”可以一直这样碰碰运气。&lt;/p&gt;
&lt;p&gt;〖解决方法〗&lt;/p&gt;
&lt;p&gt;在每次发送信息时，先对信息的内容进行一个hash计算得出一个hash值，将信息的内容和这个hash值一起加密后发送。接收方在收到后进行解密得到明文的内容和hash值，然后接收方再自己对收到信息内容做一次hash计算，与收到的hash值进行对比看是否匹配，如果匹配就说明信息在传输过程中没有被修改过。如果不匹配说明中途有人故意对加密数据进行了修改，立刻中断通话过程后做其它处理。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h5&gt;3. 证书的构成和原理&lt;/h5&gt;
&lt;h6&gt;3.1 证书的构成和原理&lt;/h6&gt;
&lt;p&gt;之前已经大概说了一个证书由什么构成，但是没有仔细进行介绍，这里对证书的内容做一个详细的介绍。先看下一个证书到底是个什么东西，在windows下查看一个证书时，界面是这样的，我们主要关注一下Details Tab页，其中的内容比较长，我滚动内容后后抓了三个图，把完整的信息显示出来：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/3b43a1fa4354156cbd2ad40b6fd1b638.png&quot; rel=&quot;lightbox[74614]&quot; title=&quot;数字证书原理&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-74616&quot; alt=&quot;2009121816032340&quot; src=&quot;/images/jobbole.com/497e3ecd7ee5e85812305d5768ede5fc.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;上面的步骤结束后，会又弹出一个对话框，里面有三个单选按钮如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;My user account&lt;/li&gt;
&lt;li&gt;Service account&lt;/li&gt;
&lt;li&gt;Computer account&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以选择第一或者第三个选项，用来查看当前用户的证书或整个计算里面安装的证书。我们这里就默认选择第一个，平时一般安装证书的时候都会给所有用户安装，所以选择第一个和第三个选项看到的证书会差不多。我们在左边的导航树中选中受信任的证书发布机构(Trusted Root Certificate Authorities)，然后点击下面的证书(Certificates)，在右边的区域中就可以看到所有的受信任的证书发布机构的证书。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/77823c8c43e1168f66738b58f71302cb.png&quot; rel=&quot;lightbox[74614]&quot; title=&quot;数字证书原理&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-74617&quot; alt=&quot;trustedcaAuth_thumb&quot; src=&quot;/images/jobbole.com/33a24871062fcc3175e7e62aa759cfa8.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;注意上面的图片中，右边我们选中的这个证书发布机构”SecureTrust CA”，我们前面在第3章3.2节中举例子的时候，就是去向这个证书发布机构申请的证书，由于我们申请的证书是这个机构发布的，所以应用程序在检查我们的证书的发布机构时(会检查我们证书的签名，确认是该机构发布的证书)，就会发现是可以信任的证书发布机构，从而就会相信我们证书的真实性。&lt;/p&gt;
&lt;p&gt;删除数字证书很简单，直接在右边的列表中右键然后删除就可以了。&lt;/p&gt;
&lt;p&gt;数字证书的安装也比较简单，直接双击数字证书文件，会打开数字证书，对话框下面会有一个Install Certificate按钮，点击后就可以根据向导进行安装，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/fb462dcb5609578b955317d5ae8772411.png&quot; rel=&quot;lightbox[74614]&quot; title=&quot;数字证书原理&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-74620&quot; alt=&quot;installCertificate_thumb_1&quot; src=&quot;/images/jobbole.com/caa28b56eb5e3fd6725a50fcaa2a774b.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个证书是我自己生成的测试证书，在证书的导入向导里面，它会让你选择导入到什么位置，如果是一个我们自己信任的证书发布机构自己的证书，只要导入到Certificate Authorities就可以了。Trusted Root Certificate Authorities, Intermediate Certification Authorities, Third-Party Root Certification Authorities 都是可以的，他们只是对证书的发布机构做了一个分类，还有一些其它的证书类型，例如Personal(个人证书)等等，具体就不介绍了。安装的时候一般来说可以用默认的选择项一直”下一步”到底。&lt;/p&gt;
&lt;h6&gt;4.2 如何自己创建证书&lt;/h6&gt;
&lt;p&gt;每个证书发布机构都有自己的用来创建证书的工具，当然，具体他们怎么去创建一个证书的我也不太清楚，不同类型的证书都有一定的格式和规范，我没有仔细去研究过这部分内容。 微软为我们提供了一个用来创建证书的工具makecert.exe，在安装Visual Studio的时候会安装上。如果没有安装也无所谓，可以上网去下一个，搜索&lt;strong&gt;makecert&lt;/strong&gt;就可以了。可以直接从我的博客下载，这是&lt;a href=&quot;http://files.cnblogs.com/JefferySun/makecert.zip&quot;&gt;链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;向一些正规的证书发布机构申请证书一般是要收费的(因为别人要花时间检查你的身份，确认有没有同名的证书等等)，这里我们看下如何自己创建一个证书，为后面在IIS中配置Https做准备。&lt;/p&gt;
&lt;p&gt;我们用到的是&lt;strong&gt;makecert&lt;/strong&gt;这个工具，微软有很详细的使用帮助，我这里只做一个简单的解释，详细的各种参数和使用方法请查看&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/bfsktky3(VS.80).aspx&quot;&gt;MSDN的makecert的帮助&lt;/a&gt;。但是里面有些参数说得不够清楚，而且还有遗漏的，可以参看我后面的解释作为一个补充。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;先看下&lt;strong&gt;makecert&lt;/strong&gt;最简单的使用方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;makecert.exe test.cer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的命令会在makecert.exe所在的目录生成一个证书文件test.cer的数字证书文件。可以双击证书打开，看看证书的内容如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/b9d5f834ceb3db959cee0a69c7e3de97.png&quot; rel=&quot;lightbox[74614]&quot; title=&quot;数字证书原理&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-74624&quot; alt=&quot;testCertificate1_thumb (1)&quot; src=&quot;/images/jobbole.com/d829e3d1305aa7ac585811e1ff446b20.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;证书的发布机构是”Root Agency”，证书的主题(证书发布给谁)是”Joe’s-Software-Emporium”，因为我们没有指定把证书发布给谁，makecert自己给我们随便生成了一个公司的名字。另外还指定了公钥、签名算法(用来解密签名)、指纹和指纹算法等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;，因为这个证书是由微软的工具生成的，严格来说它没什么发布机构，所以微软虚拟了一个叫做”Root Agency”的发布机构，默认情况下，windows里面安装了这个所谓的证书发布机构的证书，但是这证书默认情况下不是受信任的，原因很简单，这样做大家都可以用makecert来制作合法的数字证书了。如果我们自己硬是要，也可以把它设置为受信任的。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;下面我们看下其它的参数，比如我们要给网站 www.jefferysun.com 生成一个证书MyCA.cer，假设我们把makecert.exe放在C：盘下，命令行如下：&lt;/p&gt;
&lt;div id=&quot;_mcePaste&quot;&gt;makecert -r -pe -n “CN=10.30.146.206″ -b 01/01/2000 -e 01/01/2036 -eku 1.3.6.1.5.5.7.3.1 -ss my -sr localMachine -sky exchange -sp “Microsoft RSA SChannel Cryptographic Provider” -sy 12&lt;/div&gt;
&lt;p&gt;C:\&amp;gt; makecert.exe –pe -r  –n  “CN=www.jefferysun.com” -ss my -sr LocalMachine -a sha1 -len 2048  MyCA.cer&lt;/p&gt;
&lt;p&gt;解释一下makecert的常用参数的意思：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;-n&lt;/strong&gt; 指定主题的名字，这个是有固定的格式的， CN=主题名字 ，CN应该是Certificate Name的缩写。我这里的主题的名字就是我们的IIS所在机器的IP。这里可以指定一些主题的其它附加信息，例如 O= *** 表示组织信息等等。&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;-r&lt;/strong&gt; 创建自签署证书，意思就是说在生成证书时，将证书的发布机构设置为自己。&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;-pe&lt;/strong&gt; 将所生成的私钥标记为可导出。注意，服务器发送证书给客户端的时候，客户端只能从证书里面获取公钥，私钥是无法获取的。如果我们指定了这个参数，证书在安装在机器上后，我们还可以从证书中导出私钥，默认情况下是不能导出私钥的。正规的途径发布的证书，是不可能让你导出私钥的。&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;-b –e&lt;/strong&gt; 证书的有效期&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;-ss&lt;/strong&gt; 证书的存储名称，就是windows证书存储区的目录名，如果不存在在的话就创建一个。&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;-sr&lt;/strong&gt; 证书的存储位置，只有currentuser（默认值）或 localmachine两个值。&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;-sv&lt;/strong&gt; 指定保存私钥的文件，文件里面除了包含私钥外，其实也包含了证书。这个文件是需要保密的，这个文件在服务端配置时是需要用到的。&lt;/li&gt;
&lt;li&gt;这个CN=10.30.146.206要与自己的服务器相对应，要不然在配置HTTPS的时候会出现错误&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;-a&lt;/strong&gt; 指定签名算法，必须是md5或rsa1。(还记得签名算法的作用不？可以看一下3章的第1节中关于签名算法的介绍)&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;-in&lt;/strong&gt; 指定证书发布机构的名称&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;-len&lt;/strong&gt; 这个参数在中文的帮助文档中好像没有提到，但是这个其实很重要，用于指定公钥的位数，越大越安全，默认值是1024，推荐2048。我试了下，这个不为1024的倍数也是可以的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成证书后可以进行安装，安装过程可以参看4.1节。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Thu, 31 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-31-74614-e5103064d.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-31-74614-e5103064d.html</guid>
        
        
      </item>
    
      <item>
        <title>优化你的css</title>
        <description>

		&lt;blockquote&gt;&lt;p&gt;
  优化你的css，是优化你的xxx系列的第一篇，后续会推出多篇，欢迎大家来关注&lt;a href=&quot;http://weibo.com/mbuweb&quot;&gt;移动云前端小组&lt;/a&gt;获取最新文章。
&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;系列概述&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;
  在移动web兴起的年代，速度优化重新被大家重视起来，因为手机的网络环境和性能比PC端差了很多，估计大家也能感觉到用手机打开网页的时候，能明显感觉到页面蜗牛般的速度。&lt;/p&gt;
&lt;p&gt;  这个系列的优化会以移动环境为基础，当然绝大多数规则也同样适合PC端。
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;优化的基本原则&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;
  速度优化有一些基本思路，提前总结一下
&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;按需加载(只加载你需要的)&lt;/li&gt;
&lt;li&gt;并行(让串行的事情并行起来)&lt;/li&gt;
&lt;li&gt;压缩(通过压缩减少体积)&lt;/li&gt;
&lt;li&gt;缓存(利用缓存，减少请求等待)&lt;/li&gt;
&lt;li&gt;预测(预测用户行为，提前发出请求)&lt;/li&gt;
&lt;li&gt;合并(把多个零散文件合并起来，减少请求)&lt;/li&gt;
&lt;li&gt;自动化(让速度优化变成一种常规，和自动化工具(例如gulp,grunt,fis)结合，减少成本)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;进入正题，优化你的css&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;
  为什么第一篇讲css，因为css是最难优化的，图片和js你都可以延迟加载，而css不可以，你必须在dom前面加载css，你必须接受css阻塞dom渲染的现实。
&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;css优化之压缩(cssshrink)&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;
  我们一般都会对css进行常规压缩，主要做去空格和换行的工作。这里推荐的cssshrink会做更精细的工作，cssshrink会首先通过css parser对css进行解析，然后有针对性的进行优化。例如会吧0px和0%转换成0，bold转换成700，字符级别的极致压缩，为作者点个赞。
&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;cssshrink具体的优化策略，&lt;a href=&quot;http://cssshrink.com/velocity&quot;&gt;点此查看&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;cssshrink &lt;a href=&quot;https://github.com/stoyan/cssshrink&quot;&gt;GitHub地址&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;css优化之合并&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用gulp-concat将多个css合并在一起&lt;/li&gt;
&lt;li&gt;不要使用@import 减少阻塞和请求&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;css拆分&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;
  看起来和上面有些冲突，这也是css和其它部分优化不同的地方。 一般我们大家都习惯把css放在最上面，js放在最下面。这是一个好习惯，但是对于css来说并不是最好的选择。&lt;/p&gt;
&lt;p&gt;  在移动端，大家非常重视首屏时间，也就是用户看到页面的时间。把整个页面的css都放在最上面，大量首屏用不到的css会阻塞首屏的展现。
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;head只放首屏能用到的css，首屏外的css下移&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;css使用率&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;
  一般页面经过多人维护后，会产生大量用不到css，大家也不敢随意删除，这就需要一些检测工具
&lt;/p&gt;&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/demohi/unu&quot;&gt;unu&lt;/a&gt;&lt;br&gt;
1.1 unu是一个用来检测页面哪些css没有用到的Node.js模块&lt;br&gt;
1.2 优点：提供&lt;a href=&quot;https://github.com/demohi/unu-web&quot;&gt;可视化界面&lt;/a&gt;,使用非常简单，输入url，即可查看页面css的使用情况&lt;br&gt;
1.3 缺点：目前只支持style标签式的css，另外没有执行页面的js&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/giakki/uncss&quot;&gt;uncss&lt;/a&gt;&lt;br&gt;
2.1 uncss是可以把页面css没有用到去除的模块&lt;br&gt;
2.2 优点：支持命令行和gulp、grunt插件，支持link方式，基于phantomjs，模拟浏览器执行，支持js执行&lt;br&gt;
2.3 缺点：仅凭一个url导出的css，不具有实际价值，另外不支持style标签&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/addyosmani/critical&quot;&gt;critical&lt;/a&gt;&lt;br&gt;
3.1 critical是一个用来检测首屏css有哪些没用到的模块&lt;br&gt;
3.2优点：可以输入首屏宽高来检测、有gulp、grunt插件&lt;br&gt;
3.3 缺点：不支持url，只支持本地html，不支持style标签&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;
  速度优化对于开发人员来说是件降低生产力的事情，所以需要尽可能的自动化，设置好规则，无痛优化，同时避免后续恶化。
&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;有任何问题，欢迎&lt;/p&gt;
			&lt;!-- .entry-content --&gt;

</description>
        <pubDate>Thu, 31 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-31-%25e4%25bc%2598%25e5%258c%2596%25e4%25bd%25a0%25e7%259a%2584css.html-2280d8aae.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-31-%25e4%25bc%2598%25e5%258c%2596%25e4%25bd%25a0%25e7%259a%2584css.html-2280d8aae.html</guid>
        
        
      </item>
    
      <item>
        <title>SQL/NoSQL两大阵营激辩：谁更适合大数据</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/0ac9bfe413ce35ed7450ca428b4aba5c.jpg&quot; rel=&quot;lightbox[74548]&quot; title=&quot;SQL/NoSQL两大阵营激辩：谁更适合大数据&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-74549&quot; alt=&quot;291727418377831&quot; src=&quot;/images/jobbole.com/2b867e6c170274b71c49657cf4a7288d.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;企业在着手推动大数据项目的过程中，经常会遇到这样一个关键性的决策难题——到底该使用哪种数据库方案?经过综合考量，最终的选项往往只剩下 SQL 与 NoSQL 两种。SQL 具有骄人的业绩以及庞大的安装基础，但 NoSQL 却能够带来可观的收益并同样拥有不少支持者。在今天的辩论当中，我们将一同听听两大阵营中各位专家的意见。&lt;/p&gt;
&lt;p&gt;Network World 网站主编 John Dix 专门组织了此次辩论并邀请到多位专家。其中两位参与专家分别是 VoltDB 公司 CTO Ryan Betts 和 Couchbase 公司 CEO Bob Wiederhold。Ryan Betts 认为 SQL 已经在大型企业当中赢得了稳定的生存空间，而大数据只不过是 SQL 需要支撑的另一项工作内容。Bob Wiederhold 则认为 NoSQL 是一套极具可行性的备选方案，事实上它也在多个领域中成为大数据的卓越配合手段——特别是在可扩展性方面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;观点一：SQL 已经通过时间考验，且仍蓬勃发展——&lt;/strong&gt;VoltDB 公司 CTO Ryan Betts&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结构化查询语言(简称 SQL)几十年来已经用累累战果以及赫赫声名证明了自身实力，而且目前仍在继续投身于多家大数据厂商及相关企业当中，其中包括谷歌、Facebook、Cloudera 以及 Apache。&lt;/p&gt;
&lt;p&gt;虽然后起之秀 NoSQL 确实引起了一定反响，但 SQL 仍然在市场上保持着显著的份额优势并继续在大数据领域不断赢得投入与采纳。&lt;/p&gt;
&lt;p&gt;一旦某种技术像 SQL 这样取得了主导地位，人们往往会忘记其最为核心的竞争优势。SQL 之所以能够胜出，主要在于它拥有以下一系列独特的优势组合：&lt;/p&gt;
&lt;p&gt;1. SQL 能够加强与数据之间的互动，允许用户针对单一数据库设计提出内容广泛的问题。这正是 SQL 成功的关键所在——如果数据不具备互动性、则基本上将失去实用性。而持续增长的互动性又能为数据库的未来发展带来新的审视角度、相关问题以及实际意义。&lt;/p&gt;
&lt;p&gt;2. SQL 具备标准化特性，允许用户自由运用源自各类系统的专业知识、同时支持第三方插件及工具。&lt;/p&gt;
&lt;p&gt;3. SQL 具备扩展性、功能丰富且经过实际验证，能够解决各类难题——包括以写入为主导的快速事务处理以及涉及频繁扫描的深层分析。&lt;/p&gt;
&lt;p&gt;4. SQL 能够与数据表现及存储机制顺畅对接。某些 SQL 系统还支持 JSON 以及其它结构化对象格式，从而带来优于 NoSQL 方案的性能表现及更多功能特性。&lt;/p&gt;
&lt;p&gt;“NoSQL”这一表述其实并不准确，但在本次讨论中，我采用了 Rick Cattell 博士为 NoSQL 总结出的定义，即“指那些能够提供键/值存储或者简单记录与索引等操作的系统，旨在为这些简单操作提供垂直可扩展性。”&lt;/p&gt;
&lt;p&gt;很明显，目前市面上的很多新型数据库彼此之间存在较大差异——准确掌握它们各自特性与深层机制给用户来的便利与局限是获得项目部署成功的关键所在。NoSQL 的核心特性使其更适合于解决特定问题。举例来说，图形数据库更适合处理那些将数据根据关系而非传统行或者文档形式加以组织的实例，而特定文本搜索系统则比较擅长处理以实时方式查询用户输入内容的情况。&lt;/p&gt;
&lt;p&gt;在这里，我打算概括性阐述 SQL 系统与简单键/值乃至仅仅在存储格式及可扩展性方面有所创新的 JSON 对象存储系统相比，到底存在哪些差异与主要优势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;* SQL 带来交互特性。&lt;/strong&gt;SQL 是一种声明性查询语言。用户说出自己想要的内容(例如显示出过去五年来，每年三月份购买量最大的客户分别来自哪些地区)，数据库则在内部组建出相关算法并根据要求提取对应结果。相比之下，NoSQL 孕育出的编码创新成果 MapReduce 则是一种规程化查询技术。MapReduce 要求用户不仅了解自己想要的结果，同时也需要提供获取结果的具体执行方式。&lt;/p&gt;
&lt;p&gt;虽然听起来只是一种颇为枯燥的技术性差异，但这种特性仍然极为关键，原因有以下两点：首先，声明性 SQL 查询能够更为轻松地通过图形化工具以及对报告生成器的简单点击来创建。这种相对较低的使用门槛能够帮助分析师、运营者、管理者以及其他不了解软件编程知识的用户享受其核心功能及成效。第二，对数据库引擎使用内部信息并选择高效算法的方式进行抽象化处理。即使物理层或者数据库索引出现变动，优化算法仍然能够确切完成任务。相比之下，在过去的程序化系统当中、程序员需要重新审视现有处理方式并进行二次编程。这样既带来高昂成本，又很有可能导致意外错误。&lt;/p&gt;
&lt;p&gt;市场对于这种本质差异倒是非常了然。早在 2010 年，谷歌就宣布引入一套 SQL 方案以强化 MapReduce，从而满足内部用户的实际需求。最近，Facebook 则发布了自己的 SQL 方案 Presto，意在对其 PB 级别 HDFS 集群数据进行查询。根据 Facebook 方面的说法：“由于我们的数据仓库规模已经增长至 PB 级别、业务需求也逐步发展，我们显然需要一套经过优化的交互式系统以实现更低的查询延迟。”除此之外，Cloudera 正在 HDFS 以上建立自己的 SQL 方案 Impala。前面提到的这一系列发展都立足于 Hive——一套面向 Hadoop、长期存在且得到广泛采用的 SQL 外壳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;* SQL 具备标准化特性。&lt;/strong&gt;虽然供应商有时候会对自己的 SQL 接口进行特殊调整与定制，但从本质上讲 SQL 内核仍然是一套标准化程度很高的方案，以 ODBC 以及 JDBC 为代表的其它规范同样提供广泛可用的、面向 SQL 系统的稳定接口。由此衍生出的管理及操作工具生态系统能够帮助大家以 SQL 系统为基础，实现应用程序的设计、监控、检查、探索以及开发。&lt;/p&gt;
&lt;p&gt;SQL 用户及程序员也因此得以重新使用自己积累自多种后端系统的 API 以及用户界面知识，从而缩减应用程序开发时间。标准化特性还允许拥有声明许可的第三方打造提取、转换以及加载(简称 ETL)工具，旨在帮助企业以流程化方式处理不同数据库及系统之间的数据流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;* SQL 具备可扩展性。&lt;/strong&gt;有些朋友可能误以为 SQL 必须通过牺牲性能的方式来获得可扩展性，这其实是完全错误的。如上所述，Facebook 打造了一款 SQL 接口对 PB 级别的数据加以查询。SQL 在运行 ACID 事务处理任务时同样具备极快的速度表现。SQL 为数据存储及检索机制提供的抽象化手段允许用户以统一化方式完成处理工作，而且无需考虑具体任务类型以及数据规模;这使得 SQL 能够高效运行在各类集群化副本数据存储体系之间。将 SQL 作为接口的作法不涉及云创建、具体规模或者 HA 系统，而且 SQL 当中也没有任何固有因素会对容错性、高可用性以及复制能力产生限制。事实上，目前所有现代化 SQL 系统都能够很好地支持云体系中的横向可扩展性、复制能力以及容错性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;* SQL 支持 JSON。&lt;/strong&gt;几年之前，很多 SQL 系统开始将 XML 文档支持能力纳入自身设计思路。时至今日，随着 JSON 逐步成为主流数据交换格式之一，各 SQL 厂商也在积极为 JSON 提供支持。鉴于当下敏捷化编程流程以及对互联网接入基础设施正常运行时间的要求，结构化数据类型的支持能力已经成为不可或缺的重要一环。Oracle 12c、PostgreSQL 9.2、VoltDB 以及其它各类数据库方案都开始支持 JSON——其性能基准水平普遍优于“原生”JSON NoSQL 方案。&lt;/p&gt;
&lt;p&gt;SQL 将继续在市场份额的争夺战中占据主动，也将继续吸引到更多投资方与采纳者的支持。NoSQL 数据库在提供专有查询语言或者简单键-值语义的同时，却无法从深入的技术层面带来差异性，这无疑严重影响了其挑战市场统治者的能力。现代 SQL 系统能够在保持甚至超越原有可扩展性的同时，支持丰富的查询语义、建立并培养用户基础、拓展生态系统集成效果并在企业环境内深化采纳程度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;观点二：NoSQL 更适合大数据应用程序&lt;/strong&gt;——Couchbase 公司 CEO Bob Wiederhold&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前已经有越来越多的企业开始将 NoSQL 视为关系型数据库的一种可行性替代方案;特别是在大数据应用程序领域，很多企业用户意识到规模化操作的实际表现要优于标准化集群与商用服务器所带来的效果。除此之外，采用无模式化数据模型往往更适合当下各类不同数据的捕捉与处理工作。&lt;/p&gt;
&lt;p&gt;在 NoSQL 领域讨论大数据话题时，我们主要针对的是操作型数据库当中的读取与写入流程——也就是指人们在日常在线事务处理过程中所涉及的交互任务(例如利用大数据指导在线航班预定)。操作型数据库与分析型数据库有所不同，前者一般需要打理大量数据并收集数据当中所蕴含的分析结论(例如利用大数据分析特定某一天会有多少乘客预定某次航班)。&lt;/p&gt;
&lt;p&gt;不过对于操作型数据库中的大数据而言，其设计主旨并非围绕分析性工作所展开;操作型数据库通常需要为无数用户提供庞大的数据集，帮助他们进行持续性数据访问并进行实时事务处理。用于操作并管理大数据内容的此类数据库都具备庞大的规模，这也解释了 NoSQL 特性的重要意义及其在大数据应用程序中扮演核心角色的原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;* NoSQL 是实现可扩展性的关键所在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术行业在每一次迎来硬件发展的根本性转变时，都必然经历过渡拐点。在数据库领域，这种由向上扩展转为向外扩展架构的转变也成为推动 NoSQL 快速成长的主要因素。关系型数据库，其中包括由甲骨文及 IBM 等巨头所打造的具体方案，专注于解决向上扩展难题。也就是说，它们采取集中式、全局共享技术，只能通过添加价格更为昂贵的硬件设备满足扩展需求。&lt;/p&gt;
&lt;p&gt;与之相反，NoSQL 数据库从设计思路上就考虑到了分布式特性，属于彻头彻尾声的向外扩展技术。它们利用一系列分布式节点(构成一套整体集群)来提供具备卓越弹性的扩展能力，从而帮助用户随意添加更多节点以应对持续增加的工作负载。&lt;/p&gt;
&lt;p&gt;分布式向外扩展方案往往还会带来低于向上扩展机制的使用成本。后者属于一整套庞大、复杂、具备容错性机制的服务器体系，因此无论是设计、建造还是后期支持都会带来高昂的成本支出。商用关系型数据库的许可成本同样不容忽视，因为其计费策略以单一服务器为基本单位。在另一方面，NoSQL 数据库则通常属于开源项目，以服务器集群为整体计费单位、价格也相比较低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;* NoSQL 是实现灵活性的关键所在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关系型与 NoSQL 数据模型可谓完全不同。关系型模型需要将数据拆分成包含行与列的多个关联性表，这些表通过同样保存在列中的外键实现相互引用。&lt;/p&gt;
&lt;p&gt;当用户需要对一组数据进行查询时，所需信息必须由多个表中收集获得——通常涉及数百种当下常用的企业应用程序——并将其加以整合，而后才能交付终端应用。与之相似，在写入数据时、写入流程需要加以协调并在执行过程中面向多个表。当数据量相对较小、向数据库内导入的速度并不太快的情况下，关系型数据库通常具备捕捉并存储信息的能力。不过目前的应用程序通常需要处理海量数据的读取与写入操作、且要求以近实时方式完成，这就超出了操作型数据库的能力范围。&lt;/p&gt;
&lt;p&gt;NoSQL 数据库采取的模式则完全不同。从核心角度看，NoSQL 数据库真正实现了“NoREL”、也就是非关系型，也就是说此类方案在保存并整理信息的过程中并不依赖于表以及各个表之间的关系。举例来说，一套面向文档的 NoSQL 数据库会首先获取到我们需要的数据，而后将其整合成采用 JSON 格式的文档。每个 JSON 文档都可以被视为能供应用程序使用的对象。JSON 文档可以把原本需要 25 个关系型数据库表才能存放的数据保存在同一行当中，并将其整理为单一文档/对象。&lt;/p&gt;
&lt;p&gt;信息汇总工作可能导致信息内容出现重复，不过由于目前存储资源已经不再属于主要成本来源，因此这类数据模型能够带来更出色的灵活性、便于高效分配由此产生的文档并改进读取与写入操作的性能表现、从而提升 Web 应用程序的替代性效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;* NoSQL 是支撑大数据应用的关键所在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时至今日，我们已经能够愈发便捷地通过第三方环境、包括社交媒体网站对数据进行捕捉与访问。个人用户信息、地理位置数据、用户产生的内容、设备登录数据以及传感器数据等只是这股风潮当中的少数典型代表，数据来源清单正在不断拓展。同时，企业也越来越依赖大数据技术的力量、旨在驱动其关键性业务应用。总体而言，各企业已经开始向 NoSQL 伸出橄榄枝，因为这类方案是惟一能够适应当前新兴数据类型的处理手段。&lt;/p&gt;
&lt;p&gt;开发人员需要一套更为灵活、能够轻松适应最新数据类型的数据库方案，从而避免破坏第三方数据供应商所提供的内容结构调整。大部分新型数据属于非结构化或者半结构化类型，因此开发人员还需要自己的数据库有能力高效对其加以保存。遗憾的是，关系型数据库所采取的严格定义、以模式为基础的设计思路令我们无法快速接纳全新数据类型，自然也难以适应非结构化及半结构化数据。NoSQL 带来的数据模型则能够更好地与其实际需求加以映射。&lt;/p&gt;
&lt;p&gt;总体来说，随着 Web 与移动应用程序的不断普及、新兴趋势的推波助澜外加面向在线消费者行为与新型数据类别的转变，业界中的各类流程方案都渴望着一种能够为数据的管理及访问带来可扩展性与灵活性的数据库技术。在这样的背景下，NoSQL 技术正是能够有效满足上述需求的惟一解决方案。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Wed, 30 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-30-74548-27ff28e56.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-30-74548-27ff28e56.html</guid>
        
        
      </item>
    
      <item>
        <title>算法系列：煎饼排序</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;我对算法很感兴趣，这次介绍的煎饼排序问题是在很多算法课程上都介绍过的经典例子。如果这是你第一次接触这个问题，我非常建议你在阅读时先独立思考解决方法。下面我们开始，希望大家喜欢咯。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;煎饼排序： 维基百科给出的释义煎饼排序是数学上的一个问题的一种通俗叫法：对一堆无序的煎饼以大小排序，铲子可以在任意位置伸进去并且把上面的煎饼都翻转过来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通俗点说，我们有一个锅铲和一堆煎饼，我们的目标是将煎饼按照大小排序，大的在下面。我们唯一的办法是让锅铲从一个地方伸进去，并且把上面所有的煎饼翻下来。举个栗子，一开始的煎饼是这样子的：&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/006bcdc17b71a5bf164842458058f98b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们决定在这里铲入：&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/2532f583f72787eedf4ca721c520309c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;红色箭头代表插入位置，蓝色的表示新的煎饼堆底。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1c8217ab14bcd5a5d98745c555aa7b59.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;就是这样！&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;line-height: 15px;&quot;&gt;煎饼排序算法&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（在你往下看之前，我建议你先自己想想解决办法。）&lt;/p&gt;
&lt;p&gt;我现在讲的不是最好的办法，但是却是最直观最容易解释的。我选这种方法是为了向人们展示有些算法是非常容易并且直观的。我希望大家看了以后都能来尝试一下算法。通常，计算机专业会把普通人都吓跑，因为它一开始看上去太令人紧张。在这篇文章最后我将贴上更快的算法的链接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 将问题分解开来：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;我们需要将煎饼排序，初始的形状可能是任意的。&lt;/li&gt;
&lt;li&gt;我们只能对一部分煎饼进行翻转。&lt;/li&gt;
&lt;li&gt;如果想让某一块特定的煎饼在最下面，需要先把它翻到最上面。&lt;/li&gt;
&lt;li&gt;因此想要排好一块煎饼就需要先翻一下把它翻到顶上再把它翻到下面才行。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;凭直觉想出来的算法&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span style=&quot;line-height: 15px;&quot;&gt;把未排序的煎饼中最大（或者顺序在最后）的煎饼翻下去（需要两步）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;重复第一步。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然我们有了算法，那么我们就来思考一下看它正确与否吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只有一个煎饼的时候正确吗？——正确。&lt;/li&gt;
&lt;li&gt;两个煎饼，大的在上，正确吗？——正确，我们翻一下就行了。&lt;/li&gt;
&lt;li&gt;如果有三个煎饼，顺序从上到下依次是：中、大、小，正确吗？正确，我们先把大的翻上去，现在从上到下依次是大、中、小；然后我们再整个翻一下，顺序就变成了小、中、大。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然在这几种简单情况下都是正确的，那么我们不妨用Python写出来吧~（欢迎在Github上Fork我的&lt;a href=&quot;https://github.com/lettergram/pancakesort&quot;&gt;代码&lt;/a&gt;。）&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;# Sorts Pancakes                                                                                    
def sortPancakes(stack):

    sorted_index = 10
    for i in reversed(range(len(stack))):
        stack = flip(stack, findLargestPancake(stack, i))
        print(&quot;Flip Up&quot;, stack)
        stack = flip(stack, i)
        print(&quot;Flip Down&quot;, stack)
    return stack

# All of the pancakes are sorted after index                                                        
# Returns the index of largest unsorted pancake                                                     
def findLargestPancake(stack, index):

    largest_pancake = stack[index]
    largest_index = index;

    for i in range(index):
        if stack[i] &amp;gt; largest_pancake:
            largest_pancake = stack[i]
            largest_index = i

    print &quot;&quot;
    print(&quot;Insert Spatula in index&quot;, largest_index, &quot;Size&quot;, largest_pancake)
    return largest_index

# Slide spatula under pancake at index and flip to top                                              
def flip(stack, index):
    newStack = stack[:(index + 1)]
    newStack.reverse()
    newStack += stack[(index + 1):]
    return newStack

stack = [1, 4, 5, 2, 3, 8, 6, 7, 9, 0]

print&quot;\nUnsorted:&quot;
print stack

print &quot;\nIterating:&quot;
stack = sortPancakes(stack)

print &quot;\nSorted:&quot;
print stack
print &quot;&quot;&lt;/pre&gt;
&lt;p&gt;我们运行一下程序：&lt;/p&gt;
&lt;pre class=&quot;brush: text; gutter: true&quot;&gt;Unsorted: [1, 4, 5, 2, 3, 8, 6, 7, 9, 0]

Iterating:

(‘Insert Spatula in index’, 8, ‘Size’, 9)
 (‘Flip Up’, [9, 7, 6, 8, 3, 2, 5, 4, 1, 0])
 (‘Flip Down’, [0, 1, 4, 5, 2, 3, 8, 6, 7, 9])

(‘Insert Spatula in index’, 6, ‘Size’, 8)
 (‘Flip Up’, [8, 3, 2, 5, 4, 1, 0, 6, 7, 9])
 (‘Flip Down’, [7, 6, 0, 1, 4, 5, 2, 3, 8, 9])

(‘Insert Spatula in index’, 0, ‘Size’, 7)
 (‘Flip Up’, [7, 6, 0, 1, 4, 5, 2, 3, 8, 9])
 (‘Flip Down’, [3, 2, 5, 4, 1, 0, 6, 7, 8, 9])

(‘Insert Spatula in index’, 6, ‘Size’, 6)
 (‘Flip Up’, [6, 0, 1, 4, 5, 2, 3, 7, 8, 9])
 (‘Flip Down’, [3, 2, 5, 4, 1, 0, 6, 7, 8, 9])

(‘Insert Spatula in index’, 2, ‘Size’, 5)
 (‘Flip Up’, [5, 2, 3, 4, 1, 0, 6, 7, 8, 9])
 (‘Flip Down’, [0, 1, 4, 3, 2, 5, 6, 7, 8, 9])

(‘Insert Spatula in index’, 2, ‘Size’, 4)
 (‘Flip Up’, [4, 1, 0, 3, 2, 5, 6, 7, 8, 9])
 (‘Flip Down’, [2, 3, 0, 1, 4, 5, 6, 7, 8, 9])

(‘Insert Spatula in index’, 1, ‘Size’, 3)
 (‘Flip Up’, [3, 2, 0, 1, 4, 5, 6, 7, 8, 9])
 (‘Flip Down’, [1, 0, 2, 3, 4, 5, 6, 7, 8, 9])

(‘Insert Spatula in index’, 2, ‘Size’, 2)
 (‘Flip Up’, [2, 0, 1, 3, 4, 5, 6, 7, 8, 9])
 (‘Flip Down’, [1, 0, 2, 3, 4, 5, 6, 7, 8, 9])

(‘Insert Spatula in index’, 0, ‘Size’, 1)
 (‘Flip Up’, [1, 0, 2, 3, 4, 5, 6, 7, 8, 9])
 (‘Flip Down’, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

(‘Insert Spatula in index’, 0, ‘Size’, 0)
 (‘Flip Up’, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
 (‘Flip Down’, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

Pancake Sort Completed!

Sorted:&amp;lt;em&amp;gt; &amp;lt;/em&amp;gt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&lt;/pre&gt;
&lt;p&gt;成功了！就是这么简单！&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;计算运行时间 &lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算一个算法的运行时间是非常重要的。这可以让你知道问题的复杂程度和规模。在计算机领域我们经常用&lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;大O表示法&lt;/a&gt;（Big-O Notation)，它保证了程序的运行时间一定在这之内。（如果你想不起来或者根本没听说过这个名称，建议你移步&lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;维基。&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;分析这个算法的运行时间还是比较直观的。可以想象，最差的情况是，这堆煎饼是交替的最小和最大。比如[0, 9, 1, 8, 2, 7, 3, 6, 5, 4]。我们需要先把9翻上去，再翻到底下。然后是8、7、6等等。每一个都需要两步，所以总的步数最大是2n-3。n是总的煎饼个数，“-3”是因为当倒数第二个归位了之后倒数第一个的位置自然也就正确了，并且倒数第二个只需要一下。有些Reddit的&lt;a href=&quot;http://www.reddit.com/r/compsci/comments/29a5jd/everyday_algorithms_pancake_sort/&quot;&gt;评论&lt;/a&gt;给我提了建议：为了避免混淆，我们在这里要说清楚我们忽略了”搜索时间“，现在计算的都是翻转所需要的时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;line-height: 15px;&quot;&gt;运行时间（翻转所需要的）：O(n)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;内存大小：O(n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而，我们还没考虑每次搜索最大的煎饼所需要的时间。在我上面的代码中，如果要在翻转之前先找到最大的煎饼，我们必须搜索整个（还未排好序的）煎饼堆。这就使得我们最差的搜索时间成为了n乘以n。因为我们必须把每个都找一遍才能确定哪个是最大的，并且一共有n轮搜索。因此：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;line-height: 15px;&quot;&gt;运行时间：O(n*n)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;内存大小：O(n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还需要说明的一点是，我的程序使用了不多余n的内存：&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;# Slide spatula under pancake at index and flip to top                                              
def flip(stack, index):
    newStack = stack[:(index + 1)]
    newStack.reverse()
    newStack += stack[(index + 1):]
    return newStack&lt;/pre&gt;
&lt;p&gt;我的解法需要O(n+k)的内存，k表示第一次翻转的大小，最大不多余n-1。因此我们的解答需要2n-1或者O(n)的内存。如果我们想避免这些开销我们可以原地翻转，在数组中挨个交换，但是这样代码就不好懂了。&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上介绍的算法不是最快的。如果你还想进一步了解这个问题，我建议你读一下这篇Bill Gates和Christos Papadimitriou写的&lt;a href=&quot;http://www.cs.berkeley.edu/~christos/papers/Bounds%20For%20Sorting%20By%20Prefix%20Reversal.pdf&quot;&gt;论文&lt;/a&gt;，以及Chitturi，Fahle，Meng以及一些其他人写的这篇&lt;a href=&quot;http://www.sciencedirect.com/science/article/pii/S0304397508003575&quot;&gt;论文&lt;/a&gt;。如果你喜欢这篇文章的话，可以来读一下我写的关于计数排序的&lt;a href=&quot;http://austingwalters.com/counting-sort-in-c/&quot;&gt;文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;之后我还会推出一个更难的”烧焦的煎饼问题“：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;每块被翻到过最底下的煎饼被烧焦了，这个排序必须使得每个煎饼的烧焦的那一面在下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个解法将会在我的邮件列表中发给大家，或者你可以看这个&lt;a href=&quot;http://us8.campaign-archive2.com/?u=cb393d7130736f1fef1e65dbf&amp;amp;id=17c1e959eb&quot;&gt;更新&lt;/a&gt;。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Wed, 30 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-30-74263-3d62c6736.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-30-74263-3d62c6736.html</guid>
        
        
      </item>
    
      <item>
        <title>一种开源的部署解决方案-fleet</title>
        <description>

                &lt;p&gt;fleet是coreos的子项目之一， 是一个分布式的container发布工具，用于进行cluster中任务的提交和管理；&lt;/p&gt;
&lt;p&gt;那通过fleet来进行部署发布有何优势？ 需要具备什么样的条件？ 有什么需要考虑的问题 ？&lt;/p&gt;
&lt;p&gt;一、fleet的整体架构&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://noops.me/wp-content/uploads/2014/07/Schedule-Diagram.png&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-1546&quot; alt=&quot;Schedule-Diagram&quot; src=&quot;/images/noops.me/279bfd214f6f59396958cb01f2ef6e5e.jpg&quot; width=&quot;300&quot; height=&quot;202&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;二、fleet的运行机制&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;1、定义systemd的unit描述文件， 描述文件中指定要执行的命令（如启动的docker image或其它命令等），运行该job需要满足的一些依赖条件等;&lt;/div&gt;
&lt;div&gt;2、将该描述文件commit到registry中， Engine检测到新任务创建一个joboffer；&lt;/div&gt;
&lt;div&gt;3、所有线上机器通过fleet agent watch joboffer, 发现自身满足require描述， 则要求执行该任务；&lt;/div&gt;
&lt;div&gt;4、engine将该任务分配给某一agent;&lt;/div&gt;
&lt;div&gt;5、agent启动任务，并把JOB状态反馈到registry中；&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div&gt;三、fleet的特色&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;从fleet的架构中可以看出，它采用了一个与中心化发布完全相反的思路，采用这种方法有什么优势或者哪些值得借鉴呢？&lt;/div&gt;
&lt;div&gt;1、agent主动请求任务，而非控制端发布任务， 弱化了部署前对主机和任务的对应关系的依赖，比较容易就可以进行job copies的控制；&lt;/div&gt;
&lt;div&gt;2、天生具备针对任务的调度功能，在Engine上可以设置各种条件来进行任务的分配；&lt;/div&gt;
&lt;div&gt;2、通过实现中心化的控制端进程远程管理（虽然暂时也用的ssh+信任关系）， 但这个功能对动态调度系统来讲可以说是非常必要的一个功能，即便不能提前知道任务实际会运行在哪里仍然要以轻松进行访问和管理；&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div&gt;四、使用fleet所需要的必要条件&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;1、systemd ——  fleet使用systemd来作为JOB启停管理、状态查询；&lt;/div&gt;
&lt;div&gt;2、docker —— systemd描述文件只描述JOB的启动命令，不包含实际文件，对复杂应用来说，只有封装到docker image中一种方式；&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div&gt;五、fleet在工业应用中还可能的不足&lt;/div&gt;
&lt;div&gt;1、如果想要使fleet作为任务的分发部署管理系统，那么必然要依赖docker, 而 docker应用到工业化中仍然还有很多工作要开展， 如果仅作为任务管理系统，那需要以fleet管理的思路构建一套部署分发系统，比如支持systemd的管理方式；&lt;/div&gt;
&lt;div&gt;2、Engine似乎把任务分发之后MS就没有再管了，后续的事情都通过集中管理工具fleetctl来进行， 也就是说这每一次动作的触发都是主动的。 缺少一个自循环的状态感知机制，比如start了job, 主动停止，它会反馈回状态，但并不会再起一个新任务；如果异常中止，则没有状态反馈；&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            

</description>
        <pubDate>Wed, 30 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-30--p=1545-737411cc8.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-30--p=1545-737411cc8.html</guid>
        
        
      </item>
    
      <item>
        <title>取代cookie的网站追踪技术：”帆布指纹识别”初探</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/7d81d15d0370bd873bcaefb210ee0ab1.jpg&quot; rel=&quot;lightbox[74461]&quot; title=&quot;取代cookie的网站追踪技术：”帆布指纹识别”初探&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-74462&quot; alt=&quot;4b611878ac58d8705d4bad6874bd2a2a&quot; src=&quot;/images/jobbole.com/2e26c1070d5dab4b2b90d63b546c8437.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【前言】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般情况下，网站或者广告联盟都会非常想要一种技术方式可以在网络上精确定位到每一个个体，这样可以通过收集这些个体的数据，通过分析后更加精准的去推送广告（精准化营销）或其他有针对性的一些活动。Cookie技术是非常受欢迎的一种。当用户访问一个网站时，网站可以在用户当前的浏览器Cookie中永久植入一个含有唯一标示符（UUID）的信息，并通过这个信息将用户所有行为（浏览了哪些页面？搜索了哪些关键字？对什么感兴趣？点了哪些按钮？用了哪些功能？看了哪些商品？把哪些放入了购物车等等）关联起来。&lt;/p&gt;
&lt;p&gt;而随着网民对个人隐私的重视，Cookie越来越不受待见。不少安全工具甚至是浏览器都开始允许或引导用户关闭Cookie功能，比如很多主流浏览器都有一个“隐私模式浏览”功能。这样以来，网站就很难追踪用户行为了。但仍然有一些方法可以让网站去追踪每一个访问者的行为，比如通过flash cookie的方式也可以达到唯一标识和追踪的目的。&lt;/p&gt;
&lt;p&gt;笔者近期注意到，国外媒体报道了一种非常难以摆脱的新型在线追踪工具被用来尾随从白宫官网到色情网站YouPorn.com的热门网站的访问者。经过分析，这个就是另一种比较新的访客追踪技术：“帆布指纹识别”技术，具体代码见附录6。这个技术的独特之处是：它不像通过Cookie或者Flash Cookie等之类的方式，你基本是无法屏蔽它的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【原理分析】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者收集整理了很多知名站点上的类似代码，详见附录4，从这些“帆布指纹识别”代码可以看出，均使用到了HTML5专属标签&amp;lt;canvas&amp;gt;的一个现状：在绘制canvas图片时，同样的canvas绘制代码，不同机器和浏览器绘制的图片特征是相同并且独一无二的，这样以来，提取最简单的md5值便可以唯一标识和跟踪这个用户。&lt;/p&gt;
&lt;p&gt;一段产生canvas元素的javascript代码：&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;var canvas = document.createElement(&#39;canvas&#39;);
var ctx = canvas.getContext(&#39;2d&#39;);
var txt = &#39;http://security.tencent.com/&#39;;
ctx.textBaseline = &quot;top&quot;;
ctx.font = &quot;14px &#39;Arial&#39;&quot;;
ctx.textBaseline = &quot;tencent&quot;;
ctx.fillStyle = &quot;#f60&quot;;
ctx.fillRect(125,1,62,20);
ctx.fillStyle = &quot;#069&quot;;
ctx.fillText(txt, 2, 15);
ctx.fillStyle = &quot;rgba(102, 204, 0, 0.7)&quot;;
ctx.fillText(txt, 4, 17);&lt;/pre&gt;
&lt;p&gt;获取绘画的内容，需要使用到canvas.toDataURL()方法，该方法返回的是图片内容的base64编码字符串。对于PNG文件格式，以块(chunk)划分，最后一块是一段32位的CRC校验，提取这段CRC校验码便可以用于用户的唯一标识：&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;var b64 = canvas.toDataURL().replace(&quot;data:image/png;base64,&quot;,&quot;&quot;);
var bin = atob(b64);
var crc = bin2hex(bin.slice(-16,-12));
console.log(crc);&lt;/pre&gt;
&lt;p&gt;chrome隐身模式测试：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/e0e6635e1c4f2a9253c50f4863fc87f3.jpg&quot; rel=&quot;lightbox[74461]&quot; title=&quot;取代cookie的网站追踪技术：”帆布指纹识别”初探&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-74463&quot; alt=&quot;614042dc4c769520310cea5a7fe024ba&quot; src=&quot;/images/jobbole.com/e29560b7e829e202e4795e607070bd6f.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;同一机器的chrome浏览器，无论正常模式还是隐身模式，得到的crc值始终一致。而对于不同机器得到的值是不同的，追踪效果显而易见。&lt;/p&gt;
&lt;p&gt;看到这里，相信很多人想问，Why？为什么会出现这样的情况？同样的js代码，在不同设备的浏览器上，结果是唯一并且各不相同的。这到底是为什么？其实原因很简单，同样的HTML5 Canvas元素绘制操作，在不同的操作系统不同的浏览器上，产生的图片内容其实是不完全相同的。出现这种情况可能是有几个原因：&lt;/p&gt;
&lt;p&gt;1、在图片格式上，不同web浏览器使用了不同的图形处理引擎、不同的图片导出选项、不同的默认压缩级别等。&lt;/p&gt;
&lt;p&gt;2、在像素级别来看，操作系统各自使用了不同的设置和算法来进行抗锯齿和子像素渲染操作。&lt;/p&gt;
&lt;p&gt;因此，即使是相同的绘图操作，最终产生的图片数据在hash层面上依然是不同的。这个具体代码层面，恐怕要去搞懂各个主流浏览器的实现和以及操作系统的渲染。笔者精力所限，短期很难给出。大家可以自行摸索下，欢迎交流J&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【后话】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTML5千变万化，利用canvas 这一特性来实现用户追踪，目前并没有好的对抗方案，未来也只能依靠广大浏览器厂商自行了断，实现canvas绘图机制的随机化或许可以很好的保护用户隐私，防止被追踪。&lt;/p&gt;
&lt;p&gt;文中涉及到的代码和技术细节，只限用于技术交流，切勿用于非法用途。另外，如果想要研究更多的用户追踪技术，推荐去研究下大名鼎鼎的专注于访客追踪的开源项目：evercookie【附录5】，这个猥琐的小工具，通过几乎所有你想到和想不到的方式（Cookie、Flash、Silverlight、Web History、HTTP ETags、Web cache、window.name caching、userData storage、HTML5、甚至是java的漏洞等）来跟踪访问网站的用户行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【附录】&lt;br&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&quot;http://cseweb.ucsd.edu/~hovav/dist/canvas.pdf&quot;&gt;http://cseweb.ucsd.edu/~hovav/dist/canvas.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&quot;https://securehomes.esat.kuleuven.be/~gacar/sticky/index.html&quot;&gt;https://securehomes.esat.kuleuven.be/~gacar/sticky/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;https://panopticlick.eff.org/browser-uniqueness.pdf&quot;&gt;https://panopticlick.eff.org/browser-uniqueness.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] 部分“帆布指纹鉴别代码”地址列表：&lt;/p&gt;
&lt;p&gt;http://ct1.addthis.com/static/r07/core130.js&lt;/p&gt;
&lt;p&gt;http://i.ligatus.com/script/fingerprint.min.js&lt;/p&gt;
&lt;p&gt;http://src.kitcode.net/fp2.js&lt;/p&gt;
&lt;p&gt;http://admicro1.vcmedia.vn/fingerprint/figp.js&lt;/p&gt;
&lt;p&gt;http://shorte.st/js/packed/smeadvert-intermediate-ad.js&lt;/p&gt;
&lt;p&gt;http://stat.ringier.cz/js/fingerprint.min.js&lt;/p&gt;
&lt;p&gt;http://cya2.net/js/STAT/89946.js&lt;/p&gt;
&lt;p&gt;http://images.revtrax.com/RevTrax/js/fp/fp.min.jsp&lt;/p&gt;
&lt;p&gt;http://rackcdn.com/mongoose.fp.js&lt;/p&gt;
&lt;p&gt;[5]  evercookie官网 &lt;a href=&quot;http://samy.pl/evercookie/&quot;&gt;http://samy.pl/evercookie/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[6]  使用帆布指纹识别技术的库fingerprintjs 官网 &lt;a href=&quot;https://github.com/Valve/fingerprintjs&quot;&gt;https://github.com/Valve/fingerprintjs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[7]  &lt;a href=&quot;https://www.browserleaks.com/canvas#how-does-it-work&quot;&gt;https://www.browserleaks.com/canvas#how-does-it-work&lt;/a&gt;&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Tue, 29 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-29-74461-75168aebf.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-29-74461-75168aebf.html</guid>
        
        
      </item>
    
      <item>
        <title>Kibana 动态仪表板的使用 </title>
        <description>

  
  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;半年前，Kibana3.4 版刚出来的时候，曾经在官方博客上描述了一个新功能，当时我的翻译见：&lt;a href=&quot;/2014/01/15/kibana3-milestone4-20131105/&quot;&gt;【翻译】Kibana3 里程碑 4&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;今天我实际使用了一下这个新功能，感觉还是蛮有用的，单独拿出来记录一下用法和一些没在之前文章里提到的细节。&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;使用方法&lt;/h2&gt;
&lt;p&gt;使用方法其实在官方描述里已经比较清楚了。就是在原本的 &lt;code&gt;http://127.0.0.1:9292/#/dashboard/file/logstash.json&lt;/code&gt; 地址后面，再加上请求参数 &lt;code&gt;?query=***&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;看起来好像太过简单，不过用起来其实还是有点注意事项的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Kibana 目前不支持对保存在 Elasticsearch 中的 dashboard 做这个事情。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以一定得保存成 &lt;code&gt;yourname.json&lt;/code&gt; 文件放入 &lt;code&gt;app/dashboards/&lt;/code&gt; 目录里才行。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;静态的 JSON 文件其实是利用模板技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以直接导出得到的 JSON 文件还不能直接起作用。需要稍微做一点修改。&lt;/p&gt;
&lt;p&gt;你可以打开默认可用的 &lt;code&gt;logstash.json&lt;/code&gt; 文件，看看有什么奇特的地方，没错，就是下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;query&quot;: &quot;\{\{ARGS.query || &#39;*&#39;\}\}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而你自己保存下来的 JSON，这里都会是具体的数据。所以，要让自己的 JSON 布局也支持动态仪表板的话，按照这个写法也都加上 &lt;code&gt;ARGS.query&lt;/code&gt; 就好了！&lt;/p&gt;
&lt;p&gt;从 logstash.json 里还可以看到，除了 &lt;code&gt;?query=&lt;/code&gt; 以外，其实还支持 &lt;code&gt;from=&lt;/code&gt; 参数，默认是 &lt;code&gt;24h&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;query 参数的特殊字符问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如我之前在搜索框里输入的 querystring 是这样的：&lt;code&gt;type:mweibo_action AND urlpath:&quot;/2/statuses/friends_timeline.json&quot;&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;那么实际用的时候，如果写成这样一个 url：&lt;code&gt;http://127.0.0.1:9292/#/dashboard/file/logstash.json?query=type:mweibo_action AND urlpath:&quot;/2/statuses/friends_timeline.json&quot;&lt;/code&gt;，实际是不对的。我一度怀疑是不是 urlpath 里的 &lt;code&gt;/&lt;/code&gt; 导致的问题，后来发现，其实是 &lt;code&gt;&quot;&lt;/code&gt; 在进 JSON 文件模板变量替换的时候给当做只是字符串赋值引号的作用，就不再作为字符串本身传递给 Elasticsearch 作为请求内容本身了。&lt;strong&gt;所以需要用 &lt;code&gt;\&lt;/code&gt; 给 &lt;code&gt;&quot;&lt;/code&gt; 做转义。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(这里一定要有 &lt;code&gt;&quot;&lt;/code&gt; 的原因是，ES 的 querystring 里，&lt;code&gt;field:/regex/&lt;/code&gt; 是正则匹配搜索的语法，刚好 url 也是以 &lt;code&gt;/&lt;/code&gt; 开头的)&lt;/p&gt;
&lt;p&gt;所以可用的 url 应该是：&lt;code&gt;http://127.0.0.1:9292/#/dashboard/file/logstash.json?query=type:mweibo_action AND urlpath:\&quot;/2/statuses/friends_timeline.json\&quot;&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;经过 url_encode 之后就变成了：&lt;code&gt;http://127.0.0.1:9292/#/dashboard/file/logstash.json?query=type:mweibo_action%20AND%20urlpath:%5C%22%2F2%2Fstatuses%2Ffriends_timeline.json%5C%22&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样就可以了！&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用 JSON 的局限。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态仪表板其实有两种用法，这里只用到了 &lt;code&gt;file/logstash.json&lt;/code&gt; 静态文件方式，这种方式只支持一个 query 条件，也没有太多的附加参数支持。而 &lt;code&gt;script/logstash.js&lt;/code&gt; 方式，支持多个 query 条件，以及 index、pattern、interval、timefield 等更多的参数选项。&lt;/p&gt;
&lt;p&gt;当然，研究一下 angularjs 的用法，给 JSON 文件里也加上 &lt;code&gt;ARGS.query&lt;/code&gt; 的 &lt;code&gt;split&lt;/code&gt; 方法，也不算太难。&lt;/p&gt;
    &lt;hr&gt;
    
    &lt;hr&gt;
  &lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;
  &lt;/div&gt;

</description>
        <pubDate>Mon, 28 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-28-dynamic-dashboard-for-kibana-91a5db924.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-28-dynamic-dashboard-for-kibana-91a5db924.html</guid>
        
        
      </item>
    
      <item>
        <title>小米企业安全建设</title>
        <description>

                &lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; allowtransparency=&quot;true&quot; frameborder=&quot;0&quot; height=&quot;345&quot; id=&quot;talk_frame_111442&quot; mozallowfullscreen=&quot;true&quot; src=&quot;//speakerdeck.com/player/bf433880f86101315a2d6ebe547ea833&quot; style=&quot;border:0; padding:0; margin:0; background:transparent;&quot; webkitallowfullscreen=&quot;true&quot; width=&quot;500&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
            

</description>
        <pubDate>Mon, 28 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-28--p=1541-4dd2e1df9.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-28--p=1541-4dd2e1df9.html</guid>
        
        
      </item>
    
      <item>
        <title>小米运维自动化 WOT 2014</title>
        <description>

                &lt;p&gt;本次分享中对小米目前的自动运维体系结构，设计思路和理念，各系统间的整合方式和核心架构进行了详细阐述；&lt;/p&gt;
&lt;p&gt;同时也介绍了整个自动运维体系的构建过程和解决方案方法， 以及基础该套体系如何来解决困扰运维的若干问题&lt;/p&gt;
&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; allowtransparency=&quot;true&quot; frameborder=&quot;0&quot; height=&quot;438&quot; id=&quot;talk_frame_111443&quot; mozallowfullscreen=&quot;true&quot; src=&quot;//speakerdeck.com/player/8c391c80f86201315a2f6ebe547ea833&quot; style=&quot;border:0; padding:0; margin:0; background:transparent;&quot; webkitallowfullscreen=&quot;true&quot; width=&quot;500&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
            

</description>
        <pubDate>Mon, 28 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-28--p=1536-67fe755a4.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-28--p=1536-67fe755a4.html</guid>
        
        
      </item>
    
      <item>
        <title>Interacting with C Pointers</title>
        <description>
&lt;p&gt;Objective-C and C APIs often require the use of pointers. Data types in Swift are designed to feel natural when working with pointer-based Cocoa APIs, and Swift automatically handles several of the most common use cases for pointers as arguments. In this post we’ll look at how pointer parameters in C can be used with the variables, arrays, and strings in Swift.&lt;/p&gt; &lt;h3&gt;Pointers as In/Out Parameters&lt;/h3&gt; &lt;p&gt;C and Objective-C don’t support multiple return values, so Cocoa APIs frequently use pointers as a way of passing additional data in and out of functions. Swift allows pointer parameters to be treated like &lt;span class=&quot;keyword&quot;&gt;inout&lt;/span&gt; parameters, so you can pass a reference to a &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; as a pointer argument by using the same &lt;span class=&quot;keyword&quot;&gt;&amp;amp;&lt;/span&gt; syntax. For instance, &lt;span class=&quot;keyword&quot;&gt;UIColor&lt;/span&gt;’s &lt;span class=&quot;keyword&quot;&gt;getRed(_:green:blue:alpha:)&lt;/span&gt; method takes four &lt;span class=&quot;keyword&quot;&gt;CGFloat*&lt;/span&gt; pointers to receive the components of the color. We can use &lt;span class=&quot;keyword&quot;&gt;&amp;amp;&lt;/span&gt; to collect these components into local variables:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; r: &lt;span class=&quot;title&quot;&gt;CGFloat&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, g: &lt;span class=&quot;title&quot;&gt;CGFloat&lt;/span&gt; = &lt;span class=&quot;numner&quot;&gt;0&lt;/span&gt;, b: &lt;span class=&quot;title&quot;&gt;CGFloat&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, a: &lt;span class=&quot;title&quot;&gt;CGFloat&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;
color.getRed(&amp;amp;&lt;span class=&quot;pointer&quot;&gt;r&lt;/span&gt;, green: &amp;amp;&lt;span class=&quot;pointer&quot;&gt;g&lt;/span&gt;, blue: &amp;amp;&lt;span class=&quot;pointer&quot;&gt;b&lt;/span&gt;, alpha: &amp;amp;&lt;span class=&quot;pointer&quot;&gt;a&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Another common case is the Cocoa &lt;span class=&quot;keyword&quot;&gt;NSError&lt;/span&gt; idiom. Many methods take an &lt;span class=&quot;keyword&quot;&gt;NSError**&lt;/span&gt; parameter to save an error in case of failure. For instance, we can list the contents of a directory using &lt;span class=&quot;keyword&quot;&gt;NSFileManager&lt;/span&gt;’s &lt;span class=&quot;keyword&quot;&gt;contentsOfDirectoryAtPath(_:error:)&lt;/span&gt; method, saving the potential error directly to an &lt;span class=&quot;keyword&quot;&gt;NSError?&lt;/span&gt; variable:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; maybeError: &lt;span class=&quot;title&quot;&gt;NSError&lt;/span&gt;?
&lt;span class=&quot;key&quot;&gt;if let&lt;/span&gt; contents = &lt;span class=&quot;title&quot;&gt;NSFileManager&lt;/span&gt;.&lt;span class=&quot;method&quot;&gt;defaultManager&lt;/span&gt;()
	.&lt;span class=&quot;method&quot;&gt;contentsOfDirectoryAtPath&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;/usr/bin&quot;&lt;/span&gt;, error: &amp;amp;&lt;span class=&quot;pointer&quot;&gt;maybeError&lt;/span&gt;) {
	&lt;span class=&quot;comment&quot;&gt;// Work with the directory contents&lt;/span&gt;
} &lt;span class=&quot;key&quot;&gt;else if let&lt;/span&gt; error = &lt;span class=&quot;pointer&quot;&gt;maybeError&lt;/span&gt; {
	&lt;span class=&quot;comment&quot;&gt;// Handle the error&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;For safety, Swift requires the variables to be initialized before being passed with &lt;span class=&quot;keyword&quot;&gt;&amp;amp;&lt;/span&gt;. This is because it cannot know whether the method being called tries to read from a pointer before writing to it.&lt;/p&gt; &lt;h3&gt;Pointers as Array Parameters&lt;/h3&gt; &lt;p&gt;Pointers are deeply intertwined with arrays in C, and Swift facilitates working with array-based C APIs by allowing &lt;span class=&quot;keyword&quot;&gt;Array&lt;/span&gt; to be used as a pointer argument. An immutable array value can be passed directly as a &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; pointer, and a mutable array can be passed as a non-&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; pointer argument using the &lt;span class=&quot;keyword&quot;&gt;&amp;amp;&lt;/span&gt; operator, just like an &lt;span class=&quot;keyword&quot;&gt;inout&lt;/span&gt; parameter. For instance, we can add two arrays &lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt; and &lt;span class=&quot;keyword&quot;&gt;b&lt;/span&gt; using the &lt;span class=&quot;keyword&quot;&gt;vDSP_vadd&lt;/span&gt; function from the Accelerate framework, writing the result to a third &lt;span class=&quot;keyword&quot;&gt;result&lt;/span&gt; array:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;import&lt;/span&gt; Accelerate

&lt;span class=&quot;key&quot;&gt;let&lt;/span&gt; a: [&lt;span class=&quot;title&quot;&gt;Float&lt;/span&gt;] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]
&lt;span class=&quot;key&quot;&gt;let&lt;/span&gt; b: [&lt;span class=&quot;title&quot;&gt;Float&lt;/span&gt;] = [&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.25&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.125&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.0625&lt;/span&gt;]
&lt;span class=&quot;key&quot;&gt;var&lt;/span&gt; result: [&lt;span class=&quot;title&quot;&gt;Float&lt;/span&gt;] = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]

&lt;span class=&quot;method&quot;&gt;vDSP_vadd&lt;/span&gt;(a, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, b, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &amp;amp;&lt;span class=&quot;pointer&quot;&gt;result&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)

&lt;span class=&quot;comment&quot;&gt;// result now contains [1.5, 2.25, 3.125, 4.0625]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;Pointers as String Parameters&lt;/h3&gt; &lt;p&gt;C uses &lt;span class=&quot;keyword&quot;&gt;const char*&lt;/span&gt; pointers as the primary way to pass around strings. A Swift &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt; can be used as a &lt;span class=&quot;keyword&quot;&gt;const char*&lt;/span&gt; pointer, which will pass the function a pointer to a null-terminated, UTF–8-encoded representation of the string. For instance, we can pass strings directly to standard C and POSIX library functions:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;method&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello from libc&quot;&lt;/span&gt;)
&lt;span class=&quot;key&quot;&gt;let&lt;/span&gt; fd = &lt;span class=&quot;method&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;/tmp/scratch.txt&quot;&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;O_WRONLY&lt;/span&gt;|&lt;span class=&quot;title&quot;&gt;O_CREAT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0o666&lt;/span&gt;)

&lt;span class=&quot;key&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pointer&quot;&gt;fd&lt;/span&gt; &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; {
	&lt;span class=&quot;method&quot;&gt;perror&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;could not open /tmp/scratch.txt&quot;&lt;/span&gt;)
} &lt;span class=&quot;key&quot;&gt;else&lt;/span&gt; {
	&lt;span class=&quot;key&quot;&gt;let&lt;/span&gt; text = &lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;
	&lt;span class=&quot;method&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;pointer&quot;&gt;fd&lt;/span&gt;, text, &lt;span class=&quot;method&quot;&gt;strlen&lt;/span&gt;(text))
	&lt;span class=&quot;method&quot;&gt;close&lt;/span&gt;(&lt;span class=&quot;pointer&quot;&gt;fd&lt;/span&gt;)
}&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;Safety with Pointer Argument Conversions&lt;/h3&gt; &lt;p&gt;Swift works hard to make interaction with C pointers convenient, because of their pervasiveness within Cocoa, while providing some level of safety. However, interaction with C pointers is inherently unsafe compared to your other Swift code, so care must be taken. In particular:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;These conversions cannot safely be used if the callee saves the pointer value for use after it returns. The pointer that results from these conversions is only guaranteed to be valid for the duration of a call. Even if you pass the same variable, array, or string as multiple pointer arguments, you could receive a different pointer each time. An exception to this is global or static stored variables. You can safely use the address of a global variable as a persistent unique pointer value, e.g.: as a KVO context parameter.&lt;/li&gt; &lt;li&gt;Bounds checking is not enforced when a pointer to an &lt;span class=&quot;keyword&quot;&gt;Array&lt;/span&gt; or &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt; is passed. A C-based API can’t grow the array or string, so you must ensure that the array or string is of the correct size before passing it over to the C-based API.&lt;/li&gt;
&lt;/ul&gt; &lt;p&gt;If you need to work with pointer-based APIs that don’t follow these guidelines, or you need to override Cocoa methods that accept pointer parameters, then you can work directly with raw memory in Swift using unsafe pointers. We’ll look at a more advanced case in a future post.&lt;/p&gt;

</description>
        <pubDate>Mon, 28 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-28--id=6-ea85867c5.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-28--id=6-ea85867c5.html</guid>
        
        
      </item>
    
      <item>
        <title>在 MacBook 上使用 PDL 绘图 </title>
        <description>

  
  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;之前在 Linux 服务器上使用 PDL，主要是一些矩阵函数，这次准备在个人电脑上使用 PDL，尤其是本身的绘图功能，其一目的就是导出 zabbix 中存储的监控数据，通过 PDL 绘图观察其季节性分布情况。&lt;/p&gt;

&lt;p&gt;不过在使用的时候，发现在 MacBook 上跑 PDL 还是有点上手难度的。和 pylab 不同，PDL 是使用了 X11 的，而 MacBook 最新的版本里，X11 已经不再是自带的了。所以需要单独去下载 &lt;a href=&quot;https://www.macupdate.com/app/mac/26593/xquartz&quot;&gt;XQuartz&lt;/a&gt; 安装包来提供 X11 支持。&lt;/p&gt;

&lt;p&gt;安装好了 XQuartz 以后，再安装 PDL::Graphics:: 名字空间下的几个模块就好办了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PDL::Graphics::Simple&lt;/li&gt;
  &lt;li&gt;PDL::Graphics::Gnuplot&lt;/li&gt;
  &lt;li&gt;PDL::Graphics::PGPLOT&lt;/li&gt;
  &lt;li&gt;PDL::Graphics::Prima&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外还有 PDL::Graphics::PLplot 等，不过通过 &lt;code&gt;port install plplot&lt;/code&gt; 安装的 plplot 没有 header 文件，所以 PDL::Graphics::PLplot 是安装不上的，既然前面已经有了不少，这里也就不再追求自己下载 plplot 源代码来安装了。&lt;/p&gt;

&lt;p&gt;PDL::Graphics::Simple 是 《PDL Book》开篇第一个示例就使用的模块，其实际就是按顺序尝试加载 &lt;code&gt;::Gnuplot&lt;/code&gt;、&lt;code&gt;::PGPLOT&lt;/code&gt;、&lt;code&gt;::PLplot&lt;/code&gt; 和 &lt;code&gt;::Prima&lt;/code&gt;。所以，保证有一个可用就好了。&lt;/p&gt;

&lt;p&gt;不过在我的 air 上实际的效果来看，perldl 命令在使用 子进程跟 gnuplot 交互的时候&lt;strong&gt;非常非常非常的慢！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好了，现在就可以运行程序了：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span class=&quot;c1&quot;&gt;#!/usr/bin/env perl&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;warnings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;feature&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;:5.16&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Path::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tiny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;YAML&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PDL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;PDL::Graphics::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PGPLOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Zabbix2::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;config.yml&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slurp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zbconf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;zabbix&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zabbix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;nn&quot;&gt;Zabbix2::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://$zbconf-&amp;gt;{&#39;addr&#39;}/zabbix/api_jsonrpc.php&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$zabbix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;login&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zbconf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;user&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zbconf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;pass&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;vg&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;could not authenticate&#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$items&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zabbix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;Item&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;groupids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hostids&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11036&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;graphids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1824829&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$item&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@$items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;name&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$itemid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;itemid&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$itemid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$sitems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$zabbix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_single&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&#39;Item&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;itemids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$itemid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$pdl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pdl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$sitems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;history&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time_from&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3600&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$pdl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里使用了 &lt;a href=&quot;https://metacpan.org/pod/Zabbix2::API&quot;&gt;Zabbix2::API&lt;/a&gt; 模块，相对比 &lt;a href=&quot;http://blog.zabbix.com/getting-started-with-zabbix-api/1381/&quot;&gt;zabbix 官方博客示例&lt;/a&gt;直接使用 &lt;a href=&quot;https://metacpan.org/pod/JSON::RPC&quot;&gt;JSON::RPC&lt;/a&gt; 模块，以及 python 的 pyzabbix 模块来说，Zabbix2::API 模块封装的非常好，history 是作为 item 对象的属性出现，而不是单独再请求一次 &lt;code&gt;history.get&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;另外，不知道为什么，使用 pyzabbix 模块就一直无法正常使用，而自己写 requests 和 json 却没问题。上面的 perl 脚本用 python 改写就是下面这样：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;Read item history from zabbix, and plot as histogram&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;matplotlib&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;np&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;matplotlib.mlab&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;mlab&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;plt&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;requests&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;json&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;datetime&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ZABBIX_URI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;http://test.zabbix.com/zabbix/api_jsonrpc.php&#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ZABBIX_USR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;user&#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ZABBIX_PWD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;pass&#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HOURS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;zabbixLogin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;user&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;password&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passwd&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zabbixCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;user.login&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;zabbixCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;jsonrpc&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;2.0&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;method&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;params&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;id&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;auth&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZABBIX_URI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dumps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;content-type&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;application/json-rpc&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;result&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;authId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zabbixLogin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZABBIX_USR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZABBIX_PWD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;Get Auth ID: &#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&#39;groupids&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&#39;hostids&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11036&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&#39;graphids&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1824829&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zabbixCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;item.get&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mktime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timetuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3600&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HOURS&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;Begin loop for history...&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;output&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;extend&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;history&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;itemids&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;itemid&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&#39;time_from&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zabbixCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;history.get&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;history&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;value&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;history&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;figure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;item: &#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;itemid&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#  lline = numpy.percentile(v, 25)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#  uline = numpy.percentile(v, 75)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#  low = 2 * lline - uline&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#  up = 2 * uline - lline&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;figure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boxplot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sym&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;+&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;notch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;item: &#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;itemid&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


    &lt;hr&gt;
    
    &lt;hr&gt;
    


  &lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;






  &lt;/div&gt;

</description>
        <pubDate>Sun, 27 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-27-using-pdl-on-macbook-0a2e8590f.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-27-using-pdl-on-macbook-0a2e8590f.html</guid>
        
        
      </item>
    
      <item>
        <title>Promise 初探</title>
        <description>

		&lt;p&gt;其实 Promise 这个东西提出来也挺久时间了，它是一种解决复杂异步回调逻辑的方法。大部分人类的正常思维方式都是线性连贯的，但是在 JavaScript 中，异步却是主流。所以，在遇到复杂逻辑时，我们往往会&lt;a href=&quot;http://tritarget.org/blog/2012/11/28/the-pyramid-of-doom-a-javascript-style-trap/&quot;&gt;写成这样&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
// Code uses jQuery to illustrate the Pyramid of Doom
(function($) {
  $(function(){
    $(&quot;button&quot;).click(function(e) {
      $.get(&quot;/test.json&quot;, function(data, textStatus, jqXHR) {
        $(&quot;.list&quot;).each(function() {
          $(this).click(function(e) {
            setTimeout(function() {
              alert(&quot;Hello World!&quot;);
            }, 1000);
          });
        });
      });
    });
  });
})(jQuery);
&lt;/pre&gt;
&lt;p&gt;这就是所谓的「回调金字塔」，每当看到这样的代码，我就会不由自主地唱起一首歌：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;
  如果你愿意一层一层一层地剥开我的心……
&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;解决这个方法最简单的方法，就是把匿名函数取个名字，单独提取出来定义。但是当遇到多变的业务场景时，具名函数的方法也不太管用，于是便有了各种高级的碾平异步回调的解决方案，Promise 就是其中一种。&lt;/p&gt;
&lt;p&gt;在 ECMAScript 6 中，Promise 模式得到了原生的支持。我们就从原生模型说起。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-497&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;ECMAScript 6 Promise&lt;/h2&gt;
&lt;p&gt;为了简化各种各样的异步逻辑，我们先假设有一个会花一些时间来完成的 JS 函数。它的功能很简单，就是过一段时间以后调用传入的回调函数。&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
var wait = function(callback, param) {
  setTimeout(function() {
    callback(param)
  }, 2000 + (Math.random() - 0.5) * 1000);
}
wait(console.log.bind(console), &#39;test&#39;);
&lt;/pre&gt;
&lt;p&gt;你可以想象多层嵌套的时候大概是什么样子：&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
wait(function() {
  console.log(&#39;如果你愿意&#39;);
  wait(function() {
    console.log(&#39;一层&#39;);
    wait(function() {
      console.log(&#39;一层&#39;);
      wait(function() {
        console.log(&#39;一层地&#39;);
        wait(console.log.bind(console), &#39;剥开我的心&#39;);
      });
    });
  });
});
&lt;/pre&gt;
&lt;p&gt;那么，在 Promise 的世界里是什么样的呢？这就不得不先枯燥地解释一些东西了。首先，什么叫做一个「promise」？一个 promise 可以是一个对象或者函数，它包含一个 &lt;code&gt;then&lt;/code&gt; 接口并且符合相应的规范。使用一个 promise 的方法就是这样：&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
promise.then(function(response) {
    // onFulfilled 时执行
}, function(error) {
    // onRejected 时执行
});
&lt;/pre&gt;
&lt;p&gt;于是问题又来了，什么叫做 fulfilled 和 rejected 呢？一个 promise 会有三种状态，大致可以理解为执行成功（fulfilled）、执行失败（rejected）和正在执行中（pending）。Promise 包含一个状态机，它内部的状态转换，只允许从 pending 到 fulfilled 或者 rejected 一次，不允许更多了。如果用大家喜闻乐见的薛定谔的猫来解释，就是打开盒子的时候，我们的猫要么死了，要么没死，要么不确定死没死，死的的猫无法复活，活猫也一定不会死:D&lt;/p&gt;
&lt;p&gt;新建一个 promise 的时候，我们需要在代码中定义什么时候算成功了，什么时候算失败了。于是上面 wait 的例子便可以改写这样了：&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
function waitPromise(param) {
  return new Promise(function(resolve, reject) {
    setTimeout(function() {
      resolve(param);
    }, 2000 + (Math.random() - 0.5) * 1000);
  });
}

waitPromise(&#39;如果你愿意&#39;).then(function(response) {
  console.log(response);
  return waitPromise(&#39;一层&#39;);
}).then(function(response) {
  console.log(response);
  return waitPromise(&#39;一层&#39;);
}).then(function(response) {
  console.log(response);
  return waitPromise(&#39;一层地&#39;);
}).then(function(response) {
  console.log(response);
  return waitPromise(&#39;剥开我的心&#39;);
}).then(console.log.bind(console));
&lt;/pre&gt;
&lt;p&gt;从上面的例子中，我们可以看出几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个 promise 它 resolve（或者 reject）的东西就是 &lt;code&gt;then&lt;/code&gt; 的两个回调接受的参数。&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;then&lt;/code&gt; 可以链式调用，调用的顺序就是你定义的顺序。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;onFulfilled&lt;/code&gt;（或者 &lt;code&gt;onRejected&lt;/code&gt;）中，你可以返回一个 promise，此时 &lt;code&gt;then&lt;/code&gt; 会返回这个 promise 的一个代理，并响应它的状态变化（即给下一个 &lt;code&gt;then&lt;/code&gt; 使用）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;onFulfilled&lt;/code&gt; 和 &lt;code&gt;onRejected&lt;/code&gt; 中，除了可以返回一个 promise 以外，还可以返回一个对象，其中包含一个 &lt;code&gt;then&lt;/code&gt; 方法——这样的对象称作 &lt;em&gt;thenable&lt;/em&gt;。当 thenable 被返回时，代理的 promise 就会去调用该方法，并传入 &lt;code&gt;resolvePromise&lt;/code&gt; 和 &lt;code&gt;rejectPromise&lt;/code&gt; 两个参数，于是这个 promise 也就链式地传递下去了。除此之外，返回一个不是 thenable 的值也是可以的，这相当于一个简化，该返回值会被链式的 promise 立即 fulfill。&lt;/p&gt;
&lt;p&gt;上面的例子比较一根筋，所有的 &lt;code&gt;then&lt;/code&gt; 只定义了第一个参数（即成功的回调），其实我们还可以通过调用 &lt;code&gt;onRejected&lt;/code&gt; 或者抛出一个异常来表示 Promise 执行失败，从而进入 &lt;code&gt;then&lt;/code&gt; 的第二个函数中（&lt;code&gt;then(func1, func2)&lt;/code&gt; 必定会调用且仅调用其中一个）。听上去是不是有点 try/catch 的味道，事实上，Promise 还真提供了一个语法糖，就是 &lt;code&gt;catch(func)&lt;/code&gt;，它其实相当于 &lt;code&gt;then(undefined, func)&lt;/code&gt;。链条中加入的 &lt;code&gt;catch&lt;/code&gt; 可以管上它之前所有的 promise 中的失败情况。&lt;/p&gt;
&lt;p&gt;听上去好像很绕口的样子，而且这个 Promise 也不过是把回调拉平了而已嘛，至于这么复杂么？其实，依赖这些，我们可以方便地实现更多异步逻辑。在 ECMAScript 6中，Promise 还定义了两个接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;Promise.all&lt;/code&gt;：接受一堆 promise 的数组（任何可迭代的对象都可以），只有当他们都解决了以后，才会解决&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;Promise.race&lt;/code&gt;：也是接受一堆 promise，但是只要有一个成功或者失败了，就会立即解决或驳回它本身&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;怎么样，是不是突显出 JavaScript 的函数式风格了。就&lt;a href=&quot;http://kangax.github.io/compat-table/es6/#Promise&quot;&gt;目前的形势&lt;/a&gt;而言，Chrome 33 和 Firefox 30 以上的浏览器都已经实现了原生 Promise。&lt;/p&gt;
&lt;h2&gt;Promises/A+&lt;/h2&gt;
&lt;p&gt;之前说了那么多关于 Promise 的这个规定，那个规定，其实它是有一个统一的名称的，就叫做 Promises/A+。在&lt;a href=&quot;http://promisesaplus.com/&quot;&gt;它的网站&lt;/a&gt;上，你可以阅读到完整的规范文档。&lt;/p&gt;
&lt;p&gt;基于这个标准，除了 ECMAScript 6 中比较简易的 Promise 以外，还有很多实现各不相同，功能各有千秋的实现，比较有名的有（按现有 Github Star 数排列）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;Bluebird&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cujojs/when&quot;&gt;when&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tildeio/rsvp.js/&quot;&gt;rsvp.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，Q 支持进度查询功能，执行时间较长的异步操作（例如文件上传）可以即时获取进度信息：&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
return uploadFile()
.then(function () {
    // Success uploading the file
}, function (err) {
    // There was an error, and we get the reason for error
}, function (progress) {
    // We get notified of the upload&#39;s progress as it is executed
});
&lt;/pre&gt;
&lt;h2&gt;重新发明轮子&lt;/h2&gt;
&lt;p&gt;尽管 Promise 的实现有很多，但是它们的核心都是一样的，就是围绕着 &lt;code&gt;then&lt;/code&gt; 方法展开。既然有了标准规范，其实我们可以自己实现一个简单的 Promise。&lt;/p&gt;
&lt;p&gt;首先当然要创建一个 Promise 对象的构造函数，它接受一个函数作为参数，调用这个函数的时候，会传入 &lt;code&gt;resolve&lt;/code&gt; 和 &lt;code&gt;reject&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
function MyPromise(resolver) {
    // 简单起见就不做类型检查了，假定 resolver 一定为函数

    this.status = 0;  // 0: pending, 1: fulfilled, 2: rejected
    this.value = null;
    this.handlers = [];

    doResolve.call(this, resolver);
}

function doResolve(resolver) {
    var called = false;
    function resolvePromise(value) {
        if (called) {
            return;
        } else {
            called = true;
            resolve.call(this, value);
        }
    }

    function rejectPromise(reason) {
        if (called) {
            return;
        } else {
            called = true;
            reject.call(this, reason);
        }
    }

    try {
        resolver(resolvePromise.bind(this), rejectPromise.bind(this));
    } catch(e) {
        rejectPromise(e);
    }
}
&lt;/pre&gt;
&lt;p&gt;这样，当使用 &lt;code&gt;new Promise(function(resolve, reject) {...});&lt;/code&gt; 构造时，就会进入 &lt;code&gt;doResolve&lt;/code&gt;，这时会执行传入给 &lt;code&gt;new Promise&lt;/code&gt; 的参数，并给出 &lt;code&gt;resolve&lt;/code&gt; 和 &lt;code&gt;reject&lt;/code&gt; 的实现。可以看到为了保证 &lt;code&gt;resolve&lt;/code&gt; 或 &lt;code&gt;reject&lt;/code&gt; 总共只能被调用一次，这里用到了一个闭包。接下来来看具体的 &lt;code&gt;resolve&lt;/code&gt; 和 &lt;code&gt;reject&lt;/code&gt; 是怎么实现的。&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
function resolve(value) {
    try {
        if (this === value) {
            throw new TypeError(&#39;A promise cannot be resolved with itself.&#39;);
        }
        if (value &amp;amp;&amp;amp; (typeof value === &#39;object&#39; || typeof value === &#39;function&#39;)) {
            var then = value.then;
            if (typeof then === &#39;function&#39;) {
                doResolve.call(this, then.bind(value));
                return;
            }
        }
        this.status = 1;
        this.value = value;
        dequeue.call(this);
    } catch(e) {
        reject(e);
    }
}

function reject(reason) {
    this.status = 2;
    this.value = reason;
    dequeue.call(this);
}
&lt;/pre&gt;
&lt;p&gt;具体的 &lt;code&gt;resolve&lt;/code&gt; 实现中，我们会判断解决的值是否是一个 thenable，如果是的话，就会去执行这个 &lt;code&gt;then&lt;/code&gt; 函数，并且接受它的状态和返回值。如果不是，就直接使用该值解决这个 promise。&lt;/p&gt;
&lt;p&gt;可以想象，当我们执行 promise 的 &lt;code&gt;then&lt;/code&gt; 方法时，其实是完成了一个类似&lt;a href=&quot;http://zh.wikipedia.org/zh/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&quot;&gt;观察者模式&lt;/a&gt;的注册过程。当 promise 还处于 pending 状态时，回调函数会被暂时存储起来，待到解决或失败时再执行，但是当 &lt;code&gt;then&lt;/code&gt; 发现这个 promise 已经完成了状态转换，便可以根据状态立即执行回调了。&lt;/p&gt;
&lt;p&gt;在这里，我们使用了 &lt;code&gt;this.handlers&lt;/code&gt; 数组来暂存 &lt;code&gt;then&lt;/code&gt; 的回调函数，当状态改变时，会调用 &lt;code&gt;dequeue&lt;/code&gt; 方法来处理队列。&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
function dequeue() {
    var handler;
    while (this.handlers.length) {
        handler = this.handlers.shift();
        handle.call(this, handler.thenPromise, handler.onFulfilled, handler.onRejected);
    }
}
&lt;/pre&gt;
&lt;p&gt;最后便是核心方法 &lt;code&gt;then&lt;/code&gt; 的实现了。根据规范，它必须返回一个 promise，并根据 &lt;code&gt;onFulfilled&lt;/code&gt; 或 &lt;code&gt;onRejected&lt;/code&gt; 回调的返回值来决定是将它标记为完成还是失败。&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
MyPromise.prototype.then = function(onFulfilled, onRejected) {
    var self = this;
    var thenPromise = new MyPromise(function() {});

    if (!self.status) {
        self.handlers.push({
            thenPromise: thenPromise,
            onFulfilled: onFulfilled,
            onRejected: onRejected
        });
    } else {
        handle.call(self, thenPromise, onFulfilled, onRejected);
    }

    return thenPromise;
};

function handle(thenPromise, onFulfilled, onRejected) {
    var self = this;

    setTimeout(function() {
        var callback, ret;
        if (self.status == 1) {
            callback = onFulfilled;
        } else {
            callback = onRejected;
        }
        if (typeof callback === &#39;function&#39;) {
            try {
                ret = callback(self.value);
                resolve.call(thenPromise, ret);
            } catch(e) {
                reject.call(thenPromise, e);
            }
            return;
        }
        if (self.status == 1) {
            resolve.call(thenPromise, self.value);
        } else {
            reject.call(thenPromise, self.value);
        }
    }, 1);
}
&lt;/pre&gt;
&lt;p&gt;在上面的 &lt;code&gt;handle&lt;/code&gt; 函数中，我们立即调用回调函数，并且根据回调函数的类型来改变 &lt;code&gt;then&lt;/code&gt; 方法返回的 promise 的状态，这样就形成了一个 promise 链条。&lt;/p&gt;
&lt;p&gt;大约 100 多行代码，我们就实现了一个粗糙的 Promise 库。当然，上面的代码可能还有很多 Bug，并且也不是严格符合 Promises/A+ 的。如果读者发现问题，请不吝指出。&lt;/p&gt;
&lt;p&gt;有了这个核心的基础，实现外围的 API 例如 &lt;code&gt;Promise.all&lt;/code&gt;、&lt;code&gt;Promise.race&lt;/code&gt; 就比较简单了，这里就不给出了。其实，Promise 看似用起来很简单，想要自己严格实现一个，还是有不少难点的，其中最容易被绕晕的就是对 &lt;code&gt;then&lt;/code&gt;&lt;br&gt;
的实现，以及如何处理 &lt;code&gt;then&lt;/code&gt; 的回调中又返回新的 promise 的逻辑。&lt;/p&gt;
&lt;p&gt;我们回到文章开头的例子，使用我们自己的 MyPromise 试验一下。简单起见，就不写那么多层了。&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
function waitPromise(param) {
  return new Promise(function(resolve, reject) {
    setTimeout(function() {
      resolve(param);
    }, 2000 + (Math.random() - 0.5) * 1000);
  });
}

waitPromise(&#39;如果你愿意&#39;).then(function(response) {
  console.log(response);
  return waitPromise(&#39;一层&#39;);
}).then(console.log.bind(console));
&lt;/pre&gt;
&lt;p&gt;可以看到我们可以成功输出两行文字。你能根据上面的实现，看出这次调用事实上一共产生了多少个 promise 对象吗？&lt;/p&gt;
&lt;p&gt;答案是五个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P0：第一次 &lt;code&gt;waitPromise(&#39;如果你愿意&#39;)&lt;/code&gt; 返回的&lt;/li&gt;
&lt;li&gt;P1：第一个 &lt;code&gt;then&lt;/code&gt; 返回的&lt;/li&gt;
&lt;li&gt;P2：第二个 &lt;code&gt;then&lt;/code&gt; 返回的&lt;/li&gt;
&lt;li&gt;P3：第一个 &lt;code&gt;then&lt;/code&gt; 里，通过 &lt;code&gt;return waitPromise(&#39;一层&#39;)&lt;/code&gt; 返回的&lt;/li&gt;
&lt;li&gt;P4：在处理 P1 时，会调用 P3 的 &lt;code&gt;then&lt;/code&gt; 方法，这时候又会返回一个 promise&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.html5rocks.com/zh/tutorials/es6/promises/&quot;&gt;JavaScript Promises – There and back again&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://promisesaplus.com/&quot;&gt;Promises/A+&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;/ul&gt;
			&lt;!-- .entry-content --&gt;

</description>
        <pubDate>Sun, 27 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-27-promise-introduction.html-f65f9ebff.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-27-promise-introduction.html-f65f9ebff.html</guid>
        
        
      </item>
    
      <item>
        <title>iOS开发如何提高</title>
        <description>
&lt;p&gt;&lt;img src=&quot;/images/devtang.com/79692bab05e21d2e6ef22c2bdacb7f5d.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;许多人在博客和微信上咨询我iOS开发如何提高，经过一番思考之后，我能想到如下一些提高的办法，我个人也是通过这些方法来提高的。&lt;/p&gt;

&lt;h2&gt;阅读博客&lt;/h2&gt;

&lt;p&gt;在现在这个碎片化阅读流行的年代，博客的风头早已被微博盖过。而我却坚持写作博客，并且大量地阅读同行的iOS开发博客。博客的文章长度通常在3000字左右，许多iOS开发知识都至少需要这样的篇幅才能完整地讲解清楚。并且博客相对于书籍来说，并没有较长的出版发行时间，所以阅读博客对于获取最新的iOS开发知识有着非常良好的效果。&lt;/p&gt;

&lt;p&gt;我自己精心整理了国内40多位iOS开发博主的博客地址列表：&lt;a href=&quot;https://github.com/tangqiaoboy/iOSBlogCN&quot;&gt;https://github.com/tangqiaoboy/iOSBlogCN&lt;/a&gt;，希望大家都能培养起阅读博客的习惯。&lt;/p&gt;

&lt;p&gt;国外也有很多优秀的iOS开发博客，他们整体质量比中文的博客更高，以下是一些推荐的博客地址列表：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;博客名 &lt;/th&gt;
&lt;th&gt; 博客地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;objc.io &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://www.objc.io/&quot;&gt;http://www.objc.io/&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ray Wenderlich&lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://www.raywenderlich.com&quot;&gt;http://www.raywenderlich.com&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iOS Developer Tips &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://iosdevelopertips.com/&quot;&gt;http://iosdevelopertips.com/&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iOS Dev Weekly &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://iosdevweekly.com/&quot;&gt;http://iosdevweekly.com/&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NSHipster &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://nshipster.com/&quot;&gt;http://nshipster.com/&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Bartosz Ciechanowski &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://ciechanowski.me&quot;&gt;http://ciechanowski.me&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Big Nerd Ranch Blog &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://blog.bignerdranch.com&quot;&gt;http://blog.bignerdranch.com&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Nils Hayat &lt;/td&gt;
&lt;td&gt; &lt;a href=&quot;http://nilsou.com/&quot;&gt;http://nilsou.com/&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;另外，使用博客RSS聚合工具（例如Feedly：&lt;a href=&quot;http://www.feedly.com/&quot;&gt;http://www.feedly.com/&lt;/a&gt;）可以获得更好的博客阅读体验。手机上也有很多优秀的博客阅读工具（我使用的是&lt;a href=&quot;http://newsify.co/&quot;&gt;Newsify&lt;/a&gt;）。合理地使用这些工具也可以将你在地铁上、睡觉前等碎片时间充分利用上。&lt;/p&gt;

&lt;h2&gt;读书&lt;/h2&gt;

&lt;p&gt;博客的内容通常只能详细讲解一个知识点，而书籍则能成体系地介绍整个知识树。相比国外，中国的书籍售价相当便宜，所以这其实是一个非常划算的提高的方式。建议大家每年至少坚持读完1本高质量的iOS开发书籍。&lt;/p&gt;

&lt;p&gt;去年出版的&lt;a href=&quot;http://as.wiley.com/WileyCDA/WileyTitle/productCd-1118818342.html&quot;&gt;《iOS 7 Programming Pushing the Limits》&lt;/a&gt; 以及  &lt;a href=&quot;http://item.jd.com/11258970.html&quot;&gt;《Objective-C高级编程：iOS与OS X多线程和内存管理》&lt;/a&gt; 都算是不错的进阶方面的读物。顺便打个广告，我自己也在写一本iOS进阶方面的图书，年底前应该能上市。&lt;/p&gt;

&lt;h2&gt;看WWDC视频&lt;/h2&gt;

&lt;p&gt;由于iOS开发在快速发展，每年苹果都会给我们带来很多新的知识。而对于这些知识，第一手的资料就是WWDC的视频。&lt;/p&gt;

&lt;p&gt;通常情况下，一个iOS开发的新知识首先会在WWDC上被苹果公开，然后3个月左右，会有国内外的博客介绍这些知识，再过半年左右，会有国外的图书介绍这些知识。所以如果想尽早地了解这些知识，那么只有通过WWDC的视频。&lt;/p&gt;

&lt;p&gt;现在每年的WWDC视频都会在会议过程中逐步放出，重要的视频会带有英文字幕。坚持阅读这些视频不但可以获得最新的iOS开发知识，还可以提高英文听力水平。&lt;/p&gt;

&lt;h2&gt;看苹果的官方文档&lt;/h2&gt;

&lt;p&gt;苹果的官方文档相当详尽，对于不熟悉的API，阅读官方文档也是最直接有效地方式。&lt;/p&gt;

&lt;p&gt;苹果的文档比较海量，适合选一些重点来阅读，比如人机交互指南就是必读的，而其它的内容可以遇到的时候作为重点资源来查阅。&lt;/p&gt;

&lt;h2&gt;看开源项目的代码&lt;/h2&gt;

&lt;p&gt;大家一定有这样的感受，很多时候用文字讲解半天，还不如写几行代码来得直观。阅读优秀的开源项目代码，不但可以学习到iOS开发本身的基本知识，还能学习到设计模式等软件架构上的知识。&lt;/p&gt;

&lt;p&gt;如果读者能够参与到开源项目的开发中，则能进一步提高自己的能力。&lt;/p&gt;

&lt;h2&gt;多写代码，多思考&lt;/h2&gt;

&lt;p&gt;知识的积累离不开实践和总结，我认为iOS代码量如果没有超过10万行，是不能称得上熟悉iOS开发的。某些在校的学生，仅仅做了几个C++的大作业，就在求职简历里面写上“精通C++”，则真是让人哭笑不得。&lt;/p&gt;

&lt;p&gt;在多写代码的同时，我们也要注意不要”重复造轮子”，尽量保证每次写的代码都能具有复用性。在代码结构因为业务需求需要变更时，及时重构，在不要留下技术债的同时，我们也要多思考如何设计应用架构，能够保证满足灵活多变的产品需求。&lt;/p&gt;

&lt;p&gt;在多次重构和思考的过程中，我们就会慢慢积累出一类问题的“最佳实践”方式，成为自己宝贵的经验。&lt;/p&gt;

&lt;h2&gt;多和同行交流&lt;/h2&gt;

&lt;p&gt;有些时候遇到一些难解的技术问题，和同行的几句交流就可能让你茅塞顿开。。另外常见的技术问题通常都有人以前遇到过，简单指导几句就能让你一下子找到正确的解决方向。&lt;/p&gt;

&lt;p&gt;国内开发者之间的交流，可以通过论坛，微博，QQ群等方式来进行。另外各大公司有时候会办技术沙龙，这也是一个认识同行的好机会。&lt;/p&gt;

&lt;p&gt;需要特别提醒的是，和国内开发者之前交流要注意讨论质量，有一些论坛和QQ群讨论质量相当低下，提的问题都是能通过简单Google获得的，这种社区一定要远离，以提高自己的沟通效率。&lt;/p&gt;

&lt;p&gt;除了在国内的技术社区交流，建议读者可以去国外的stackoverflow：&lt;a href=&quot;http://www.stackoverflow.com&quot;&gt;http://www.stackoverflow.com&lt;/a&gt;上提问或回答问题。&lt;/p&gt;

&lt;h2&gt;分享&lt;/h2&gt;

&lt;p&gt;值得尝试的分享方式有：发起一个开源项目、写技术博客、在技术会议上做报告。这几种方式都比较有挑战，但是如果能大胆尝试，肯定会有巨大的收获。&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-27-ios-levelup-tips-44de87aac.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-27-ios-levelup-tips-44de87aac.html</guid>
        
        
      </item>
    
      <item>
        <title>Web Components 初探</title>
        <description>

		&lt;p&gt;众所周知，Web 页面是由 HTML+CSS+JavaScript 三板斧配合而成的，这体现了一种结构、表现、交互分离的思想。但是随着 Web 应用不断丰富，过度分离的设计也会带来可重用性上的问题。于是各家显神通，各种 UI 组件工具库层出不穷，煞有八仙过海之势。于是 W3C 坐不住了，大手一挥，说道：不如让我们统一一个 Web Components 的标准吧怎么样。&lt;/p&gt;
&lt;p&gt;Web Components 的核心思想就是把 UI 元素组件化，即将 HTML、CSS、JS 封装起来，使用的时候就不需要这里贴一段 HTML，那里贴一段样式，最后再贴一段 JS 了。一般来说，它其实是由四个部分的功能组成的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模板，&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 标签&lt;/li&gt;
&lt;li&gt;自定义元素&lt;/li&gt;
&lt;li&gt;Shadow DOM（隐匿 DOM）&lt;/li&gt;
&lt;li&gt;Imports（导入）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们还是通过一个简单的例子看看这些新玩意儿都是些什么吧。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-489&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;一段简单的 HTML&lt;/h2&gt;
&lt;p&gt;假设我们有一个提供 App 介绍的代码片段，为了不让事情变得更复杂，这里只有 HTML 和 CSS，不关 JS 什么事。&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
&amp;lt;div class=&quot;app-info&quot;&amp;gt;
  &amp;lt;div class=&quot;app-bar&quot;&amp;gt;
    &amp;lt;img class=&quot;app-icon&quot; src=&quot;http://img.dayanjia.com/di/TOY7/6c2442a7d933c8950f39059ed31373f083020094.png&quot; width=&quot;36&quot; height=&quot;36&quot;/&amp;gt;
    &amp;lt;div class=&quot;app-name&quot;&amp;gt;百度手机助手&amp;lt;/div&amp;gt;
    &amp;lt;a class=&quot;app-downbtn&quot; href=&quot;http://gdown.baidu.com/data/wisegame/de5074e4e28aecec/baidushoujizhushou_16783385.apk&quot;&amp;gt;下载&amp;lt;/a&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;app-description&quot;&amp;gt;
    百度手机助手是Android手机的权威资源平台，拥有最全最好的应用、游戏、壁纸资源，帮助您在海量资源中精准搜索、高速下载、轻松管理，万千汇聚，一触即得。海量资源：免费获取数十万款应用和游戏，更有海量独家正版壁纸，任你挑选。
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
.app-info {
  padding: 0.2em;
  border-bottom: 1px dotted #ddd;
}
.app-bar {
  display: flex;
  align-items: center;
  font-size: 14px;
}
.app-name {
  flex-grow: 2;
  margin-left: 1em;
}
.app-downbtn {
  text-decoration: none;
  padding: 0.2em 1.1em;
  margin-right: 1em;
  color: #fff;
  background: #5573eb;
}
.app-description {
  font-size: 12px;
}
&lt;/pre&gt;
&lt;p&gt;看上去就是这样的：&lt;/p&gt;
&lt;p data-height=&quot;170&quot; data-theme-id=&quot;0&quot; data-slug-hash=&quot;kKvif&quot; data-default-tab=&quot;result&quot; class=&quot;codepen&quot;&gt;See the Pen &lt;a href=&quot;http://codepen.io/clippit/pen/kKvif/&quot;&gt;kKvif&lt;/a&gt; by Letian Zhang (&lt;a href=&quot;http://codepen.io/clippit&quot;&gt;@clippit&lt;/a&gt;) on &lt;a href=&quot;http://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;模板&lt;/h2&gt;
&lt;p&gt;HTML 模板这个东西已经存在很久了，模板的实现无非是这么几种。一种是直接写在 DOM 里，但是给它一个 &lt;code&gt;display: none&lt;/code&gt; 的样式。使用这种模板，我们可以很方便地用 JavaScript 来操作 DOM 结构，但是如果你在模板里写了一个 &lt;code&gt;img&lt;/code&gt; 元素之类，不好意思，即使你看不到，这个图片的网络请求还是要发一下的。此外，与模板相对应的 CSS 也是和页面其他部分平行的关系，你需要给模板加一个 ID 之类的选择器前缀来指定样式，以保证不和页面中的其他元素冲突。&lt;/p&gt;
&lt;p&gt;第二种是使用 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签，但是给它指定一个非脚本的 &lt;code&gt;type&lt;/code&gt; 属性，这样浏览器就不会把它当做 JS 来执行了：&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
&amp;lt;script id=&quot;template&quot; type=&quot;x-tmpl-mustache&quot;&amp;gt;
Hello {{ name }}!
&amp;lt;/script&amp;gt;
&lt;/pre&gt;
&lt;p&gt;这种方法的好处在于，DOM 元素是不会预先渲染的，因为在被 JS 取得模板数据并插入 DOM 之前，它都是一堆死气沉沉的纯文本。同时这也是它的弊端，因为是纯文本，所以你要手动处理这些复杂的标签，需要格外小心 XSS 之类的问题。&lt;/p&gt;
&lt;p&gt;于是新的 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 标签就被提出了，它可以看做是结合了上面两种方法的优势。我们将上面的 HTML 模版化后：&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
&amp;lt;template id=&quot;appTmpl&quot;&amp;gt;
... 和之前一样的内容 ...
&amp;lt;/template&amp;gt;
&lt;/pre&gt;
&lt;p&gt;使用下面的 JS 就可以访问到模板，并将其插入 DOM 中。&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
var tmpl = document.querySelector(&#39;#appTmpl&#39;);
// 取到 t 以后，可以像操作 DOM 一样随意修改其中的内容
// 然后需要从模板创建一个深拷贝（Deep Copy），将其插入 DOM
var clone = document.importNode(tmpl.content, true);
// 创建深拷贝还可以使用下面的方法：
// var clone = tmpl.content.cloneNode(true);
document.body.appendChild(clone);
&lt;/pre&gt;
&lt;p&gt;最后的效果和之前看到的其实是一样的。&lt;/p&gt;
&lt;p data-height=&quot;170&quot; data-theme-id=&quot;0&quot; data-slug-hash=&quot;wglFf&quot; data-default-tab=&quot;result&quot; class=&quot;codepen&quot;&gt;See the Pen &lt;a href=&quot;http://codepen.io/clippit/pen/wglFf/&quot;&gt;wglFf&lt;/a&gt; by Letian Zhang (&lt;a href=&quot;http://codepen.io/clippit&quot;&gt;@clippit&lt;/a&gt;) on &lt;a href=&quot;http://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;当然了，这个模板的实现其实还是很原始的，并没有像 Mustache、Handlebars 等模板库的占位符替换的功能。&lt;/p&gt;
&lt;h2&gt;Shadow DOM&lt;/h2&gt;
&lt;p&gt;这个 Shadow 不太好翻译，反正理解成「隐藏在黑暗中的 DOM」就差不多了。所以说，Shadow DOM 其实是在文档的主 DOM 中生成了一块子 DOM，这个子 DOM 的 CSS 环境是和主文档隔离的。可以说，使用 Shadow DOM，我们就拥有了一个组件封装的原始模型。从外面看，它只是一个 DOM 节点，但是这其实是一个黑盒，里面还可以包含复杂的结构。这种抽象其实在大自然中随处可见，例如当我们谈论太阳系的时候，我们会把地球作为一个节点，但是当我们深入地球这个节点时，会发现还存在地月系这个结构。&lt;/p&gt;
&lt;p&gt;使用 Shadow DOM，我们需要在一个元素上创建一个根（Root），然后将模板内文档添加到这个根上即可。&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
&amp;lt;template id=&quot;appTmpl&quot;&amp;gt;
  &amp;lt;style&amp;gt;
  /* ... 将 CSS 移动到模板内 ... */
  &amp;lt;/style&amp;gt;
  ... 原来的模板内容 ...
&amp;lt;/template&amp;gt;

&amp;lt;div class=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
var tmpl = document.querySelector(&#39;#appTmpl&#39;);
var host = document.querySelector(&#39;.app&#39;);
var root = host.createShadowRoot();
root.appendChild(document.importNode(tmpl.content, true));
&lt;/pre&gt;
&lt;p&gt;最终的效果看上去是一样的，但是我们已经将这个 App 信息组件封装了一层 DOM。&lt;/p&gt;
&lt;p data-height=&quot;202&quot; data-theme-id=&quot;0&quot; data-slug-hash=&quot;xBpqn&quot; data-default-tab=&quot;result&quot; class=&quot;codepen&quot;&gt;See the Pen &lt;a href=&quot;http://codepen.io/clippit/pen/xBpqn/&quot;&gt;xBpqn&lt;/a&gt; by Letian Zhang (&lt;a href=&quot;http://codepen.io/clippit&quot;&gt;@clippit&lt;/a&gt;) on &lt;a href=&quot;http://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;自定义元素&lt;/h2&gt;
&lt;p&gt;现在我们已经能够使用一句 &lt;code&gt;&amp;lt;div class=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 外加一些 JS 来显示这个 App 信息的组件了（如果它够的上被称作是一个「组件」的话）。但是，我们能不能再给力一点，使用一个自己命名的元素呢？答案当然是肯定的。通过自定义元素的功能，就可以实现通过 &lt;code&gt;&amp;lt;app-info&amp;gt;&amp;lt;/app-info&amp;gt;&lt;/code&gt; 这样的方式来调用它了。&lt;/p&gt;
&lt;p&gt;HTML 除了上文的那些模板以外，只需要一个简单的容器。同时，接下来的例子中，我们还可以看到如何使用属性来替换模版中的变量，因此模板中也要做出一些修改。&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
&amp;lt;template id=&quot;appTmpl&quot;&amp;gt;
  &amp;lt;style&amp;gt;
    /* ... CSS 省略 ... */
  &amp;lt;/style&amp;gt;
  &amp;lt;div class=&quot;app-info&quot;&amp;gt;
    &amp;lt;div class=&quot;app-bar&quot;&amp;gt;
      &amp;lt;img class=&quot;app-icon&quot; src=&quot;&quot; width=&quot;36&quot; height=&quot;36&quot;/&amp;gt;
      &amp;lt;div class=&quot;app-name&quot;&amp;gt;&amp;lt;/div&amp;gt;
      &amp;lt;a class=&quot;app-downbtn&quot; href=&quot;&quot;&amp;gt;下载&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;app-description&quot;&amp;gt;
      &amp;lt;content selector=&quot;.description&quot;&amp;gt;&amp;lt;/content&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;app-info name=&quot;百度手机助手&quot; downurl=&quot;http://gdown.baidu.com/data/wisegame/de5074e4e28aecec/baidushoujizhushou_16783385.apk&quot; iconurl=&quot;http://img.dayanjia.com/di/TOY7/6c2442a7d933c8950f39059ed31373f083020094.png&quot;&amp;gt;
   &amp;lt;p class=&quot;description&quot;&amp;gt;百度手机助手是Android手机的权威资源平台，拥有最全最好的应用、游戏、壁纸资源，帮助您在海量资源中精准搜索、高速下载、轻松管理，万千汇聚，一触即得。海量资源：免费获取数十万款应用和游戏，更有海量独家正版壁纸，任你挑选。&amp;lt;/p&amp;gt;
&amp;lt;/app-info&amp;gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，Shadow DOM 也可以拥有子元素，而这些子元素在模板中将会使用 &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; 标签进行定位并替换。接下来，我们使用 JavaScript 创建这个名叫 app-info 的自定义元素。&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
var tmpl = document.querySelector(&#39;#appTmpl&#39;);

// 创建新元素的 Prototype
var appInfoProto = Object.create(HTMLElement.prototype);

// 自定义元素在不同的生命周期有不同的 Callback 可以使用。
// createdCallback 是在创建时调用的，此外还有
// attachedCallback（插入 DOM 时的回调）、
// detachedCallback（从 DOM 中移除时的回调）、
// attributeChangedCallback（属性改变时的回调）
appInfoProto.createdCallback = function() {
  var root = this.createShadowRoot();
  var name = this.getAttribute(&#39;name&#39;) || &#39;&#39;;
  var downUrl = this.getAttribute(&#39;downurl&#39;) || &#39;&#39;;
  var iconurl = this.getAttribute(&#39;iconurl&#39;) || &#39;&#39;;
  tmpl.content.querySelector(&#39;.app-name&#39;).textContent = name;
  tmpl.content.querySelector(&#39;.app-downbtn&#39;).href = downUrl;
  tmpl.content.querySelector(&#39;.app-icon&#39;).src = iconurl;
  // 将模板插入 Shadow DOM
  root.appendChild(document.importNode(tmpl.content, true));
};

// 注册自定义元素
var appInfo = document.registerElement(&#39;app-info&#39;, {
    prototype: appInfoProto
});
&lt;/pre&gt;
&lt;p&gt;最后看到的效果，其实和之前的没什么不同，但是我们很清楚，一个简单的 Web Component 雏形已经诞生了。&lt;/p&gt;
&lt;p data-height=&quot;170&quot; data-theme-id=&quot;6588&quot; data-slug-hash=&quot;wdkgo&quot; data-default-tab=&quot;result&quot; class=&quot;codepen&quot;&gt;See the Pen &lt;a href=&quot;http://codepen.io/clippit/pen/wdkgo/&quot;&gt;wdkgo&lt;/a&gt; by Letian Zhang (&lt;a href=&quot;http://codepen.io/clippit&quot;&gt;@clippit&lt;/a&gt;) on &lt;a href=&quot;http://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;通过 Chrome 的开发工具我们可以很清楚地看到 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 中的文档片段和我们自定义的 &lt;code&gt;&amp;lt;app-info&amp;gt;&lt;/code&gt; 元素中存在的 Shadow DOM。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bcs.duapp.com/mbuweb/shadow-dom.png&quot;&gt;&lt;img src=&quot;/images/mweb.baidu.com/64041d6ba7256ad606202108d9e21c6d.jpg&quot; alt=&quot;shadow-dom&quot; class=&quot;alignnone size-medium wp-image-494&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;导入&lt;/h2&gt;
&lt;p&gt;Web Components 的最后一部分是导入，这就比较容易理解了，就是提供了一个可复用的途径。我们可以像导入 CSS 一样，导入外部文件中的 HTML 代码。&lt;/p&gt;
&lt;pre class=&quot;wp-code-highlight prettyprint&quot;&gt;
&amp;lt;link rel=&quot;import&quot; href=&quot;app-info.html&quot;&amp;gt;
&lt;/pre&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;Web Components 这个东西还非常新，但是它代表了 Web 前端今后的一个发展方向。包括比较火的  AngularJS 等框架，其中的一些功能也或多或少地在使用 Web Components 的思想，并且推动其标准化（见 &lt;a href=&quot;https://docs.google.com/presentation/d/1Gv-dvU-yy6WY7SiNJ9QRo9XayPS6N2jtgWezdRpoI04/present&quot;&gt;the future of AngularJS&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;同时，也是因为它太新了，所以可能还会有非常大的改变，也许过几个月再来看这篇文章，部分内容就已经过时了:D 此外，当前浏览器对 Web Components 的支持也很有限，在 Chrome 35+ 中，本文中的全部例子都可以正常展现，其他浏览器就基本上悲剧了。对于这样一个新生状态，还处于快速变化期的事物，我也仅仅是浅尝辄止，本文更多在于抛砖引玉，若有疏漏还请读者多多指正。&lt;/p&gt;
&lt;p&gt;针对 Web Components 的功能，Google 出了一个叫做 &lt;a href=&quot;http://www.polymer-project.org/&quot;&gt;polymer&lt;/a&gt; 的项目，用于填补目前浏览器尚不能实现的部分，此外还内建了许多做好的组件。其实这个项目也推出挺久的了，但是一直不温不火，风头赶不上同是出自 Google 的 AngularJS。但是今年 Google IO 大会中，它却被作为 Material Design 的一部分拿出来介绍了，可见其还是很受重视的。下次如果有机会，可以介绍一下它。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://w3c.github.io/webcomponents/explainer&quot;&gt;Introduction to Web Components – W3C Editor’s Draft 9 June 2014&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://css-tricks.com/modular-future-web-components/&quot;&gt;A Guide to Web Components&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/webcomponents/template/&quot;&gt;HTML’s New Template Tag – standardizing client-side templating&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/&quot;&gt;Shadow DOM 101&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

			&lt;!-- .entry-content --&gt;

</description>
        <pubDate>Sat, 26 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-26-web-components-introduction.html-e996e644c.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-26-web-components-introduction.html-e996e644c.html</guid>
        
        
      </item>
    
      <item>
        <title>Chef入门（二）</title>
        <description>

	
	

	&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/a21eddb15b6ddbe9e395938fd299dee1.jpg&quot; title=&quot;Chef&quot; alt=&quot;Chef&quot;&gt;&lt;/p&gt;

&lt;p&gt;上一篇文章&lt;a href=&quot;/learn-chef-01.html&quot;&gt;Chef入门（一）&lt;/a&gt;我们介绍了Chef是什么、以及如何搭建Chef环境。这篇文章，我们介绍一下Chef中的一些概念以及如何编写&lt;a href=&quot;http://docs.getchef.com/chef_overview_cookbooks.html&quot;&gt;cookbook&lt;/a&gt;，并在此过程中部署一个Apache环境，通过本文你可以学到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建一个cookbook，并在其中添加recipe&lt;/li&gt;
&lt;li&gt;上传你的cookbook到Chef server&lt;/li&gt;
&lt;li&gt;配置node的run list&lt;/li&gt;
&lt;li&gt;在你的目标node上运行chef-client，执行cookbook中定义的操作。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;一些概念&lt;/h1&gt;

&lt;h2&gt;cookbook&lt;/h2&gt;

&lt;p&gt;cookbook是配置和策略的集合单元，它定义了一个场景，比如部署Apache环境。一个cookbook包含了很多组件来支持实现这个场景，以下是一个cookbook的目录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-rw-r--r--  1 weizhifeng  staff   495 Jul 21 11:01 CHANGELOG.md
-rw-r--r--@ 1 weizhifeng  staff  1536 Jul 21 11:01 README.md
drwxr-xr-x  2 weizhifeng  staff    68 Jul 21 11:01 attributes
drwxr-xr-x  2 weizhifeng  staff    68 Jul 21 11:01 definitions
drwxr-xr-x  3 weizhifeng  staff   102 Jul 21 11:01 files
drwxr-xr-x  2 weizhifeng  staff    68 Jul 21 11:01 libraries
-rw-r--r--@ 1 weizhifeng  staff   298 Jul 21 11:01 metadata.rb
drwxr-xr-x  2 weizhifeng  staff    68 Jul 21 11:01 providers
drwxr-xr-x  3 weizhifeng  staff   102 Jul 26 11:05 recipes
drwxr-xr-x  2 weizhifeng  staff    68 Jul 21 11:01 resources
drwxr-xr-x  3 weizhifeng  staff   102 Jul 21 11:01 templates
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;attributes：用来设置node的属性&lt;/li&gt;
&lt;li&gt;definitions：用来创建可以重用的resource集合&lt;/li&gt;
&lt;li&gt;files：一些需要的文件&lt;/li&gt;
&lt;li&gt;libraries：用来扩展chef-client或者添加一些helper到Ruby中&lt;/li&gt;
&lt;li&gt;metadata.rb：包含一些元数据，比如cookbook的名字、版本、支持的平台等等&lt;/li&gt;
&lt;li&gt;recipes：存储recipe，每个recipe指定了需要的resource以及这些resource执行的顺序&lt;/li&gt;
&lt;li&gt;resources：存储自定义的resource&lt;/li&gt;
&lt;li&gt;providers：存储自定义的provider&lt;/li&gt;
&lt;li&gt;templates：存储ruby模板语言描述的文件，用来解决复杂的配置场景&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;recipe&lt;/h2&gt;

&lt;p&gt;每个cookbook都会包含一到多个recipe（默认是default.rb）。一个recipe就是实现cookbook所描述场景的步骤。看以下这个简单的recipe：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package &#39;apache2&#39; do
  action :install
end

service &#39;apache2&#39; do
  action [ :enable, :start ]
end

cookbook_file &#39;/var/www/index.html&#39; do
  source &#39;index.html&#39;
  mode &#39;0644&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出这个recipe分为三个步骤，分别是安装apache2、启动apache2、拷贝文件。&lt;/p&gt;

&lt;h2&gt;resource和provider&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.getchef.com/chef/resources.html&quot;&gt;resource&lt;/a&gt;就是recipe中的配置项，可以是package、service、bash等等。provider就是为这些resource提供实现的程序。以编程语言来描述的话，resource定义了接口，provider提供了不同平台的实现。&lt;/p&gt;

&lt;h1&gt;实战&lt;/h1&gt;

&lt;p&gt;说了那么多概念，我们接下来在ubuntu上安装并配置Apache。&lt;/p&gt;

&lt;h2&gt;第一步：创建cookbook&lt;/h2&gt;

&lt;p&gt;在workstation中，我们通过&lt;a href=&quot;http://docs.opscode.com/knife.html&quot;&gt;knife&lt;/a&gt;来和Chef server进行交互。执行以下命令来创建一个cookbook。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/chef-repo
$ knife cookbook create apache-tutorial-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完成之后，在&lt;code&gt;~/chef-repo/cookbooks&lt;/code&gt;目录下会生成名为&lt;code&gt;apache-tutorial-1&lt;/code&gt;的cookbook。不过cookbook都是在本地的，还没有上传到Chef server。&lt;/p&gt;

&lt;h2&gt;第二步：编写recipe&lt;/h2&gt;

&lt;p&gt;当你创建了一个cookbook，Chef会帮你创建一个默认的recipe。用你的编辑器打开&lt;code&gt;~/chef-repo/cookbooks/apache-tutorial-1/recipes/default.rb&lt;/code&gt;。现在让我们来写一些ruby代码来执行以下的动作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装Apache&lt;/li&gt;
&lt;li&gt;启动Apache并且添加到开机启动&lt;/li&gt;
&lt;li&gt;配置home page&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;把以下代码添加到recipe中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package &#39;apache2&#39; do
  action :install
end

service &#39;apache2&#39; do
  action [ :enable, :start ]
end

cookbook_file &#39;/var/www/index.html&#39; do
  source &#39;index.html&#39;
  mode &#39;0644&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;第三步：添加文件资源&lt;/h2&gt;

&lt;p&gt;recipe的最后一步我们使用了&lt;a href=&quot;http://docs.opscode.com/resource_cookbook_file.html&quot;&gt;cookbook_file&lt;/a&gt;来拷贝home page。把以下内容添加到文件&lt;code&gt;~/chef-repo/cookbooks/apache-tutorial-1/files/default/index.html&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;第四步：上传cookbook&lt;/h2&gt;

&lt;p&gt;在你的chef-repo目录中执行以下命令来上传cookbook。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ knife cookbook upload apache-tutorial-1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;第五步：创建run list&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://learn.getchef.com/concepts/run-lists/&quot;&gt;run list&lt;/a&gt;定义了recipe的执行顺序，当前的例子中我们的run list中只有一个recipe。打开&lt;a href=&quot;http://manage.opscode.com&quot;&gt;manage.opscode.com&lt;/a&gt;，我们来配置run list。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/96c74b6968085a0b965e264aa5580207.jpg&quot; title=&quot;Chef&quot; alt=&quot;Chef&quot;&gt;&lt;/p&gt;

&lt;p&gt;然后从&lt;code&gt;Available Recipes&lt;/code&gt;中拖拽recipe到&lt;code&gt;Current Run List&lt;/code&gt;之中。然后点击&lt;code&gt;Save Run List&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/102b02c4239de93eb603a4c0cedeacba.jpg&quot; title=&quot;Chef&quot; alt=&quot;Chef&quot;&gt;&lt;/p&gt;

&lt;h2&gt;第六步：运行chef-client&lt;/h2&gt;

&lt;p&gt;接下来你需要执行&lt;a href=&quot;http://docs.opscode.com/essentials_chef_client.html&quot;&gt;chef-client&lt;/a&gt;来从Chef server获取最新的cookbook，并且在目标node上执行。你可以自己登录到node上，然后手动执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh chef@your.host
$ ssh sudo chef-client
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者使用knife。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ knife ssh your.host &#39;sudo chef-client&#39; -m -x chef -P chef
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-x&lt;/code&gt;表示username，&lt;code&gt;-P&lt;/code&gt;表示password。&lt;/p&gt;

&lt;p&gt;如果你使用的是vagrant，则执行如下命令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ knife ssh localhost &#39;sudo chef-client&#39; -m -x vagrant -P vagrant --ssh-port 2200
Starting Chef Client, version 11.12.8
resolving cookbooks for run list: [&quot;apache-tutorial-1&quot;]
Synchronizing Cookbooks:
  - apache-tutorial-1
Compiling Cookbooks...
Converging 3 resources
Recipe: apache-tutorial-1::default
  * package[apache2] action install (up to date)
  * service[apache2] action enable (up to date)
  * service[apache2] action start (up to date)
  * cookbook_file[/var/www/index.html] action create (up to date)

Running handlers:
Running handlers complete

Chef Client finished, 0/4 resources updated in 19.554803129 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等chef-client执行完成之后，你会发现Apache已经配置好并且运行了，并且把home page拷贝到了&lt;code&gt;/var/www/index.html&lt;/code&gt;，访问80端口应该可以看到home page的输出。&lt;/p&gt;

&lt;p&gt;至此我们已经创建了自己的cookbook，并在目标node上执行，更多的内容可以查看&lt;a href=&quot;http://docs.opscode.com/&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h1&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.getchef.com/chef_overview_cookbooks.html&quot;&gt;http://docs.getchef.com/chef_overview_cookbooks.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.getchef.com/legacy/tutorials/create-your-first-cookbook/&quot;&gt;http://learn.getchef.com/legacy/tutorials/create-your-first-cookbook/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.getchef.com/chef/resources.html&quot;&gt;http://docs.getchef.com/chef/resources.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


	(完)

	&lt;div class=&quot;post-info&quot;&gt;
		26 Jul 2014  
	
		
	
		
	&lt;/div&gt;
	
	&lt;!-- disqus start --&gt;
	
	
	&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;http://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;
&lt;/noscript&gt;
	
	&lt;!-- disqus end --&gt;

	&lt;!-- related start --&gt;
	
	&lt;!-- related end --&gt;

</description>
        <pubDate>Sat, 26 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-26-learn-chef-02.html-182938c79.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-26-learn-chef-02.html-182938c79.html</guid>
        
        
      </item>
    
      <item>
        <title>整形数据转换为字符串的研究</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;目前已经有多种将整形数据转换为字符串表达式的方法。虽然这些转换方法很少会遇到什么瓶颈，但是在分析特定应用的时候就有可能了。比如，在&lt;a title=&quot;Lawn&quot; href=&quot;http://lwan.ws/&quot; target=&quot;_blank&quot;&gt;Lwan&lt;/a&gt;里面构建响应头部的时候就经常会出现。&lt;/p&gt;
&lt;p&gt;就拿Lwan来说吧，最初是用snprintf()函数来转换数字。虽然在表面上这确实能起作用，但是却太没劲了。&lt;/p&gt;
&lt;p&gt;第二种方法是使用朴素算法：将原数连续与10相除，每次都把模转换成一个字符加在字符串后，当除到最后的余数为0时就停止并将字符串倒序得到最后的字符串。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: false&quot;&gt;// Code based on https://code.google.com/p/stringencoders/
size_t naive_uint32_to_str(uint32_t value, char *str) {
    char *wstr = str;
    // Conversion. Number is reversed.
    do
       *wstr++ = (char) decimal_digits[uvalue % 10];
    while (uvalue /= 10);
    *wstr = &#39;&#39;;
    // Reverse string
    strreverse(str, wstr - 1);
    return wstr - str;
}&lt;/pre&gt;
&lt;p&gt;这在一般情况下还是可以的，但倒转字符串的那一步总是令我困扰，为什么不直接向后写字符串呢?&lt;/p&gt;
&lt;p&gt;之后我就把Lawn的代码改写成了如下代码段。需要注意的是，无论sizeof(int32_t)是多少，我都把数字的最大的字节大小(包括终止符)设置成了MAX_INT的3倍。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: false&quot;&gt;#define INT_TO_STR_BUFFER_SIZE (3 * sizeof(int32_t))

char *lwan_uint32_to_str(uint32_t value,
            char buffer[static INT_TO_STR_BUFFER_SIZE],
            size_t *len) {
    char *p = buffer + INT_TO_STR_BUFFER_SIZE - 1;

    *p = &#39;&#39;;
    do {
        *--p = &quot;0123456789&quot;[value % 10];
    } while (value /= 10);

    size_t difference = (size_t)(p - buffer);
    *len = (size_t)(INT_TO_STR_BUFFER_SIZE - difference - 1;

    return p;
}&lt;/pre&gt;
&lt;p&gt;减少数组的写入操作使得算法速度明显加快。然而，在我修补刚才那个算法的时候我却犯了一个很多人都会尽量避免的错误：我让数组进行了额外的查询工作，在没有测试它的表现是否会更好的情况下就不管三七二十一提交了代码。如果使用查表法会比这快9%，噢！&lt;/p&gt;
&lt;p&gt;就在去年，Facebook的工程团队发布了一个更快的将整数转换成字符串的&lt;a title=&quot;函数&quot; href=&quot;https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920&quot; target=&quot;_blank&quot;&gt;函数&lt;/a&gt;。他们同样避免了将各个数字转换后形成的字符串转置的操作，并且他们把查表法运用得很好。&lt;/p&gt;
&lt;p&gt;这里的技巧就是，他们把这张表做成了从00到99的数值对，而不是简单的10个数字。这样就把除法运算的数量减少了一半，算法的性能得到很大的提升：比上面的代码段快了大概31%：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: false&quot;&gt;size_t facebook_uint32_to_str(uint32_t value, char *dst)
{
    static const char digits[201] =
        &quot;0001020304050607080910111213141516171819&quot;
        &quot;2021222324252627282930313233343536373839&quot;
        &quot;4041424344454647484950515253545556575859&quot;
        &quot;6061626364656667686970717273747576777879&quot;
        &quot;8081828384858687888990919293949596979899&quot;;
    size_t const length = digits10(value);
    size_t next = length - 1;
    while (value &amp;gt;= 100) {
        auto const i = (value % 100) * 2;
        value /= 100;
        dst[next] = digits[i + 1];
        dst[next - 1] = digits[i];
        next -= 2;
    }
    // Handle last 1-2 digits
    if (value &amp;lt; 10) {
        dst[next] = &#39;0&#39; + uint32_t(value);
    } else {
        auto i = uint32_t(value) * 2;
        dst[next] = digits[i + 1];
        dst[next - 1] = digits[i];
    }
    return length;
}&lt;/pre&gt;
&lt;p&gt;digits10()函数是另外一个使用特殊方式计算数字里面数字个数的函数。即使是高性能，我们也得想法防止一起调用这些东西：使用一个像numeric_limits&amp;lt;uint32_t&amp;gt;::digits10的常量来保持接口的一致性。这是可以实现的，因为dst缓存应该有足够的大小去容纳最大32位的无符号整型数据。&lt;/p&gt;
&lt;p&gt;这个函数基本上都是在把数字和10的次方相比较，并且当数字的位数超过了他们要比较的数的最大次方时就递归。由于这种实现细节，对于一个很小的数使用一个不变的长度并不会使速度得到显著的提升(比如一位或两位数字)；但如果你是出于优化的角度讲，那么使用一个常量并无大碍。如此，在我的机器上(一款搭载酷睿i7 2640M装有最新64位Arch Linux系统的笔记本)，它始终都会执行得更快：&lt;/p&gt;
&lt;div id=&quot;attachment_73982&quot; class=&quot;wp-caption alignnone&quot; style=&quot;width: 610px&quot;&gt;
&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/518b3804e42dfec09dc928ef21a38739.png&quot; rel=&quot;lightbox[73979]&quot; title=&quot;facebook_unit32_to_str()函数使用digits10()和常量值的相对速度&quot;&gt;&lt;img class=&quot;size-full wp-image-73982&quot; title=&quot;facebook_unit32_to_str()函数使用digits10()和常量值的相对速度&quot; alt=&quot;9V0PsPK&quot; src=&quot;/images/jobbole.com/ecbb24c54a151c9301fb6ad3fbeab730.jpg&quot; width=&quot;600&quot; height=&quot;371&quot;&gt;&lt;/a&gt;
&lt;p class=&quot;wp-caption-text&quot;&gt;facebook_unit32_to_str()函数使用digits10()和常量值的相对速度&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;上面这张图来源于我自己写的一个能够测试上面所有的整型转字符串方法的一个标准的程序。下面是一更完整的表，里面还和其它的一些方法进行了对比。&lt;/p&gt;
&lt;div id=&quot;attachment_73985&quot; class=&quot;wp-caption alignnone&quot; style=&quot;width: 610px&quot;&gt;
&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/531f1ea7fff6273f70d391ccff0af298.png&quot; rel=&quot;lightbox[73979]&quot; title=&quot;整形数据转换为字符串的研究&quot;&gt;&lt;img class=&quot;size-full wp-image-73985&quot; alt=&quot;b2enLNt&quot; src=&quot;/images/jobbole.com/f87cb7aa8b121de8ca5b0c94ae8ef0cd.jpg&quot; width=&quot;600&quot; height=&quot;371&quot;&gt;&lt;/a&gt;
&lt;p class=&quot;wp-caption-text&quot;&gt;省去了较大偏差的snprintf()函数，PS：它太慢了&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;不幸的是，本文存在这一个许可问题，它并不允许我使用Lawn的代码。这篇博客文章并没有提到这个许可。我是在《&lt;a title=&quot;https://mail-archives.apache.org/mod_mbox/apr-dev/200704.mbox/%3C344-65769@sneakemail.com%3E&quot; href=&quot;https://mail-archives.apache.org/mod_mbox/apr-dev/200704.mbox/%3C344-65769@sneakemail.com%3E&quot; target=&quot;_blank&quot;&gt;two-digit lookup table in places unrelated to Facebook&lt;/a&gt;》发现这个算法的，所以我并不确定到底是谁最先提出的。上面这些问题的很大的一个来源是&lt;a href=&quot;http://www.hackersdelight.org/&quot; target=&quot;_blank&quot;&gt;Hacker’s Delight&lt;/a&gt;网站，但是现在在那里却找不到了。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Sat, 26 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-26-73979-ecbf32eac.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-26-73979-ecbf32eac.html</guid>
        
        
      </item>
    
      <item>
        <title>Python 网页爬虫 &amp; 文本处理 &amp; 科学计算 &amp; 机器学习 &amp; 数据挖掘兵器谱</title>
        <description>

						&lt;p&gt;曾经因为&lt;a href=&quot;http://www.52nlp.cn/%E6%8E%A8%E8%8D%90%EF%BC%8D%E7%94%A8python%E8%BF%9B%E8%A1%8C%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%8D%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-nltk%E9%85%8D%E5%A5%97%E4%B9%A6&quot;&gt;NLTK&lt;/a&gt;的缘故开始学习Python，之后渐渐成为我工作中的第一辅助脚本语言，虽然开发语言是C/C++，但平时的很多文本数据处理任务都交给了Python。离开腾讯创业后，第一个作品&lt;a href=&quot;http://coursegraph.com/&quot;&gt;课程图谱&lt;/a&gt;也是选择了Python系的Flask框架，渐渐的将自己的绝大部分工作交给了Python。这些年来，接触和使用了很多Python工具包，特别是在文本处理，科学计算，机器学习和数据挖掘领域，有很多很多优秀的Python工具包可供使用，所以作为Pythoner，也是相当幸福的。其实如果仔细留意微博，你会发现很多这方面的分享，自己也Google了一下，发现也有同学总结了“&lt;a href=&quot;http://qxde01.blog.163.com/blog/static/67335744201368101922991/&quot;&gt;Python机器学习库&lt;/a&gt;”，不过总感觉缺少点什么。最近流行一个词，全栈工程师（full stack engineer），作为一个苦逼的创业者，天然的要把自己打造成一个full stack engineer，而这个过程中，这些Python工具包给自己提供了足够的火力，所以想起了这个系列。当然，这也仅仅是抛砖引玉，希望大家能提供更多的线索，来汇总整理一套Python网页爬虫，文本处理，科学计算，机器学习和数据挖掘的兵器谱。&lt;/p&gt;
&lt;p&gt;一、Python网页爬虫工具集&lt;/p&gt;
&lt;p&gt;一个真实的项目，一定是从获取数据开始的。无论文本处理，机器学习和数据挖掘，都需要数据，除了通过一些渠道购买或者下载的专业数据外，常常需要大家自己动手爬数据，这个时候，爬虫就显得格外重要了，幸好，Python提供了一批很不错的网页爬虫工具框架，既能爬取数据，也能获取和清洗数据，我们也就从这里开始了：&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://scrapy.org/&quot;&gt;Scrapy&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Scrapy, a fast high-level screen scraping and web crawling framework for Python.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;鼎鼎大名的Scrapy，相信不少同学都有耳闻，&lt;a href=&quot;http://coursegraph.com&quot;&gt;课程图谱&lt;/a&gt;中的很多课程都是依靠Scrapy抓去的，这方面的介绍文章有很多，推荐大牛pluskid早年的一篇文章：《&lt;a href=&quot;http://blog.pluskid.org/?p=366&quot;&gt;Scrapy 轻松定制网络爬虫&lt;/a&gt;》，历久弥新。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://scrapy.org/&quot;&gt;http://scrapy.org/&lt;/a&gt;&lt;br&gt;
Github代码页: &lt;a href=&quot;https://github.com/scrapy/scrapy&quot;&gt;https://github.com/scrapy/scrapy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/&quot;&gt;Beautiful Soup&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;You didn’t write that awful page. You’re just trying to get some data out of it. Beautiful Soup is here to help. Since 2004, it’s been saving programmers hours or days of work on quick-turnaround screen scraping projects.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;读书的时候通过《集体智慧编程》这本书知道Beautiful Soup的，后来也偶尔会用用，非常棒的一套工具。客观的说，Beautifu Soup不完全是一套爬虫工具，需要配合urllib使用，而是一套HTML/XML数据分析，清洗和获取工具。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/&quot;&gt;http://www.crummy.com/software/BeautifulSoup/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;https://github.com/grangier/python-goose&quot;&gt;Python-Goose&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Html Content / Article Extractor, web scrapping lib in Python&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/GravityLabs/goose&quot;&gt;Goose&lt;/a&gt;最早是用Java写得，后来用Scala重写，是一个Scala项目。Python-Goose用Python重写，依赖了Beautiful Soup。前段时间用过，感觉很不错，给定一个文章的URL, 获取文章的标题和内容很方便。&lt;/p&gt;
&lt;p&gt;Github主页：&lt;a href=&quot;https://github.com/grangier/python-goose&quot;&gt;https://github.com/grangier/python-goose&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二、Python文本处理工具集&lt;/p&gt;
&lt;p&gt;从网页上获取文本数据之后，依据任务的不同，就需要进行基本的文本处理了，譬如对于英文来说，需要基本的tokenize，对于中文，则需要常见的中文分词，进一步的话，无论英文中文，还可以词性标注，句法分析，关键词提取，文本分类，情感分析等等。这个方面，特别是面向英文领域，有很多优秀的工具包，我们一一道来。&lt;br&gt;
&lt;span id=&quot;more-6666&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://www.nltk.org/&quot;&gt;NLTK&lt;/a&gt; — Natural Language Toolkit&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;NLTK is a leading platform for building Python programs to work with human language data. It provides easy-to-use interfaces to over 50 corpora and lexical resources such as WordNet, along with a suite of text processing libraries for classification, tokenization, stemming, tagging, parsing, and semantic reasoning, and an active discussion forum.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;搞自然语言处理的同学应该没有人不知道NLTK吧，这里也就不多说了。不过推荐两本书籍给刚刚接触NLTK或者需要详细了解NLTK的同学: 一个是官方的《Natural Language Processing with Python》，以介绍NLTK里的功能用法为主，同时附带一些Python知识，同时国内陈涛同学友情翻译了一个中文版，这里可以看到：&lt;a href=&quot;http://www.52nlp.cn/%E6%8E%A8%E8%8D%90%EF%BC%8D%E7%94%A8python%E8%BF%9B%E8%A1%8C%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%8D%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-nltk%E9%85%8D%E5%A5%97%E4%B9%A6&quot;&gt;推荐《用Python进行自然语言处理》中文翻译-NLTK配套书&lt;/a&gt;；另外一本是《Python Text Processing with NLTK 2.0 Cookbook》，这本书要深入一些，会涉及到NLTK的代码结构，同时会介绍如何定制自己的语料和模型等，相当不错。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.nltk.org/&quot;&gt;http://www.nltk.org/&lt;/a&gt;&lt;br&gt;
Github代码页：&lt;a href=&quot;https://github.com/nltk/nltk&quot;&gt;https://github.com/nltk/nltk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://www.clips.ua.ac.be/pattern&quot;&gt;Pattern&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pattern is a web mining module for the Python programming language.&lt;/p&gt;
&lt;p&gt;It has tools for data mining (Google, Twitter and Wikipedia API, a web crawler, a HTML DOM parser), natural language processing (part-of-speech taggers, n-gram search, sentiment analysis, WordNet), machine learning (vector space model, clustering, SVM), network analysis and canvas visualization.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pattern由比利时安特卫普大学CLiPS实验室出品，客观的说，Pattern不仅仅是一套文本处理工具，它更是一套web数据挖掘工具，囊括了数据抓取模块（包括Google, Twitter, 维基百科的API，以及爬虫和HTML分析器），文本处理模块（词性标注，情感分析等），机器学习模块(VSM, 聚类，SVM）以及可视化模块等，可以说，Pattern的这一整套逻辑也是这篇文章的组织逻辑，不过这里我们暂且把Pattern放到文本处理部分。我个人主要使用的是它的英文处理模块&lt;a href=&quot;http://www.clips.ua.ac.be/pages/pattern-en&quot;&gt;Pattern.en&lt;/a&gt;, 有很多很不错的文本处理功能，包括基础的tokenize, 词性标注，句子切分，语法检查，拼写纠错，情感分析，句法分析等，相当不错。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.clips.ua.ac.be/pattern&quot;&gt;http://www.clips.ua.ac.be/pattern&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;http://textblob.readthedocs.org/en/dev/&quot;&gt;TextBlob&lt;/a&gt;: Simplified Text Processing&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;TextBlob is a Python (2 and 3) library for processing textual data. It provides a simple API for diving into common natural language processing (NLP) tasks such as part-of-speech tagging, noun phrase extraction, sentiment analysis, classification, translation, and more.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;TextBlob是一个很有意思的Python文本处理工具包，它其实是基于上面两个Python工具包NLKT和Pattern做了封装（TextBlob stands on the giant shoulders of NLTK and pattern, and plays nicely with both），同时提供了很多文本处理功能的接口，包括词性标注，名词短语提取，情感分析，文本分类，拼写检查等，甚至包括翻译和语言检测，不过这个是基于Google的API的，有调用次数限制。TextBlob相对比较年轻，有兴趣的同学可以关注。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://textblob.readthedocs.org/en/dev/&quot;&gt;http://textblob.readthedocs.org/en/dev/&lt;/a&gt;&lt;br&gt;
Github代码页：&lt;a href=&quot;https://github.com/sloria/textblob&quot;&gt;https://github.com/sloria/textblob&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;a href=&quot;http://www.clips.ua.ac.be/pages/MBSP&quot;&gt;MBSP&lt;/a&gt; for Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;MBSP is a text analysis system based on the TiMBL and MBT memory based learning applications developed at CLiPS and ILK. It provides tools for Tokenization and Sentence Splitting, Part of Speech Tagging, Chunking, Lemmatization, Relation Finding and Prepositional Phrase Attachment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;MBSP与Pattern同源，同出自比利时安特卫普大学CLiPS实验室，提供了Word Tokenization, 句子切分，词性标注，Chunking, Lemmatization，句法分析等基本的文本处理功能，感兴趣的同学可以关注。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.clips.ua.ac.be/pages/MBSP&quot;&gt;http://www.clips.ua.ac.be/pages/MBSP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;a href=&quot;http://radimrehurek.com/gensim/index.html&quot;&gt;Gensim&lt;/a&gt;: Topic modeling for humans&lt;/p&gt;
&lt;p&gt;Gensim是一个相当专业的主题模型Python工具包，无论是代码还是文档，我们曾经用《&lt;a href=&quot;http://www.52nlp.cn/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%96%87%E6%A1%A3%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%80&quot;&gt;如何计算两个文档的相似度&lt;/a&gt;》介绍过Gensim的安装和使用过程，这里就不多说了。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://radimrehurek.com/gensim/index.html&quot;&gt;http://radimrehurek.com/gensim/index.html&lt;/a&gt;&lt;br&gt;
github代码页：&lt;a href=&quot;https://github.com/piskvorky/gensim&quot;&gt;https://github.com/piskvorky/gensim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6. &lt;a href=&quot;https://github.com/saffsd/langid.py&quot;&gt;langid.py&lt;/a&gt;: Stand-alone language identification system&lt;/p&gt;
&lt;p&gt;语言检测是一个很有意思的话题，不过相对比较成熟，这方面的解决方案很多，也有很多不错的开源工具包，不过对于Python来说，我使用过langid这个工具包，也非常愿意推荐它。langid目前支持97种语言的检测，提供了很多易用的功能，包括可以启动一个建议的server，通过json调用其API，可定制训练自己的语言检测模型等，可以说是“麻雀虽小，五脏俱全”。&lt;/p&gt;
&lt;p&gt;Github主页：&lt;a href=&quot;https://github.com/saffsd/langid.py&quot;&gt;https://github.com/saffsd/langid.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7. &lt;a href=&quot;https://github.com/fxsjy/jieba&quot;&gt;Jieba&lt;/a&gt;: 结巴中文分词&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;“结巴”中文分词：做最好的Python中文分词组件 “Jieba” (Chinese for “to stutter”) Chinese text segmentation: built to be the best Python Chinese word segmentation module.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;好了，终于可以说一个国内的Python文本处理工具包了：结巴分词，其功能包括支持三种分词模式（精确模式、全模式、搜索引擎模式），支持繁体分词，支持自定义词典等，是目前一个非常不错的Python中文分词解决方案。&lt;/p&gt;
&lt;p&gt;Github主页：&lt;a href=&quot;https://github.com/fxsjy/jieba&quot;&gt;https://github.com/fxsjy/jieba&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8. &lt;a href=&quot;https://github.com/NLeSC/xtas&quot;&gt;xTAS&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;xtas, the eXtensible Text Analysis Suite, a distributed text analysis package based on Celery and Elasticsearch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;感谢微博朋友 &lt;a href=&quot;http://weibo.com/sinorichard&quot;&gt;@大山坡的春&lt;/a&gt; 提供的线索：我们组同事之前发布了xTAS，也是基于python的text mining工具包，欢迎使用，链接：http://t.cn/RPbEZOW。看起来很不错的样子，回头试用一下。&lt;/p&gt;
&lt;p&gt;Github代码页：&lt;a href=&quot;https://github.com/NLeSC/xtas&quot;&gt;https://github.com/NLeSC/xtas&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三、Python科学计算工具包&lt;/p&gt;
&lt;p&gt;说起科学计算，大家首先想起的是Matlab，集数值计算，可视化工具及交互于一身，不过可惜是一个商业产品。开源方面除了&lt;a href=&quot;http://www.gnu.org/software/octave/&quot;&gt;GNU Octave&lt;/a&gt;在尝试做一个类似Matlab的工具包外，Python的这几个工具包集合到一起也可以替代Matlab的相应功能：NumPy+SciPy+Matplotlib+iPython。同时，这几个工具包，特别是NumPy和SciPy，也是很多Python文本处理 &amp;amp; 机器学习 &amp;amp; 数据挖掘工具包的基础，非常重要。最后再推荐一个系列《&lt;a href=&quot;http://sebug.net/paper/books/scipydoc/index.html&quot;&gt;用Python做科学计算&lt;/a&gt;》，将会涉及到NumPy, SciPy, Matplotlib，可以做参考。&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NumPy is the fundamental package for scientific computing with Python. It contains among other things:&lt;br&gt;
1）a powerful N-dimensional array object&lt;br&gt;
2）sophisticated (broadcasting) functions&lt;br&gt;
3）tools for integrating C/C++ and Fortran code&lt;br&gt;
4） useful linear algebra, Fourier transform, and random number capabilities&lt;/p&gt;
&lt;p&gt;Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data. Arbitrary data-types can be defined. This allows NumPy to seamlessly and speedily integrate with a wide variety of databases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NumPy几乎是一个无法回避的科学计算工具包，最常用的也许是它的N维数组对象，其他还包括一些成熟的函数库，用于整合C/C++和Fortran代码的工具包，线性代数、傅里叶变换和随机数生成函数等。NumPy提供了两种基本的对象：ndarray（N-dimensional array object）和 ufunc（universal function object）。ndarray是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.numpy.org/&quot;&gt;http://www.numpy.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt;：Scientific Computing Tools for Python&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SciPy refers to several related but distinct entities:&lt;/p&gt;
&lt;p&gt;1）The SciPy Stack, a collection of open source software for scientific computing in Python, and particularly a specified set of core packages.&lt;br&gt;
2）The community of people who use and develop this stack.&lt;br&gt;
3）Several conferences dedicated to scientific computing in Python – SciPy, EuroSciPy and SciPy.in.&lt;br&gt;
4）The SciPy library, one component of the SciPy stack, providing many numerical routines.
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“SciPy是一个开源的Python算法库和数学工具包，SciPy包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。其功能与软件MATLAB、Scilab和GNU Octave类似。 Numpy和Scipy常常结合着使用，Python大多数机器学习库都依赖于这两个模块。”—-引用自“&lt;a href=&quot;http://qxde01.blog.163.com/blog/static/67335744201368101922991/&quot;&gt;Python机器学习库&lt;/a&gt;”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.scipy.org/&quot;&gt;http://www.scipy.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;http://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;matplotlib is a python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. matplotlib can be used in python scripts, the python and ipython shell (ala MATLAB®* or Mathematica®†), web application servers, and six graphical user interface toolkits.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;matplotlib 是python最著名的绘图库，它提供了一整套和matlab相似的命令API，十分适合交互式地进行制图。而且也可以方便地将它作为绘图控件，嵌入GUI应用程序中。Matplotlib可以配合ipython shell使用，提供不亚于Matlab的绘图体验，总之用过了都说好。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://matplotlib.org/&quot;&gt;http://matplotlib.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;a href=&quot;http://ipython.org/&quot;&gt;iPython&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IPython provides a rich architecture for interactive computing with:&lt;/p&gt;
&lt;p&gt;1）Powerful interactive shells (terminal and Qt-based).&lt;br&gt;
2）A browser-based notebook with support for code, text, mathematical expressions, inline plots and other rich media.&lt;br&gt;
3）Support for interactive data visualization and use of GUI toolkits.&lt;br&gt;
4）Flexible, embeddable interpreters to load into your own projects.&lt;br&gt;
5）Easy to use, high performance tools for parallel computing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“iPython 是一个Python 的交互式Shell，比默认的Python Shell 好用得多，功能也更强大。 她支持语法高亮、自动完成、代码调试、对象自省，支持 Bash Shell 命令，内置了许多很有用的功能和函式等，非常容易使用。 ” 启动iPython的时候用这个命令“ipython –pylab”，默认开启了matploblib的绘图交互，用起来很方便。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://ipython.org/&quot;&gt;http://ipython.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;四、Python 机器学习 &amp;amp; 数据挖掘 工具包&lt;/p&gt;
&lt;p&gt;机器学习和数据挖掘这两个概念不太好区分，这里就放到一起了。这方面的开源Python工具包有很多，这里先从熟悉的讲起，再补充其他来源的资料，也欢迎大家补充。&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://scikit-learn.org/&quot;&gt;scikit-learn&lt;/a&gt;: Machine Learning in Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;scikit-learn (formerly scikits.learn) is an open source machine learning library for the Python programming language. It features various classification, regression and clustering algorithms including support vector machines, logistic regression, naive Bayes, random forests, gradient boosting, k-means and DBSCAN, and is designed to interoperate with the Python numerical and scientific libraries NumPy and SciPy.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;首先推荐大名鼎鼎的scikit-learn，scikit-learn是一个基于NumPy, SciPy, Matplotlib的开源机器学习工具包，主要涵盖分类，回归和聚类算法，例如SVM， 逻辑回归，朴素贝叶斯，随机森林，k-means等算法，代码和文档都非常不错，在许多Python项目中都有应用。例如在我们熟悉的NLTK中，分类器方面就有专门针对scikit-learn的接口，可以调用scikit-learn的分类算法以及训练数据来训练分类器模型。这里推荐一个视频，也是我早期遇到scikit-learn的时候推荐过的：&lt;a href=&quot;http://52opencourse.com/552/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AApython%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7%E5%8C%85scikit-learn%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A7%86%E9%A2%91-tutorial-scikit-learn-machine-learning-in-python&quot;&gt;推荐一个Python机器学习工具包Scikit-learn以及相关视频–Tutorial: scikit-learn – Machine Learning in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://scikit-learn.org/&quot;&gt;http://scikit-learn.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://pandas.pydata.org/&quot;&gt;Pandas&lt;/a&gt;: Python Data Analysis Library&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Pandas is a software library written for the Python programming language for data manipulation and analysis. In particular, it offers data structures and operations for manipulating numerical tables and time series.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;第一次接触Pandas是由于Udacity上的一门数据分析课程“&lt;a href=&quot;http://coursegraph.com/introduction-to-data-science-udacity-ud359-%E5%85%B6%E4%BB%96%E5%A4%A7%E5%AD%A6%E6%88%96%E6%9C%BA%E6%9E%84&quot;&gt;Introduction to Data Science&lt;/a&gt;” 的Project需要用Pandas库，所以学习了一下Pandas。Pandas也是基于NumPy和Matplotlib开发的，主要用于数据分析和数据可视化，它的数据结构DataFrame和R语言里的data.frame很像，特别是对于时间序列数据有自己的一套分析机制，非常不错。这里推荐一本书《&lt;a href=&quot;http://bin.sc/Readings/Programming/Python/Python%20for%20Data%20Analysis/Python_for_Data_Analysis.pdf&quot;&gt;Python for Data Analysis&lt;/a&gt;》，作者是Pandas的主力开发，依次介绍了iPython, NumPy, Pandas里的相关功能，数据可视化，数据清洗和加工，时间数据处理等，案例包括金融股票数据挖掘等，相当不错。&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://pandas.pydata.org/&quot;&gt;http://pandas.pydata.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;=====================================================================&lt;br&gt;
分割线，以上工具包基本上都是自己用过的，以下来源于其他同学的线索，特别是《&lt;a href=&quot;http://qxde01.blog.163.com/blog/static/67335744201368101922991/&quot;&gt;Python机器学习库&lt;/a&gt;》，《&lt;a href=&quot;http://52opencourse.com/1125/23%E4%B8%AApython%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8C%85&quot;&gt;23个python的机器学习包&lt;/a&gt;》，做了一点增删修改，欢迎大家补充&lt;br&gt;
=====================================================================&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;http://mlpy.sourceforge.net/&quot;&gt;mlpy – Machine Learning Python&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mlpy is a Python module for Machine Learning built on top of NumPy/SciPy and the GNU Scientific Libraries.&lt;/p&gt;
&lt;p&gt;mlpy provides a wide range of state-of-the-art machine learning methods for supervised and unsupervised problems and it is aimed at finding a reasonable compromise among modularity, maintainability, reproducibility, usability and efficiency. mlpy is multiplatform, it works with Python 2 and 3 and it is Open Source, distributed under the GNU General Public License version 3.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://mlpy.sourceforge.net/&quot;&gt;http://mlpy.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;a href=&quot;http://mdp-toolkit.sourceforge.net/&quot;&gt;MDP&lt;/a&gt;：The Modular toolkit for Data Processing&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Modular toolkit for Data Processing (MDP) is a Python data processing framework.&lt;br&gt;
From the user’s perspective, MDP is a collection of supervised and unsupervised learning algorithms and other data processing units that can be combined into data processing sequences and more complex feed-forward network architectures.&lt;br&gt;
From the scientific developer’s perspective, MDP is a modular framework, which can easily be expanded. The implementation of new algorithms is easy and intuitive. The new implemented units are then automatically integrated with the rest of the library.&lt;br&gt;
The base of available algorithms is steadily increasing and includes signal processing methods (Principal Component Analysis, Independent Component Analysis, Slow Feature Analysis), manifold learning methods ([Hessian] Locally Linear Embedding), several classifiers, probabilistic methods (Factor Analysis, RBM), data pre-processing methods, and many others.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“MDP用于数据处理的模块化工具包，一个Python数据处理框架。 从用户的观点，MDP是能够被整合到数据处理序列和更复杂的前馈网络结构的一批监督学习和非监督学习算法和其他数据处理单元。计算依照速度和内存需求而高效的执行。从科学开发者的观点，MDP是一个模块框架，它能够被容易地扩展。新算法的实现是容易且直观的。新实现的单元然后被自动地与程序库的其余部件进行整合。MDP在神经科学的理论研究背景下被编写，但是它已经被设计为在使用可训练数据处理算法的任何情况中都是有用的。其站在用户一边的简单性，各种不同的随时可用的算法，及应用单元的可重用性，使得它也是一个有用的教学工具。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://mdp-toolkit.sourceforge.net/&quot;&gt;http://mdp-toolkit.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;a href=&quot;http://www.pybrain.org/&quot;&gt;PyBrain&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PyBrain is a modular Machine Learning Library for Python. Its goal is to offer flexible, easy-to-use yet still powerful algorithms for Machine Learning Tasks and a variety of predefined environments to test and compare your algorithms.&lt;/p&gt;
&lt;p&gt;PyBrain is short for Python-Based Reinforcement Learning, Artificial Intelligence and Neural Network Library. In fact, we came up with the name first and later reverse-engineered this quite descriptive “Backronym”.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“PyBrain(Python-Based Reinforcement Learning, Artificial Intelligence and Neural Network)是Python的一个机器学习模块，它的目标是为机器学习任务提供灵活、易应、强大的机器学习算法。（这名字很霸气）&lt;/p&gt;
&lt;p&gt;PyBrain正如其名，包括神经网络、强化学习(及二者结合)、无监督学习、进化算法。因为目前的许多问题需要处理连续态和行为空间，必须使用函数逼近(如神经网络)以应对高维数据。PyBrain以神经网络为核心，所有的训练方法都以神经网络为一个实例。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.pybrain.org/&quot;&gt;http://www.pybrain.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6. &lt;a href=&quot;http://pyml.sourceforge.net/&quot;&gt;PyML&lt;/a&gt; – machine learning in Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;PyML is an interactive object oriented framework for machine learning written in Python. PyML focuses on SVMs and other kernel methods. It is supported on Linux and Mac OS X.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“PyML是一个Python机器学习工具包，为各分类和回归方法提供灵活的架构。它主要提供特征选择、模型选择、组合分类器、分类评估等功能。”&lt;/p&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;http://pyml.sourceforge.net/&quot;&gt;http://pyml.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7. &lt;a href=&quot;https://pypi.python.org/pypi/milk/&quot;&gt;Milk&lt;/a&gt;：Machine learning toolkit in Python.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Its focus is on supervised classification with several classifiers available:&lt;br&gt;
SVMs (based on libsvm), k-NN, random forests, decision trees. It also performs&lt;br&gt;
feature selection. These classifiers can be combined in many ways to form&lt;br&gt;
different classification systems.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“Milk是Python的一个机器学习工具箱，其重点是提供监督分类法与几种有效的分类分析：SVMs(基于libsvm)，K-NN，随机森林经济和决策树。它还可以进行特征选择。这些分类可以在许多方面相结合，形成不同的分类系统。对于无监督学习，它提供K-means和affinity propagation聚类算法。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://luispedro.org/software/milk&quot;&gt;http://luispedro.org/software/milk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;http://luispedro.org/software/milk&lt;/p&gt;
&lt;p&gt;8. &lt;a href=&quot;http://www.pymvpa.org/&quot;&gt;PyMVPA&lt;/a&gt;: MultiVariate Pattern Analysis (MVPA) in Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;PyMVPA is a Python package intended to ease statistical learning analyses of large datasets. It offers an extensible framework with a high-level interface to a broad range of algorithms for classification, regression, feature selection, data import and export. It is designed to integrate well with related software packages, such as scikit-learn, and MDP. While it is not limited to the neuroimaging domain, it is eminently suited for such datasets. PyMVPA is free software and requires nothing but free-software to run.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“PyMVPA(Multivariate Pattern Analysis in Python)是为大数据集提供统计学习分析的Python工具包，它提供了一个灵活可扩展的框架。它提供的功能有分类、回归、特征选择、数据导入导出、可视化等”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.pymvpa.org/&quot;&gt;http://www.pymvpa.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9. &lt;a href=&quot;https://github.com/pydata/pyrallel&quot;&gt;Pyrallel&lt;/a&gt; – Parallel Data Analytics in Python&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Experimental project to investigate distributed computation patterns for machine learning and other semi-interactive data analytics tasks.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“Pyrallel(Parallel Data Analytics in Python)基于分布式计算模式的机器学习和半交互式的试验项目，可在小型集群上运行”&lt;/p&gt;
&lt;p&gt;Github代码页：&lt;a href=&quot;https://github.com/pydata/pyrallel&quot;&gt;http://github.com/pydata/pyrallel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;10. &lt;a href=&quot;http://montepython.sourceforge.net/&quot;&gt;Monte&lt;/a&gt; – gradient based learning in Python&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
Monte (python) is a Python framework for building gradient based learning machines, like neural networks, conditional random fields, logistic regression, etc. Monte contains modules (that hold parameters, a cost-function and a gradient-function) and trainers (that can adapt a module’s parameters by minimizing its cost-function on training data). &lt;/p&gt;
&lt;p&gt;Modules are usually composed of other modules, which can in turn contain other modules, etc. Gradients of decomposable systems like these can be computed with back-propagation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“Monte (machine learning in pure Python)是一个纯Python机器学习库。它可以迅速构建神经网络、条件随机场、逻辑回归等模型，使用inline-C优化，极易使用和扩展。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://montepython.sourceforge.net&quot;&gt;http://montepython.sourceforge.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;11. &lt;a href=&quot;http://deeplearning.net/software/theano/&quot;&gt;Theano&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently. Theano features:&lt;br&gt;
1）tight integration with NumPy – Use numpy.ndarray in Theano-compiled functions.&lt;br&gt;
2）transparent use of a GPU – Perform data-intensive calculations up to 140x faster than with CPU.(float32 only)&lt;br&gt;
3）efficient symbolic differentiation – Theano does your derivatives for function with one or many inputs.&lt;br&gt;
4）speed and stability optimizations – Get the right answer for log(1+x) even when x is really tiny.&lt;br&gt;
5）dynamic C code generation – Evaluate expressions faster.&lt;br&gt;
6） extensive unit-testing and self-verification – Detect and diagnose many types of mistake.&lt;br&gt;
Theano has been powering large-scale computationally intensive scientific investigations since 2007. But it is also approachable enough to be used in the classroom (IFT6266 at the University of Montreal).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“Theano 是一个 Python 库，用来定义、优化和模拟数学表达式计算，用于高效的解决多维数组的计算问题。Theano的特点：紧密集成Numpy；高效的数据密集型GPU计算；高效的符号微分运算；高速和稳定的优化；动态生成c代码；广泛的单元测试和自我验证。自2007年以来，Theano已被广泛应用于科学运算。theano使得构建深度学习模型更加容易，可以快速实现多种模型。PS：Theano，一位希腊美女，Croton最有权势的Milo的女儿，后来成为了毕达哥拉斯的老婆。”&lt;/p&gt;
&lt;p&gt;12. &lt;a href=&quot;http://deeplearning.net/software/pylearn2/&quot;&gt;Pylearn2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Pylearn2 is a machine learning library. Most of its functionality is built on top of Theano. This means you can write Pylearn2 plugins (new models, algorithms, etc) using mathematical expressions, and theano will optimize and stabilize those expressions for you, and compile them to a backend of your choice (CPU or GPU).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“Pylearn2建立在theano上，部分依赖scikit-learn上，目前Pylearn2正处于开发中，将可以处理向量、图像、视频等数据，提供MLP、RBM、SDA等深度学习模型。”&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://deeplearning.net/software/pylearn2/&quot;&gt;http://deeplearning.net/software/pylearn2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他的，欢迎大家补充，这里也会持续更新这篇文章。&lt;/p&gt;
&lt;p&gt;注：原创文章，转载请注明出处“&lt;a href=&quot;http://www.52nlp.cn&quot;&gt;我爱自然语言处理&lt;/a&gt;”：&lt;a href=&quot;http://www.52nlp.cn&quot;&gt;www.52nlp.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接地址：&lt;a href=&quot;http://www.52nlp.cn/python-%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98&quot;&gt;http://www.52nlp.cn/python-网页爬虫-文本处理-科学计算-机器学习-数据挖掘&lt;/a&gt;&lt;/p&gt;

											

</description>
        <pubDate>Thu, 24 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-24-python-%25e7%25bd%2591%25e9%25a1%25b5%25e7%2588%25ac%25e8%2599%25ab-%25e6%2596%2587%25e6%259c%25ac%25e5%25a4%2584%25e7%2590%2586-%25e7%25a7%2591%25e5%25ad%25a6%25e8%25ae%25a1%25e7%25ae%2597-%25e6%259c%25ba%25e5%2599%25a8%25e5%25ad%25a6%25e4%25b9%25a0-%25e6%2595%25b0%25e6%258d%25ae%25e6%258c%2596%25e6%258e%2598-060a30129.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-24-python-%25e7%25bd%2591%25e9%25a1%25b5%25e7%2588%25ac%25e8%2599%25ab-%25e6%2596%2587%25e6%259c%25ac%25e5%25a4%2584%25e7%2590%2586-%25e7%25a7%2591%25e5%25ad%25a6%25e8%25ae%25a1%25e7%25ae%2597-%25e6%259c%25ba%25e5%2599%25a8%25e5%25ad%25a6%25e4%25b9%25a0-%25e6%2595%25b0%25e6%258d%25ae%25e6%258c%2596%25e6%258e%2598-060a30129.html</guid>
        
        
      </item>
    
      <item>
        <title>一比特之差：无需利用漏洞的DNS劫持</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p align=&quot;left&quot;&gt;Bitsquatting表示去注册一个域名，它和知名的域名只有一个bit的差别。这个单词源自typosquatting，意为注册一个和知名域名只有一字之差的域名。在解析域名时，bitsquatting可能通过DNS导致计算机上的硬件错误。关于bitsquatting更详细的信息，可以参看我的&lt;a href=&quot;http://media.blackhat.com/bh-us-11/Dinaburg/BH_US_11_Dinaburg_Bitsquatting_WP.pdf&quot;&gt;Blackhat 2011 whitepaper&lt;/a&gt;。YouTube上有人发布了我在DEF CON 19上有关此话题的演讲&lt;a href=&quot;http://www.youtube.com/watch?v=lZ8s1JwtNas&quot;&gt;视频&lt;/a&gt;，当时使用的幻灯片可以在&lt;a href=&quot;http://dinaburg.org/data/DC19_Dinaburg_Presentation.pdf&quot;&gt;这里下载&lt;/a&gt;。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;引言&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;计算机常常由于一个或多比特的内存损坏出现错误，而造成这些错误的原因可能是制造上的缺陷或者宇宙射线、高温之类的环境因素。虽然单个机器中出现这样的错误的可能性是极小的，但是整个互联网上设备的总量却非常庞大：2010年时就有大约50亿个设备连接到互联网。我们可以将这种存在于各个设备上的小概率错误更加形象地描述，那就是买彩票。赢得头奖的概率是极小的，但是只要有足够多的人去买，总有人会成为赢家。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;研究人员之前就在很多&lt;a href=&quot;https://www.cs.princeton.edu/~appel/papers/memerr.pdf&quot;&gt;惊人的地方&lt;/a&gt;利用了比特错误（bit-errors）。现在，在互联网尺度上，我们又有新的办法去利用它。Bitsquatting是其中之一，也就是注册和某个常被访问的域名仅一比特之差的新域名。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;工作原理&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;当比特错误发生时，内存中的数据会被修改。计算机内存的内容可能代表各种意义，有时，它刚好就表示域名。如果程序使用这块内存，就会读取到错误的域名。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下面的图解能够更清楚的说明这个问题，表中是cnn.com的二进制表示方法：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01100011&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101110&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0110111&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0101110&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01100011&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101111&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;n&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;n&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;o&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;m&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p align=&quot;left&quot;&gt;现在假设你使用的计算机含有损坏的内存模块，你打开一个包含超链接到cnn.com的网页，然后你点击了这个链接。会有多少个操作将cnn.com的二进制数据保存到你的内存？写这篇文章时，我想到了下面这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP/IP协议栈由核心态向用户态转化时（根据操作系统的具体实现各有区别）&lt;/li&gt;
&lt;li&gt;在浏览器解析HTML时&lt;/li&gt;
&lt;li&gt;在创建DOM树的内部表示时&lt;/li&gt;
&lt;li&gt;在创建新的HTTP请求时&lt;/li&gt;
&lt;li&gt;在操作系统解析域名时&lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&quot;left&quot;&gt;更进一步，假设其中有一次将域名写入到了损坏的内存模块，它的二进制形式被修改了1bit，现在表示为：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01100011&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0110111&lt;span style=&quot;color: red;&quot;&gt;1&lt;/span&gt;
&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0110111&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0101110&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01100011&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101111&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;01101101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;o&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;n&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;o&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;m&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p align=&quot;left&quot;&gt; 这样一来，当你点击链接时，浏览器将会跳转到con.com，而不是cnn.com。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;实验&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;这个实验背后的概念很简单：如果比特错误确实改变了设备内存中的域名，那么这些设备会访问到和正确域名一比特之差的bitsquat域名。因此很多频繁解析的域名的bitsquat域名会被全球各地的设备访问到。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;然而这个实验实施起来却没有那么容易，首要的问题是选择合适的域名来进行比特修改。流行的网站和常被解析的域名是不太相同的，很多鲜为人知的域名实际上会被频繁解析。这类域名一般属于内容分发网络或者广告网络，例如fbcdn.net,、2mdn.net和 akamai.com。由于很少有人实际在浏览器中输入这些域名，它们也成为本次实验中最合适的目标。还有个问题就是每次DNS查询必须有两次响应：一次是原本的域名，一次是经过比特修改的域名。因为原始的请求可能会得到正确域名的响应，而丢弃对无效域名的响应。这方面更多的信息，请参考&lt;a href=&quot;http://media.blackhat.com/bh-us-11/Dinaburg/BH_US_11_Dinaburg_Bitsquatting_WP.pdf&quot;&gt;白皮书&lt;/a&gt;或者&lt;a href=&quot;http://dinaburg.org/data/DC19_Dinaburg_Presentation.pdf&quot;&gt;幻灯片&lt;/a&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;为了这次实验我注册了下面这些域名。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注：目前它们全都已经过期，不再属于我了。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;&lt;b&gt;Bitsquat Domain&lt;/b&gt;&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;&lt;b&gt;Original Domain&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;ikamai.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;akamai.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;aeazon.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;amazon.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;a-azon.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;amazon.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;amazgn.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;amazon.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsmft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;micrgsoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;miarosoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;iicrosoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsnft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;mhcrosoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;eicrosoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;mic2osoft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;micro3oft.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;microsoft.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;li6e.com&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;live.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;0mdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2-dn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2edn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2ldn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mfn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mln.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2odn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;6mdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;2mdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbbdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbgdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;gbcdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fjcdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;dbcdn.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;fbcdn.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;roop-servers.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;root-servers.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;doublechick.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;doubleclick.net&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;do5bleclick.net&lt;/td&gt;
&lt;td style=&quot;padding: 0; border: 1px solid #e8e8e8;&quot;&gt;doubleclick.net&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p align=&quot;left&quot;&gt;我使用Python脚本应答DNS请求，并且使用Apache记录HTTP请求。令我惊讶的是，有设备连接了。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;实验发现&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;以下结论是基于2010年9月26日至2011年5月5日间的Apache日志得出的。由搜索引擎爬虫和Web漏洞扫描器引起的日志已经被手动过滤了。正因为是手动操作，所以最后统计时可能还有很小一部分漏网之鱼。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现1：比特错误可以被利用在DNS上&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在记录日志期间总共有52317次针bitsquat域名的请求，它们来自与12949个独立IP。除去其中3次产生巨大网络流量的事件，平均每天有59个独立IP对32个bitsquat域名进行了请求。这些请求不是来自于拼写错误或者其他形式的手工输入URL，还有一部分表现出有多个比特错误的特征。以下是一些实际的例子（个人信息已经移除）：&lt;/p&gt;
&lt;div style=&quot;background-color: #eeeeee;&quot;&gt;
&lt;p align=&quot;left&quot;&gt;static.ak.fjcdn.net 109.242.50.xxx “GET /rsrc.php/z67NS/hash/4ys0envq.js HTTP/1.1″ “http://www.facebook.com/profile.php?id=xxxxxxxxxx” “Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; WOW64; Trident/4.0; GTB6.5; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.30729; .NET CLR 3.5.30729; InfoPath.2; Hotbar 11.0.78.0; OfficeLiveConnector.1.5; OfficeLivePatch.1.3; AskTbZTV/5.8.0.12304)”&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;msgr.dlservice.mic2osoft.com 213.178.224.xxx “GET /download/A/6/1/A616CCD4-B0CA-4A3D-B975-3EDB38081B38/ar/wlsetup-cvr.exe HTTP/1.1″ 404 268 “Microsoft BITS/6.6″&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;s0.2ldn.net 66.82.9.xxx “GET /879366/flashwrite_1_2.js HTTP/1.1″ “http://webmail.satx.rr.com/_uac/adpage.html” “Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; HPNTDF; AskTB5.2)”&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;mmv.admob.com 109.175.185.xxx “GET /static/iphone/img/app@2x.png HTTP/1.1″ “Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_1 like Mac OS X; HW iPhone2,1; en_gb) AppleWebKit/525.18.1 (KHTML, like Gecko) (AdMob-iSDK-20101108; iphoneos4.2)”&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现2：并不是所有的比特错误都造成同等程度的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;有些机器相比其他而言，明显控制着更多的网络流量。当一个比特错误发生在普通PC机或者手机上时，它只会影响到一个用户。然而当它发生在代理、DNS服务器或者数据库缓存中时，将会影响到成千上万的用户。在我的实验中，已经观察到了比特错误出现在Web应用、DNS解析服务器和代理服务器中。例如，一个比特错误将fbcnd.net变为fbbdn.net，将使上千个开心农场的玩家请求到我的服务器。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现3：手机和嵌入式设备可能比传统硬件受的影响更大&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我对2011年3月期间访问Wikipedia和bitsquat域名的HTTP User-Agent进行了对比，展示在下面的图例中。其中Other包括了各种手机、游戏机控制台和其他嵌入式设备，它们在对bitsquat域名的访问中，增加的幅度最大。令人好奇的是，来自MacOS针对bitsquat域名的访问相比Wikipedia有显著减少，对此我还没有一个合理的解释。（译注：这里是按两个域名各自的设备分布算的，其中有增多必然有减少，也许分别计算每种设备访问错域名的几率更加合理，即&lt;i&gt;访问错误域名的次数 / 对两种域名的访问总数&lt;/i&gt;。）&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/f435855d0cd7c34aa3ae589293727d00.png&quot; rel=&quot;lightbox[74149]&quot; title=&quot;一比特之差：无需利用漏洞的DNS劫持&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-74152&quot; alt=&quot;bitsquat_1&quot; src=&quot;/images/jobbole.com/d6868d8be74912de5d5ab88747e4aace.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现4：对bitsquat域名的访问流量是日常网络流量的真实写照&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Bitsquat域名的访问者来自于全球各地，其使用的设备也几乎涵盖每种主流的操作系统和嵌入式平台。除使用MacOS的访问者所占的百分比在两种域名间有显著差别之外，使用Windows、Linux、Android和iPhones的百分比基本相同。另外，基于IP地理位置数据库，我们可以观察到来自于美国的访问者在一天内的流量走势。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/ade11df8bbcc2b7bcbd7e3564ed2cdfa.png&quot;&gt;&lt;br&gt;
&lt;/a&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/ade11df8bbcc2b7bcbd7e3564ed2cdfa.png&quot; rel=&quot;lightbox[74149]&quot; title=&quot;一比特之差：无需利用漏洞的DNS劫持&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-74153&quot; alt=&quot;bitsquat_2&quot; src=&quot;/images/jobbole.com/15bbd2df363455797824469e667561cb.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;发现5：HTTPS/TLS不会有帮助，DNSSEC可能会有一丁点&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;HTTP 1.1在头中包含了一个叫Host的字段，其数值是客户端想要访问的域名。如果Host中包含着bitsquat域名，那么比特错误在域名解析前就发生了。如果Host中是原始域名，那么错误就是发生在域名解析中。我数据中96%的情况是在DNS解析前就出现了比特错误。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/a78196125356295d8d331b1a05dc252a.png&quot; rel=&quot;lightbox[74149]&quot; title=&quot;一比特之差：无需利用漏洞的DNS劫持&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-74154&quot; alt=&quot;bitsquat_3&quot; src=&quot;/images/jobbole.com/cd7c742d1f56b45900a483b0ed4471db.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;像SSL和TLS这种安全传输技术是用于保证两端之间数据的机密性、真实性和完整性，但是比特错误更多发生在数据在某一端还未传输的时候。DNSSEC只能解决那4%发生在域名解析过程中的比特错误。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;数据&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;DNS流量的全部PCAP在此：&lt;a href=&quot;http://dinaburg.org/data/dnslogs.tar.7z&quot;&gt;dnslogs.tar.7z&lt;/a&gt;，56Mb&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;HTTP日志可能包含个人信息，因此不会公开发布。如果你有正当的研究目的需要它们，请&lt;a href=&quot;http://dinaburg.org/about.html&quot;&gt;联系我&lt;/a&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这里有个工具可以快速识别潜在的bitsquat域名：&lt;a href=&quot;http://dinaburg.org/data/bitsquat.py&quot;&gt;bitsquat.py&lt;/a&gt;，&lt;a href=&quot;https://github.com/artemdinaburg/bitsquat-script&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;进一步研究&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;来自Verisign的Duane Wessels也在DNS查询中寻找过网络级别的比特错误，他指出“&lt;b&gt;&lt;a href=&quot;http://www.verisigninc.com/assets/VRSN_Bitsquatting_TR_20120320.pdf&quot;&gt;网络中比特错误相对而言是很少见的，但是有一个可预期的概率&lt;/a&gt;&lt;/b&gt;”。他研究的主要目的，是确定那4%发生在域名解析时的比特错误是否由UDP包在传输后的损坏造成。结论是网络中传输的包不太可能被损坏，用他自己的话说：“我们相信UDP的校验和能够有效防范bitsquat攻击或者其他DNS查询时的错误。无论如何，在进入网络前发生的比特错误不会从中受益，因为在传输前计算的校验和是基于错误的数据得出的。“&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我非常鼓励读者重复我的实验，并且分享你们的结果。如果需要更多信息，请随时&lt;a href=&quot;http://dinaburg.org/about.html&quot;&gt;联系我&lt;/a&gt;。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Thu, 24 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-24-74149-9c77c2cb8.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-24-74149-9c77c2cb8.html</guid>
        
        
      </item>
    
      <item>
        <title>四层和七层负载均衡的区别</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;（一）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;简单理解四层和七层负载均衡:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;① &lt;/strong&gt;所谓四层就是基于IP+端口的负载均衡；七层就是基于URL等应用层信息的负载均衡；同理，还有基于MAC地址的二层负载均衡和基于IP地址的三层负载均衡。 换句换说，二层负载均衡会通过一个虚拟MAC地址接收请求，然后再分配到真实的MAC地址；三层负载均衡会通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址；四层通过虚拟IP+端口接收请求，然后再分配到真实的服务器；七层通过虚拟的URL或主机名接收请求，然后再分配到真实的服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② &lt;/strong&gt;所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。 比如四层的负载均衡，就是通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。七层的负载均衡，就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ &lt;/strong&gt;负载均衡器通常称为四层交换机或七层交换机。四层交换机主要分析IP层及TCP/UDP层，实现四层流量负载均衡。七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息。&lt;/p&gt;
&lt;p&gt;1、负载均衡分为L4 switch（四层交换），即在OSI第4层工作，就是TCP层啦。此种Load Balance不理解应用协议（如HTTP/FTP/MySQL等等）。例子：LVS，F5。&lt;/p&gt;
&lt;p&gt;2、另一种叫做L7 switch（七层交换），OSI的最高层，应用层。此时，该Load Balancer能理解应用协议。例子：  haproxy，MySQL Proxy。&lt;/p&gt;
&lt;p&gt;注意：上面的很多Load Balancer既可以做四层交换，也可以做七层交换。&lt;/p&gt;
&lt;p&gt;（二）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　负载均衡设备也常被称为”四到七层交换机”，那么四层和七层两者到底区别在哪里？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第一，技术原理上的区别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　所谓四层负载均衡&lt;/strong&gt;，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。&lt;/p&gt;
&lt;p&gt;以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/b91593dea3eb4eeaacc72d17c55295c4.png&quot; rel=&quot;lightbox[74131]&quot; title=&quot;四层和七层负载均衡的区别&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-74132&quot; alt=&quot;03114159-1d39f32589b04705b65bf5bda16d2252&quot; src=&quot;/images/jobbole.com/8483cda2a4febf251cbf250fc9ae6c06.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所&lt;/strong&gt;&lt;strong&gt;谓七层负载均衡&lt;/strong&gt;，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。&lt;/p&gt;
&lt;p&gt;以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第二，应用场景的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;七层应用负载的好处，是使得整个网络更”&lt;strong&gt;智能化&lt;/strong&gt;“。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，例如Nginx或者Apache上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。&lt;/p&gt;
&lt;p&gt;另外一个常常被提到功能就&lt;strong&gt;是&lt;/strong&gt;安全性。网络中最常见的SYN Flood攻击，即黑客控制众多源客户端，使用虚假IP地址对同一目标发送SYN攻击，通常这种攻击会大量发送SYN报文，耗尽服务器上的相关资源，以达到Denial of Service(&lt;em&gt;DoS&lt;/em&gt;)的目的。从技术原理上也可以看出，四层模式下这些SYN攻击都会被转发到后端的服务器上；而七层模式下这些SYN攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。另外负载均衡设备可以在七层层面设定多种策略，过滤特定报文，例如SQL Injection等应用层面的特定攻击手段，从应用层面进一步提高系统整体安全。&lt;/p&gt;
&lt;p&gt;现在的7层负载均衡，主要还是着重于&lt;strong&gt;应用&lt;/strong&gt;HTTP协议，所以其应用范围主要是众多的网站或者内部信息平台等基于B/S开发的系统。 4层负载均衡则对应其他TCP应用，例如基于C/S开发的ERP等系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第三，七层应用需要考虑的问题。&lt;a href=&quot;http://hi.baidu.com/aking_roc&quot; target=&quot;_blank&quot;&gt;&lt;br&gt;
&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1：是否真的必要&lt;/strong&gt;，七层应用的确可以提高流量智能化，同时必不可免的带来设备配置复杂，负载均衡压力增高以及故障排查上的复杂性等问题。在设计系统时需要考虑四层七层同时应用的混杂情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2：是否真的可以提高安全性&lt;/strong&gt;。例如SYN Flood攻击，七层模式的确将这些流量从服务器屏蔽，但负载均衡设备本身要有强大的抗DDoS能力，否则即使服务器正常而作为中枢调度的负载均衡设备故障也会导致整个应用的崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3：是否有足够的灵活度&lt;/strong&gt;。七层应用的优势是可以让整个应用的流量智能化，但是负载均衡设备需要提供完善的七层功能，满足客户根据不同情况的基于应用的调度。最简单的一个考核就是能否取代后台Nginx或者Apache等服务器上的调度功能。能够提供一个七层应用开发接口的负载均衡设备，可以让客户根据需求任意设定功能，才真正有可能提供强大的灵活性和智能性。&lt;/p&gt;
&lt;p&gt;（三）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　负载均衡四七层介绍:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡（Load Balance）建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。&lt;/p&gt;
&lt;p&gt;负载均衡有两方面的含义：首先，大量的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间；其次，单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高。&lt;/p&gt;
&lt;p&gt;本文所要介绍的负载均衡技术主要是指在均衡服务器群中所有服务器和应用程序之间流量负载的应用，目前负载均衡技术大多数是用于提高诸如在Web服务器、FTP服务器和其它关键任务服务器上的Internet服务器程序的可用性和可伸缩性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　负载均衡技术分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前有许多不同的负载均衡技术用以满足不同的应用需求，下面从负载均衡所采用的设备对象、应用的网络层次（指OSI参考模型）及应用的地理结构等来分类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　软/硬件负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，如DNS Load Balance，CheckPoint Firewall-1 ConnectControl等，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。&lt;/p&gt;
&lt;p&gt;软件解决方案缺点也较多，因为每台服务器上安装额外的软件运行会消耗系统不定量的资源，越是功能强大的模块，消耗得越多，所以当连接请求特别大的时候，软件本身会成为服务器工作成败的一个关键；软件可扩展性并不是很好，受到操作系统的限制；由于操作系统本身的Bug，往往会引起安全问题。&lt;/p&gt;
&lt;p&gt;硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备我们通常称之为负载均衡器，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。&lt;/p&gt;
&lt;p&gt;负载均衡器有多种多样的形式，除了作为独立意义上的负载均衡器外，有些负载均衡器集成在交换设备中，置于服务器与Internet链接之间，有些则以两块网络适配器将这一功能集成到PC中，一块连接到Internet上，一块连接到后端服务器群的内部网络上。&lt;/p&gt;
&lt;p&gt;一般而言，硬件负载均衡在功能、性能上优于软件方式，不过成本昂贵。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　本地/全局负载均衡&lt;a href=&quot;http://hi.baidu.com/aking_roc&quot; target=&quot;_blank&quot;&gt;&lt;br&gt;
&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡从其应用的地理结构上分为本地负载均衡(Local Load Balance)和全局负载均衡(Global Load Balance，也叫地域负载均衡)，本地负载均衡是指对本地的服务器群做负载均衡，全局负载均衡是指对分别放置在不同的地理位置、有不同网络结构的服务器群间作负载均衡。&lt;/p&gt;
&lt;p&gt;本地负载均衡能有效地解决数据流量过大、网络负荷过重的问题，并且不需花费昂贵开支购置性能卓越的服务器，充分利用现有设备，避免服务器单点故障造成数据流量的损失。其有灵活多样的均衡策略把数据流量合理地分配给服务器群内的服务器共同负担。即使是再给现有服务器扩充升级，也只是简单地增加一个新的服务器到服务群中，而不需改变现有网络结构、停止现有的服务。&lt;/p&gt;
&lt;p&gt;全局负载均衡主要用于在一个多区域拥有自己服务器的站点，为了使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器，从而获得最快的访问速度，也可用于子公司分散站点分布广的大公司通过Intranet（企业内部互联网）来达到资源统一合理分配的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　网络层次上的负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对网络上负载过重的不同瓶颈所在，从网络的不同层次入手，我们可以采用相应的负载均衡技术来解决现有问题。&lt;/p&gt;
&lt;p&gt;随着带宽增加，数据流量不断增大，网络核心部分的数据接口将面临瓶颈问题，原有的单一线路将很难满足需求，而且线路的升级又过于昂贵甚至难以实现，这时就可以考虑采用链路聚合（Trunking）技术。&lt;/p&gt;
&lt;p&gt;链路聚合技术（第二层负载均衡）将多条物理链路当作一条单一的聚合逻辑链路使用，网络数据流量由聚合逻辑链路中所有物理链路共同承担，由此在逻辑上增大了链路&lt;a href=&quot;http://hi.baidu.com/aking_roc&quot; target=&quot;_blank&quot;&gt;的&lt;/a&gt;容量，使其能满足带宽增加的需求。&lt;/p&gt;
&lt;p&gt;现代负载均衡技术通常操作于网络的第四层或第七层。第四层负载均衡将一个Internet上合法注册的IP地址映射为多个内部服务器的IP地址，对每次 TCP连接请求动态使用其中一个内部IP地址，达到负载均衡的目的。在第四层交换机中，此种均衡技术得到广泛的应用，一个目标地址是服务器群VIP（虚拟 IP，Virtual IP address）连接请求的数据包流经交换机，交换机根据源端和目的IP地址、TCP或UDP端口号和一定的负载均衡策略，在服务器IP和VIP间进行映射，选取服务器群中最好的服务器来处理连接请求。&lt;/p&gt;
&lt;p&gt;第七层负载均衡控制应用层服务的内容，提供了一种对访问流量的高层控制方式，适合对HTTP服务器群的应用。第&lt;strong&gt;七层负载均衡技术通过检查流经的HTTP报头，根据报头内的信息来执行负载均衡任务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第七层负载均衡优点表现在如下几个方面：&lt;/p&gt;
&lt;p&gt;通过对HTTP报头的检查，可以检测出HTTP400、500和600系列的错误信息，因而能透明地将连接请求重新定向到另一台服务器，避免应用层故障。&lt;/p&gt;
&lt;p&gt;可根据流经的数据类型（如判断数据包是图像文件、压缩文件或多媒体文件格式等），把数据流量引向相应内容的服务器来处理，增加系统性能。&lt;/p&gt;
&lt;p&gt;能根据连接请求的类型，如是普通文本、图象等静态文档请求，还是asp、cgi等的动态文档请求，把相应的请求引向相应的服务器来处理，提高系统的性能及安全性。&lt;/p&gt;
&lt;p&gt;第七层负载均衡受到其所支持的协议限制（一般只有HTTP），这样就限制了它应用的广泛性，并且检查HTTP报头会占用大量的系统资源，势必会影响到系统的性能，在大量连接请求的情况下，负载均衡设备自身容易成为网络整体性能的瓶颈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实际应用中，我们可能不想仅仅是把客户端的服务请求平均地分配给内部服务器，而不管服务器是否宕机。而是想使Pentium III服务器比Pentium II能接受更多的服务请求，一台处理服务请求较少的服务器能分配到更多的服务请求，出现故障的服务器将不再接受服务请求直至故障恢复等等。&lt;/p&gt;
&lt;p&gt;选择合适的负载均衡策略，使多个设备能很好的共同完成任务，消除或避免现有网络负载分布不均、数据流量拥挤反应时间长的瓶颈。在各负载均衡方式中，针对不同的应用需求，在OSI参考模型的第二、三、四、七层的负载均衡都有相应的负载均衡策略。&lt;/p&gt;
&lt;p&gt;负载均衡策略的优劣及其实现的难易程度有两个关键因素：一、负载均衡算法，二、对网络系统状况的检测方式和能力。&lt;/p&gt;
&lt;p&gt;考虑到服务请求的不同类型、服务器的不同处理能力以及随机选择造成的负载分配不均匀等问题，为了更加合理的把负载分配给内部的多个服务器，就需要应用相应的能够正确反映各个服务器处理能力及网络状态的&lt;strong&gt;负载均衡算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;轮循均衡（Round Robin）：每一次来自网络的请求轮流分配给内部中的服务器，从1至N然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。&lt;/p&gt;
&lt;p&gt;权重轮循均衡（Weighted Round Robin）：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。例如：服务器A的权值被设计成1，B的权值是 3，C的权值是6，则服务器A、B、C将分别接受到10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。&lt;/p&gt;
&lt;p&gt;随机均衡（Random）：把来自网络的请求随机分配给内部中的多个服务器。&lt;/p&gt;
&lt;p&gt;权重随机均衡（Weighted Random）：此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。&lt;/p&gt;
&lt;p&gt;响应速度均衡（Response Time）：负载均衡设备对内部各服务器发出一个探测请求（例如Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。&lt;/p&gt;
&lt;p&gt;最少连接数均衡（Least Connection）：客户端的每一次请求服务在服务器停留的时间可能会有较大的差异，随着工作时间加长，如果采用简单的轮循或随机均衡算法，每一台服务器上的连接进程可能会产生极大的不同，并没有达到真正的负载均衡。最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如FTP。&lt;/p&gt;
&lt;p&gt;处理能力均衡：此种均衡算法将把服务请求分配给内部中处理负荷（根据服务器CPU型号、CPU数量、内存大小及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行状况，所以此种均衡算法相对来说更加精确，尤其适合运用到第七层（应用层）负载均衡的情况下。&lt;/p&gt;
&lt;p&gt;DNS响应均衡（Flash DNS）：在Internet上，无论是HTTP、FTP或是其它的服务请求，客户端一般都是通过域名解析来找到服务器确切的IP地址的。在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在同一时间内把此域名解析成各自相对应服务器的IP地址（即与此负载均衡设备在同一位地理位置的服务器的IP地址）并返回给客户端，则客户端将以最先收到的域名解析IP地址来继续请求服务，而忽略其它的IP地址响应。在种均衡策略适合应用在全局负载均衡的情况下，对本地负载均衡是没有意义的。&lt;/p&gt;
&lt;p&gt;尽管有多种的负载均衡算法可以较好的把数据流量分配给服务器去负载，但如果负载均衡策略没有对网络系统状况的检测方式和能力，一旦在某台服务器或某段负载均衡设备与服务器网络间出现故障的情况下，负载均衡设备依然把一部分数据流量引向那台服务器，这势必造成大量的服务请求被丢失，达不到不间断可用性的要求。所以良好的负载均衡策略应有对网络故障、服务器系统故障、应用服务故障的检&lt;strong&gt;测方式和能力&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Ping侦测：通过ping的方式检测服务器及网络系统状况，此种方式简单快速，但只能大致检测出网络及服务器上的操作系统是否正常，对服务器上的应用服务检测就无能为力了。&lt;/p&gt;
&lt;p&gt;TCP Open侦测：每个服务都会开放某个通过TCP连接，检测服务器上某个TCP端口（如Telnet的23口，HTTP的80口等）是否开放来判断服务是否正常。&lt;/p&gt;
&lt;p&gt;HTTP URL侦测：比如向HTTP服务器发出一个对main.html文件的访问请求，如果收到错误信息，则认为服务器出现故障。&lt;/p&gt;
&lt;p&gt;负载均衡策略的优劣除受上面所讲的两个因素影响外，在有些应用情况下，我们需要将来自同一客户端的所有请求都分配给同一台服务器去负担，例如服务器将客户端注册、购物等服务请求信息保存的本地数据库的情况下，把客户端的子请求分配给同一台服务器来处理就显的至关重要了。有两种方式可以解决此问题，一是根据IP地址把来自同一客户端的多次请求分配给同一台服务器处理，客户端IP地址与服务器的对应信息是保存在负载均衡设备上的；二是在客户端浏览器 cookie内做独一无二的标识来把多次请求分配给同一台服务器处理，适合通过代理服务器上网的客户端。&lt;/p&gt;
&lt;p&gt;还有一种路径外返回模式（Out of Path Return），当客户端连接请求发送给负载均衡设备的时候，中心负载均衡设备将请求引向某个服务器，服务器的回应请求不再返回给中心负载均衡设备，即绕过流量分配器，直接返回给客户端，因此中心负载均衡设备只负责接受并转发请求，其网络负担就减少了很多，并且给客户端提供了更快的响应时间。此种模式一般用于HTTP服务器群，在各服务器上要安装一块虚拟网络适配器，并将其IP地址设为服务器群的VIP，这样才能在服务器直接回应客户端请求时顺利的达成三次握手。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡实施要素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡方案应是在网站建设初期就应考虑的问题，不过有时随着访问流量的爆炸性增长，超出决策者的意料，这也就成为不得不面对的问题。当我们在引入某种负载均衡方案乃至具体实施时，像其他的许多方案一样，首先是确定当前及将来的应用需求，然后在代价与收效之间做出权衡。&lt;/p&gt;
&lt;p&gt;针对当前及将来的应用需求，分析网络瓶颈的不同所在，我们就需要确立是采用哪一类的负载均衡技术，采用什么样的均衡策略，在可用性、兼容性、安全性等等方面要满足多大的需求，如此等等。&lt;/p&gt;
&lt;p&gt;不管负载均衡方案是采用花费较少的软件方式，还是购买代价高昂在性能功能上更强的第四层交换机、负载均衡器等硬件方式来实现，亦或其他种类不同的均衡技术，下面这几项都是我们在引入均衡方案时可能要考虑的问题：&lt;/p&gt;
&lt;p&gt;性能：性能是我们在引入均衡方案时需要重点考虑的问题，但也是一个最难把握的问题。衡量性能时可将每秒钟通过网络的数据包数目做为一个参数，另一个参数是均衡方案中服务器群所能处理的最大并发连接数目，但是，假设一个均衡系统能处理百万计的并发连接数，可是却只能以每秒2个包的速率转发，这显然是没有任何作用的。性能的优劣与负载均衡设备的处理能力、采用的均衡策略息息相关，并且有两点需要注意：一、均衡方案对服务器群整体的性能，这是响应客户端连接请求速度的关键；二、负载均衡设备自身的性能，避免有大量连接请求时自身性能不足而成为服务瓶颈。有时我们也可以考虑采用混合型负载均衡策略来提升服务器群的总体性能，如DNS负载均衡与NAT负载均衡相结合。另外，针对有大量静态文档请求的站点，也可以考虑采用高速缓存技术，相对来说更节省费用，更能提高响应性能；对有大量ssl/xml内容传输的站点，更应考虑采用ssl/xml加速技术。&lt;/p&gt;
&lt;p&gt;可扩展性：IT技术日新月异，一年以前最新的产品，现在或许已是网络中性能最低的产品；业务量的急速上升，一年前的网络，现在需要新一轮的扩展。合适的均衡解决方案应能满足这些需求，能均衡不同操作系统和硬件平台之间的负载，能均衡HTTP、邮件、新闻、代理、数据库、防火墙和 Cache等不同服务器的负载，并且能以对客户端完全透明的方式动态增加或删除某些资源。&lt;/p&gt;
&lt;p&gt;灵活性：均衡解决方案应能灵活地提供不同的应用需求，满足应用需求的不断变化。在不同的服务器群有不同的应用需求时，应有多样的均衡策略提供更广泛的选择。&lt;/p&gt;
&lt;p&gt;可靠性：在对服务质量要求较高的站点，负载均衡解决方案应能为服务器群提供完全的容错性和高可用性。但在负载均衡设备自身出现故障时，应该有良好的冗余解决方案，提高可靠性。使用冗余时，处于同一个冗余单元的多个负载均衡设备必须具有有效的方式以便互相进行监控，保护系统尽可能地避免遭受到重大故障的损失。&lt;/p&gt;
&lt;p&gt;易管理性：不管是通过软件还是硬件方式的均衡解决方案，我们都希望它有灵活、直观和安全的管理方式，这样便于安装、配置、维护和监控，提高工作效率，避免差错。在硬件负载均衡设备上，目前主要有三种管理方式可供选择：一、命令行接口（CLI：Command Line Interface），可通过超级终端连接负载均衡设备串行接口来管理，也能telnet远程登录管理，在初始化配置时，往往要用到前者；二、图形用户接口（GUI：Graphical User Interfaces），有基于普通web页的管理，也有通过Java Applet 进行安全管理，一般都需要管理端安装有某个版本的浏览器；三、SNMP（Simple Network Management Protocol，简单网络管理协议）支持，通过第三方网络管理软件对符合SNMP标准的设备进行管理。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23-74131-098069b71.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23-74131-098069b71.html</guid>
        
        
      </item>
    
      <item>
        <title>关于字符编码，你所需要知道的</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;字符编码的问题看似很小，经常被技术人员忽视，但是很容易导致一些莫名其妙的问题。这里总结了一下字符编码的一些普及性的知识，希望对大家有所帮助。&lt;/p&gt;
&lt;h2&gt;还是得从ASCII码说起&lt;/h2&gt;
&lt;p&gt;说到字符编码，不得不说ASCII码的简史。计算机一开始发明的时候是用来解决数字计算的问题，后来人们发现，计算机还可以做更多的事，例如文本处理。但由于计算机只识“数”，因此人们必须告诉计算机哪个数字来代表哪个特定字符，例如65代表字母‘A’，66代表字母‘B’，以此类推。但是&lt;strong&gt;计算机之间字符-数字的对应关系必须得一致，否则就会造成同一段数字在不同计算机上显示出来的字符不一样&lt;/strong&gt;。因此美国国家标准协会ANSI制定了一个标准，规定了常用字符的集合以及每个字符对应的编号，这就是ASCII字符集（Character Set），也称ASCII码。&lt;/p&gt;
&lt;p&gt;当时的计算机普遍使用8比特字节作为最小的存储和处理单元，加之当时用到的字符也很少，26个大小写英文字母还有数字再加上其他常用符号，也不到100个，因此使用7个比特位就可以高效的存储和处理ASCII码，剩下最高位1比特被用作一些通讯系统的奇偶校验。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;注意，字节代表系统能够处理的最小单位，不一定是8比特。只是现代计算机的事实标准就是用8比特来代表一个字节。在很多技术规格文献中，为了避免产生歧义，更倾向于使用8位组（Octet）而不是字节（Byte）这个术语来强调8个比特的二进制流。下文中为了便于理解，我会延用大家熟悉的“字节”这个概念。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/113c27ca8568e4a3ac626cf9100fb578.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;ASCII字符集由95个可打印字符（0×20-0x7E）和33个控制字符（0×00-0×19，0x7F）组成。可打印字符用于显示在输出设备上，例如荧屏或者打印纸上，控制字符用于向计算机发出一些特殊指令，例如0×07会让计算机发出哔的一声，0×00通常用于指示字符串的结束，0x0D和0x0A用于指示打印机的打印针头退到行首（回车）并移到下一行（换行）。&lt;/p&gt;
&lt;p&gt;那时候的字符编解码系统非常简单，就是简单的查表过程。例如将字符序列编码为二进制流写入存储设备，只需要在ASCII字符集中依次找到字符对应的字节，然后直接将该字节写入存储设备即可。解码二进制流的过程也是类似。&lt;/p&gt;
&lt;h2&gt;OEM字符集的衍生&lt;/h2&gt;
&lt;p&gt;当计算机开始发展起来的时候，人们逐渐发现，ASCII字符集里那可怜的128个字符已经不能再满足他们的需求了。人们就在想，一个字节能够表示的数字（编号）有256个，而ASCII字符只用到了0×00~0x7F，也就是占用了前128个，后面128个数字不用白不用，因此很多人打起了后面这128个数字的主意。可是问题在于，很多人同时有这样的想法，但是大家对于0×80-0xFF这后面的128个数字分别对应什么样的字符，却有各自的想法。这就导致了当时销往世界各地的机器上出现了大量各式各样的OEM字符集。&lt;/p&gt;
&lt;p&gt;下面这张表是IBM-PC机推出的其中一个OEM字符集，字符集的前128个字符和ASCII字符集的基本一致（为什么说基本一致呢，是因为前32个控制字符在某些情况下会被IBM-PC机当作可打印字符解释），后面128个字符空间加入了一些欧洲国家用到的重音字符，以及一些用于画线条画的字符。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d39baa2a063d2459172053cd3871f53c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;事实上，大部分OEM字符集是兼容ASCII字符集的，也就是说，大家对于0×00~0x7F这个范围的解释基本是相同的，而对于后半部分0×80~0xFF的解释却不一定相同。甚至有时候同样的字符在不同OEM字符集中对应的字节也是不同的。&lt;/p&gt;
&lt;p&gt;不同的OEM字符集导致人们无法跨机器交流各种文档。例如职员甲发了一封简历résumés给职员乙，结果职员乙看到的却是r&lt;img alt=&quot;ג&quot; src=&quot;/images/jobbole.com/3471887fbcc718581dd03866ca11d4b7.jpg&quot; width=&quot;5&quot; height=&quot;9&quot; border=&quot;0&quot;&gt;sum&lt;img alt=&quot;ג&quot; src=&quot;/images/jobbole.com/3471887fbcc718581dd03866ca11d4b7.jpg&quot; width=&quot;5&quot; height=&quot;9&quot; border=&quot;0&quot;&gt;s，因为é字符在职员甲机器上的OEM字符集中对应的字节是0×82，而在职员乙的机器上，由于使用的OEM字符集不同，对0×82字节解码后得到的字符却是&lt;img alt=&quot;ג&quot; src=&quot;/images/jobbole.com/3471887fbcc718581dd03866ca11d4b7.jpg&quot; width=&quot;5&quot; height=&quot;9&quot; border=&quot;0&quot;&gt;。&lt;/p&gt;
&lt;h2&gt;多字节字符集（MBCS）和中文字符集&lt;/h2&gt;
&lt;p&gt;上面我们提到的字符集都是基于单字节编码，也就是说，一个字节翻译成一个字符。这对于拉丁语系国家来说可能没有什么问题，因为他们通过扩展第8个比特，就可以得到256个字符了，足够用了。但是对于亚洲国家来说，256个字符是远远不够用的。因此这些国家的人为了用上电脑，又要保持和ASCII字符集的兼容，就发明了多字节编码方式，相应的字符集就称为多字节字符集。例如中国使用的就是双字节字符集编码（DBCS，Double Byte Character Set）。&lt;/p&gt;
&lt;p&gt;对于单字节字符集来说，代码页中只需要有一张码表即可，上面记录着256个数字代表的字符。程序只需要做简单的查表操作就可以完成编解码的过程。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;代码页是字符集编码的具体实现，你可以把他理解为一张“字符-字节”映射表，通过查表实现“字符-字节”的翻译。下面会有更详细的描述。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;而对于多字节字符集，代码页中通常会有很多码表。那么程序怎么知道该使用哪张码表去解码二进制流呢？答案是，&lt;strong&gt;根据第一个字节来选择不同的码表进行解析&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如目前最常用的中文字符集GB2312，涵盖了所有简体字符以及一部分其他字符；GBK（K代表扩展的意思）则在GB2312的基础上加入了对繁体字符等其他非简体字符（GB18030字符集不是双字节字符集，我们在讲Unicode的时候会提到）。这两个字符集的字符都是使用1-2个字节来表示。Windows系统采用936代码页来实现对GBK字符集的编解码。在解析字节流的时候，如果遇到字节的最高位是0的话，那么就使用936代码页中的第1张码表进行解码，这就和单字节字符集的编解码方式一致了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3c5a6e635c7657a78f2660500245dbc8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当字节的高位是1的时候，确切的说，当第一个字节位于0x&lt;code&gt;81&lt;/code&gt;–0x&lt;code&gt;FE之间时，根据第一个字节不同找到代码页中的相应的码表，例如当第一个字节是0x81，那么对应936中的下面这张码表：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c1bd6358303b67c10ec465b39e8eeca3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（关于936代码页中完整的码表信息，参见MSDN：&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc194913%28v=MSDN.10%29.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/cc194913%28v=MSDN.10%29.aspx&lt;/a&gt;.）&lt;/p&gt;
&lt;p&gt;按照936代码页的码表，当程序遇到连续字节流0×81 0×40的时候，就会解码为“丂”字符。&lt;/p&gt;
&lt;h2&gt;ANSI标准、国家标准、ISO标准&lt;/h2&gt;
&lt;p&gt;不同ASCII衍生字符集的出现，让文档交流变得非常困难，因此各种组织都陆续进行了标准化流程。例如美国ANSI组织制定了ANSI标准字符编码（注意，&lt;strong&gt;我们现在通常说到ANSI编码，通常指的是平台的默认编码，例如英文操作系统中是ISO-8859-1，中文系统是GBK&lt;/strong&gt;），ISO组织制定的各种ISO标准字符编码，还有各国也会制定一些国家标准字符集，例如中国的GBK，GB2312和GB18030。&lt;/p&gt;
&lt;p&gt;操作系统在发布的时候，通常会往机器里预装这些标准的字符集还有平台专用的字符集，这样只要你的文档是使用标准字符集编写的，通用性就比较高了。例如你用GB2312字符集编写的文档，在中国大陆内的任何机器上都能正确显示。同时，我们也可以在一台机器上阅读多个国家不同语言的文档了，前提是本机必须安装该文档使用的字符集。&lt;/p&gt;
&lt;h2&gt;Unicode的出现&lt;/h2&gt;
&lt;p&gt;虽然通过使用不同字符集，我们可以在一台机器上查阅不同语言的文档，但是我们仍然无法解决一个问题：&lt;strong&gt;在一份文档中显示所有字符&lt;/strong&gt;。为了解决这个问题，我们需要一个全人类达成共识的巨大的字符集，这就是Unicode字符集。&lt;/p&gt;
&lt;h3&gt;Unicode字符集概述&lt;/h3&gt;
&lt;p&gt;Unicode字符集涵盖了目前人类使用的所有字符，并为每个字符进行统一编号，分配唯一的字符码（Code Point）。Unicode字符集将所有字符按照使用上的频繁度划分为17个层面（Plane），每个层面上有2&lt;sup&gt;16&lt;/sup&gt;=65536个字符码空间。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/63afa920ddf7fb8202d32e33c241a304.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中第0个层面BMP，基本涵盖了当今世界用到的所有字符。其他的层面要么是用来表示一些远古时期的文字，要么是留作扩展。我们平常用到的Unicode字符，一般都是位于BMP层面上的。目前Unicode字符集中尚有大量字符空间未使用。&lt;/p&gt;
&lt;h3&gt;编码系统的变化&lt;/h3&gt;
&lt;p&gt;在Unicode出现之前，所有的字符集都是和具体编码方案绑定在一起的，都是直接将字符和最终字节流绑定死了，例如ASCII编码系统规定使用7比特来编码ASCII字符集；GB2312以及GBK字符集，限定了使用最多2个字节来编码所有字符，并且规定了字节序。这样的编码系统通常用简单的查表，也就是通过代码页就可以直接将字符映射为存储设备上的字节流了。例如下面这个例子：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b8d527f9a38ca589c9d1f0865a6ad409.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种方式的缺点在于，字符和字节流之间耦合得太紧密了，从而限定了字符集的扩展能力。假设以后火星人入住地球了，要往现有字符集中加入火星文就变得很难甚至不可能了，而且很容易破坏现有的编码规则。&lt;/p&gt;
&lt;p&gt;因此Unicode在设计上考虑到了这一点，将字符集和字符编码方案分离开。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b742e06f36eaf51794743b85e7701651.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;虽然每个字符在Unicode字符集中都能找到唯一确定的编号（字符码，又称Unicode码），但是决定最终字节流的却是具体的字符编码&lt;/strong&gt;。例如同样是对Unicode字符“A”进行编码，UTF-8字符编码得到的字节流是0×41，而UTF-16（大端模式）得到的是0×00 0×41。&lt;/p&gt;
&lt;h3&gt;常见的Unicode编码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;UCS-2/UTF-16&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果要我们来实现Unicode字符集中BMP字符的编码方案，我们会怎么实现？由于BMP层面上有2&lt;sup&gt;16&lt;/sup&gt;=65536个字符码，因此我们只需要两个字节就可以完全表示这所有的字符了。&lt;/p&gt;
&lt;p&gt;举个例子，“中”的Unicode字符码是0x4E2D(01001110 00101101)，那么我们可以编码为01001110 00101101（大端）或者00101101 01001110 （小端）。&lt;/p&gt;
&lt;p&gt;UCS-2和UTF-16对于BMP层面的字符均是使用2个字节来表示，并且编码得到的结果完全一致。不同之处在于，&lt;strong&gt;UCS-2最初设计的时候只考虑到BMP字符，因此使用固定2个字节长度，也就是说，他无法表示Unicode其他层面上的字符，而UTF-16为了解除这个限制，支持Unicode全字符集的编解码，采用了变长编码，最少使用2个字节，如果要编码BMP以外的字符，则需要4个字节结对&lt;/strong&gt;，这里就不讨论那么远，有兴趣可以参考维基百科：&lt;a title=&quot;UTF-16/UCS-2&quot; href=&quot;http://en.wikipedia.org/wiki/UTF-16/UCS-2&quot; target=&quot;_blank&quot;&gt;UTF-16/UCS-2&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Windows从NT时代开始就采用了UTF-16编码，很多流行的编程平台，例如.Net，Java，Qt还有Mac下的Cocoa等都是使用UTF-16作为基础的字符编码。例如代码中的字符串，在内存中相应的字节流就是用UTF-16编码过的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTF-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UTF-8应该是目前应用最广泛的一种Unicode编码方案。由于UCS-2/UTF-16对于ASCII字符使用两个字节进行编码，存储和处理效率相对低下，并且由于ASCII字符经过UTF-16编码后得到的两个字节，高字节始终是0×00，很多C语言的函数都将此字节视为字符串末尾从而导致无法正确解析文本。因此一开始推出的时候遭到很多西方国家的抵触，大大影响了Unicode的推行。后来聪明的人们发明了UTF-8编码，解决了这个问题。&lt;/p&gt;
&lt;p&gt;UTF-8编码方案采用1-4个字节来编码字符，方法其实也非常简单。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a3efe42c610a2564c98044a8bfc8ff09.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（上图中的x代表Unicode码的低8位，y代表高8位）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于ASCII字符的编码使用单字节，和ASCII编码一摸一样，这样所有原先使用ASCII编解码的文档就可以直接转到UTF-8编码了。对于其他字符，则使用2-4个字节来表示，其中，首字节前置1的数目代表正确解析所需要的字节数，剩余字节的高2位始终是10。例如首字节是1110yyyy，前置有3个1，说明正确解析总共需要3个字节，需要和后面2个以10开头的字节结合才能正确解析得到字符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;关于UTF-8的更多信息，参考维基百科：&lt;a title=&quot;UTF-8&quot; href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot; target=&quot;_blank&quot;&gt;UTF-8&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GB18030&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何能够将Unicode字符映射为字节流的编码都属于Unicode编码。中国的GB18030编码，覆盖了Unicode所有的字符，因此也算是一种Unicode编码。只不过他的编码方式并不像UTF-8或者UTF-16一样，将Unicode字符的编号通过一定的规则进行转换，而只能通过查表的手段进行编码。&lt;/p&gt;
&lt;p&gt;关于GB18030的更多信息，参考：&lt;a title=&quot;GB18030&quot; href=&quot;http://en.wikipedia.org/wiki/GB18030&quot; target=&quot;_blank&quot;&gt;GB18030&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Unicode相关的常见问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Unicode是两个字节吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储为什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-16和UTF-8。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带签名的UTF-8指的是什么意思？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;带签名指的是字节流以BOM标记开始。很多软件会“智能”的探测当前字节流使用的字符编码，这种探测过程出于效率考虑，通常会提取字节流前面若干个字节，看看是否符合某些常见字符编码的编码规则。由于UTF-8和ASCII编码对于纯英文的编码是一样的，无法区分开来，因此通过在字节流最前面添加BOM标记可以告诉软件，当前使用的是Unicode编码，判别成功率就十分准确了。但是需要注意，不是所有软件或者程序都能正确处理BOM标记，例如PHP就不会检测BOM标记，直接把它当普通字节流解析了。因此如果你的PHP文件是采用带BOM标记的UTF-8进行编码的，那么有可能会出现问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unicode编码和以前的字符集编码有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;早期字符编码、字符集和代码页等概念都是表达同一个意思。例如GB2312字符集、GB2312编码，936代码页，实际上说的是同个东西。但是对于Unicode则不同，Unicode字符集只是定义了字符的集合和唯一编号，Unicode编码，则是对UTF-8、UCS-2/UTF-16等具体编码方案的统称而已，并不是具体的编码方案。所以当需要用到字符编码的时候，你可以写gb2312，codepage936，utf-8，utf-16，但请不要写unicode（看过别人在网页的meta标签里头写charset=unicode，有感而发）。&lt;/p&gt;
&lt;h2&gt;乱码问题&lt;/h2&gt;
&lt;p&gt;乱码指的是程序显示出来的字符文本无法用任何语言去解读。一般情况下会包含大量?或者�。乱码问题是所有计算机用户或多或少会遇到的问题。&lt;strong&gt;造成乱码的原因就是因为使用了错误的字符编码去解码字节流&lt;/strong&gt;，&lt;strong&gt;因此当我们在思考任何跟文本显示有关的问题时，请时刻保持清醒：当前使用的字符编码是什么&lt;/strong&gt;。只有这样，我们才能正确分析和处理乱码问题。&lt;/p&gt;
&lt;p&gt;例如最常见的网页乱码问题。如果你是网站技术人员，遇到这样的问题，需要检查以下原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器返回的响应头Content-Type没有指明字符编码&lt;/li&gt;
&lt;li&gt;网页内是否使用META HTTP-EQUIV标签指定了字符编码&lt;/li&gt;
&lt;li&gt;网页文件本身存储时使用的字符编码和网页声明的字符编码是否一致&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2209b7e687b98f96f1ad15b8bb53cff6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/911fab48d5f8e58eed3c18827af628ce.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意，网页解析的过程如果使用的字符编码不正确，还可能会导致脚本或者样式表出错。具体细节可以参考我以前写过的文章：&lt;a href=&quot;http://www.imkevinyang.com/2009/08/%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E9%9B%86%E5%AF%BC%E8%87%B4%E7%9A%84%E8%84%9A%E6%9C%AC%E9%94%99%E8%AF%AF.html&quot;&gt;文档字符集导致的脚本错误&lt;/a&gt;和&lt;a href=&quot;http://www.imkevinyang.com/2009/11/asp-net%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98.html&quot;&gt;Asp.Net页面的编码问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不久前看到某技术论坛有人反馈，WinForm程序使用Clipboard类的GetData方法去访问剪切板中的HTML内容时会出现乱码的问题，我估计也是由于WinForm在获取HTML文本的时候没有用对正确的字符编码导致的。Windows剪贴板只支持UTF-8编码，也就是说你传入的文本都会被UTF-8编解码。这样一来，只要两个程序都是调用Windows剪切板API编程的话，那么复制粘贴的过程中不会出现乱码。除非一方在获取到剪贴板数据之后使用了错误的字符编码进行解码，才会得到乱码（我做了简单的WinForm剪切板编程实验，发现GetData使用的是系统默认编码，而不是UTF-8编码）。&lt;/p&gt;
&lt;p&gt;关于乱码中出现?或者�，这里需要额外提一下，&lt;strong&gt;当程序使用特定字符编码解析字节流的时候，一旦遇到无法解析的字节流时，就会用?或者�来替代。因此，一旦你最终解析得到的文本包含这样的字符，而你又无法得到原始字节流的时候，说明正确的信息已经彻底丢失了，尝试任何字符编码都无法从这样的字符文本中还原出正确的信息来&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;必要的术语解释&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;字符集（Character Set）&lt;/strong&gt;，字面上的理解就是字符的集合，例如ASCII字符集，定义了128个字符；GB2312定义了7445个字符。而&lt;strong&gt;计算机系统中提到的字符集准确来说，指的是已编号的字符的有序集合（不一定是连续）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符码（Code Point）&lt;/strong&gt;指的就是字符集中每个字符的数字编号。例如ASCII字符集用0-127这连续的128个数字分别表示128个字符；GBK字符集使用区位码的方式为每个字符编号，首先定义一个94X94的矩阵，行称为“区”，列称为“位”，然后将所有国标汉字放入矩阵当中，这样每个汉字就可以用唯一的“区位”码来标识了。例如“中”字被放到54区第48位，因此字符码就是5448。而Unicode中将字符集按照一定的类别划分到0~16这17个层面（Planes）中，每个层面中拥有2&lt;sup&gt;16&lt;/sup&gt;=65536个字符码，因此Unicode总共拥有的字符码，也即是Unicode的字符空间总共有17*65536=1114112。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/46c43be8707d3543d63f0331008c36a6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码&lt;/strong&gt;的过程是将字符转换成字节流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解码&lt;/strong&gt;的过程是将字节流解析为字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符编码（Character Encoding）&lt;/strong&gt;是将字符集中的字符码映射为字节流的一种具体实现方案。例如ASCII字符编码规定使用单字节中低位的7个比特去编码所有的字符。例如‘A’的编号是65，用单字节表示就是0×41，因此写入存储设备的时候就是b’01000001’。GBK编码则是将区位码（GBK的字符码）中的区码和位码的分别加上0xA0（160）的偏移（之所以要加上这样的偏移，主要是为了和ASCII码兼容），例如刚刚提到的“中”字，区位码是5448，十六进制是0×3630，区码和位码分别加上0xA0的偏移之后就得到0xD6D0，这就是“中”字的GBK编码结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码页（Code Page）&lt;/strong&gt;一种字符编码具体形式。早期字符相对少，因此通常会使用类似表格的形式将字符直接映射为字节流，然后通过查表的方式来实现字符的编解码。现代操作系统沿用了这种方式。例如Windows使用936代码页、Mac系统使用EUC-CN代码页实现GBK字符集的编码，名字虽然不一样，但对于同一汉字的编码肯定是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大小端&lt;/strong&gt;的说法源自《格列佛游记》。我们知道，鸡蛋通常一端大一端小，小人国的人们对于剥蛋壳时应从哪一端开始剥起有着不一样的看法。同样，计算机界对于传输多字节字（由多个字节来共同表示一个数据类型）时，是先传高位字节（大端）还是先传低位字节（小端）也有着不一样的看法，这就是计算机里头大小端模式的由来了。无论是写文件还是网络传输，实际上都是往流设备进行写操作的过程，而且这个写操作是从流的低地址向高地址开始写（这很符合人的习惯），对于多字节字来说，如果先写入高位字节，则称作大端模式。反之则称作小端模式。也就是说，大端模式下，字节序和流设备的地址顺序是相反的，而小端模式则是相同的。一般网络协议都采用大端模式进行传输。&lt;/p&gt;
&lt;p&gt;——&lt;a title=&quot;关于字符编码，你所需要知道的&quot; href=&quot;http://www.imkevinyang.com/2010/06/%e5%85%b3%e4%ba%8e%e5%ad%97%e7%ac%a6%e7%bc%96%e7%a0%81%ef%bc%8c%e4%bd%a0%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84.html&quot;&gt;&lt;em&gt;&lt;strong&gt;Kevin Yang&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a title=&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&quot; href=&quot;http://www.joelonsoftware.com/printerFriendly/articles/Unicode.html&quot; target=&quot;_blank&quot;&gt;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://developers.sun.com/dev/gadc/technicalpublications/articles/gb18030.html&quot;&gt;http://developers.sun.com/dev/gadc/technicalpublications/articles/gb18030.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Universal_Character_Set&quot;&gt;http://en.wikipedia.org/wiki/Universal_Character_Set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Code_page&quot;&gt;http://en.wikipedia.org/wiki/Code_page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23-74109-23c6c0d86.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23-74109-23c6c0d86.html</guid>
        
        
      </item>
    
      <item>
        <title>Stream 的 Perl 后端实现关键技术介绍 (Mojolicous)</title>
        <description>

							&lt;p&gt;上一个文章&lt;a href=&quot;http://%20http://www.php-oa.com/2014/07/23/%E5%85%A8%E5%B9%B3%E5%8F%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%B8%8A%E4%BC%A0%E6%8A%80%E6%9C%AF.html&quot;&gt;全平台大文件断点续传上传技术&lt;/a&gt;中的核心技术除了浏览器, 就是服务器端的实现了. 我在这边了简单高效, 是使用的 Mojolicious 来实现的.&lt;br&gt;
 Mojolcious 有着很好的事件支持, 所以就算本身只启动一个进程的时候, 都可以接收无数用户的同时上传.&lt;br&gt;
下面我来讲一下这个技术中实现的重点.&lt;br&gt;
我们知道 POST 上传, 是分很多种不同的情况, 在 Stream 的项目中,  HTML5 的实现, 是使用的 POST body 的方式实现的.有关 post 上关方式的介绍, 请看: &lt;a href=&quot;http://www.php-oa.com/2014/07/15/http-post-mojolicious.html&quot;&gt;HTTP 的 POST 参数提交&lt;/a&gt;.&lt;br&gt;
在上面文章的例子中, 取 body 都是从使用 req-&amp;gt;body 的方式来取, 这也就意味着, 如果上传 1G ,我们会一次给一 G 的内容都放入内存. 在 Mojolicious 中有一个叫 Mojo::Upload 的模块, 也是处理上传的, 但是它只能处理以  application/x-www-form-urlencoded 和  application/x-www-form-urlencoded 的上传. 这个处理得非常有技巧, 整个文件上传了多少, 就会给多少内容存到文件本身, 这样就不会有过大的内存占用. 并且都是事件回调, 所以可以很好的处理多用户.&lt;/p&gt;
&lt;p&gt;但这个模块并不能处理 post 一个超大 body 就是文件本身的情况. 直接取 body 又大占内存, 所以在这, 我是使用的 Mojolicous 本身提供的 hook 点, 在用户提交创建完连接后, 然后请求的 header 解析完的时候, 来做了一个事件注册.&lt;br&gt;
整个核心的代码简写是:&lt;/p&gt;
&lt;pre class=&quot;brush:perl;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;&quot;&gt;
hook after_build_tx =&amp;gt; sub {
    my $tx = shift;
    my $app = shift;
    weaken $tx;

    $tx-&amp;gt;req-&amp;gt;content-&amp;gt;on(body =&amp;gt; sub {
        my $single  = shift;

        return unless $tx-&amp;gt;req-&amp;gt;url-&amp;gt;path-&amp;gt;contains(&#39;/upload&#39;);
        my $file = Mojo::Asset::File-&amp;gt;new(path =&amp;gt; $tx-&amp;gt;req-&amp;gt;param(&#39;path&#39;), cleanup =&amp;gt; 0);

        $single-&amp;gt;unsubscribe(&#39;read&#39;)-&amp;gt;on(read =&amp;gt; sub {
            my ($single, $bytes) = @_;
            $file-&amp;gt;add_chunk($bytes);
        });
    });
};

&lt;/pre&gt;
&lt;p&gt;
这个 body 的事件是创建完连接, 并在 header 解析完, 但 body 并没有开始取的时候注册, 所以这个地方, 只针对我们上传的目录来进行实时写入的事件回调注册就行.&lt;/p&gt;
&lt;p&gt;这时我们进入 body , 然后对 body 读取的事件中的可读的时候, 进行注册, 使用 Mojo::Asset::File 来对一个文件不断的追加, 直到整个文件写入完整后.&lt;/p&gt;
&lt;p&gt;注意, Mojo::Asset::File 这个模块是在 Mojolicous 5.16 以后才支持对已存在的文件进行追加写入( 还是我好不容易向作者提交的补丁 ).&lt;/p&gt;

			&lt;!--[syntaxhighlighter]--&gt;
			&lt;!--代码高亮，请勿编辑--&gt;
			&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shCore.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shBrushPerl.js&quot;&gt;&lt;/script&gt;

			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shCoreDefault.css&quot;&gt;
			&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;http://www.php-oa.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shThemeDefault.css&quot;&gt;
			&lt;script type=&quot;text/javascript&quot;&gt;
			SyntaxHighlighter.defaults[&#39;class-name&#39;]	= &#39;.syntaxhighlighter {     background-color: 999999 }&#39;;
			SyntaxHighlighter.defaults[&#39;smart-tabs&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;tab-size&#39;]		= 4;
			SyntaxHighlighter.defaults[&#39;gutter&#39;]		= true;
			SyntaxHighlighter.defaults[&#39;quick-code&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;collapse&#39;] 		= false;
			SyntaxHighlighter.defaults[&#39;auto-links&#39;]	= true;
			SyntaxHighlighter.defaults[&#39;toolbar&#39;]		= true;
			SyntaxHighlighter.all();
			&lt;/script&gt;
			&lt;!--[/syntaxhighlighter]--&gt;						

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23-5642.html-a2578a751.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23-5642.html-a2578a751.html</guid>
        
        
      </item>
    
      <item>
        <title>Access Control</title>
        <description>
&lt;p&gt;In Xcode 6 beta 4, Swift adds support for access control. This gives you complete control over what part of the code is accessible within a single file, available across your project, or made public as API for anyone that imports your framework. The three access levels included in this release are:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;
&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; entities are available only from within the source file where they are defined.&lt;/li&gt; &lt;li&gt;
&lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt; entities are available to the entire module that includes the definition (e.g. an app or framework target).&lt;/li&gt; &lt;li&gt;
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; entities are intended for use as API, and can be accessed by any file that imports the module, e.g. as a framework used in several of your projects.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;By default, most entities have &lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt; access. This allows application developers to largely ignore access control, and most Swift code already written will continue to work without change. Your framework code does need to be updated to define &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; API, giving you total control of the exposed interface your framework provides.&lt;/p&gt; &lt;p&gt;The &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; access level is the most restrictive, and makes it easy to hide implementation details from other source files. By properly structuring your code, you can safely use features like extensions and top-level functions without exposing that code to the rest of your project.&lt;/p&gt; &lt;p&gt;Developers building frameworks to be used across their projects need to mark their API as &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;. While distribution and use of 3rd-party binary frameworks is not recommended (as mentioned in a previous blog post), Swift supports construction and distribution of frameworks in source form.&lt;/p&gt; &lt;p&gt;In addition to allowing access specification for an entire declaration, Swift allows the &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; of a property to be more accessible than its &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;. Here is an example class that is part of a framework:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&lt;span class=&quot;key&quot;&gt;public class&lt;/span&gt; ListItem {

	&lt;span class=&quot;comment&quot;&gt;// Public properties.&lt;/span&gt;
	&lt;span class=&quot;key&quot;&gt;public var&lt;/span&gt; text: &lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;
	&lt;span class=&quot;key&quot;&gt;public var&lt;/span&gt; isComplete: &lt;span class=&quot;title&quot;&gt;Bool&lt;/span&gt;

	&lt;span class=&quot;comment&quot;&gt;// Readable throughout the module, but only writeable from within this file.&lt;/span&gt;
	&lt;span class=&quot;key&quot;&gt;private(set) var&lt;/span&gt; UUID: &lt;span class=&quot;title&quot;&gt;NSUUID&lt;/span&gt;

	&lt;span class=&quot;key&quot;&gt;public init&lt;/span&gt;(text: &lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;, completed: &lt;span class=&quot;title&quot;&gt;Bool&lt;/span&gt;, UUID: &lt;span class=&quot;title&quot;&gt;NSUUID&lt;/span&gt;) {
		&lt;span class=&quot;key&quot;&gt;self&lt;/span&gt;.text = text
		&lt;span class=&quot;key&quot;&gt;self&lt;/span&gt;.isComplete = completed
		&lt;span class=&quot;key&quot;&gt;self&lt;/span&gt;.UUID = UUID
	}

	&lt;span class=&quot;comment&quot;&gt;// Usable within the framework target, but not by other targets.&lt;/span&gt;
	&lt;span class=&quot;key&quot;&gt;func&lt;/span&gt; refreshIdentity() {
		&lt;span class=&quot;key&quot;&gt;self&lt;/span&gt;.UUID = NSUUID()
	}

	&lt;span class=&quot;key&quot;&gt;public override func&lt;/span&gt; isEqual(object: &lt;span class=&quot;title&quot;&gt;AnyObject&lt;/span&gt;?) -&amp;gt; &lt;span class=&quot;title&quot;&gt;Bool&lt;/span&gt; {
		&lt;span class=&quot;key&quot;&gt;if let&lt;/span&gt; item = object &lt;span class=&quot;key&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;title&quot;&gt;ListItem&lt;/span&gt; {
			&lt;span class=&quot;key&quot;&gt;return self&lt;/span&gt;.UUID == item.UUID
		}
		&lt;span class=&quot;key&quot;&gt;return false&lt;/span&gt;
	}
}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;When mixing Objective-C and Swift, because the generated header for a framework is part of the framework’s public Objective-C interface, only declarations marked &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; appear in the generated header for a Swift framework. For applications, the generated header contains both &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; and &lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt; declarations.&lt;/p&gt; &lt;p&gt; For more information, &lt;a href=&quot;http://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/&quot;&gt;The Swift Programming Language&lt;/a&gt; and &lt;a href=&quot;http://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/&quot;&gt;Using Swift with Cocoa and Objective-C&lt;/a&gt; books have been updated to cover access control. &lt;a href=&quot;https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_6_beta_4_o2p8fz/xcode_6_beta_4_release_notes.pdf&quot;&gt;Read the complete Xcode 6 beta 4 release notes here&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23--id=5-bae94eb73.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23--id=5-bae94eb73.html</guid>
        
        
      </item>
    
      <item>
        <title>全平台大文件断点续传上传技术 ( 开源项目 Stream )</title>
        <description>

							&lt;p&gt;近来看了一下大文件断点续传的开源项目, 发现了 &lt;a href=&quot;http://www.twinkling.cn/&quot;&gt;Stream &lt;/a&gt;这个好项目, 非常非常感谢作者. 然后我花了点时间, 简单的使用 Perl 来实现了一下相关的接口. 这个是非常好的用来解决不同浏览器上传文件的方案.&lt;/p&gt;
&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;mainContentOfPage&quot;&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#stream-%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D&quot; name=&quot;user-content-stream-%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D&quot;&gt;&lt;/a&gt;Stream 上传插件介绍&lt;/h1&gt;
&lt;p&gt;
	Stream 这个项目主要是为了解决大文件上传, 本程序只是它的一个 Perl 后端的实现. 项目网站是: &lt;a href=&quot;http://www.twinkling.cn&quot;&gt;http://www.twinkling.cn&lt;/a&gt; 原始地址是: &lt;a href=&quot;http://git.oschina.net/jiangdx/stream/wikis/home&quot;&gt;http://git.oschina.net/jiangdx/stream/wikis/home&lt;/a&gt;. 因为它对 HTML5 和 Flash 都支持, 所以很合适做全功能的上传平台. 在这, 感谢作者为我们大家提供这么好的开源项目.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;支持HTML5、Flash两种方式（跨域）上传
支持多文件一起上传
HTML5方式支持断点续传，拖拽等新特性
兼容性好IE7+, FF3.6+, Chrome*，Safari4+，遨游等主流浏览器
选择文件的按钮完全可以自定义
进度条、速度、剩余时间等附属信息
基本的自定义属性及函数，如文件多选、上传成功的响应函数等
示例代码java实现（StreamServlet, FormDataServlet{commons-fileupload的stream api}, TokenServlet）

注：Chrome没测试最低版本，不想支持IE6
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#stream-%E7%9A%84-perl-%E5%90%8E%E7%AB%AF&quot; name=&quot;user-content-stream-%E7%9A%84-perl-%E5%90%8E%E7%AB%AF&quot;&gt;&lt;/a&gt;Stream 的 Perl 后端&lt;/h1&gt;
&lt;p&gt;
	本后端是使用 Perl 中常用的框架 Mojolicious 实现. 本程序做为后端接收上传过来的大文件的时候, 完全使用的是异步流式处理, 所以就算是单进程, 也可以处理多个上传的请求. 并且不会有多少内存的占用. 因为使用 Mojolicious 实现, 所以需要安装这个框架和一些相关的模块. Perl 中模块的安装需要使用 cpanm 所以先要下载 cpanm .&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ wget  http://xrl.us/cpanm  --no-check-certificate -O /sbin/cpanm
$ chmod +x  /sbin/cpanm 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	然后开始安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cpanm Mojolicious EV Digest::MD5 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#%E5%AE%89%E8%A3%85&quot; name=&quot;user-content-%E5%AE%89%E8%A3%85&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;
&lt;p&gt;
	这个 Perl 的后端的 stream 的实现文件都在项目 &lt;a href=&quot;https://github.com/iakuf/mojolicious-stream-upload&quot;&gt;https://github.com/iakuf/mojolicious-stream-upload&lt;/a&gt; 中. 大家需要使用到其中二个文件 stream.pl 和 StreamUpload.conf 所以可以使用任何方法下载这个项目中的文件. 其中 stream.pl 是执行文件, StreamUpload.conf 是配置文件.&lt;/p&gt;
&lt;p&gt;
	stream.pl 可以放在任何路径, StreamUpload.conf 请放到 &#39;/etc&#39; 的目录下.&lt;/p&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#%E9%85%8D%E7%BD%AE&quot; name=&quot;user-content-%E9%85%8D%E7%BD%AE&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;
&lt;p&gt;
	整个配置文件如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    hypnotoad =&amp;gt; {
        listen =&amp;gt; [&#39;http://*:3008&#39;],
            user   =&amp;gt; &#39;newupload&#39;,
            group  =&amp;gt; &#39;newupload&#39;,
    },
    UploadServer   =&amp;gt; &#39;http://xxx.xxxx.com&#39;,
    CrossOrigins   =&amp;gt; &#39;http://xxx.xxxx.com&#39;,
    FileRepository =&amp;gt; &#39;/tmp/&#39;,
    debug          =&amp;gt; 1,
    log            =&amp;gt; &#39;/var/log/upload.log&#39;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	指定用户和组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user   =&amp;gt; &#39;newupload&#39;
group  =&amp;gt; &#39;newupload&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	哪些域名的文件, 是可以接收并存储的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CrossOrigins   =&amp;gt; &#39;http://xxx.xxx.com&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	文件存储的目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FileRepository =&amp;gt; &#39;/tmp/&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	修改服务器启动的端口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;listen =&amp;gt; [&#39;http://*:3008&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;
	&lt;a class=&quot;anchor&quot; href=&quot;https://github.com/iakuf/mojolicious-stream-upload#%E5%90%AF%E5%8A%A8&quot; name=&quot;user-content-%E5%90%AF%E5%8A%A8&quot;&gt;&lt;/a&gt;启动&lt;/h1&gt;
&lt;p&gt;
	hyphotoad 是一个常用的 Perl 后端的 Web 异步服务器, 为 Mojolicious 的原生配置. 多进程, 为 Unix 优化过. 所以使用它来启动,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ hypnotoad stream.pl 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	现在就可以直接打开这个服务器来进行测试了&lt;/p&gt;
&lt;/article&gt;
						

</description>
        <pubDate>Wed, 23 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-23-%25e5%2585%25a8%25e5%25b9%25b3%25e5%258f%25b0%25e5%25a4%25a7%25e6%2596%2587%25e4%25bb%25b6%25e6%2596%25ad%25e7%2582%25b9%25e7%25bb%25ad%25e4%25bc%25a0%25e4%25b8%258a%25e4%25bc%25a0%25e6%258a%2580%25e6%259c%25af.html-a531e7bfe.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-23-%25e5%2585%25a8%25e5%25b9%25b3%25e5%258f%25b0%25e5%25a4%25a7%25e6%2596%2587%25e4%25bb%25b6%25e6%2596%25ad%25e7%2582%25b9%25e7%25bb%25ad%25e4%25bc%25a0%25e4%25b8%258a%25e4%25bc%25a0%25e6%258a%2580%25e6%259c%25af.html-a531e7bfe.html</guid>
        
        
      </item>
    
      <item>
        <title>教你用NeoBundle管理Vim插件</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shougo/neobundle.vim&quot;&gt;NeoBundle&lt;/a&gt; 是一个 &lt;a href=&quot;http://olex.openlogic.com/packages/vim&quot;&gt;Vim&lt;/a&gt; 的插件管理器，以 &lt;a href=&quot;https://github.com/gmarik/Vundle.vim&quot;&gt;Vundle&lt;/a&gt; 为基础（Vundle 是一个基于 &lt;a href=&quot;https://github.com/tpope/vim-pathogen&quot;&gt;Pathogen&lt;/a&gt; 的 Vim 插件管理器）。在之前的文章中，我&lt;a href=&quot;http://www.openlogic.com/wazi/bid/262302/Three-tools-for-managing-Vim-plugins&quot;&gt;非常不推荐使用 Neobundle&lt;/a&gt;，原因是它当时还处于高速开发阶段（LCTT：意味着不稳定、变数大），并且当时它的英文文档很少。现在，已经过了一年多了，这两个问题都早已不再是问题。&lt;/p&gt;
&lt;p&gt;我们为什么要使用插件管理器？Vim 支持大量插件，但是由于它没有严格定义框架，插件的文件可以胡乱分布在不同目录下，导致用户管理起来会很困难（LCTT：当然，前提是你有很多插件，还有点小小的强迫症，觉得理一理这些插件心里会舒服点）。而一款插件管理器能让管理变得简单许多。Pathogen, Vundle 和 NeoBundle 的工作就是为不同插件建立一个目录，然后将这些目录扔到 ~/.vim/bundle 目录下。这个文件整理方法可以让你方便彻底地删除插件，使用 ‘rm -rf &amp;lt;插件目录&amp;gt;’ 或直接在文件管理器里面把插件所在的目录删除就可以了，绝对绿色环保无残留。同时，这种方法还能最大程度避免插件与插件之间的不兼容性。&lt;/p&gt;
&lt;p&gt;eoBundle 是一个基于 Vundle 的项目，如同 Vundle，它们都可以安装和升级插件。然而 NeoBundle 的说明文件上明确指出：“NeoBundle 不是一个稳定的插件管理器，如果你想要一个稳定的，请选择 Vundle”。最新的 release-note 上也有警告“可能会造成兼容性问题”——这是一个开发者写的注解，说明这个管理器还不能让人放心使用。&lt;/p&gt;
&lt;p&gt;所以，我们为什么要使用 NeoBundle？它都不能保证稳定运行！好吧，它还是有可取之处的。Vundle 只支持 &lt;a href=&quot;http://olex.openlogic.com/packages/git&quot;&gt;Git&lt;/a&gt; 这种版本控制系统，而 NeoBundle 可以支持 &lt;a href=&quot;http://olex.openlogic.com/packages/subversion&quot;&gt;Subversion&lt;/a&gt; 和 &lt;a href=&quot;http://olex.openlogic.com/packages/mercurial&quot;&gt;Mercurial&lt;/a&gt;。另一个原因是如果你不想插件升级时破坏你的 Vim 生态环境，你可以锁住 NeoBundle，让它只使用某个插件的固定版本。&lt;/p&gt;
&lt;p&gt;另外，NeoBundle 创建者，Shougo Matsuishita（LCTT：名字看着像日本人），正在将它的命令接口添加到其他插件项目，以便减少他们的命令使用量。现在 NeoBundle 支持3种插件：&lt;a href=&quot;https://github.com/Shougo/unite.vim&quot;&gt;unite.vim&lt;/a&gt;，Vim 使用的文件和缓存管理器；&lt;a href=&quot;https://github.com/Shougo/vimshell.vim/blob/master/doc/vimshell.txt&quot;&gt;vimshell.vim&lt;/a&gt;，Vim 使用的脚本程序；&lt;a href=&quot;https://github.com/Shougo/vimproc.vim/blob/master/doc/vimproc.txt&quot;&gt;vimproc.vim&lt;/a&gt;，运行于 vimshell.vim 中，用于对异步事件的支持。上面说的都是特殊案例，缺少英文文档，所以用户希望有人能完善它们。在正式使用它们之前，我们需要把注意力先集中在一些基本操作上。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;安装并初始化 NeoBundle&lt;/h3&gt;
&lt;p&gt;NeoBundle 支持 Vim 7.2.051 或更高版本，需要 git 和 &lt;a href=&quot;http://olex.openlogic.com/packages/curl&quot;&gt;cURL&lt;/a&gt;（用于下载文件）。你可以手动下载 NeoBundle，也可以使用 cURL 下载它在 GitHub 上的库。在你的 home 目录下使用如下命令，可以将 NeoBundle 插件下载到 .vim/bundle/neobundle.vim 目录里，然后 NeoBundle 就能管理它自己了。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;curl https://raw.githubusercontent.com/Shougo/neobundle.vim/master/bin/install.sh | sh&lt;/pre&gt;
&lt;p&gt;你还需要修改 .vimrc 文件。NeoBundle 的 GitHub 主页提供一个 .vimrc 范本，但是直接使用这个范本，NeoBundle 需要你安装5个可能不需要插件。如果不需要它们，你可以使用下面的最小配置：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;if has(&#39;vim_starting&#39;)
set nocompatible    
set runtimepath+=~/.vim/bundle/neobundle.vim/
call neobundle#begin(expand(&#39;~/.vim/bundle/&#39;))
NeoBundleFetch &#39;Shougo/neobundle.vim&#39;
call neobundle#end()
filetype plugin indent on&lt;/pre&gt;
&lt;p&gt;上述配置的作用是：启动 NeoBundle 并且像其他插件一样升级自己。NeoBundle 默认从 GitHub 下载并升级，如果你正好在使用 GitHub，你只需要为这个插件指定维护者的用户名和路径。在上面的配置中，NeoBundleFetch 只需要指定为“Shougo/neobundle.vim”，而不是完整的 GitHub 路径。如果你想使用其他网站，比如是 Subversion 或 Mecurial 的网站，你就需要添加完整的 URL。&lt;/p&gt;
&lt;p&gt;如果你想安装其他插件，你可以使用下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;curl -k https://github.com/[项目维护者]/[插件路径] &amp;gt; ~/.vim/bundle/[插件路径]&lt;/pre&gt;
&lt;p&gt;举个例子：你想安装 &lt;a href=&quot;https://github.com/tpope/vim-abolish&quot;&gt;vim-abolish&lt;/a&gt;，一个超级 NB 的文本搜索和替换插件，就使用下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;curl -k https://github.com/tpope/vim-abolish &amp;gt; ~/.vim/bundle/abolish&lt;/pre&gt;
&lt;p&gt;如果要让它自动升级，在 NeoBundleFetch 那行下面添加一行：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;NeoBundle &#39;tpope/vim-abolish&#39;&lt;/pre&gt;
&lt;p&gt;再介绍一个小技巧：你可以为插件指定一个分支或版本号。什么意思？NeoBundle 只会使用这个插件的某个分支或版本，而忽略其版本更新。如果你使用的某个插件处于高速开发过程，你就可以使用这个技巧，避免用到有 bug 的插件版本。举个例子：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;NeoBundle &#39;Shougo/vimshell&#39;, { &#39;rev&#39; : &#39;3787e5&#39; }&lt;/pre&gt;
&lt;p&gt;还有一个技巧：在 .vimtc 文件内添加一行关于“NeoBundleCheck”的属性。NeoBundle 会根据配置检查没安装的插件，并提示你安装它们。你也可以使用命令“:NeoBundleInstall”（LCTT：这是要在 Vim 编辑器的命令模式下输入）来安装或升级插件。&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;NeoBundle 用法&lt;/h3&gt;
&lt;p&gt;很多 NeoBundle 命令用起来和 Vundle 类似，但命令的名字不一样。下面是 NeoBundle 命令的用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;:NeoBundleUpdate：安装或升级插件，如果你手动把一个插件的目录删除了，这个命令会重新安装这个插件。在这个命令后面加上插件名称，就只升级一个插件；不加参数，会将所有己安装但没被记录在案的插件给记录下来。:NeoBundleInstall 命令效果相同。&lt;/li&gt;
&lt;li&gt;:NeoBundle {REPOSITORY URI} [[REVISION}] [,OPTIONS}]]：将一个插件锁定到固定版本，防止胡乱升级。&lt;/li&gt;
&lt;li&gt;:NeoBundleList：列出所有未初始化的插件。&lt;/li&gt;
&lt;li&gt;:NeoBundleClean：进入交互界面，删除插件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些命令在配合 unite.vim （LCTT：就是上面举过的32个例子之一）使用时，效果会稍微有些出入。你可以使用“:help neobundle”命令了解更多信息。&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;是否使用 NeoBundle，自己决定&lt;/h3&gt;
&lt;p&gt;NeoBundle 是强大的工具，正处于高速开发状态。任何处于这种状态的项目，都会被帖上“有前途”和“不稳定”两个标签，看你自己怎么选。如果你想要最新的稳定版本的插件，NeoBundle 能够把 Vundle 和 Pathogen 甩出几条街。&lt;/p&gt;
&lt;p&gt;然而在线帮助文档已经给出警告，它不是个稳定的产品，不及时更新版本可能造成一些插件运行出错。最后，你需要在 .vimrc 文件为你的 Neoundle 和其他插件指定一个稳定的版本。记住这警告，然后你可以在使用这些尖端技术产品时游刃有余。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Tue, 22 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-22-74055-d95c87eea.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-22-74055-d95c87eea.html</guid>
        
        
      </item>
    
      <item>
        <title>一站式学习Wireshark（八）：应用Wireshark过滤条件抓取特定数据流</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;应用抓包过滤，选择Capture | Options，扩展窗口查看到&lt;strong&gt;Capture Filter&lt;/strong&gt;栏。双击选定的接口，如下图所示，弹出&lt;strong&gt;Edit Interface Settints&lt;/strong&gt;窗口。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7ffcc37d1b7296aa062e068b9c3a28bb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图显示了&lt;strong&gt;Edit Interface Settings&lt;/strong&gt;窗口，这里可以设置抓包过滤条件。如果你确知抓包过滤条件的语法，直接在Capture Filter区域输入。在输入错误时，Wireshark通过红色背景区域表明无法处理过滤条件。最有可能的情况是，过滤条件中含有输入错误，或是使用了display filter的语法。&lt;/p&gt;
&lt;p&gt;点击&lt;strong&gt;Capture Filter&lt;/strong&gt;按钮查看并选择已保存的抓包过滤条件。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e9792c6412bc2a86af25ffcb1d7a5cb5.jpg&quot;&gt;&lt;/p&gt;
&lt;div&gt;
&lt;h1&gt;更多信息&lt;/h1&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;抓取指定&lt;/strong&gt;&lt;strong&gt;IP地址的数据流:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的抓包环境下有很多主机正在通讯，可以考虑使用所观察主机的IP地址来进行过滤。以下为IP地址抓包过滤示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;host 10.3.1.1：抓取发到/来自10.3.1.1的数据流&lt;/li&gt;
&lt;li&gt;host 2406:da00:ff00::6b16:f02d：抓取发到/来自IPv6地址2406:da00:ff00::6b16:f02d的数据流&lt;/li&gt;
&lt;li&gt;not host 10.3.1.1：抓取除了发到/来自10.3.1.1以外的所有数据流&lt;/li&gt;
&lt;li&gt;src host 10.3.1.1：抓取来自10.3.1.1的数据流&lt;/li&gt;
&lt;li&gt;dst host 10.3.1.1：抓取发到10.3.1.1的数据流&lt;/li&gt;
&lt;li&gt;host 10.3.1.1 or 10.3.1.2：抓取发到/来自10.3.1.1，以及与之通讯的所有数据流，与10.3.1.2，以及与之通讯的所有数据流&lt;/li&gt;
&lt;li&gt;host &lt;a href=&quot;http://www.espn.com/&quot; target=&quot;_blank&quot;&gt;www.espn.com&lt;/a&gt;：抓取发到/来自所有解析为&lt;a href=&quot;http://www.espn.xn--comip-k81m/&quot; target=&quot;_blank&quot;&gt;www.espn.com的IP&lt;/a&gt;地址的数据流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;抓取指定&lt;/strong&gt;&lt;strong&gt;IP地址范围的数据流:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你需要抓取来自/发到一组地址的数据流，可以采用CIDR(无类别域间路由，Classless Interdomain Routing)格式或使用mask参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;net 10.3.0.0/16：抓取网络10.3.0.0上发到/来自所有主机的数据流(16表示长度)&lt;/li&gt;
&lt;li&gt;net 10.3.0.0 mask 255.255.0.0：与之前的过滤结果相同&lt;/li&gt;
&lt;li&gt;ip6 net 2406:da00:ff00::/64：抓取网络2406:da00:ff00:0000(IPv6)上发到/来自所有主机的数据流&lt;/li&gt;
&lt;li&gt;not dst net 10.3.0.0/16：抓取除了发到以10.3开头的IP地址以外的所有数据流&lt;/li&gt;
&lt;li&gt;not src net 10.3.0.0/16：抓取除了来自以10.3开头的IP地址以外的所有数据流&lt;/li&gt;
&lt;li&gt;ip proto &amp;lt;protocol code&amp;gt;：抓取ip协议字段等于&amp;lt;protocol code&amp;gt;值的报文。如TCP(code 6), UDP(code 17), ICMP(code 1)。&lt;/li&gt;
&lt;li&gt;ip[2:2]==&amp;lt;number&amp;gt;：ip报文大小&lt;/li&gt;
&lt;li&gt;ip[8]==&amp;lt;number&amp;gt;：TTL(Time to Live)值&lt;/li&gt;
&lt;li&gt;ip[9]==&amp;lt;number&amp;gt;：协议值&lt;/li&gt;
&lt;li&gt;icmp[icmptype]==&amp;lt;identifier&amp;gt;: 抓取 ICMP代码等于identifier的ICMP报文, 如icmp-echo 以及 icmp-request。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方括号中第一个数字表示从协议头开始的偏移量，第二个数字表示需要观察多少位。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6e18d07030a1bb14e1c6e6ff26fb78de.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抓取发到广播或多播地址的数据流&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只需侦听广播或多播数据流，就可以掌握网络上主机的许多信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ip broadcast：抓取广播报文&lt;/li&gt;
&lt;li&gt;ip multicast：抓取多播报文&lt;/li&gt;
&lt;li&gt;dst host ff02::1：抓取到IPv6多播地址所有主机的数据流&lt;/li&gt;
&lt;li&gt;dst host ff02::2：抓取到IPv6多播地址所有路由器的数据流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小贴士：&lt;/p&gt;
&lt;p&gt;Wireshark包含了一些默认的抓包过滤条件。点击主工具栏的&lt;strong&gt;Edit Capture Filters&lt;/strong&gt;，跳转到已保存抓包过滤列表。你会发现一些常见抓包过滤的示例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抓取基于&lt;/strong&gt;&lt;strong&gt;MAC地址的数据流:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你需要抓取发到/来自某一主机的IPv4或IPv6数据流，可创建基于主机MAC地址的抓包过滤条件。&lt;/p&gt;
&lt;p&gt;应用MAC地址时，需确保与目标主机处于同一网段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ether host 00:08:15:00:08:15：抓取发到/来自00:08:15:00:08:15的数据流&lt;/li&gt;
&lt;li&gt;ether src 02:0A:42:23:41:AC：抓取来自02:0A:42:23:41:AC的数据流&lt;/li&gt;
&lt;li&gt;ether dst 02:0A:42:23:41:AC：抓取发到02:0A:42:23:41:AC的数据流&lt;/li&gt;
&lt;li&gt;not ether host 00:08:15:00:08:15：抓取除了发到/来自00:08:15:00:08:15以外的所有数据流&lt;/li&gt;
&lt;li&gt;ether broadcast或ether dst ff:ff:ff:ff:ff:ff：抓取广播报文&lt;/li&gt;
&lt;li&gt;ether multicast：多播报文&lt;/li&gt;
&lt;li&gt;抓取指定以太网类型的报文：ether proto 0800&lt;/li&gt;
&lt;li&gt;抓取指定VLAN：vlan &amp;lt;vlan number&amp;gt;&lt;/li&gt;
&lt;li&gt;抓取指定几个VLAN：vlan &amp;lt;vlan number&amp;gt; and vlan &amp;lt;vlan number&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;抓取基于指定应用的数据流&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可能需要查看基于一个或几个应用的数据流。抓包过滤器语法无法识别应用名，因此需要根据端口号来定义应用。通过目标应用的TCP或UDP端口号，将不相关的报文过滤掉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;port 53：抓取发到/来自端口53的UDP/TCP数据流（典型是DNS数据流）&lt;/li&gt;
&lt;li&gt;not port 53：抓取除了发到/来自端口53以外的UDP/TCP数据流&lt;/li&gt;
&lt;li&gt;port 80：抓取发到/来自端口80的UDP/TCP数据流（典型是HTTP数据流）&lt;/li&gt;
&lt;li&gt;udp port 67：抓取发到/来自端口67的UDP数据流（典型是DHCP据流）&lt;/li&gt;
&lt;li&gt;tcp port 21：抓取发到/来自端口21的TCP数据流（典型是FTP命令通道）&lt;/li&gt;
&lt;li&gt;portrange 1-80：抓取发到/来自端口1-80的所有UDP/TCP数据流&lt;/li&gt;
&lt;li&gt;tcp portrange 1-80：抓取发到/来自端口1-80的所有TCP数据流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;抓取结合端口的数据流&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你需要抓取多个不连续端口号的数据流，将它们通过逻辑符号连接起来，如下图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;port 20 or port 21：抓取发到/来自端口20或21的UDP/TCP数据流（典型是FTP数据和命令端口）&lt;/li&gt;
&lt;li&gt;host 10.3.1.1 and port 80：抓取发到/来自10.3.1.1端口80的数据流&lt;/li&gt;
&lt;li&gt;host 10.3.1.1 and not port 80：抓取发到/来自10.3.1.1除了端口80以外的数据流&lt;/li&gt;
&lt;li&gt;udp src port 68 and udp dst port 67：抓取从端口68到端口67的所有UDP数据流（典型是从DHCP客户端到DHCP服务器）&lt;/li&gt;
&lt;li&gt;udp src port 67 and udp dst port 68：抓取从端口67到端口68的所有UDP数据流（典型是从DHCP服务器到DHCP客户端）&lt;/li&gt;
&lt;li&gt;抓取TCP连接的开始（SYN）和结束（FIN）报文，配置tcp[tcpflags] &amp;amp; (tcp-syn|tcp-fin)!=0&lt;/li&gt;
&lt;li&gt;抓取所有RST(Reset)标志位为1的TCP报文，配置tcp[tcpflags] &amp;amp; (tcp-rst)!=0&lt;/li&gt;
&lt;li&gt;less &amp;lt;length&amp;gt;：抓取小于等于某一长度的报文，等同于len &amp;lt;=&amp;lt;length&amp;gt;&lt;/li&gt;
&lt;li&gt;greater &amp;lt;length&amp;gt;：抓取大于等于某一长度的报文，等同于len &amp;gt;=&amp;lt;length&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SYN: 简历连接的信号&lt;/p&gt;
&lt;p&gt;FIN: 关闭连接的信号&lt;/p&gt;
&lt;p&gt;ACK: 确认接收数据的信号&lt;/p&gt;
&lt;p&gt;RST: 立即关闭连接的信号&lt;/p&gt;
&lt;p&gt;PSH: 推信号，尽快将数据转由应用处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×00 = 0: No flags set (null scan)&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×01 = 1: FIN set and ACK not set&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×03 = 3: SYN set and FIN set&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×05 = 5: RST set and FIN set&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×06 = 6: SYN set and RST set&lt;/li&gt;
&lt;li&gt;tcp[13] &amp;amp; 0×08 = 8: PSH set and ACK not set&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tcp[13]是从协议头开始的偏移量，0,1,3,5,6,8是标识位&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/589b72d6f6daa6d9de863f779bac8c7c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尽量避免使用抓包过滤。即便多看几个报文，也比漏看一个报文要好。&lt;/strong&gt;当你抓取了大量报文的时候，用显示过滤（过滤选项也更多）来重点查看某一数据流。&lt;/p&gt;
&lt;p&gt;小贴士：&lt;/p&gt;
&lt;p&gt;如果你需要查看TCP帧中的某一ASCII字符串，用Wireshark String-Matching Capture Filter Generator(&lt;a href=&quot;http://www.wireshark.org/tools/string-cf.html&quot; target=&quot;_blank&quot;&gt;http://www.wireshark.org/tools/string-cf.html&lt;/a&gt;)。例如，想要抓取HTTP GET报文，输入GET并将TCP偏移量设置为0。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Tue, 22 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-22-74018-e2c2860b8.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-22-74018-e2c2860b8.html</guid>
        
        
      </item>
    
      <item>
        <title>Feature Flag 功能发布控制</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;产品在新功能发布前，可能会采取小流量测试的方式，或者在确定方案前使用A/B测试来衡量。一般开发人员会跟运维同学合作，通过一些现有平台切换机器或者流量来实现。本文介绍了另外一种简便的方式，并解释了其在持续集成上的应用，同时提供了现有的开发框架供快速使用。&lt;/p&gt;
&lt;h2&gt;Feature Flag VS Feature Branches&lt;/h2&gt;
&lt;p&gt;Feature Flag(又名 Feature Toggle、Flip等)是一种允许控制线上功能开启或者关闭的方式，通常会采取配置文件的方式来控制。提到Feature Flag一般都会跟Feature Branches进行比较。这两个有什么关联与差别呢？可以通过一个简单的示例来比较：&lt;/p&gt;
&lt;p&gt;假设产品需要添加一个功能，如果你在主干上进行开发，那么通常的做法是在前端开发人员在界面上添加功能，然后可能会有其他同学来完成后端服务、安全保障，最后测试及Bug修复并发布上线。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/3f023edafa76373e737f3cda38decf85.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73931&quot; alt=&quot;new-feature&quot; src=&quot;/images/jobbole.com/0ceec95bf020414d8fd832e7b7e08a76.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;上图中有个明显的问题是&lt;strong&gt;主干分支上在功能测试完毕之前是不能进行发布&lt;/strong&gt;的，因为功能已经在提供在界面中，必须完备之后才能发布给用户使用。&lt;/p&gt;
&lt;p&gt;当然解决方法也很简单，例如我们常见的是会使用功能分支(Feature Branches)来解决。在主干上拉取一个分支，然后在分支上开完测试完之后在合并到主干上，这样就不会影响主干的持续发布了。如果有另外的新的功能那么同样拉取新的分支来解决。如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/b139771f4bd796365f7d28ed3593d19c.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73933&quot; alt=&quot;new-feature2&quot; src=&quot;/images/jobbole.com/b4e810b6466d9ac806b26bbd5a79ad40.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;但这样同样存在问题，如果一个功能比较复杂，开发的周期较长，而在此期间主干上已经多次修改代码，那么等分支上开发完之后合并到主干将是一个比较麻烦的工作。你必须去处理各种冲突，与其他开发人员沟通修改点。这是很多人不愿意做的。&lt;/p&gt;
&lt;p&gt;于是有人提供了新的方案来解决这个问题。例如将开发工作拆分成多个小块，在各个分支上开发测试完成后及时合并到主干中，并且可以先隐藏界面功能，直到所有的功能开发完成之后才展现。这样每次合并的难度就小多了；或者每次将主干上的修改都及时同步到分支上，这样分支上开发完成之后合并到主干上就简单多了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/5876f970ca04ac464c0e4664f69a9a51.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73934&quot; alt=&quot;new-feature3&quot; src=&quot;/images/jobbole.com/cd969a53adefb39cbb953d2828ec2028.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;但如果&lt;strong&gt;发布时出现bug&lt;/strong&gt;怎么办？可能常见的是进行回滚重新上线。有什么方式既能避免分支合并的麻烦、保持主干快速迭代随时发布，又能更好的控制新功能的发布、方便的进行小流量或快速回滚操作呢？答案就是Feature Flag。&lt;/p&gt;
&lt;p&gt;Feature Flag允许关闭未完成的功能，你可以在主干上进行迭代开发，新功能即便未开发完成也不会影响发布，因为它对用户是&lt;code&gt;关闭&lt;/code&gt;的。当功能开发完成之后，修改配置便可以让功能发布。这种操作甚至可以在线上进行，例如代码已经发布但功能不可见，你可以修改配置让功能对&lt;strong&gt;特定的用户&lt;/strong&gt;(线上测试、小流量或者全量发布等)可见。如果发现新功能存在问题，那么可以通过配置文件来迅速回滚，而必须重新分支上线。Feature Flag原理示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/990e4ee6ca912e39bafcd11f05375d5f.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73936&quot; alt=&quot;featureToggle&quot; src=&quot;/images/jobbole.com/6312cf3bb128a0d3eb8de77d6c9798fe.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;各自的优缺点&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;选择合适的方案，而不拘泥于方式本身&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;并没有万能的方案，两种方式都有各自的优缺点。&lt;/p&gt;
&lt;h3&gt;Feature Branches&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同时开发多个功能分支不会影响主干和线上代码&lt;/li&gt;
&lt;li&gt;在分支上开发新功能时不用担心对其他在开发的功能的影响&lt;/li&gt;
&lt;li&gt;现有很多持续集成系统支持分支的构建、测试、部署等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;也很明显，&lt;a href=&quot;http://martinfowler.com/bliki/FeatureBranch.html&quot; target=&quot;_blank&quot;&gt;Martin Fowler&lt;/a&gt;的文章中已经做了全面的阐述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分支分出去时间越长往往代码合并难度越大&lt;/li&gt;
&lt;li&gt;在一个分支中修改了函数名字可能会引入大量编译错误。这点被称为语义冲突（semantic conflict）&lt;/li&gt;
&lt;li&gt;为了减少语义冲突，会尽量少做重构。而重构是持续改进代码质量的手段。如果在开发的过程中持续不断的存在功能分支，就会阻碍代码质量的改进。&lt;/li&gt;
&lt;li&gt;一旦代码库中存在了分支，也就不再是真正的持续集成了。当然你可以给每个分支建立一个对应的CI，但它只能测试当前分支的正确性。如果在一个分支中修改了函数功能，但是在另一个分支还是按照原来的假设在使用，在合并的时候会引入bug，需要大量的时间来修复这些bug。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Feature Toggle&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免了分支合并代码冲突的问题，因为是基于主干的开发&lt;/li&gt;
&lt;li&gt;每次提交都在主干，迭代速度明显有优势&lt;/li&gt;
&lt;li&gt;新功能的整个过程都持续集成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未完成的功能可能会部署到线上，如果配置有误可能将未完成的功能开启。当然可以将界面层最后开发避免过早暴露。&lt;/li&gt;
&lt;li&gt;主干上担心提交代码影响其他功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以根据需要选择合适的方案。Feature Flag在避免分支合并加快迭代上有优势，另外Feature Flag除了主干开发上的支持，还有什么实用功能呢？下面来介绍。&lt;/p&gt;
&lt;h2&gt;Feature Flag种类与应用&lt;/h2&gt;
&lt;p&gt;一般Feature Flag可以分为两类，见下所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发布开关&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在发布代码时关掉未完成的功能&lt;/li&gt;
&lt;li&gt;生存期短&lt;/li&gt;
&lt;li&gt;功能稳定就马上删除&lt;/li&gt;
&lt;li&gt;在整个开发过程中有预定义的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;业务开关&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现A/B测试&lt;/li&gt;
&lt;li&gt;针对特定人群发布功能尽早获得反馈&lt;/li&gt;
&lt;li&gt;针对特定条件开启或者关闭功能。例如可以设置在指定时间点开启，这样新功能将按照设定自动上线下线，无需手动上线，适合专题等情况&lt;/li&gt;
&lt;li&gt;能线上开启或者关闭,实现快速回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发布开关主要是为了隐藏未开发完成的功能，而业务开关则可以帮助我们快速满足某些需求。例如A/B测试，Feature Flag可以轻松控制展现哪个功能，提升A/B测试的可维护性。我们也可以通过配置里面的逻辑让新功能针对小部分人群甚至是特定地域的人群发布，尽早获取功能的反馈。甚至是可以在线上开启调试，只让新功能对调试人员可见。而这些都只需要配置文件和简单的标记来实现。&lt;/p&gt;
&lt;h2&gt;谁在用Feature Flag&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;功能看起来很酷，但是不是新东西？有谁在用呢，我可不不愿意承担风险&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;事实上Feature Flag已经在国外互联网公司中获得广泛的使用。例如FaceBook、Google等公司使用基于主干的开发模式来持续集成开发，Feature Flag是其中一个基础技术。下面这幅图展现了FaceBook开发模式转变历程,可以看到几年前facebook就开始使用Feature Toggle，使用了Feature Flag关闭主干上未开发完成的功能来保证快速迭代和高频率的发布。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/546b1655ef24c07a846869272a16ae15.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73938&quot; alt=&quot;facebook&quot; src=&quot;/images/jobbole.com/90222994abf75057531d3a23ffcb6e14.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;国外主干开发中推荐这样一种方式：trunk作为开发主线，所有开发人员完成开发后向及时向主干提交代码，开发人员不允许在主干上拉取分支。在发布的时候由系统拉取分支发布，主干上的bug修复及时同步到发布分支。开发人员可以本地使用git等工具进行版本管理。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/d2c55b38c1f915bba4d4b1af268aa552.jpg&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73939&quot; alt=&quot;tbd&quot; src=&quot;/images/jobbole.com/595bdd6f052b91c2161119c4bff5c5f4.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;虽然基于主干的开发模式已经成为国外的主流，但分支开发并不是不该使用。使用分支不推荐的是让新功能代码在分支上长时间堆积，分支应当是生存周期短的。&lt;/p&gt;
&lt;p&gt;实际应用中我们可以根据业务场景来选择是否用功能分支还是Feature Flag，并且这两者可以相互结合。例如在文章前面提到的示例中，可以使用分支来开发细分的子功能保持分支及时合并，同时使用Feature Flag来控制功能的发布，提升工作效率。&lt;/p&gt;
&lt;h2&gt;最佳实践&lt;/h2&gt;
&lt;p&gt;除了主干开发，什么情况下选择使用Feature Flag呢？下面是使用Feature Flag的一些典型场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 UI 中隐藏或禁用新功能&lt;/li&gt;
&lt;li&gt;在应用程序中隐藏或禁用新组件&lt;/li&gt;
&lt;li&gt;对接口进行版本控制&lt;/li&gt;
&lt;li&gt;扩展接口&lt;/li&gt;
&lt;li&gt;支持组件的多个版本&lt;/li&gt;
&lt;li&gt;将新功能添加到现有应用程序&lt;/li&gt;
&lt;li&gt;增强现有应用程序中的现有功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，由于Feature Flag本身是对业务功能的控制，所以不适于功能大范围的改动等情况。另外使用过程中需要注意一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只在需要的地方创建开关。美酒虽豪，不可贪杯。滥用任何技术都会出现问题。&lt;/li&gt;
&lt;li&gt;控制开关的数量。同上，开关应按需使用并及时清除。&lt;/li&gt;
&lt;li&gt;开关之间代码保持独立。如果代码存在依赖就没法删除，最终维护性反而变差&lt;/li&gt;
&lt;li&gt;清除发布开关和废弃代码。发布开关应当在功能稳定后删除，旧代码也是。&lt;/li&gt;
&lt;li&gt;界面层最后暴露。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;如何实现&lt;/h2&gt;
&lt;p&gt;实现这套东西复杂吗？下面以php和smarty模板为例来介绍。&lt;/p&gt;
&lt;p&gt;首先需要一套控制代码逻辑的工具，虽然开源的框架有在后端代码层的支持，但推荐在模板层使用Feature Flag，因为模板直接跟功能挂钩，维护起来更加直观方便。&lt;/p&gt;
&lt;p&gt;例如我们会提供一个smarty插件，让你控制相应的展现:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/4f8e3c1849fd0fcf7be5f15a50f4deba.png&quot; rel=&quot;lightbox[73930]&quot; title=&quot;Feature Flag 功能发布控制&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73940&quot; alt=&quot;feature-smarty&quot; src=&quot;/images/jobbole.com/9fb17b4ac0813c18537c4c413574ebbc.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;这个代码的意思是如果common模块的featureA命中，则展现下面代码，否则展现另外一套代码，展现代码由于与功能相关，所以就相当于控制了展现哪个功能。当然你也可以不用&lt;code&gt;featureelse&lt;/code&gt;只控制功能的开启或者关闭。&lt;/p&gt;
&lt;p&gt;另外我们需要一个配置文件，对应featureA的配置，如下所示：&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: false&quot;&gt;{
      &quot;features&quot; : {
          &quot;featureA&quot; : {
              &quot;type&quot; : &quot;switch&quot;,
              &quot;value&quot; : &quot;on&quot;,
              &quot;desc&quot; : &quot;test switch feature work or not&quot;
          }
      }
 }&lt;/pre&gt;
&lt;p&gt;featureA配置的value是&lt;code&gt;on&lt;/code&gt;，开关类型是&lt;code&gt;switch&lt;/code&gt;。也就是说这个功能是开启的。与switch类似的可以实现多个feature类型，例如抽样控制、日期控制、地域控制等，代码逻辑只需要根据value的设定判断是true还是false。例如抽样类型，value设置0.5，那么对应的类型逻辑只需要判断随机数是否在0-0.5范围内而已。&lt;/p&gt;
&lt;p&gt;部署中我们只需要修改featureA的配置就可以控制功能的发布，是不是so easy!&lt;/p&gt;
&lt;h2&gt;开发框架&lt;/h2&gt;
&lt;p&gt;有哪些相应的开源框架呢？几乎各种语言都有相应的实现。例如FEX &lt;a href=&quot;http://fis.baidu.com/&quot; target=&quot;_blank&quot;&gt;FIS&lt;/a&gt;小组提供了基于php和node.js的框架。此外还有多种语言的开源实现：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语言&lt;/th&gt;
&lt;th&gt;Feature Flag框架&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;php&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;基于smarty的&lt;a href=&quot;https://github.com/wangcheng714/feature-flag&quot; target=&quot;_blank&quot;&gt;Feature Flag框架&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;NodeJs&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;基于Node前后端解决方案Yogurt的&lt;a href=&quot;https://github.com/fex-team/yog-feature&quot; target=&quot;_blank&quot;&gt;Feature Flag框架&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.togglz.org/&quot; target=&quot;_blank&quot;&gt;Togglz&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.NET&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/jason-roberts/FeatureToggle&quot; target=&quot;_blank&quot;&gt;FeatureToggle&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ruby&lt;/td&gt;
&lt;td&gt;
&lt;a href=&quot;https://github.com/FetLife/rollout&quot; target=&quot;_blank&quot;&gt;Rollout&lt;/a&gt;、&lt;a href=&quot;https://github.com/jamesgolick/degrade&quot; target=&quot;_blank&quot;&gt;Degrade&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;
&lt;a href=&quot;https://github.com/disqus/gargoyle&quot; target=&quot;_blank&quot;&gt;Gargoyle&lt;/a&gt;、&lt;a href=&quot;https://github.com/disqus/nexus&quot; target=&quot;_blank&quot;&gt;Nexus admin&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Groovy&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/ryannorris/grails-feature-toggle&quot; target=&quot;_blank&quot;&gt;GrailsFeatureToggle&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Feature Flag与Feature Branches各有优势，结合使用能发挥更大作用&lt;/li&gt;
&lt;li&gt;结合业务场景选择合适方案&lt;/li&gt;
&lt;li&gt;Feature Flag能支持主干开发，并在控制功能发布上有独特优势&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/magazine/dn683796.aspx&quot; target=&quot;_blank&quot;&gt;采用功能切换进行软件开发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations&quot; target=&quot;_blank&quot;&gt;使用功能开关更好地实现持续部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://martinfowler.com/bliki/FeatureToggle.html&quot; target=&quot;_blank&quot;&gt;FeatureToggle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/HendrikEbbers/feature-driven-development-35863636?qid=2a29fcc2-9c8c-404f-ae41-d4dc7494d278&amp;amp;v=qf1&amp;amp;b=&amp;amp;from_search=5&quot; target=&quot;_blank&quot;&gt;Feature driven development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.pluralsight.com/favor-feature-toggles-over-feature-branches&quot; target=&quot;_blank&quot;&gt;Favor Feature Toggles over Feature Branches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://paulhammant.com/2013/04/05/what-is-trunk-based-development/&quot; target=&quot;_blank&quot;&gt;What is Trunk Based Development?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://abhishek-tiwari.com/post/decoupling-deployment-and-release-feature-toggles&quot; target=&quot;_blank&quot;&gt;Decoupling Deployment and Release- Feature Toggles&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Mon, 21 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-21-73930-06f292316.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-21-73930-06f292316.html</guid>
        
        
      </item>
    
      <item>
        <title>推荐！国外程序员整理的机器学习资源大全</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;本文汇编了一些机器学习领域的框架、库以及软件（按编程语言排序）。&lt;/p&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#c&quot; name=&quot;user-content-c&quot;&gt;&lt;/a&gt;C++&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#compute-vision&quot; name=&quot;user-content-compute-vision&quot;&gt;&lt;/a&gt;计算机视觉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/liuliu/ccv&quot;&gt;CCV&lt;/a&gt; —基于C语言/提供缓存/核心的机器视觉库，新颖的机器视觉库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://opencv.org/&quot;&gt;OpenCV&lt;/a&gt;—它提供C++, C, Python, Java 以及 MATLAB接口，并支持Windows, Linux, Android and Mac OS操作系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning&quot; name=&quot;user-content-general-purpose-machine-learning&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mlpack.org/&quot;&gt;MLPack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dlib.net/ml.html&quot;&gt;DLib&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://code.google.com/p/encog-cpp/&quot;&gt;ecogg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://image.diku.dk/shark/sphinx_pages/build/html/index.html&quot;&gt;shark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#closure&quot; name=&quot;user-content-closure&quot;&gt;&lt;/a&gt;Closure&lt;/h2&gt;
&lt;h4&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.clojure-toolbox.com/&quot;&gt;Closure Toolbox&lt;/a&gt;—Clojure语言库与工具的分类目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#go&quot; name=&quot;user-content-go&quot;&gt;&lt;/a&gt;Go&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing&quot; name=&quot;user-content-natural-language-processing&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/reiver/go-porterstemmer&quot;&gt;go-porterstemmer&lt;/a&gt;—一个Porter词干提取算法的原生Go语言净室实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/Rookii/paicehusk&quot;&gt;paicehusk&lt;/a&gt;—Paice/Husk词干提取算法的Go语言实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://bitbucket.org/tebeka/snowball&quot;&gt;snowball&lt;/a&gt;—Go语言版的Snowball词干提取器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 16px; font-style: normal; font-weight: bold;&quot;&gt;通用机器学习&lt;/span&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-2&quot; name=&quot;user-content-general-purpose-machine-learning-2&quot;&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/sjwhitworth/golearn&quot;&gt;Go Learn&lt;/a&gt;— Go语言机器学习库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/daviddengcn/go-pr&quot;&gt;go-pr&lt;/a&gt; —Go语言机器学习包.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/jbrukh/bayesian&quot;&gt;bayesian&lt;/a&gt;—Go语言朴素贝叶斯分类库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/thoj/go-galib&quot;&gt;go-galib&lt;/a&gt;—Go语言遗传算法库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization&quot; name=&quot;user-content-data-analysis--data-visualization&quot;&gt;&lt;/a&gt;&lt;br&gt;
数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/StepLg/go-graph&quot;&gt;go-graph&lt;/a&gt;—Go语言图形库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.svgopen.org/2011/papers/34-SVGo_a_Go_Library_for_SVG_generation/&quot;&gt;SVGo&lt;/a&gt;—Go语言的SVG生成库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#java&quot; name=&quot;user-content-java&quot;&gt;&lt;/a&gt;Java&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-1&quot; name=&quot;user-content-natural-language-processing-1&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/corenlp.shtml&quot;&gt;CoreNLP&lt;/a&gt;—斯坦福大学的CoreNLP提供一系列的自然语言处理工具，输入原始英语文本，可以给出单词的基本形式（下面Stanford开头的几个工具都包含其中）。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/lex-parser.shtml&quot;&gt;Stanford Parser&lt;/a&gt;—一个自然语言解析器。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/tagger.shtml&quot;&gt;Stanford POS Tagger&lt;/a&gt; —一个词性分类器。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/CRF-NER.shtml&quot;&gt;Stanford Name Entity Recognizer&lt;/a&gt;—Java实现的名称识别器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/segmenter.shtml&quot;&gt;Stanford Word Segmenter&lt;/a&gt;—分词器，很多NLP工作中都要用到的标准预处理步骤。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/tregex.shtml&quot;&gt;Tregex, Tsurgeon and Semgrex&lt;/a&gt; —用来在树状数据结构中进行模式匹配，基于树关系以及节点匹配的正则表达式（名字是“tree regular expressions”的缩写）。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/phrasal/&quot;&gt;Stanford Phrasal:&lt;/a&gt;最新的基于统计短语的机器翻译系统，&lt;a href=&quot;http://nlp.stanford.edu/software/phrasal/&quot;&gt; &lt;/a&gt;java编写&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/tokensregex.shtml&quot;&gt;Stanford Tokens Regex&lt;/a&gt;—用以定义文本模式的框架。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/sutime.shtml&quot;&gt;Stanford Temporal Tagger&lt;/a&gt;—SUTime是一个识别并标准化时间表达式的库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/patternslearning.shtml&quot;&gt;Stanford SPIED&lt;/a&gt;—在种子集上使用模式，以迭代方式从无标签文本中学习字符实体&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/tmt/tmt-0.4/&quot;&gt;Stanford Topic Modeling Toolbox&lt;/a&gt; —为社会科学家及其他希望分析数据集的人员提供的主题建模工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/twitter-text-java&quot;&gt;Twitter Text Java&lt;/a&gt;—Java实现的推特文本处理库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://mallet.cs.umass.edu/&quot;&gt;MALLET&lt;/a&gt; -—基于Java的统计自然语言处理、文档分类、聚类、主题建模、信息提取以及其他机器学习文本应用包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://opennlp.apache.org/&quot;&gt;OpenNLP&lt;/a&gt;—处理自然语言文本的机器学习工具包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://alias-i.com/lingpipe/index.html&quot;&gt;LingPipe&lt;/a&gt; —使用计算机语言学处理文本的工具包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-3&quot; name=&quot;user-content-general-purpose-machine-learning-3&quot;&gt;&lt;/a&gt;&lt;br&gt;
通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://spark.apache.org/docs/latest/mllib-guide.html&quot;&gt;MLlib in Apache Spark&lt;/a&gt;—Spark中的分布式机器学习程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/apache/mahout&quot;&gt;Mahout&lt;/a&gt; —分布式的机器学习库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://nlp.stanford.edu/software/classifier.shtml&quot;&gt;Stanford Classifier&lt;/a&gt; —斯坦福大学的分类器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.cs.waikato.ac.nz/ml/weka/&quot;&gt;Weka&lt;/a&gt;—Weka是数据挖掘方面的机器学习算法集。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/cloudera/oryx&quot;&gt;ORYX&lt;/a&gt;—提供一个简单的大规模实时机器学习/预测分析基础架构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-1&quot; name=&quot;user-content-data-analysis--data-visualization-1&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/apache/hadoop-mapreduce&quot;&gt;Hadoop&lt;/a&gt;—大数据分析平台&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/apache/spark&quot;&gt;Spark&lt;/a&gt;—快速通用的大规模数据处理引擎。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/cloudera/impala&quot;&gt;Impala&lt;/a&gt; —为Hadoop实现实时查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#javascript&quot; name=&quot;user-content-javascript&quot;&gt;&lt;/a&gt;Javascript&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-2&quot; name=&quot;user-content-natural-language-processing-2&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/twitter-text-js&quot;&gt;Twitter-text-js&lt;/a&gt; —JavaScript实现的推特文本处理库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nicktesla/nlpjs&quot;&gt;NLP.js&lt;/a&gt; —javascript及coffeescript编写的NLP工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/NaturalNode/natural&quot;&gt;natural&lt;/a&gt;—Node下的通用NLP工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/loadfive/Knwl.js&quot;&gt;Knwl.js&lt;/a&gt;—JS编写的自然语言处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-2&quot; name=&quot;user-content-data-analysis--data-visualization-2&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://d3js.org/&quot;&gt;D3.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.highcharts.com/&quot;&gt;High Charts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nvd3.org/&quot;&gt;NVD3.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dc-js.github.io/dc.js/&quot;&gt;dc.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.chartjs.org/&quot;&gt;chartjs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dimplejs.org/&quot;&gt;dimple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amcharts.com/&quot;&gt;amCharts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-4&quot; name=&quot;user-content-general-purpose-machine-learning-4&quot;&gt;&lt;/a&gt;&lt;br&gt;
通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://cs.stanford.edu/people/karpathy/convnetjs/&quot;&gt;Convnet.js&lt;/a&gt;—训练深度学习模型的JavaScript库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tixz/clustering.js&quot;&gt;Clustering.js&lt;/a&gt;—用JavaScript实现的聚类算法，供Node.js及浏览器使用。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/serendipious/nodejs-decision-tree-id3&quot;&gt;Decision Trees&lt;/a&gt;—Node.js实现的决策树，使用ID3算法。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/rlidwka/node-fann&quot;&gt;Node-fann&lt;/a&gt; —Node.js下的快速人工神经网络库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tixz/kmeans.js&quot;&gt;Kmeans.js&lt;/a&gt;—k-means算法的简单Javascript实现，供Node.js及浏览器使用。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/primaryobjects/lda&quot;&gt;LDA.js&lt;/a&gt; —供Node.js用的LDA主题建模工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/yandongliu/learningjs&quot;&gt;Learning.js&lt;/a&gt;—逻辑回归/c4.5决策树的JavaScript实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://joonku.com/project/machine_learning&quot;&gt;Machine Learning&lt;/a&gt;—Node.js的机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nicolaspanel/node-svm&quot;&gt;Node-SVM&lt;/a&gt;—Node.js的支持向量机&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/harthur/brain&quot;&gt;Brain&lt;/a&gt; —JavaScript实现的神经网络&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/omphalos/bayesian-bandit.js&quot;&gt;Bayesian-Bandit&lt;/a&gt; —贝叶斯强盗算法的实现，供Node.js及浏览器使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#julia&quot; name=&quot;user-content-julia&quot;&gt;&lt;/a&gt;Julia&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-5&quot; name=&quot;user-content-general-purpose-machine-learning-5&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/PGM.jl&quot;&gt;PGM&lt;/a&gt;—Julia实现的概率图模型框架。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/trthatcher/DA.jl&quot;&gt;DA&lt;/a&gt;—Julia实现的正则化判别分析包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/lindahua/Regression.jl&quot;&gt;Regression&lt;/a&gt;—回归分析算法包（如线性回归和逻辑回归）。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/dcjones/Loess.jl&quot;&gt;Local Regression&lt;/a&gt; —局部回归，非常平滑！&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nutsiepully/NaiveBayes.jl&quot;&gt;Naive Bayes&lt;/a&gt; —朴素贝叶斯的简单Julia实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/dmbates/MixedModels.jl&quot;&gt;Mixed Models&lt;/a&gt; —（统计）混合效应模型的Julia包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fredo-dedup/SimpleMCMC.jl&quot;&gt;Simple MCMC&lt;/a&gt; —Julia实现的基本mcmc采样器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/Distance.jl&quot;&gt;Distance&lt;/a&gt;—Julia实现的距离评估模块&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/bensadeghi/DecisionTree.jl&quot;&gt;Decision Tree&lt;/a&gt; —决策树分类器及回归分析器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/compressed/neural.jl&quot;&gt;Neural&lt;/a&gt; —Julia实现的神经网络&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/doobwa/MCMC.jl&quot;&gt;MCMC&lt;/a&gt; —Julia下的MCMC工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLM&lt;/a&gt; —Julia写的广义线性模型包&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lendle/OnlineLearning.jl&quot;&gt;Online Learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/simonster/GLMNet.jl&quot;&gt;GLMNet&lt;/a&gt; —GMLNet的Julia包装版，适合套索/弹性网模型。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/Clustering.jl&quot;&gt;Clustering&lt;/a&gt;—数据聚类的基本函数：k-means, dp-means等。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/SVM.jl&quot;&gt;SVM&lt;/a&gt;—Julia下的支持向量机。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/KernelDensity.jl&quot;&gt;Kernal Density&lt;/a&gt;—Julia下的核密度估计器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/DimensionalityReduction.jl&quot;&gt;Dimensionality Reduction&lt;/a&gt;—降维算法&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/NMF.jl&quot;&gt;NMF&lt;/a&gt; —Julia下的非负矩阵分解包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/EricChiang/ANN.jl&quot;&gt;ANN&lt;/a&gt;—Julia实现的神经网络&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-3&quot; name=&quot;user-content-natural-language-processing-3&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/slycoder/TopicModels.jl&quot;&gt;Topic Models&lt;/a&gt; —Julia下的主题建模&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/johnmyleswhite/TextAnalysis.jl&quot;&gt;Text Analysis&lt;/a&gt;—Julia下的文本分析包&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-3&quot; name=&quot;user-content-data-analysis--data-visualization-3&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/IainNZ/GraphLayout.jl&quot;&gt;Graph Layout&lt;/a&gt; —纯Julia实现的图布局算法。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/DataFramesMeta.jl&quot;&gt;Data Frames Meta&lt;/a&gt; —DataFrames的元编程工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nfoti/JuliaData&quot;&gt;Julia Data&lt;/a&gt;—处理表格数据的Julia库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/WizardMac/DataRead.jl&quot;&gt;Data Read&lt;/a&gt;—从Stata、SAS、SPSS读取文件&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/HypothesisTests.jl&quot;&gt;Hypothesis Tests&lt;/a&gt;—Julia中的假设检验包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/dcjones/Gadfly.jl&quot;&gt;Gladfly&lt;/a&gt; —Julia编写的灵巧的统计绘图系统。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/johnmyleswhite/stats.jl&quot;&gt;Stats&lt;/a&gt;—Julia编写的统计测试函数包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/johnmyleswhite/RDatasets.jl&quot;&gt;RDataSets&lt;/a&gt; —读取R语言中众多可用的数据集的Julia函数包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/DataFrames.jl&quot;&gt;DataFrames&lt;/a&gt; —处理表格数据的Julia库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;Distributions&lt;/a&gt;—概率分布及相关函数的Julia包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/DataArrays.jl&quot;&gt;Data Arrays&lt;/a&gt; —元素值可以为空的数据结构。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/TimeSeries.jl&quot;&gt;Time Series&lt;/a&gt;—Julia的时间序列数据工具包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaStats/Sampling.jl&quot;&gt;Sampling&lt;/a&gt;—Julia的基本采样算法包&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#misc-stuff--presentations&quot; name=&quot;user-content-misc-stuff--presentations&quot;&gt;&lt;/a&gt;杂项/演示文稿&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaDSP/DSP&quot;&gt;DSP&lt;/a&gt; —数字信号处理&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/JuliaCon/presentations&quot;&gt;JuliaCon Presentations&lt;/a&gt;—Julia大会上的演示文稿&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/davidavdav/SignalProcessing&quot;&gt;SignalProcessing&lt;/a&gt;—Julia的信号处理工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/timholy/Images.jl&quot;&gt;Images&lt;/a&gt;—Julia的图片库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#matlab&quot; name=&quot;user-content-matlab&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;Lua&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#general-purpose-machine-learning-7&quot; name=&quot;user-content-general-purpose-machine-learning-7&quot;&gt;&lt;/a&gt;&lt;br&gt;
通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://torch.ch/&quot;&gt;Torch7&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://jucor.github.io/torch-cephes&quot;&gt;cephes&lt;/a&gt; —Cephes数学函数库，包装成Torch可用形式。提供并包装了超过180个特殊的数学函数，由Stephen L. Moshier开发，是SciPy的核心，应用于很多场合。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/graph&quot;&gt;graph&lt;/a&gt; —供Torch使用的图形包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://jucor.github.io/torch-randomkit/&quot;&gt;randomkit&lt;/a&gt;—从Numpy提取的随机数生成包，包装成Torch可用形式。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://soumith.ch/torch-signal/signal/&quot;&gt;signal&lt;/a&gt; —Torch-7可用的信号处理工具包，可进行FFT, DCT, Hilbert, cepstrums, stft等变换。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/nn&quot;&gt;nn&lt;/a&gt; —Torch可用的神经网络包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/nngraph&quot;&gt;nngraph&lt;/a&gt; —为nn库提供图形计算能力。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/lua---nnx&quot;&gt;nnx&lt;/a&gt;—一个不稳定实验性的包，扩展Torch内置的nn库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/optim&quot;&gt;optim&lt;/a&gt;—Torch可用的优化算法库，包括 SGD, Adagrad, 共轭梯度算法, LBFGS, RProp等算法。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/koraykv/unsup&quot;&gt;unsup&lt;/a&gt;—Torch下的非监督学习包。提供的模块与nn(LinearPsd, ConvPsd, AutoEncoder, …)及独立算法 (k-means, PCA)等兼容。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/manifold&quot;&gt;manifold&lt;/a&gt;—操作流形的包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/koraykv/torch-svm&quot;&gt;svm&lt;/a&gt;—Torch的支持向量机库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/lbfgs&quot;&gt;lbfgs&lt;/a&gt;—将liblbfgs包装为FFI接口。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/vowpal_wabbit&quot;&gt;vowpalwabbit&lt;/a&gt; —老版的vowpalwabbit对torch的接口。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/lua---opengm&quot;&gt;OpenGM&lt;/a&gt;—OpenGM是C++编写的图形建模及推断库，该binding可以用Lua以简单的方式描述图形，然后用OpenGM优化。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/MichaelMathieu/lua---spaghetti&quot;&gt;sphagetti&lt;/a&gt; —MichaelMathieu为torch7编写的稀疏线性模块。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ocallaco/LuaSHkit&quot;&gt;LuaSHKit&lt;/a&gt; —将局部敏感哈希库SHKit包装成lua可用形式。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/rlowrance/kernel-smoothers&quot;&gt;kernel smoothing&lt;/a&gt; —KNN、核权平均以及局部线性回归平滑器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/cutorch&quot;&gt;cutorch&lt;/a&gt;—torch的CUDA后端实现&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/torch/cunn&quot;&gt;cunn&lt;/a&gt; —torch的CUDA神经网络实现。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/lua---imgraph&quot;&gt;imgraph&lt;/a&gt;—torch的图像/图形库，提供从图像创建图形、分割、建立树、又转化回图像的例程&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clementfarabet/videograph&quot;&gt;videograph&lt;/a&gt;—torch的视频/图形库，提供从视频创建图形、分割、建立树、又转化回视频的例程&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/marcoscoffier/torch-saliency&quot;&gt;saliency&lt;/a&gt; —积分图像的代码和工具，用来从快速积分直方图中寻找兴趣点。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/marcoscoffier/lua---stitch&quot;&gt;stitch&lt;/a&gt; —使用hugin拼合图像并将其生成视频序列。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/marcoscoffier/lua---sfm&quot;&gt;sfm&lt;/a&gt;—运动场景束调整/结构包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/koraykv/fex&quot;&gt;fex&lt;/a&gt; —torch的特征提取包，提供SIFT和dSIFT模块。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/sermanet/OverFeat&quot;&gt;OverFeat&lt;/a&gt;—当前最高水准的通用密度特征提取器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://numlua.luaforge.net/&quot;&gt;Numeric Lua&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://labix.org/lunatic-python&quot;&gt;Lunatic Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.scilua.org/&quot;&gt;SciLua&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bitbucket.org/lucashnegri/lna&quot;&gt;Lua – Numerical Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zrake.webfactional.com/projects/lunum&quot;&gt;Lunum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#demos-and-scripts&quot; name=&quot;user-content-demos-and-scripts&quot;&gt;&lt;/a&gt;演示及脚本&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/e-lab/torch7-demos&quot;&gt;Core torch7 demos repository&lt;/a&gt;.核心torch7演示程序库
&lt;ul&gt;
&lt;li&gt;线性回归、逻辑回归&lt;/li&gt;
&lt;li&gt;人脸检测（训练和检测是独立的演示）&lt;/li&gt;
&lt;li&gt;基于mst的断词器&lt;/li&gt;
&lt;li&gt;train-a-digit-classifier&lt;/li&gt;
&lt;li&gt;train-autoencoder&lt;/li&gt;
&lt;li&gt;optical flow demo&lt;/li&gt;
&lt;li&gt;train-on-housenumbers&lt;/li&gt;
&lt;li&gt;train-on-cifar&lt;/li&gt;
&lt;li&gt;tracking with deep nets&lt;/li&gt;
&lt;li&gt;kinect demo&lt;/li&gt;
&lt;li&gt;滤波可视化&lt;/li&gt;
&lt;li&gt;saliency-networks&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/soumith/galaxyzoo&quot;&gt;Training a Convnet for the Galaxy-Zoo Kaggle challenge(CUDA demo)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mbhenaff/MusicTagging&quot;&gt;Music Tagging&lt;/a&gt;—torch7下的音乐标签脚本&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/rosejn/torch-datasets&quot;&gt;torch-datasets&lt;/a&gt; 读取几个流行的数据集的脚本，包括：
&lt;ul&gt;
&lt;li&gt;BSR 500&lt;/li&gt;
&lt;li&gt;CIFAR-10&lt;/li&gt;
&lt;li&gt;COIL&lt;/li&gt;
&lt;li&gt;Street View House Numbers&lt;/li&gt;
&lt;li&gt;MNIST&lt;/li&gt;
&lt;li&gt;NORB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fidlej/aledataset&quot;&gt;Atari2600&lt;/a&gt; —在Arcade Learning Environment模拟器中用静态帧生成数据集的脚本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Matlab&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#computer-vision&quot; name=&quot;user-content-computer-vision&quot;&gt;&lt;/a&gt;计算机视觉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.ifp.illinois.edu/~minhdo/software/contourlet_toolbox.tar&quot;&gt;Contourlets&lt;/a&gt; —实现轮廓波变换及其使用函数的MATLAB源代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.shearlab.org/index_software.html&quot;&gt;Shearlets&lt;/a&gt;—剪切波变换的MATLAB源码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.curvelet.org/software.html&quot;&gt;Curvelets&lt;/a&gt;—Curvelet变换的MATLAB源码（Curvelet变换是对小波变换向更高维的推广，用来在不同尺度角度表示图像。）&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.cmap.polytechnique.fr/~peyre/download/&quot;&gt;Bandlets&lt;/a&gt;—Bandlets变换的MATLAB源码&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-4&quot; name=&quot;user-content-natural-language-processing-4&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://amplab.cs.berkeley.edu/2012/05/05/an-nlp-library-for-matlab/&quot;&gt;NLP&lt;/a&gt; —一个Matlab的NLP库&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-6&quot; name=&quot;user-content-general-purpose-machine-learning-6&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.cs.toronto.edu/~hinton/MatlabForSciencePaper.html&quot;&gt;Training a deep autoencoder or a classifier on MNIST digits&lt;/a&gt;—在MNIST字符数据集上训练一个深度的autoencoder或分类器[深度学习]。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://homepage.tudelft.nl/19j49/t-SNE.html&quot;&gt;t-Distributed Stochastic Neighbor Embedding&lt;/a&gt; —获奖的降维技术，特别适合于高维数据集的可视化&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://people.kyb.tuebingen.mpg.de/spider/&quot;&gt;Spider&lt;/a&gt;—Matlab机器学习的完整面向对象环境。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.csie.ntu.edu.tw/~cjlin/libsvm/#matlab&quot;&gt;LibSVM&lt;/a&gt; —支持向量机程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.csie.ntu.edu.tw/~cjlin/liblinear/#download&quot;&gt;LibLinear&lt;/a&gt; —大型线性分类程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/josephmisiti/machine-learning-module&quot;&gt;Machine Learning Module&lt;/a&gt; —M. A .Girolami教授的机器学习课程，包括PDF，讲义及代码。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://caffe.berkeleyvision.org/&quot;&gt;Caffe&lt;/a&gt;—考虑了代码清洁、可读性及速度的深度学习框架&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/newfolder/PRT&quot;&gt;Pattern Recognition Toolbox&lt;/a&gt; —Matlab中的模式识别工具包，完全面向对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 16px; font-style: normal; font-weight: bold;&quot;&gt;数据分析/数据可视化&lt;/span&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-4&quot; name=&quot;user-content-data-analysis--data-visualization-4&quot;&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://www.cs.purdue.edu/homes/dgleich/packages/matlab_bgl/&quot;&gt;matlab_gbl&lt;/a&gt;—处理图像的Matlab包&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.mathworks.com/matlabcentral/fileexchange/24134-gaimc---graph-algorithms-in-matlab-code&quot;&gt;gamic&lt;/a&gt;—图像算法纯Matlab高效实现，对MatlabBGL的mex函数是个补充。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#python&quot; name=&quot;user-content-python&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;.NET&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#computer-vision-3&quot; name=&quot;user-content-computer-vision-3&quot;&gt;&lt;/a&gt;计算机视觉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://code.google.com/p/opencvdotnet/&quot;&gt;OpenCVDotNet&lt;/a&gt; —包装器，使.NET程序能使用OpenCV代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.emgu.com/wiki/index.php/Main_Page&quot;&gt;Emgu CV&lt;/a&gt;—跨平台的包装器，能在Windows, Linus, Mac OS X, iOS, 和Android上编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#natural-language-processing-6&quot; name=&quot;user-content-natural-language-processing-6&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/sergey-tihon/Stanford.NLP.NET/&quot;&gt;Stanford.NLP for .NET&lt;/a&gt; —斯坦福大学NLP包在.NET上的完全移植，还可作为NuGet包进行预编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#general-purpose-machine-learning-9&quot; name=&quot;user-content-general-purpose-machine-learning-9&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nuget.org/packages/Accord.MachineLearning/&quot;&gt;Accord.MachineLearning&lt;/a&gt; —支持向量机、决策树、朴素贝叶斯模型、K-means、高斯混合模型和机器学习应用的通用算法，例如：随机抽样一致性算法、交叉验证、网格搜索。这个包是Accord.NET框架的一部分。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fsprojects/Vulpes&quot;&gt;Vulpes&lt;/a&gt;—F#语言实现的Deep belief和深度学习包，它在Alea.cuBase下利用CUDA GPU来执行。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nuget.org/packages/encog-dotnet-core/&quot;&gt;Encog&lt;/a&gt; —先进的神经网络和机器学习框架，包括用来创建多种网络的类，也支持神经网络需要的数据规则化及处理的类。它的训练采用多线程弹性传播。它也能使用GPU加快处理时间。提供了图形化界面来帮助建模和训练神经网络。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://bragisoft.com/&quot;&gt;Neural Network Designer&lt;/a&gt; —这是一个数据库管理系统和神经网络设计器。设计器用WPF开发，也是一个UI，你可以设计你的神经网络、查询网络、创建并配置聊天机器人，它能问问题，并从你的反馈中学习。这些机器人甚至可以从网络搜集信息用来输出，或是用来学习。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning#data-analysis--data-visualization-6&quot; name=&quot;user-content-data-analysis--data-visualization-6&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nuget.org/packages/numl/&quot;&gt;numl&lt;/a&gt; —numl这个机器学习库，目标就是简化预测和聚类的标准建模技术。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nuget.org/packages/MathNet.Numerics/&quot;&gt;Math.NET Numerics&lt;/a&gt;—Math.NET项目的数值计算基础，着眼提供科学、工程以及日常数值计算的方法和算法。支持 Windows, Linux 和 Mac上的 .Net 4.0, .Net 3.5 和 Mono ，Silverlight 5, WindowsPhone/SL 8, WindowsPhone 8.1 以及装有 PCL Portable Profiles 47 及 344的Windows 8， 装有 Xamarin的Android/iOS 。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://research.microsoft.com/en-us/projects/sho/&quot;&gt;Sho&lt;/a&gt; —Sho是数据分析和科学计算的交互式环境，可以让你将脚本（IronPython语言）和编译的代码（.NET）无缝连接，以快速灵活的建立原型。这个环境包括强大高效的库，如线性代数、数据可视化，可供任何.NET语言使用，还为快速开发提供了功能丰富的交互式shell。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Python&lt;/h2&gt;
&lt;h4&gt;计算机视觉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://simplecv.org/&quot;&gt;SimpleCV&lt;/a&gt;—开源的计算机视觉框架，可以访问如OpenCV等高性能计算机视觉库。使用Python编写，可以在Mac、Windows以及Ubuntu上运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-5&quot; name=&quot;user-content-natural-language-processing-5&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.nltk.org/&quot;&gt;NLTK&lt;/a&gt; —一个领先的平台，用来编写处理人类语言数据的Python程序&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.clips.ua.ac.be/pattern&quot;&gt;Pattern&lt;/a&gt;—Python可用的web挖掘模块，包括自然语言处理、机器学习等工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://textblob.readthedocs.org/&quot;&gt;TextBlob&lt;/a&gt;—为普通自然语言处理任务提供一致的API，以NLTK和Pattern为基础，并和两者都能很好兼容。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fxsjy/jieba#jieba-1&quot;&gt;jieba&lt;/a&gt;—中文断词工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/isnowfy/snownlp&quot;&gt;SnowNLP&lt;/a&gt; —中文文本处理库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/victorlin/loso&quot;&gt;loso&lt;/a&gt;—另一个中文断词库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/duanhongyi/genius&quot;&gt;genius&lt;/a&gt; —基于条件随机域的中文断词库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/pprett/nut&quot;&gt;nut&lt;/a&gt; —自然语言理解工具包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-7&quot; name=&quot;user-content-general-purpose-machine-learning-7&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers&quot;&gt;Bayesian Methods for Hackers&lt;/a&gt; —Python语言概率规划的电子书&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://spark.apache.org/docs/latest/mllib-guide.html&quot;&gt;MLlib in Apache Spark&lt;/a&gt;—Spark下的分布式机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://scikit-learn.org/&quot;&gt;scikit-learn&lt;/a&gt;—基于SciPy的机器学习模块&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://graphlab.com/products/create/docs/&quot;&gt;graphlab-create&lt;/a&gt; —包含多种机器学习模块的库（回归，聚类，推荐系统，图分析等），基于可以磁盘存储的DataFrame。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://bigml.com/&quot;&gt;BigML&lt;/a&gt;—连接外部服务器的库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/clips/pattern&quot;&gt;pattern&lt;/a&gt;—Python的web挖掘模块&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/numenta/nupic&quot;&gt;NuPIC&lt;/a&gt;—Numenta公司的智能计算平台。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/lisa-lab/pylearn2&quot;&gt;Pylearn2&lt;/a&gt;—基于Theano的机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/hannes-brt/hebel&quot;&gt;hebel&lt;/a&gt; —Python编写的使用GPU加速的深度学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/piskvorky/gensim&quot;&gt;gensim&lt;/a&gt;—主题建模工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/pybrain/pybrain&quot;&gt;PyBrain&lt;/a&gt;—另一个机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/muricoca/crab&quot;&gt;Crab&lt;/a&gt; —可扩展的、快速推荐引擎。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ocelma/python-recsys&quot;&gt;python-recsys&lt;/a&gt; —Python实现的推荐系统。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/AllenDowney/ThinkBayes&quot;&gt;thinking bayes&lt;/a&gt;—关于贝叶斯分析的书籍&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/echen/restricted-boltzmann-machines&quot;&gt;Restricted Boltzmann Machines&lt;/a&gt; —Python实现的受限波尔兹曼机。[深度学习]。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/pprett/bolt&quot;&gt;Bolt&lt;/a&gt; —在线学习工具箱。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/patvarilly/CoverTree&quot;&gt;CoverTree&lt;/a&gt; —cover tree的Python实现，scipy.spatial.kdtree便捷的替代。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/nilearn/nilearn&quot;&gt;nilearn&lt;/a&gt;—Python实现的神经影像学机器学习库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/shogun-toolbox/shogun&quot;&gt;Shogun&lt;/a&gt;—机器学习工具箱。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/perone/Pyevolve&quot;&gt;Pyevolve&lt;/a&gt; —遗传算法框架。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://caffe.berkeleyvision.org/&quot;&gt;Caffe&lt;/a&gt; —考虑了代码清洁、可读性及速度的深度学习框架&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/breze-no-salt/breze&quot;&gt;breze&lt;/a&gt;—深度及递归神经网络的程序库，基于Theano。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-5&quot; name=&quot;user-content-data-analysis--data-visualization-5&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt; —基于Python的数学、科学、工程开源软件生态系统。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt;—Python科学计算基础包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://numba.pydata.org/&quot;&gt;Numba&lt;/a&gt; —Python的低级虚拟机JIT编译器，Cython and NumPy的开发者编写，供科学计算使用&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://networkx.github.io/&quot;&gt;NetworkX&lt;/a&gt; —为复杂网络使用的高效软件。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://pandas.pydata.org/&quot;&gt;Pandas&lt;/a&gt;—这个库提供了高性能、易用的数据结构及数据分析工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/avelino/mining&quot;&gt;Open Mining&lt;/a&gt;—Python中的商业智能工具（Pandas web接口）。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/pymc-devs/pymc&quot;&gt;PyMC&lt;/a&gt; —MCMC采样工具包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/quantopian/zipline&quot;&gt;zipline&lt;/a&gt;—Python的算法交易库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://pydy.org/&quot;&gt;PyDy&lt;/a&gt;—全名Python Dynamics，协助基于NumPy, SciPy, IPython以及 matplotlib的动态建模工作流。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/sympy/sympy&quot;&gt;SymPy&lt;/a&gt; —符号数学Python库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/statsmodels/statsmodels&quot;&gt;statsmodels&lt;/a&gt;—Python的统计建模及计量经济学库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.astropy.org/&quot;&gt;astropy&lt;/a&gt; —Python天文学程序库，社区协作编写&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; —Python的2D绘图库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ContinuumIO/bokeh&quot;&gt;bokeh&lt;/a&gt;—Python的交互式Web绘图库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://plot.ly/python&quot;&gt;plotly&lt;/a&gt; —Python and matplotlib的协作web绘图库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/wrobstory/vincent&quot;&gt;vincent&lt;/a&gt;—将Python数据结构转换为Vega可视化语法。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mikedewar/d3py&quot;&gt;d3py&lt;/a&gt;—Python的绘图库，基于D3.js。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/yhat/ggplot&quot;&gt;ggplot&lt;/a&gt; —和R语言里的ggplot2提供同样的API。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/kartograph/kartograph.py&quot;&gt;Kartograph.py&lt;/a&gt;—Python中渲染SVG图的库，效果漂亮。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://pygal.org/&quot;&gt;pygal&lt;/a&gt;—Python下的SVG图表生成器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/twitter/pycascading&quot;&gt;pycascading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;杂项脚本/iPython笔记/代码库&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#misc-scripts--ipython-notebooks--codebases&quot; name=&quot;user-content-misc-scripts--ipython-notebooks--codebases&quot;&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rasbt/pattern_classification&quot;&gt;pattern_classification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Wavelets/ThinkStats2&quot;&gt;thinking stats 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hyperopt/hyperopt-sklearn&quot;&gt;hyperopt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/numenta/nupic&quot;&gt;numpic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ged-lab/2012-paper-diginorm&quot;&gt;2012-paper-diginorm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ogrisel/notebooks&quot;&gt;ipython-notebooks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CamDavidsonPilon/decision-weights&quot;&gt;decision-weights&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/Wavelets/sarah-palin-lda&quot;&gt;Sarah Palin LDA&lt;/a&gt; —Sarah Palin关于主题建模的电邮。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/Wavelets/diffusion-segmentation&quot;&gt;Diffusion Segmentation&lt;/a&gt; —基于扩散方法的图像分割算法集合。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/Wavelets/scipy-tutorials&quot;&gt;Scipy Tutorials&lt;/a&gt; —SciPy教程，已过时，请查看scipy-lecture-notes&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/marcelcaraciolo/crab&quot;&gt;Crab&lt;/a&gt;—Python的推荐引擎库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/maxsklar/BayesPy&quot;&gt;BayesPy&lt;/a&gt;—Python中的贝叶斯推断工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/GaelVaroquaux/scikit-learn-tutorial&quot;&gt;scikit-learn tutorials&lt;/a&gt;—scikit-learn学习笔记系列&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/madhusudancs/sentiment-analyzer&quot;&gt;sentiment-analyzer&lt;/a&gt; —推特情绪分析器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/fabianp/group_lasso&quot;&gt;group-lasso&lt;/a&gt;—坐标下降算法实验，应用于（稀疏）群套索模型。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mne-tools/mne-python-notebooks&quot;&gt;mne-python-notebooks&lt;/a&gt;—使用 mne-python进行EEG/MEG数据处理的IPython笔记&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/jvns/pandas-cookbook&quot;&gt;pandas cookbook&lt;/a&gt;—使用Python pandas库的方法书。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/BRML/climin&quot;&gt;climin&lt;/a&gt;—机器学习的优化程序库，用Python实现了梯度下降、LBFGS、rmsprop、adadelta 等算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#kaggle-competition-source-code&quot; name=&quot;user-content-kaggle-competition-source-code&quot;&gt;&lt;/a&gt;Kaggle竞赛源代码&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/hammer/wikichallenge&quot;&gt;wiki challange&lt;/a&gt; —Kaggle上一个维基预测挑战赛 Dell Zhang解法的实现。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/amueller/kaggle_insults&quot;&gt;kaggle insults&lt;/a&gt;—Kaggle上”从社交媒体评论中检测辱骂“竞赛提交的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/MLWave/kaggle_acquire-valued-shoppers-challenge&quot;&gt;kaggle_acquire-valued-shoppers-challenge&lt;/a&gt;—Kaggle预测回头客挑战赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-cifar&quot;&gt;kaggle-cifar&lt;/a&gt; —Kaggle上CIFAR-10 竞赛的代码，使用cuda-convnet&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-blackbox&quot;&gt;kaggle-blackbox&lt;/a&gt; —Kaggle上blackbox赛代码，关于深度学习。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-accelerometer&quot;&gt;kaggle-accelerometer&lt;/a&gt; —Kaggle上加速度计数据识别用户竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-advertised-salaries&quot;&gt;kaggle-advertised-salaries&lt;/a&gt; —Kaggle上用广告预测工资竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-amazon&quot;&gt;kaggle amazon&lt;/a&gt; —Kaggle上给定员工角色预测其访问需求竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-bestbuy_big&quot;&gt;kaggle-bestbuy_big&lt;/a&gt;—Kaggle上根据bestbuy用户查询预测点击商品竞赛的代码（大数据版）&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-bestbuy_small&quot;&gt;kaggle-bestbuy_small&lt;/a&gt;—Kaggle上根据bestbuy用户查询预测点击商品竞赛的代码（小数据版）&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/kastnerkyle/kaggle-dogs-vs-cats&quot;&gt;Kaggle Dogs vs. Cats&lt;/a&gt; —Kaggle上从图片中识别猫和狗竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/benanne/kaggle-galaxies&quot;&gt;Kaggle Galaxy Challenge&lt;/a&gt; —Kaggle上遥远星系形态分类竞赛的优胜代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-gender&quot;&gt;Kaggle Gender&lt;/a&gt; —Kaggle竞赛：从笔迹区分性别&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-merck&quot;&gt;Kaggle Merck&lt;/a&gt;—Kaggle上预测药物分子活性竞赛的代码（默克制药赞助）&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/kaggle-stackoverflow&quot;&gt;Kaggle Stackoverflow&lt;/a&gt;—Kaggle上 预测Stack Overflow网站问题是否会被关闭竞赛的代码&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zygmuntz/wine-quality&quot;&gt;wine-quality&lt;/a&gt; —预测红酒质量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#ruby&quot; name=&quot;user-content-ruby&quot;&gt;&lt;/a&gt;Ruby&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-6&quot; name=&quot;user-content-natural-language-processing-6&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/louismullie/treat&quot;&gt;Treat&lt;/a&gt;—文本检索与注释工具包，Ruby上我见过的最全面的工具包。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.deveiate.org/projects/Linguistics/&quot;&gt;Ruby Linguistics&lt;/a&gt;—这个框架可以用任何语言为Ruby对象构建语言学工具。包括一个语言无关的通用前端，一个将语言代码映射到语言名的模块，和一个含有很有英文语言工具的模块。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/aurelian/ruby-stemmer&quot;&gt;Stemmer&lt;/a&gt;—使得Ruby可用 libstemmer_c中的接口。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.deveiate.org/projects/Ruby-WordNet/&quot;&gt;Ruby Wordnet&lt;/a&gt; —WordNet的Ruby接口库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://sourceforge.net/projects/raspell/&quot;&gt;Raspel&lt;/a&gt; —aspell绑定到Ruby的接口&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ealdent/uea-stemmer&quot;&gt;UEA Stemmer&lt;/a&gt;—UEALite Stemmer的Ruby移植版，供搜索和检索用的保守的词干分析器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/twitter-text-rb&quot;&gt;Twitter-text-rb&lt;/a&gt;—该程序库可以将推特中的用户名、列表和话题标签自动连接并提取出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-8&quot; name=&quot;user-content-general-purpose-machine-learning-8&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tsycho/ruby-machine-learning&quot;&gt;Ruby Machine Learning&lt;/a&gt; —Ruby实现的一些机器学习算法。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mizoR/machine-learning-ruby&quot;&gt;Machine Learning Ruby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/vasinov/jruby_mahout&quot;&gt;jRuby Mahout&lt;/a&gt; —精华！在JRuby世界中释放了Apache Mahout的威力。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/cardmagic/classifier&quot;&gt;CardMagic-Classifier&lt;/a&gt;—可用贝叶斯及其他分类法的通用分类器模块。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/mnielsen/neural-networks-and-deep-learning&quot;&gt;Neural Networks and Deep Learning&lt;/a&gt;—《神经网络和深度学习》一书的示例代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数据分析/数据可视化&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-6&quot; name=&quot;user-content-data-analysis--data-visualization-6&quot;&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/alexgutteridge/rsruby&quot;&gt;rsruby&lt;/a&gt; - Ruby – R bridge&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/chrislo/data_visualisation_ruby&quot;&gt;data-visualization-ruby&lt;/a&gt;—关于数据可视化的Ruby Manor演示的源代码和支持内容&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://www.ruby-toolbox.com/projects/ruby-plot&quot;&gt;ruby-plot&lt;/a&gt; —将gnuplot包装为Ruby形式，特别适合将ROC曲线转化为svg文件。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/zuhao/plotrb&quot;&gt;plot-rb&lt;/a&gt;—基于Vega和D3的ruby绘图库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.rubyinside.com/scruffy-a-beautiful-graphing-toolkit-for-ruby-194.html&quot;&gt;scruffy&lt;/a&gt; —Ruby下出色的图形工具包&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sciruby.com/&quot;&gt;SciRuby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/glean/glean&quot;&gt;Glean&lt;/a&gt;—数据管理工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/bioruby/bioruby&quot;&gt;Bioruby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/nkallen/arel&quot;&gt;Arel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#misc&quot; name=&quot;user-content-misc&quot;&gt;&lt;/a&gt;Misc&lt;br&gt;
杂项&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/infochimps-labs/big_data_for_chimps&quot;&gt;Big Data For Chimps&lt;/a&gt;—大数据处理严肃而有趣的指南书&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#r&quot; name=&quot;user-content-r&quot;&gt;&lt;/a&gt;R&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-9&quot; name=&quot;user-content-general-purpose-machine-learning-9&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jbrownlee/CleverAlgorithmsMachineLearning&quot;&gt;Clever Algorithms For Machine Learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/johnmyleswhite/ML_for_Hackers&quot;&gt;Machine Learning For Hackers&lt;br&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://cran.r-project.org/web/views/MachineLearning.html&quot;&gt;Machine Learning Task View on CRAN&lt;/a&gt;—R语言机器学习包列表，按算法类型分组。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://caret.r-forge.r-project.org/&quot;&gt;caret&lt;/a&gt;—R语言150个机器学习算法的统一接口&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/ecpolley/SuperLearner&quot;&gt;SuperLearner&lt;/a&gt; and &lt;a href=&quot;http://cran.r-project.org/web/packages/subsemble/index.html&quot;&gt;subsemble&lt;/a&gt;—该包集合了多种机器学习算法&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www-bcf.usc.edu/~gareth/ISL/&quot;&gt;Introduction to Statistical Learning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-7&quot; name=&quot;user-content-data-analysis--data-visualization-7&quot;&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;h4&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://health.adelaide.edu.au/psychology/ccs/teaching/lsr/&quot;&gt;Learning Statistics Using R&lt;br&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;http://ggplot2.org/&quot;&gt;ggplot2&lt;/a&gt;—基于图形语法的数据可视化包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#scala&quot; name=&quot;user-content-scala&quot;&gt;&lt;/a&gt;Scala&lt;/h2&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#natural-language-processing-7&quot; name=&quot;user-content-natural-language-processing-7&quot;&gt;&lt;/a&gt;自然语言处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://www.scalanlp.org/&quot;&gt;ScalaNLP&lt;/a&gt;—机器学习和数值计算库的套装&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/scalanlp/breeze&quot;&gt;Breeze&lt;/a&gt; —Scala用的数值处理库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/scalanlp/chalk&quot;&gt;Chalk&lt;/a&gt;—自然语言处理库。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/factorie/factorie&quot;&gt;FACTORIE&lt;/a&gt;—可部署的概率建模工具包，用Scala实现的软件库。为用户提供简洁的语言来创建关系因素图，评估参数并进行推断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#data-analysis--data-visualization-8&quot; name=&quot;user-content-data-analysis--data-visualization-8&quot;&gt;&lt;/a&gt;数据分析/数据可视化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;http://spark.apache.org/docs/latest/mllib-guide.html&quot;&gt;MLlib in Apache Spark&lt;/a&gt;—Spark下的分布式机器学习库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/scalding&quot;&gt;Scalding&lt;/a&gt; —CAscading的Scala接口&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/summingbird&quot;&gt;Summing Bird&lt;/a&gt;—用Scalding 和 Storm进行Streaming MapReduce&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/twitter/algebird&quot;&gt;Algebird&lt;/a&gt; —Scala的抽象代数工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/xerial/xerial&quot;&gt;xerial&lt;/a&gt; —Scala的数据管理工具&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/avibryant/simmer&quot;&gt;simmer&lt;/a&gt; —化简你的数据，进行代数聚合的unix过滤器&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/PredictionIO/PredictionIO&quot;&gt;PredictionIO&lt;/a&gt; —供软件开发者和数据工程师用的机器学习服务器。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/BIDData/BIDMat&quot;&gt;BIDMat&lt;/a&gt;—支持大规模探索性数据分析的CPU和GPU加速矩阵库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;
&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#general-purpose-machine-learning-10&quot; name=&quot;user-content-general-purpose-machine-learning-10&quot;&gt;&lt;/a&gt;通用机器学习&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/etsy/Conjecture&quot;&gt;Conjecture&lt;/a&gt;—Scalding下可扩展的机器学习框架&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/avibryant/brushfire&quot;&gt;brushfire&lt;/a&gt;—scalding下的决策树工具。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/tresata/ganitha&quot;&gt;ganitha&lt;/a&gt; —基于scalding的机器学习程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/bigdatagenomics/adam&quot;&gt;adam&lt;/a&gt;—使用Apache Avro, Apache Spark 和 Parquet的基因组处理引擎，有专用的文件格式，Apache 2软件许可。&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/bioscala/bioscala&quot;&gt;bioscala&lt;/a&gt; —Scala语言可用的生物信息学程序库&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.com/BIDData/BIDMach&quot;&gt;BIDMach&lt;/a&gt;—机器学习CPU和GPU加速库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/README.md#credits&quot; name=&quot;user-content-credits&quot;&gt;&lt;/a&gt;&lt;/h2&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Mon, 21 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-21-73806-f8e20413f.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-21-73806-f8e20413f.html</guid>
        
        
      </item>
    
      <item>
        <title>技术的进化</title>
        <description>&lt;p&gt;前几日，吴军博士在微博上转发了王石为其新书《文明之光》写的序言。在序言里，王石提到了达尔文进化论在社会与技术的适应性问题。王石在他短短几句话里并未充分说明了他的观点，只是举了英文键盘的例子说明了&lt;strong&gt;存活下来的不一定更“好”，仅仅是更“适”而已&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我在微博上留下了一条评论：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;生物突变过程，并不一定是适合文明尤其是技术的进化的，好比如从帆船不可能突变到轮船，喷气机也不是内燃机或其它任何先前技术的变种，技术的进化更多是组合进化不太具有偶然性，而不是生物的单物种偶然性突变。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;用达尔文的理论去解释不同领域的演进,是许多人的偏好，尤其是国人。但是，无论觉得达尔文理论能如何为你切身地解答从哪而来的问题，将它放置于任何领域成为“大一统”的进化观点，我想是不合适的，至少将其置于技术的领域，是不完整的。尽管吴军博士回复说，《文明之光》一书并没有太谈进化论，我还是想把我的观点讲清楚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一.不完整的进化论理解&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;达尔文的生物进化理论需要从两个方面来理解：&lt;strong&gt;变异与选择&lt;/strong&gt;。由于某些历史与政治的原因，进化论被引进进入中国时，就被严复梁启超他们“阉割”了，只片面的强调了“选择”一含义，这也就是大多数人固有的“物竞天择，适者生存”的观点，而对其“变异”层面的含义却知之甚少。由于“进化就是选择”这一狭隘观点的影响，导致达尔文的理论被”泛滥“地解释所有的领域的发展，因为单从“选择”层面来看，其确实是适合其它领域的。当然，用来解释社会发展领域的发展，也是当初严复和梁启超他们原本目的。&lt;/p&gt;

&lt;p&gt;如果说“进化就是选择”，那前面王石先生举的英文键盘一例来说进化，也是合理的（其实这也就是常说的”路径依赖“）。但是这样的观点如果奉成为“理论”，肯定是不完整的。选择论回答不了被选择的“物件”从何而来的疑问。而完整的达尔文理论认为&lt;strong&gt;变异为选择提供了资源&lt;/strong&gt;。如果说”选择“解答了发展的问题，那”变异“则解答了起源的问题。在生物的进化上，这里的变异指的就是基因突变，并且是单个物种内的自身基因变化。&lt;/p&gt;

&lt;p&gt;正是这种关乎基因突变的观点，将达尔文理论套到技术领域，是根本站不住脚的。比如雷达诞生于半导体，你可以对20世纪30年代的半导体线圈进行任何你喜欢的改变，但是你永远不可能得到雷达，制造雷达需要一个和半导体完全不同的理念。我前文微博里提到的帆船到轮船，喷气机到内燃机的也同样如此，无论你对帆船如何改造，没有革命性发动机出现，你不可能得到轮船，而发动机的出现，跟”船“这个”物种“不存在任何关系。而从喷气机到内燃机，也不是一脉的向前突变得到的，而是依赖完全不同的物理理论的出现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二.技术进化的特点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;那么技术领域的究竟如何向前进化的呢？技术作家布莱恩.阿瑟在其《技术的本质》一书里给出了一个初步的答案。布莱恩.阿瑟认为技术的进化具有以下两大特点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组合进化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;技术总是由一些基本的功能模块组合而成的&lt;/strong&gt;。技术的组合进化，是技术演变的最本质特征，也是其不同与生物进化的根本区别。&lt;/p&gt;

&lt;p&gt;在人类发展最初的石器时代，石制工具就被打磨成两类，锋利的和有孔的，这两类又与木制的手柄组合成复合工具，锋利的成了矛，有孔的成了锤头。回到现代，你打开一台老式的台式电脑，你会发现里面的零部件，如CPU，硬盘，内存条等。同时拆开一台现代的智能手机，也会发生同样的部件。同样，蒸汽机的出现，其与原来的帆船技术的组合，从而使得轮船得以出现服务于人类。&lt;strong&gt;技术在某种程度上一定是来自此前已有技术的新的组合&lt;/strong&gt;，这是新技术出现的根本特征，也解答了进化论中关于”变异“那一部分问题。而这个组合进化产生变异的特征在生物体上是看不到的，生物的变异是指单个生物体的基因突变，而不同物种相互组合杂交而进化，几乎没出现过。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;具有层级递归性模块化演进&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;技术是组合进化的，但是其不是单纯的一层组合，也就是说不是将具有匹配的概念或原理的目的单层次的聚集起来，即可得到新的技术。其组合具有层次结构。可以将技术分解成主集成，次级集成，次次级集成等，直至分解为最基本的部分。如果说整体的技术是树干的话，那次级集成是枝条，最基本的零件就是更小的分支了。以一本纸质书为例，其主集成是纸张和印刷的组合，而纸张和印刷两者可以继续拆分，如印刷可以拆分为油墨技术，电子技术等等。&lt;strong&gt;技术呈现出这种递归性的结构，技术总是包含着技术，直到最基础的水平&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果只是将技术的单元进行层次化的组合，那将是一个无比复杂的工程。比如一个手表有1000个零件，一个钟表匠一个零件一个零件地安装，安装过程中，如果他的工作被打断了，他就必须从头开始。但是，如果将10个模块组装起来，每个模块又由10个子模块组装起来，每个子模块由10个零件组合起来，当他暂停或被打断工作时，他只是损失了一小部分工作。这种零件集成可以更好地预防不可预知的变动，且更易修复。同时，除了解决复杂性的带来的低效问题，模块化更为重要的一点是允许技术的组成部分分别演进，从而又再推动整体技术的前进。好比如发动机的这一模块的进步，可以推动汽车，轮船这些整体技术的进步一样。&lt;/p&gt;

&lt;p&gt;当然，将技术分割为功能模块是需要付出一些代价的，比如需要耗费时间和精力定义模块之间的标准等。所以，&lt;strong&gt;只有模块能被反复使用，且反复使用的次数足够时，才值得付出代价将技术进行分割&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三.技术进化的启示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面关于技术进化的特点的讨论，不只是让我们认识了技术进化的与生物进化的区别，更是能更好的指导我们构建更有生命力能向前进化的技术产品。回到我们熟悉的软件系统领域，我们见过太多技术产品被很快淘汰，也见过很多技术产品永远处于不断推倒后重构的死胡同里。从进化的角度看，这样的技术产品根本不存在进化的可能。这其中根本原因，我想更多是其没有满足我们前文说到的可进化技术的一些基本特点。一个没有组合特点的系统，其必然扩展性差，必然面临无法向前进一步进化的可能。而没有定义层次和规则，那也就没有模块化的概念，系统无法进行单个模块的垂直演进，没有模块级别的重用， 当碰到任何不可预知的变动，必然是全部推倒重新再来。这样的系统产品，当然也就不存在生命力可言。&lt;/p&gt;

&lt;p&gt;对此审视我们用过的系统产品，那些经久不衰的，如Unix/Linux，必然是遵循这技术进化的根本特征的。而对于当今互联网产品而言，生命力确实是一个奢侈的词，这应该不仅仅是生态环境的选择问题,而需要系统产品生产者更多的反思！&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;如果您觉得这篇文字有意思，欢迎转发！欢迎更多的朋友们关注我的微信公众号：&lt;strong&gt;JustinNotes&lt;/strong&gt;&lt;/p&gt;

&lt;hr&gt;
</description>
        <pubDate>Sun, 20 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-20-ji-zhu-de-jin-hua-9c5e0c611.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-20-ji-zhu-de-jin-hua-9c5e0c611.html</guid>
        
        
      </item>
    
      <item>
        <title>Chef入门（一）</title>
        <description>

	
	

	&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/a21eddb15b6ddbe9e395938fd299dee1.jpg&quot; title=&quot;Chef&quot; alt=&quot;Chef&quot;&gt;&lt;/p&gt;

&lt;h1&gt;Chef是什么&lt;/h1&gt;

&lt;p&gt;官方的介绍是这样的：&lt;code&gt;Automation for Web-Scale IT.Chef delivers fast, scalable, flexible IT automation.&lt;/code&gt;简单来说Chef就是IT自动化工具，它把服务器的环境（软件、依赖库、网络等）进行抽象，以特有的配置语法（Ruby语言）对其进行管理，可以自动的进行服务器环境的初始化工作。Chef也是实践&lt;a href=&quot;http://www.infoq.com/cn/articles/devops-not-legend/&quot;&gt;DevOps&lt;/a&gt;和&lt;a href=&quot;http://martinfowler.com/articles/continuousIntegration.html&quot;&gt;Continuous Integration&lt;/a&gt;的重要工具，同类的工具还有&lt;a href=&quot;http://puppetlabs.com/&quot;&gt;puppet&lt;/a&gt;。&lt;/p&gt;

&lt;h1&gt;为什么需要Chef&lt;/h1&gt;

&lt;p&gt;Web开发者肯定对以下的情景熟悉：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新开发的功能在开发环境运行得很好，可是一部署到生产环境就出错了，登录到服务器上一看，我靠，少个lib没装 = =&lt;/li&gt;
&lt;li&gt;很多人入职一家新公司首先做的事情就是配环境，这个工作比较浪费时间，经常是缺这个库缺那个库，还有很多未知的坑，即使有完整的文档，手动的安装也是比较反人类的。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;以上的问题总结为一句话就是环境管理的混乱，或者说根本没有环境管理。环境管理可能是个不那么太引起开发者重视的一项事情，许多人对环境的要求只是能够跑起来，不管通过什么自虐的方式配置起来都没有问题，如果生产环境发生了变更，而开发环境没有及时变更，那么只能骂娘。其实环境管理和代码的版本控制是一样的重要，你能想象没有版本控制的开发方式吗？有人会说：我照着文档手动配置环境也很快，也不会出错啊。如果这样那么你可以关闭当前网页了。&lt;/p&gt;

&lt;p&gt;Chef基本上做两件事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境管理&lt;/li&gt;
&lt;li&gt;以自动化的方式进行服务器环境初始化或变更工作&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Chef环境&lt;/h1&gt;

&lt;p&gt;Chef环境由三个部分组成：Chef server，Workstation, Node（此Node非Node.js）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Chef server是Chef环境的中枢，其中存储了基础设施环境的信息。你可以使用&lt;a href=&quot;http://www.getchef.com/chef/install/&quot;&gt;开源Chef server&lt;/a&gt;，也可以使用Chef官方提供的商业服务：&lt;a href=&quot;http://www.getchef.com/contact/on-premises/&quot;&gt;Enterprise Chef&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Workstation是你的工作台，一般情况下就是你的开发机器。你会在Workstation中创建cookbook，并且上传到Chef server，以及其他与Chef相关的工作。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个Node就是你基础设施环境中的一台服务器，也就是你用Chef来管理的机器。一个Node可以是一台物理机器，一个虚拟机，也可以是cloud环境中的一个instance，甚至是你网络环境中的一个交换机或路由器。如果你想要在Node上部署环境，那么Node会与Chef server进行交互获取信息，并在Node上执行环境初始化操作。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;三者之间的关系是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/e12c12b86ad41150d7fb7b05974ec5bf.jpg&quot; title=&quot;chef-overview&quot; alt=&quot;chef-overview&quot;&gt;&lt;/p&gt;

&lt;h1&gt;获取Chef Server&lt;/h1&gt;

&lt;p&gt;为了节省时间和资源，本文使用Enterprise Chef作为自己的Chef Server，先&lt;a href=&quot;https://manage.opscode.com&quot;&gt;注册&lt;/a&gt;账号，然后登录并添加自己的ORGANIZATION，这里就不详细说明了，请自行摸索。&lt;/p&gt;

&lt;h1&gt;安装Workstation&lt;/h1&gt;

&lt;h2&gt;Omnibus installer&lt;/h2&gt;

&lt;p&gt;我们首先安装&lt;a href=&quot;http://docs.opscode.com/install_omnibus.html&quot;&gt;omnibus installer&lt;/a&gt;，Mac或Ubuntu用户执行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L https://www.opscode.com/chef/install.sh | sudo bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上命令会在机器上安装&lt;code&gt;chef-client&lt;/code&gt;，&lt;code&gt;Ruby语言&lt;/code&gt;，&lt;code&gt;Knife&lt;/code&gt;等一系列工具，安装结束后输入以下命令来确认安装没有问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chef-client -v
Chef: 11.12.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chef-client安装完成之后，会在&lt;code&gt;/opt&lt;/code&gt;生成如下的目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/opt
   /chef
      /bin
      /embedded
         /bin
         /include
         /lib
         /share
         /ssl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：如果我们使用的是自行安装的开源Chef server，那么需要安装git，git安装方法这里不再叙述。&lt;/p&gt;

&lt;p&gt;以上完成之后，我们需要获取chef-repo，如果使用的是Enterprise Chef，那么你需要下载&lt;a href=&quot;https://manage.opscode.com/starter-kit&quot;&gt;Starter Kit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/9d43ca46dcedf9b0160ed7b18026fae5.jpg&quot; title=&quot;chef-starter-kit&quot; alt=&quot;chef-starter-kit&quot;&gt;&lt;/p&gt;

&lt;p&gt;之后拷贝到home目录下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp chef-repo ~/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;获取配置文件&lt;/h2&gt;

&lt;p&gt;为了能够与Chef server通讯，我们需要&lt;a href=&quot;https://manage.opscode.com&quot;&gt;登录&lt;/a&gt;到Enterprise Chef上获取三个配置文件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;knife.rb&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/193f51d5d4d4caeeeb5c9aade1765432.jpg&quot; title=&quot;chef-get-knife.rb&quot; alt=&quot;chef-get-knife.rb&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ORGANIZATION-validator.pem（注：ORGANIZATION为你自己组织的名字）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/c01a4cf5bcdbaafb14553183b4c0f9b2.jpg&quot; title=&quot;chef-get-validator.pem&quot; alt=&quot;chef-get-validator.pem&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;USER.pem（注：USER为你的用户名）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/68e34d68915b1691b2bfaeee9de968c7.jpg&quot; title=&quot;chef-get-USER.pem&quot; alt=&quot;chef-get-USER.pem&quot;&gt;&lt;/p&gt;

&lt;p&gt;获取到以上三个文件之后，我们需要把它们拷贝到&lt;code&gt;~/chef-repo/.chef&lt;/code&gt;目录下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp /path/to/knife.rb /path/to/ORGANIZATION-validator.pem /path/to/USERNAME.pem ~/chef-repo/.chef
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;把Ruby添加到$PATH&lt;/h2&gt;

&lt;p&gt;由于Chef中的工具都是基于Ruby语言的，所以chef-client中包含了一个稳定版本的Ruby解释器，你需要把它添加到$PATH中，以便通过命令行可以执行Ruby脚本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;export PATH=&quot;/opt/chef/embedded/bin:$PATH&quot;&#39; &amp;gt;&amp;gt; ~/.bash_profile &amp;amp;&amp;amp; source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;验证chef-client&lt;/h2&gt;

&lt;p&gt;如果通过Knife可以和Chef server通信，那么代表Workstation安装成功，接下来需要验证。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进入&lt;code&gt;chef-repo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; $ cd ~/chef-repo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行以下命令&lt;/p&gt;

&lt;p&gt; $ knife client list&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;如果执行成功会返回一个可以访问Chef server的client列表。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;workstation
registered_node
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;安装Node&lt;/h1&gt;

&lt;p&gt;一个Node可以是任何可以连接上网络的电脑，你必须是它的管理员，并且拥有sudo或者root权限。官方推荐CentOS 6+，Windows Server 2008+，或者Ubuntu 12.04+。你还需要拥有它的SSH账号、密码以及端口。&lt;/p&gt;

&lt;p&gt;虽然你可以自己折腾物理机器，不过如果只是想看看Chef有什么功能的话，Chef官方提供了一些配置好的虚拟机，君请自取：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://opscode-cheflab.herokuapp.com/labs/learnchef/ubuntu/attend&quot;&gt;Ubuntu Training Lab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://opscode-cheflab.herokuapp.com/labs/learnchef/centos/attend&quot;&gt;CentOS Training Lab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://opscode-cheflab.herokuapp.com/labs/learnchef/windows/attend&quot;&gt;Windows Training Lab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如果你想在自己的本地折腾，那么Chef官方也提供了&lt;a href=&quot;http://www.vagrantup.com/&quot;&gt;Vagrant&lt;/a&gt;方案：在你之前下载的&lt;code&gt;Starter Kit&lt;/code&gt;中已经包含了&lt;code&gt;Vagrantfile&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ll ~/chef-repo
-rw-r--r--  1 weizhifeng  staff       2405 Jul 18 06:26 README.md
-rw-r--r--  1 weizhifeng  staff       3747 Jul 18 16:24 Vagrantfile
drwxr-xr-x  4 weizhifeng  staff        136 Jul 18 06:26 cookbooks
drwxr-xr-x  3 weizhifeng  staff        102 Jul 18 06:26 roles
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以直接执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant up
Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider...
==&amp;gt; default: Clearing any previously set forwarded ports...
==&amp;gt; default: Fixed port collision for 22 =&amp;gt; 2222. Now on port 2200.
==&amp;gt; default: Clearing any previously set network interfaces...
==&amp;gt; default: Preparing network interfaces based on configuration...
    default: Adapter 1: nat
==&amp;gt; default: Forwarding ports...
    default: 8080 =&amp;gt; 9090 (adapter 1)
    default: 22 =&amp;gt; 2200 (adapter 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来启动VM。&lt;/p&gt;

&lt;p&gt;接下来我们需要执行&lt;code&gt;knife bootstrap&lt;/code&gt;命令，这个命令会在VM上安装chef-client，并且chef-client会与Chef server进行交互。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ knife bootstrap localhost --sudo -x vagrant -P vagrant --ssh-port 2222 -N node1   
Connecting to localhost
localhost Starting first Chef Client run...
....
....
localhost Starting Chef Client, version 11.12.8
localhost resolving cookbooks for run list: []
localhost Synchronizing Cookbooks:
localhost Compiling Cookbooks...
localhost [2014-07-19T13:50:55+00:00] WARN: Node node1 has an empty run list.
localhost Converging 0 resources
localhost 
localhost Running handlers:
localhost Running handlers complete
localhost 
localhost Chef Client finished, 0/0 resources updated in 76.501062463 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：如果你运行了N个Vagrant VM，那么&lt;code&gt;--ssh-port 2222&lt;/code&gt;可能不正确，你可以在&lt;code&gt;vagrant up&lt;/code&gt;输出的日志中找到正确的网络转发端口。&lt;/p&gt;

&lt;p&gt;为了确认Node是否已经bootstrap成功，访问&lt;a href=&quot;http://manage.opscode.com/organizations&quot;&gt;manage.opscode.com/organizations&lt;/a&gt;，在Nodes标签上你应该可以看到刚才bootstrap的node名称。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/weizhifeng.net/bd078a428c2ecc13b11602729b0c40d6.jpg&quot; title=&quot;chef-nodes&quot; alt=&quot;chef-nodes&quot;&gt;&lt;/p&gt;

&lt;p&gt;恭喜，你现在拥有了一个Chef环境，下一篇文章我们开始介绍Chef怎么使用。&lt;/p&gt;

&lt;h1&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.opscode.com/install_workstation.html&quot;&gt;http://docs.opscode.com/install_workstation.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.opscode.com/knife.html&quot;&gt;http://docs.opscode.com/knife.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.getchef.com/legacy/get-started/&quot;&gt;http://learn.getchef.com/legacy/get-started/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.vagrantup.com/v2/getting-started/up.html&quot;&gt;http://docs.vagrantup.com/v2/getting-started/up.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


	(完)

	&lt;div class=&quot;post-info&quot;&gt;
		19 Jul 2014  
	
		
	
		
	&lt;/div&gt;
	
	&lt;!-- disqus start --&gt;
	
	
	&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;http://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;
&lt;/noscript&gt;
	
	&lt;!-- disqus end --&gt;

	&lt;!-- related start --&gt;
	
	&lt;!-- related end --&gt;

</description>
        <pubDate>Sat, 19 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-19-learn-chef-01.html-2708b97ab.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-19-learn-chef-01.html-2708b97ab.html</guid>
        
        
      </item>
    
      <item>
        <title>击败二分检索算法——插值检索、快速检索</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;二分检索是查找有序数组最简单然而最有效的算法之一。现在的问题是，更复杂的算法能不能做的更好？我们先看一下其他方法。&lt;/p&gt;
&lt;p&gt;有些情况下，散列整个数据集是不可行的，或者要求既查找位置，又查找数据本身。这个时候，用哈希表就不能实现O(1)的运行时间了。但对有序数组， 采用分治法通常可以实现O(log(n))的最坏运行时间。&lt;/p&gt;
&lt;p&gt;在下结论前，有一点值得注意，那就是可以从很多方面“击败”一个算法：所需的空间，所需的运行时间，对底层数据结构的访问需求。接下来我们做一个运行时对比实验，实验中创建多个不同的随机数组，其元素个数均在10,000到81,920,000之间，元素均为4字节整型数据。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二分检索&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/28c8edde3d61a0411511d3b1866f06364.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73518&quot; alt=&quot;1&quot; src=&quot;/images/jobbole.com/3926f1cd5450556aeb560d367b40808e.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot; align=&quot;center&quot;&gt;二分检索算法的每一步，搜索空间总会减半，因此保证了运行时间。在数组中查找一个特定元素，可以保证在 O(log(n))时间内完成，而且如果找的正好是中间元素就更快了。也就是说，要从81,920,000个元素的数组中找某个元素的位置，只需要27个甚至更少的迭代。&lt;/p&gt;
&lt;p&gt;由于二分检索的随机跳跃性，该算法并非缓存友好的，因此只要搜索空间小于特定值（64或者更少），一些微调的二分检索算法就会切换回线性检索继续查找。然而，这个最终的空间值是极其架构相关的，因此大部分框架都没有做这个优化。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速检索；最后回归到二分检索的快速检索&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/665f644e43731ff9db3d341da5c827e14.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73519&quot; alt=&quot;2&quot; src=&quot;/images/jobbole.com/55b8b2b1d8240367a4a8d1ebb6fec3b1.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果由于某些原因，数组长度未知，快速检索可以识别初始的搜索域。这个算法从第一个元素开始，一直加倍搜索域的上界，直到这个上界已经大于待查关键字。之后，根据实现不同，或者采用标准的二分检索查找，或者开始另一轮的快速检索。前者可以保证O(log(n)) 的运行时间，后者则更接近O(n)的运行时间。&lt;/p&gt;
&lt;p&gt;如果我们要找的元素比较接近数组的开头，快速检索就非常有效。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽样检索&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/38026ed22fc1a91d92b5d2ef93540f204.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73520&quot; alt=&quot;3&quot; src=&quot;/images/jobbole.com/8fe61d7b867c882f73dcc417d21cf0c2.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;抽样检索有点类似二分检索，不过在确定主要搜索区域之前，它会先从数组中拿几个样例。最后，如果范围足够小，就采用标准的二分检索确定待查元素的准确位置。这个理论很有趣，不过在实践中执行效果并不好。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插值检索；最后回归到顺序查找的插值检索&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/011ecee7d295c066ae68d4396215c3d03.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-73521&quot; alt=&quot;4&quot; src=&quot;/images/jobbole.com/1834e255a86da238292eb405ad63b4e4.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在被测的算法中，插值检索可以说是“最聪明”的一个算法。它类似于人类使用电话簿的方法，它试图通过假设元素在数组中均匀分布，来猜测元素的位置。&lt;/p&gt;
&lt;p&gt;首先，它抽样选择出搜索空间的开头和结尾，然后猜测元素的位置。算法一直重复这个步骤，直到找到元素。如果猜测是准确的，比较的次数大概是O(log(log(n))，运行时间大概是O(log(n))；但如果猜测的不对，运行时间就会是O(n)了。&lt;/p&gt;
&lt;p&gt;插值检索的一个改进版本是，只要可推测我们猜测的元素位置是接近最终位置的，就开始执行顺序查找。相比二分检索，插值检索的每次迭代计算代价都很高，因此在最后一步采用顺序查找，无需猜测元素位置的复杂计算，很容易就可以从很小的区域（大概10个元素）中找到最终的元素位置。&lt;/p&gt;
&lt;p&gt;围绕插值检索的一大疑问就是，O(log(log(n))的比较次数可能产生O(log(log(n))的运行时间。这并非个案，因为存储访问时间和计算下一次猜测的CPU时间相比，这两者之间要有所权衡。如果数据量很大，而且存储访问时间也很显著，比如在一个实际的硬盘上，插值检索轻松击败二分检索。然而，实验表明，如果访问时间很短，比如说RAM，插值检索可能不会产生任何好处。&lt;/p&gt;
&lt;p&gt;&lt;b&gt; &lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;试验结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;试验中的源代码都是用Java写的；每个实验在相同的数组上运行10次；数组是随机产生的整型数组，存储在内存中。&lt;/p&gt;
&lt;p&gt;在插值检索中，首先会采用抽样检索，从检索空间拿20个样例，以确定接下来的搜索域。如果假定的域只有10个或更少的元素，就开始采用线性检索。另外，如果这个搜索域元素个数小于2000，就回退到标准的二分检索了。&lt;/p&gt;
&lt;p&gt;作为参考，java默认的Arrays.binarySearch算法也被加入实验，以同自定义的算法对比运行时间。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/e4da3b7fbbce2345d7772b0674a318d5.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-73522&quot; alt=&quot;5&quot; src=&quot;/images/jobbole.com/c302133d6c5ba5d207301064dba6000e.jpg&quot;&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;Average search time / element, given the array size&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/07/1679091c5a880faf6fb5e6087eb1b2dc.png&quot; rel=&quot;lightbox[73517]&quot; title=&quot;击败二分检索算法——插值检索、快速检索&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-73523&quot; alt=&quot;6&quot; src=&quot;/images/jobbole.com/30896ce76290686b4428b60a44ba2562.jpg&quot;&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;Average comparisons / search, given the array size&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;尽管我们对插值检索期望很高，它的实际运行时间并未击败java默认的二分检索算法。如果存储访问时间长，结合采用某些类型的哈希树和B+树可能是一个更好的选择。但值得注意的是，对均匀分布的数组，组合使用插值检索和顺序检索在比较次数上总能胜过二分检索。不过平台的二分检索已经很高效，所以很多情况下，可能不需要用更复杂的算法来代替它。&lt;/p&gt;
&lt;p&gt;原始数据 – 每个检索的平均运行时间&lt;/p&gt;
&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Size&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Arrays.&lt;br&gt;
&lt;/b&gt;&lt;b&gt;binarySearch&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Interpolation&lt;br&gt;
&lt;/b&gt;&lt;b&gt;+Seq&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Interpolation&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Sampling&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Binary&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Gallop&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Gallop&lt;br&gt;
&lt;/b&gt;&lt;b&gt;+Binary&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,000&lt;/td&gt;
&lt;td&gt;1.50E-04 ms&lt;/td&gt;
&lt;td&gt;1.60E-04 ms&lt;/td&gt;
&lt;td&gt;2.50E-04 ms&lt;/td&gt;
&lt;td&gt;3.20E-04 ms&lt;/td&gt;
&lt;td&gt;5.00E-05 ms&lt;/td&gt;
&lt;td&gt;1.50E-04 ms&lt;/td&gt;
&lt;td&gt;1.00E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20,000&lt;/td&gt;
&lt;td&gt;5.00E-05 ms&lt;/td&gt;
&lt;td&gt;5.50E-05 ms&lt;/td&gt;
&lt;td&gt;1.05E-04 ms&lt;/td&gt;
&lt;td&gt;2.35E-04 ms&lt;/td&gt;
&lt;td&gt;7.00E-05 ms&lt;/td&gt;
&lt;td&gt;1.15E-04 ms&lt;/td&gt;
&lt;td&gt;6.50E-05 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40,000&lt;/td&gt;
&lt;td&gt;4.75E-05 ms&lt;/td&gt;
&lt;td&gt;5.00E-05 ms&lt;/td&gt;
&lt;td&gt;9.00E-05 ms&lt;/td&gt;
&lt;td&gt;1.30E-04 ms&lt;/td&gt;
&lt;td&gt;5.25E-05 ms&lt;/td&gt;
&lt;td&gt;1.33E-04 ms&lt;/td&gt;
&lt;td&gt;8.75E-05 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80,000&lt;/td&gt;
&lt;td&gt;4.88E-05 ms&lt;/td&gt;
&lt;td&gt;5.88E-05 ms&lt;/td&gt;
&lt;td&gt;9.88E-05 ms&lt;/td&gt;
&lt;td&gt;1.95E-04 ms&lt;/td&gt;
&lt;td&gt;6.38E-05 ms&lt;/td&gt;
&lt;td&gt;1.53E-04 ms&lt;/td&gt;
&lt;td&gt;9.00E-05 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;160,000&lt;/td&gt;
&lt;td&gt;5.25E-05 ms&lt;/td&gt;
&lt;td&gt;5.94E-05 ms&lt;/td&gt;
&lt;td&gt;1.01E-04 ms&lt;/td&gt;
&lt;td&gt;2.53E-04 ms&lt;/td&gt;
&lt;td&gt;6.56E-05 ms&lt;/td&gt;
&lt;td&gt;1.81E-04 ms&lt;/td&gt;
&lt;td&gt;9.38E-05 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;320,000&lt;/td&gt;
&lt;td&gt;5.16E-05 ms&lt;/td&gt;
&lt;td&gt;6.13E-05 ms&lt;/td&gt;
&lt;td&gt;1.22E-04 ms&lt;/td&gt;
&lt;td&gt;2.19E-04 ms&lt;/td&gt;
&lt;td&gt;6.31E-05 ms&lt;/td&gt;
&lt;td&gt;2.45E-04 ms&lt;/td&gt;
&lt;td&gt;1.04E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;640,000&lt;/td&gt;
&lt;td&gt;5.30E-05 ms&lt;/td&gt;
&lt;td&gt;6.06E-05 ms&lt;/td&gt;
&lt;td&gt;9.61E-05 ms&lt;/td&gt;
&lt;td&gt;2.12E-04 ms&lt;/td&gt;
&lt;td&gt;7.27E-05 ms&lt;/td&gt;
&lt;td&gt;2.31E-04 ms&lt;/td&gt;
&lt;td&gt;1.16E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1,280,000&lt;/td&gt;
&lt;td&gt;5.39E-05 ms&lt;/td&gt;
&lt;td&gt;6.06E-05 ms&lt;/td&gt;
&lt;td&gt;9.72E-05 ms&lt;/td&gt;
&lt;td&gt;2.59E-04 ms&lt;/td&gt;
&lt;td&gt;7.52E-05 ms&lt;/td&gt;
&lt;td&gt;2.72E-04 ms&lt;/td&gt;
&lt;td&gt;1.18E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2,560,000&lt;/td&gt;
&lt;td&gt;5.53E-05 ms&lt;/td&gt;
&lt;td&gt;6.40E-05 ms&lt;/td&gt;
&lt;td&gt;1.11E-04 ms&lt;/td&gt;
&lt;td&gt;2.57E-04 ms&lt;/td&gt;
&lt;td&gt;7.37E-05 ms&lt;/td&gt;
&lt;td&gt;2.75E-04 ms&lt;/td&gt;
&lt;td&gt;1.05E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5,120,000&lt;/td&gt;
&lt;td&gt;5.53E-05 ms&lt;/td&gt;
&lt;td&gt;6.30E-05 ms&lt;/td&gt;
&lt;td&gt;1.26E-04 ms&lt;/td&gt;
&lt;td&gt;2.69E-04 ms&lt;/td&gt;
&lt;td&gt;7.66E-05 ms&lt;/td&gt;
&lt;td&gt;3.32E-04 ms&lt;/td&gt;
&lt;td&gt;1.18E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,240,000&lt;/td&gt;
&lt;td&gt;5.66E-05 ms&lt;/td&gt;
&lt;td&gt;6.59E-05 ms&lt;/td&gt;
&lt;td&gt;1.22E-04 ms&lt;/td&gt;
&lt;td&gt;2.92E-04 ms&lt;/td&gt;
&lt;td&gt;8.07E-05 ms&lt;/td&gt;
&lt;td&gt;4.27E-04 ms&lt;/td&gt;
&lt;td&gt;1.42E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20,480,000&lt;/td&gt;
&lt;td&gt;5.95E-05 ms&lt;/td&gt;
&lt;td&gt;6.54E-05 ms&lt;/td&gt;
&lt;td&gt;1.18E-04 ms&lt;/td&gt;
&lt;td&gt;3.50E-04 ms&lt;/td&gt;
&lt;td&gt;8.31E-05 ms&lt;/td&gt;
&lt;td&gt;4.88E-04 ms&lt;/td&gt;
&lt;td&gt;1.49E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40,960,000&lt;/td&gt;
&lt;td&gt;5.87E-05 ms&lt;/td&gt;
&lt;td&gt;6.58E-05 ms&lt;/td&gt;
&lt;td&gt;1.15E-04 ms&lt;/td&gt;
&lt;td&gt;3.76E-04 ms&lt;/td&gt;
&lt;td&gt;8.59E-05 ms&lt;/td&gt;
&lt;td&gt;5.72E-04 ms&lt;/td&gt;
&lt;td&gt;1.75E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;81,920,000&lt;/td&gt;
&lt;td&gt;6.75E-05 ms&lt;/td&gt;
&lt;td&gt;6.83E-05 ms&lt;/td&gt;
&lt;td&gt;1.04E-04 ms&lt;/td&gt;
&lt;td&gt;3.86E-04 ms&lt;/td&gt;
&lt;td&gt;8.66E-05 ms&lt;/td&gt;
&lt;td&gt;6.89E-04 ms&lt;/td&gt;
&lt;td&gt;2.15E-04 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;原始数据 – 每个检索的平均比较次数&lt;/p&gt;
&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Size&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Arrays.&lt;br&gt;
&lt;/b&gt;&lt;b&gt;binarySearch&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Interpolation&lt;br&gt;
&lt;/b&gt;&lt;b&gt;+Seq&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Interpolation&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Sampling&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Binary&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Gallop&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;b&gt;Gallop&lt;br&gt;
&lt;/b&gt;&lt;b&gt;+Binary&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;10.6&lt;/td&gt;
&lt;td&gt;17.6&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;12.2&lt;/td&gt;
&lt;td&gt;58.2&lt;/td&gt;
&lt;td&gt;13.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;11.3&lt;/td&gt;
&lt;td&gt;20.7&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;13.2&lt;/td&gt;
&lt;td&gt;66.3&lt;/td&gt;
&lt;td&gt;14.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;11.0&lt;/td&gt;
&lt;td&gt;16.9&lt;/td&gt;
&lt;td&gt;20.9&lt;/td&gt;
&lt;td&gt;14.2&lt;/td&gt;
&lt;td&gt;74.9&lt;/td&gt;
&lt;td&gt;15.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.1&lt;/td&gt;
&lt;td&gt;19.9&lt;/td&gt;
&lt;td&gt;38.0&lt;/td&gt;
&lt;td&gt;15.2&lt;/td&gt;
&lt;td&gt;84.0&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;160,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;11.7&lt;/td&gt;
&lt;td&gt;18.3&lt;/td&gt;
&lt;td&gt;38.0&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;td&gt;93.6&lt;/td&gt;
&lt;td&gt;17.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;320,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.4&lt;/td&gt;
&lt;td&gt;25.3&lt;/td&gt;
&lt;td&gt;38.2&lt;/td&gt;
&lt;td&gt;17.2&lt;/td&gt;
&lt;td&gt;103.8&lt;/td&gt;
&lt;td&gt;18.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;640,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.4&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;41.6&lt;/td&gt;
&lt;td&gt;18.2&lt;/td&gt;
&lt;td&gt;114.4&lt;/td&gt;
&lt;td&gt;19.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1,280,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.5&lt;/td&gt;
&lt;td&gt;20.2&lt;/td&gt;
&lt;td&gt;57.0&lt;/td&gt;
&lt;td&gt;19.2&lt;/td&gt;
&lt;td&gt;125.5&lt;/td&gt;
&lt;td&gt;20.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2,560,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.8&lt;/td&gt;
&lt;td&gt;22.7&lt;/td&gt;
&lt;td&gt;57.0&lt;/td&gt;
&lt;td&gt;20.2&lt;/td&gt;
&lt;td&gt;137.1&lt;/td&gt;
&lt;td&gt;21.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5,120,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;12.7&lt;/td&gt;
&lt;td&gt;26.5&lt;/td&gt;
&lt;td&gt;57.5&lt;/td&gt;
&lt;td&gt;21.2&lt;/td&gt;
&lt;td&gt;149.2&lt;/td&gt;
&lt;td&gt;22.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,240,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;13.2&lt;/td&gt;
&lt;td&gt;25.2&lt;/td&gt;
&lt;td&gt;62.1&lt;/td&gt;
&lt;td&gt;22.2&lt;/td&gt;
&lt;td&gt;161.8&lt;/td&gt;
&lt;td&gt;23.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20,480,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;13.4&lt;/td&gt;
&lt;td&gt;23.4&lt;/td&gt;
&lt;td&gt;76.0&lt;/td&gt;
&lt;td&gt;23.2&lt;/td&gt;
&lt;td&gt;175.0&lt;/td&gt;
&lt;td&gt;24.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40,960,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;13.4&lt;/td&gt;
&lt;td&gt;21.9&lt;/td&gt;
&lt;td&gt;76.1&lt;/td&gt;
&lt;td&gt;24.2&lt;/td&gt;
&lt;td&gt;188.6&lt;/td&gt;
&lt;td&gt;25.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;81,920,000&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;19.7&lt;/td&gt;
&lt;td&gt;77.0&lt;/td&gt;
&lt;td&gt;25.2&lt;/td&gt;
&lt;td&gt;202.7&lt;/td&gt;
&lt;td&gt;26.2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;源代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/adam-ho/misc/tree/master/searchPerformance/src/main/java/com/search&quot;&gt;点此获取检索算法的完整源代码&lt;/a&gt;。注意，代码不是产品级别的；比如，在某些例子里，可能有过多或过少的范围检查。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;http://www.jobdeer.com/?fr=jobbole&quot;&gt;&lt;/a&gt;&lt;/p&gt;
	


	

</description>
        <pubDate>Sat, 19 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-07-19-73517-816d30f94.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-07-19-73517-816d30f94.html</guid>
        
        
      </item>
    
  </channel>
</rss>
