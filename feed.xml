<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IT技术干货</title>
    <description>[IT技术干货iftti.com] @KernelHacks</description>
    <link>http://iftti.com/</link>
    <atom:link href="http://iftti.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 26 May 2015 01:21:35 +0800</pubDate>
    <lastBuildDate>Tue, 26 May 2015 01:21:35 +0800</lastBuildDate>
    <generator>Jekyll v2.2.0</generator>
    
      <item>
        <title>八岁小孩的数学：少儿图论</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;今天早上，我有幸到女儿所在的三年级客串数学老师，和这一群好问的八九岁的小女孩有了一个愉快的互动。接着我去年的时候讲过的话题《&lt;a href=&quot;http://blog.jobbole.com/71701/&quot; target=&quot;_blank&quot;&gt;七岁儿童的数学：图形着色，色彩数，欧拉路径和欧拉环&lt;/a&gt;》，我想和她们一起探索图论里的一些基本概念。这些概念数学内涵丰富，难度对于孩子来说也适宜。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/193b545fa8aa0316ffde1c0b9b7cb3c9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这次我讲课的目标是让她们体会到独立发现连通平面图的欧拉示性数的惊喜。&lt;/p&gt;
&lt;p&gt;我们从一个简单的例子开始，分别数出图中顶点(V)、边(E)和区域(R)的数量。在数区域的数量的时候，我强调说“图外面”的区域也算一个区域。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/60560ecd676ffd59e51e2e5fb752ade9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;接着，为了给这堂课添加一些神秘色彩，我提到欧拉在计算V-E+R这个量时，发现它有个独特的性质。她们能够注意到欧拉的发现么？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/89cf438309650adbd928ef58d8fd1565.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个学生都有自己的小册子且计算了各种各样简单的图的欧拉示性数，我也在教室里走动帮助他们。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fbb8019a970dba71e777d3250ecc6e7a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后，这些小女孩发现了：她们总是得到同一个结果—2！我听到她们说，“为什么总是得到2呢？”。她们发现了欧拉的惊喜！&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4fb0d38ffd90b92ab500831f8f551868.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;老师们也对这个结果非常好奇，一个老师惊异地对我说，“我真的很想知道为什么总是2！”&lt;/p&gt;
&lt;p&gt;接着，我建议同学们试试其他的几个不太常见的图，来检验一下这个“始终等于2”的情况有多么稳定。但是在这些图中，我们得到的结果仍然是2。&lt;/p&gt;
&lt;p&gt;女孩们自己画出图形检验了这一假设。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/78bf6ab3c9b648419a45b228293df86d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;最终，我设法提出了非连通图和有交叉边的图的例子，来检验“始终等于2”的现象。（&lt;span style=&quot;color: #808080;&quot;&gt;注：V-E+R=2对这样的图不成立&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9bc3d955cae6af2b8219a0be0a6e3037.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e90351d43d137a88da0300abb4138b3a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;就这样，我们一起把V-E+R=2的假设改进到只适用于连通平面图的情况。&lt;/p&gt;
&lt;p&gt;现在，到了该证明的时候了。我一开始不确定我是否应该给出一个证明，毕竟他们才三年级，证明对他们来说有些太难。但是有些老师向我表达了他们想知道为什么的想法，他们鼓励我让我给出证明，说“即使有的同学不能够理解这个证明，光看到有人能给出这样的证明也会有很大的价值。多好的老师啊！&lt;/p&gt;
&lt;p&gt;证明的过程如下。当一个图只有一个顶点，没有边的时候，V-E+R=2是成立的。而且，当往图里添加一个顶点和一个边的情况下，顶点和边（的贡献）能够互相抵消，这个等式也是成立的。同时，当往图中添加一条边并把一个已有的区域切分成两个的情况下，因为多了一个区域，多了一条边，这两个相互抵消，等式也是成立的。因为任何一个连通平面图都可以用上面描述的两种添加边和顶点的方式构建出来，所以V-E+R=2这个论证对于任何连通平面图都是成立的。这种证明是对图的势（size）的数学归纳法证明。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ec68809030a9aa81df6d7ece925807e6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/97b9af63b703689c6fcac61c37b41112.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下一步，我们把研究对象转移到三维立方体和它们的表面上。对于各种各样的多面体，小女孩们依旧能够证实V-E+R=2的拓展例子。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1b5438ecfc1dc0645d6962a4f19d332d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a4c4256ad6c1bb361e3c6b20c2f883bf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;接着，小女孩们自己画出多面体来计算欧拉示性数，我教她们怎么画立方体和图中所示的立方体；当图形不仅仅是一个简单的立方体时，这对孩子而言是一个挑战，尽管如此，一些小朋友仍然画出了些有趣的立方体。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fa8a648600994aa05be3703a40fd7707.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3eccd08f74a93ffb90452528fb6517fd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/64217b72026723eaacfad1a235670446.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后，每个孩子都有一个可以带回家的精美的小册子。以上图片摘自班里一位同学的小册子。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f0b06e04b618460a912c79aca4bf02a8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;多棒的一天啊！&lt;/p&gt;
&lt;p&gt;你可以在这儿找到小册子—八岁小孩的数学：&lt;a title=&quot;少儿图论&quot; href=&quot;https://plus.google.com/u/0/+JoelDavidHamkins1/posts/46ZctASr5US&quot; target=&quot;_blank&quot;&gt;少儿图论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也可以查看我上一次讲课的报道：&lt;a title=&quot;七岁小孩的数学：图着色和欧拉路径&quot; href=&quot;http://jdh.hamkins.org/math-for-seven-year-olds-graph-coloring-chromatic-numbers-eulerian-paths/&quot; target=&quot;_blank&quot;&gt;七岁小孩的数学：图着色和欧拉路径。&lt;/a&gt;&lt;/p&gt;

        
        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者： &lt;a href=&quot;http://blog.jobbole.com/author/mingyuan/&quot;&gt;刘志成&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a href=&quot;http://blog.jobbole.com/author/mingyuan/&quot;&gt;
					&lt;/a&gt;
	&lt;/div&gt;
	&lt;p&gt;新浪微博：&lt;a href=&quot;http://weibo.com/sdwf&quot;&gt;@柳鸣渊&lt;/a&gt;&lt;/p&gt;
	&lt;p&gt;
		&lt;a style=&quot;text-decoration: none;&quot; href=&quot;http://blog.jobbole.com/author/mingyuan/&quot;&gt;查看刘志成的更多文章 »&lt;/a&gt;
	&lt;/p&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
	
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Fri, 22 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-22-86960-8358d0dfa.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-22-86960-8358d0dfa.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Shell（二）：变量、数据重定向和管道</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;在上一篇博客&lt;a href=&quot;http://blog.jobbole.com/86820/&quot; target=&quot;_blank&quot;&gt;Shell（一）：功能、配置和插件&lt;/a&gt;中，介绍了为什么要使用shell，shell有哪些功能，如何使用oh my zsh来提高效率等，本篇重点介绍，shell中的变量的如何设置和读取数据，读取之后如何使用变量？每个程序一般都有输入和输出，让我们看看数据重定向如何处理输入和输出的？还有，Unix/Linux系统提供丰富的工具，我们如何将这些工具通过管道来组合成更加强大的宏工具呢？下面，由我来逐一详细介绍变量、数据重定向和管道。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/23fde73486c88b8ec60e205c3373da96.jpg&quot; width=&quot;690&quot; height=&quot;433&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;变量的作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变量与其他程序设计语言一样，都是存储数据，然后被程序引用。相比于不使用变量，而是直接使用数据，存在两个问题：&lt;/p&gt;
&lt;p&gt;当数据改变时，直接使用数据的时候却不能灵活地根据数据改变而随着改变，而使用变量却不同，它能够做到这点。&lt;br&gt;
当数据发生变化时，如果想保证数据一致性，必须查找所有引用该数据的所有地方，然后将它修改，当下一次再需要修改时，也是像这种情况一样，是多么繁琐的事，而变量却不用，只需要修改变量值即可。&lt;br&gt;
因此，变量具有可变性和易于修改的两个特点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量的分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在shell中，大概分为两种变量：环境变量和局部变量，主要区别在于它们的使用范围不同，环境变量可以在父进程与子进程之间共享，而自定义变量只在本进程使用。举一个简单的例子来说明：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/779131174bda78f098c81335331d9195.jpg&quot; width=&quot;690&quot; height=&quot;123&quot;&gt;&lt;/p&gt;
&lt;p&gt;我首先设置一个shell变量devname=sam，然后输入bash打开一个新的shell，而这个shell是子进程，然后echo $devname输出变量值，变量值为空，最后exit退出子进程。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/caa630db46ddeaf5b6c08bcacc241fda.jpg&quot; width=&quot;690&quot; height=&quot;83&quot;&gt;&lt;/p&gt;
&lt;p&gt;但使用export devname设置环境变量后，再次进入输入bash进入子进程之后，echo $devname输出变量值，这次变量值是sam&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看环境变量env和set&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果想查看系统中以及自定义有哪些环境变量，可以使用env命令：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/1fa42177ba90ab550862e9b1abacee2e.jpg&quot; width=&quot;690&quot; height=&quot;500&quot;&gt;&lt;/p&gt;
&lt;p&gt;而set命令不仅能查看环境变量，还可以查看与shell接口有关的变量，下面只截取一部分变量：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/b387f8ad5812896873a4269c59ae8e30.jpg&quot; width=&quot;690&quot; height=&quot;353&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量有哪些操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显示echo $variable&lt;/p&gt;
&lt;p&gt;如果你想显示某个变量的值，例如PATH，你只需要输入：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;echo $PATH&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3f2b3bd9138d4012de7e7a1ef8d16a99.jpg&quot; width=&quot;690&quot; height=&quot;146&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意上面一条命令，需要在变量名前加上一个符号$，这样才能访问变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置variable=value和取消unset&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你想设置某个变量的值，只需在变量名和变量值之间用符号=连接就行了，例如：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3a6455d45005433527fc1ddf9571cfe4.jpg&quot; width=&quot;690&quot; height=&quot;231&quot;&gt;&lt;/p&gt;
&lt;p&gt;由上面的输入命令echo $devname，显示结果为空。由此可知，一开始如果没有设置某个变量时，它的是为空。另外，设置变量的规则还需要几点注意：&lt;/p&gt;
&lt;p&gt;1. 在命名变量名时，变量名称只能是英文字母和数字，而且首字母不能是数字。下面演示一个错误的例子：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/25cdbc229733ce96b3833b5a5e62f09d.jpg&quot; width=&quot;690&quot; height=&quot;77&quot;&gt;&lt;/p&gt;
&lt;p&gt;2. 等号=两边不能有空格&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/0808b1c942675bd695b3886bf48631b6.jpg&quot; width=&quot;690&quot; height=&quot;259&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 如果变量值有空格，可用双引号” “或单引号’ ‘来包围变量值，但两者是有区别：&lt;br&gt;
双引号” “内的一些特殊字符，可以保持原有的特性，例如：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/8ffabfd9a22eecdff7caad20394703f8.jpg&quot; width=&quot;690&quot; height=&quot;190&quot;&gt;&lt;/p&gt;
&lt;p&gt;而单引号’ ‘内的一些特殊字符，仅为一般字符，即纯文本，例如：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/6571f2b0da4d402246fd52d748a3444c.jpg&quot; width=&quot;690&quot; height=&quot;155&quot;&gt;&lt;/p&gt;
&lt;p&gt;4. 如果想显示一些特殊字符（$、空格、!等），在字符前面加上用转义字符\&lt;/p&gt;
&lt;p&gt;5. 有些时候，变量的值可能来源于一些命令，这时你可以使用反单引号`命令`或$(命令)，例如：&lt;/p&gt;
&lt;p&gt;使用反单引号`命令`的方式&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/ccd324509bd446b0e87f2943166831c9.jpg&quot; width=&quot;690&quot; height=&quot;146&quot;&gt;‘&lt;/p&gt;
&lt;p&gt;使用$(命令)的方式&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/8100e6d64cf53da84349526eb9335815.jpg&quot; width=&quot;690&quot; height=&quot;164&quot;&gt;&lt;/p&gt;
&lt;p&gt;6. 如果变量想增加变量的值，可以使用$variable累加&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/930c7e298386a35cff2f2a81b7ea9e24.jpg&quot; width=&quot;690&quot; height=&quot;285&quot;&gt;&lt;/p&gt;
&lt;p&gt;7. 如果变量需要在其他子进程使用，用&lt;code&gt;export&lt;/code&gt;关键字来设置变量为环境变量&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;export VARIABLE&lt;/pre&gt;
&lt;p&gt;8. 系统环境变量一般都是字母全部大写，例如：PATH，HOME，SHELL等&lt;/p&gt;
&lt;p&gt;9. 如果想取消设置变量的值，使用unset variable命令。注意，变量之前是没有符号$&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/ee65dd7bd45f8405c75d605f2e17d2d2.jpg&quot; width=&quot;690&quot; height=&quot;214&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前那些设置的环境变量，一旦退出系统后，就不能再次使用，如果想再次使用，必须重新再设置才行。如果想就算退出系统，也能重新使用自定义的环境变量，那怎么办呢？&lt;/p&gt;
&lt;p&gt;不用怕，系统提供一些环境配置文件：/etc/profile和~/.bash_profile。/etc/profile是系统整体的设置，每个用户共享，最好不要修改；而~/.bash_profile属于单个用户的设置，每个用户设置后，互不影响和共享。但因为我使用oh my zsh，之前~/.bash_profile设置一些配置都不生效了，但它提供一个环境配置文件.zshrc，所以如果想设置环境变量TEST，只需将export TEST=test添加.zshrc即可。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/ea68fa7a4089f8b86f765403f6e0b76c.jpg&quot; width=&quot;690&quot; height=&quot;223&quot;&gt;&lt;/p&gt;
&lt;p&gt;但在.zshrc文件设置好环境变量TEST后，echo $TEST为空，原因是还没使用source命令来读取环境配置文件。使用source .zshrc命令之后，设置环境变量TEST生效了&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e00a2a0672aeade7d0bbb0e3d29b1a7f.jpg&quot; width=&quot;690&quot; height=&quot;142&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;数据重定向&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当输入命令行时，一般都有输入参数(standard input)，而命令行处理完之后，一般都有输出结果，结果有可能成功(standard output)，也有可能失败(standard error)，而这些结果一般都会输出到屏幕上，如果你想控制结果输出到文件或以文件作为输入的话，你需要了解数据重定向的分类和符号操作。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/b03e3b25d6d6cc9b9d5d1fdcf38be4bf.jpg&quot; width=&quot;690&quot; height=&quot;259&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据重定向主要分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stdin，表示标准输入，代码为0，使用&amp;lt;或&amp;lt;&amp;lt;操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;符号&amp;lt;表示以文件内容作为输入&lt;br&gt;
符号&amp;lt;&amp;lt;表示输入时的结束符号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stdout，表示标准输出，代码为1，使用&amp;gt;或&amp;gt;&amp;gt;操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;符号&amp;gt;表示以覆盖的方式将正确的数据输出到指定文件中&lt;br&gt;
符号&amp;gt;&amp;gt;表示以追加的方式将正确的数据输出到指定文件中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stderr，表示标准错误输出，代码为2，使用2&amp;gt;或2&amp;gt;&amp;gt;操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;符号2&amp;gt;表示以覆盖的方式将错误的数据输出到指定文件中&lt;br&gt;
符号2&amp;gt;&amp;gt;表示以追加的方式将错误的数据输出到指定文件中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;stdout&lt;br&gt;
当你输入ls命令，屏幕会显示当前目录有哪些文件和目录；而当你使用符号&amp;gt;时，输出结果将重定向到dir.txt文件，而不显示在屏幕上&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/2146aa56576d3dd6a5a0b45bced80de1.jpg&quot; width=&quot;690&quot; height=&quot;230&quot;&gt;&lt;/p&gt;
&lt;p&gt;而符号&amp;gt;与符号&amp;gt;&amp;gt;有什么区别呢？&amp;gt;表示当文件存在时，将文件内容清空，然后stdout结果存放到文件中。而&amp;gt;&amp;gt;表示当文件存在时，文件内容并没有清空，而是将stdout结果追加到文件尾部。&lt;/p&gt;
&lt;p&gt;当你再次输入命令ls &amp;gt; dir.txt时，文件内容并没有改变，因为之前文件内容被清空，然后stdout结果存放在dir.txt文件&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/0e8da5fd9460376825e200adf87ba101.jpg&quot; width=&quot;690&quot; height=&quot;194&quot;&gt;&lt;/p&gt;
&lt;p&gt;而你这次使用符号ls &amp;gt;&amp;gt; dir.txt的话，文件内容被追加到dir.txt文件&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/07182755db7287ea7f767acd25eb6488.jpg&quot; width=&quot;690&quot; height=&quot;236&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stderr&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这次我输入命令ls test显示一个不存在的文件，会显示错误信息。然后将错误信息输出到文件error.txt。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/01211958d45d90545ce6108a2c565ae1.jpg&quot; width=&quot;690&quot; height=&quot;138&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你想追加错误信息，可以使用2&amp;gt;&amp;gt;符号&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/d130de034e3874ccff04dd534edfe3dc.jpg&quot; width=&quot;690&quot; height=&quot;117&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stdout &amp;amp; stderr&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将stdout和stderr分离：&amp;gt;和2&amp;gt;符号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入ls README.md test，在屏幕显示既有正确信息，也有错误信息，如果想将正确信息和错误信息分离到不同文件，你可以同时使用&amp;gt;和2&amp;gt;符号&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/4938a3e37d9b7d53c45fbdcf664c19de.jpg&quot; width=&quot;690&quot; height=&quot;185&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将stdout和stderr合并：&amp;amp;&amp;gt;符号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你想将正确信息和错误信息合并，且输出到同一个文件，可以使用&amp;amp;&amp;gt;符号&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/d32578ed30f64d4a03e8a1296d8cafe6.jpg&quot; width=&quot;690&quot; height=&quot;171&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stdin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般输入一些简单的数据的方式都是通过键盘，但是如果要输入大量的数据，最好还是通过文件的方式。举一个简单例子：&lt;br&gt;
首先输入cat &amp;gt; test命令之后，你就可以输入内容，那些内容最终会存放在test文件&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e22d933ed7692846b61a1822316fbfc7.jpg&quot; width=&quot;690&quot; height=&quot;152&quot;&gt;&lt;/p&gt;
&lt;p&gt;但如果有大量数据从一个文件导入到test文件时，此时需要用到&amp;lt;符号&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/2b8cb1033043b77918f9a8941dd9444d.jpg&quot; width=&quot;690&quot; height=&quot;350&quot;&gt;&lt;/p&gt;
&lt;p&gt;还一个符号&amp;lt;&amp;lt;需要解释，符号&amp;lt;&amp;lt;表示输入时的结束符号。输入cat &amp;gt; test &amp;lt;&amp;lt; “eof”命令之后，你就可以输入内容，那些内容最终会存放在test文件，输入完内容后可以输入eof来结束输入&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/10a52fb8bf0b2ecb32be793ba96367a9.jpg&quot; width=&quot;690&quot; height=&quot;166&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;管道&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在Unix设计哲学中，有一个重要设计原则–KISS(Keep it Simple, Stupid)，大概意思就是只关注如何做好一件事，并把它做到极致。每个程序都有各自的功能，那么有没有一样东西将不同功能的程序互相连通，自由组合成更为强大的宏工具呢？此时，管道出现了，它能够让程序实现了高内聚，低耦合。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/a9e464ef9cb6e5aeb9fad8eb8b544c22.jpg&quot; width=&quot;690&quot; height=&quot;160&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果我想查看文件是否存在某个关键字，此时我可以使用管道&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/62816c4c13f157c3686fa178d179747c.jpg&quot; width=&quot;690&quot; height=&quot;141&quot;&gt;&lt;/p&gt;
&lt;p&gt;命令cat README.md | grep ‘pod’的处理过程分为两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cat README.md查看文件内容&lt;/li&gt;
&lt;li&gt;然后将cat README.md输出的内容作为grep ‘pod’命令的输入，再进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面一个很关键的符号|，就是管道，它能够将前一个命令处理完的stdout作为下一条命令stdin。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;扩展阅读&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/4889838/&quot; target=&quot;_blank&quot;&gt;鸟哥的Linux私房菜-基础学习篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://coolshell.cn/articles/1351.html&quot; target=&quot;_blank&quot;&gt;Unix Pipes 管道原稿&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 21 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-21-87053-498a03022.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-21-87053-498a03022.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>算法题：删除 K 位数字</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;h3&gt;&lt;strong&gt;1.问题描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;现有一个 n 位数，你需要删除其中的 k 位，请问如何删除才能使得剩下的数最大？&lt;/p&gt;
&lt;p&gt;比如当数为 2319274， k=1 时，删去 2 变成 319274 后是可能的最大值。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.问题分析&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;[1]贪心解法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这题可以使用贪心策略，每次从高位向低位数，删除高位比低位数字小的那位上的数字，直到删除了k位之后，得到的数字肯定是最大值。&lt;/p&gt;
&lt;p&gt;(1)删数问题具有最优子结构：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/4eb1ec5a141234981f4e15990f4bd405.jpg&quot; width=&quot;690&quot; height=&quot;90&quot;&gt;&lt;/p&gt;
&lt;p&gt;(2)删数问题具有贪心选择性质：&lt;/p&gt;
&lt;p&gt;设问题T已按照上面的方法删除，假设 A=(y1,y2,···,yk) 是删数问题的一个最优解。易知，若问题有解，则1≤k≤n。 (1)当k=1时，由前得证，A=(y1,A′)是问题的最优解，其中A′是A中不删除了y1而删除其他位的最优解； (2)当k=q时，由反证法，可得A=(y1,y2···,yq)是最优解； 当k=q+1时，由前得证，A=(y1,y2···,yq+yq+1)是最优解。 所以，删数问题具有贪心选择性质。&lt;/p&gt;
&lt;p&gt;代码很容易实现，AC，1.484s，1.089MB&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;
int t,k,len;
string name;
void deletek(){
    int tlen=name.length();
    int tk=k;
    bool flag=true;
    while (k--&amp;gt; 0 &amp;amp;&amp;amp; flag) {
        flag=false;
        len = name.length();
        for (int i=0; i&amp;lt;len; i++) {
            if (i+1&amp;lt;len &amp;amp;&amp;amp; name[i]&amp;lt;name[i+1]) {
                name.erase(i,1);
                len--;
                flag=true;
                break;
            }
        }
    }
    cout &amp;lt;&amp;lt; name.substr(0,tlen-tk) &amp;lt;&amp;lt; endl;
}
int main(int argc, const char * argv[])
{
    cin &amp;gt;&amp;gt; t;
    while (t--&amp;gt;0) {
        cin &amp;gt;&amp;gt; name;
        cin &amp;gt;&amp;gt; k;
        deletek();
    }
    return 0;
}&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[2]动态规划解法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据上面的分析可以看出此题还可用动态规划来解决，思路如下：&lt;/p&gt;
&lt;p&gt;假设A(i,j)表示输入数字(字符串)的从第i位到第j位数字组成的字符串，S(i,j)表示前i位中删除j位得到的最优解，它实际上可以看做两个子问题：如果删除第j位，那么S(i,j)等于前i-1位删除j-1位的最优解加上第j位数字；如果不删除第j位，那么S(i,j)等于前i-1位删除j位的最优解。于是便有下面的递推式：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/25d9f951793b5aa11c3f98e18a85bcf2.jpg&quot; width=&quot;519&quot; height=&quot;67&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个递推式非常类似最长公共子序列问题的递推式，所以解法也类似，在空间方面可以只使用一个一维数组，加上一个额外的O(1)的空间，计算过程如下面制作的表格所示，除了第一列，其他中间元素都只依赖于上面一行对应位置S(i−1,j)和上面一行左边位置S(i−1,j−1)两个元素的大小，比较的是字符串，使用字典序进行比较，C++内置的字符串比较函数compare即可。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/1e83f13184510ff68937db00444881b9.jpg&quot; width=&quot;460&quot; height=&quot;331&quot;&gt;&lt;/p&gt;
&lt;p&gt;动态规划实现代码 [这份代码没有AC，只能得到60分就超时了，应该还可以改进]。&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;
#define MAX_K 1001
int t,k;
string name;string up;string last;string temp;
void deletek(){
    int len=name.length();
    if(k&amp;gt;=len){
        cout &amp;lt;&amp;lt; &quot;&quot; &amp;lt;&amp;lt; endl;
        return;
    }
    string cur[MAX_K]={&quot;&quot;};
    for (int i=1; i &amp;lt;= len; i++) {
        for (int j=0; j &amp;lt; i &amp;amp;&amp;amp; j &amp;lt;= k; j++) {//
            if (j==0) {//sub string
                last=cur[j];
                cur[j]=name.substr(0,i);
            }else{//0 &amp;lt; j &amp;lt;= i
                up=cur[j]+name[i-1];//
                if (up.compare(last)&amp;gt;=0) {//up &amp;gt; left
                    last=cur[j];
                    cur[j]=up;
                }else{//up &amp;lt; left
                    temp=cur[j];
                    cur[j]=last;
                    last=temp;
                }
            }
        }
    }
    cout &amp;lt;&amp;lt; cur[k] &amp;lt;&amp;lt; endl;
}
int main(int argc, const char * argv[])
{
    cin &amp;gt;&amp;gt; t;
    while (t--&amp;gt;0) {
        cin &amp;gt;&amp;gt; name;
        cin &amp;gt;&amp;gt; k;
        deletek();
    }
    return 0;
}&lt;/pre&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 21 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-21-87018-3225f88cf.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-21-87018-3225f88cf.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>算法题：最长公共子序列</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;最长公共子序列(LCS)是典型的动态规划问题，如果不理解动态规划请移步先看&lt;a href=&quot;http://python.jobbole.com/81465/&quot; target=&quot;_blank&quot;&gt;这篇动态规划的总结&lt;/a&gt;，否则本篇文章中的代码实现会不理解的哟！&lt;/p&gt;
&lt;p&gt;LCS问题的一个变种就是求最长单调递增子序列，它的一种简易求解方法就是先将原序列A进行排序得到序列B，然后求解序列A和序列B的最长公共子序列。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.问题描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3e466bd42e6eac26c6b37f9a8e1e7977.jpg&quot; width=&quot;636&quot; height=&quot;181&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.最优子结构和子问题重叠&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3658414382687496f599f1d277450d10.jpg&quot; width=&quot;629&quot; height=&quot;701&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.5种实现方式&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;根据LCS的递推公式&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/dd591d0c1eda24cd1ca024af328f729e.jpg&quot; width=&quot;452&quot; height=&quot;85&quot;&gt;&lt;/p&gt;
&lt;p&gt;(1)从中可以看出计算c[i][j]时只需要2行即可，前一行(i-1)和当前行(i)，每行的长度是min{m,n}，首先初始化前一行都为0，然后计算当前行的值，当要计算下一行之前将当前行的值复制到前一行中即可。&lt;/p&gt;
&lt;p&gt;(2)从递推公式中还可以看出计算当前行i的话，其实只需要一行再加上O(1)的额外空间就行了。因为计算c[i][j]只需要前一行中c[i-1][k] (k&amp;gt;=j-1)的数据，对于k&amp;lt;j-1的数据都是没有用的，而当前行c[i]l的数据都是有用的，要用来计算下一行的值，所以，可以在计算当前行的时候，将当前行的前面计算好的部分复制到前一行中对应位置上，但是c[i][j-1]除外，因为c[i-1][j-1]也是需要的，所以需要额外的O(1)的空间保存c[i][j-1]。&lt;/p&gt;
&lt;p&gt;LCS的五种实现：分别为0：直接递归；1：带备忘录的递归；2：使用二维数组保存结果的迭代；3：使用2个一维数组保存结果的迭代；4：使用1个一维数组和额外的O(1)空间保存结果的迭代。&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;def lcs0(i,j):
    #string starts at index 0, not 1
    if i&amp;lt;0 or j&amp;lt;0: return 0 #attention to this!!!
    if x[i]==y[j]:  return lcs0(i-1,j-1)+1
    return max(lcs0(i-1,j),lcs0(i,j-1))

x,y=&#39;abcde&#39;,&#39;oaob&#39;
lenx,leny=len(x),len(y)
print(lcs0(lenx-1,leny-1)) #2

from functools import wraps

def memo(func):
    cache={}
    @wraps(func)
    def wrap(*args):
        if args not in cache:
            cache[args]=func(*args)
        return cache[args]
    return wrap

@memo
def lcs1(i,j):
    #string starts at index 0, not 1
    if i&amp;lt;0 or j&amp;lt;0: return 0 #attention to this!!!
    if x[i]==y[j]:  return lcs1(i-1,j-1)+1
    return max(lcs1(i-1,j),lcs1(i,j-1))

x,y=&#39;abcde&#39;,&#39;oaob&#39;
lenx,leny=len(x),len(y)
print(lcs1(lenx-1,leny-1)) #2

def lcs2(x,y):
    lenx,leny=len(x),len(y)
    minlen,maxlen=0,0
    if lenx&amp;lt;leny: minlen,maxlen=lenx,leny; x,y=y,x
    else: minlen,maxlen=leny,lenx;
    #s is maxlen * minlen
    s=[[0 for j in range(minlen)] for i in range(maxlen)]
    for i in range(maxlen): #so, let x be the longer string!!!
        for j in range(minlen):
            if x[i]==y[j]: s[i][j]=s[i-1][j-1]+1
            else: s[i][j]=max(s[i-1][j],s[i][j-1])
    return s

x,y=&#39;abcde&#39;,&#39;oaob&#39;
s=lcs2(x,y)
print(s) #[[0, 1, 1, 1], [0, 1, 1, 2], [0, 1, 1, 2], [0, 1, 1, 2], [0, 1, 1, 2]]

def lcs3(x,y):
    lenx,leny=len(x),len(y)
    minlen,maxlen=0,0
    if lenx&amp;lt;leny: minlen,maxlen=lenx,leny; x,y=y,x
    else: minlen,maxlen=leny,lenx;
    #s is maxlen * minlen
    pre=[0 for j in range(minlen)]
    cur=[0 for j in range(minlen)]
    for i in range(maxlen): #so, let x be the longer string!!!
        for j in range(minlen):
            if x[i]==y[j]: cur[j]=pre[j-1]+1
            else: cur[j]=max(pre[j],cur[j-1])
        pre[:]=cur[:]
    return cur

x,y=&#39;abcde&#39;,&#39;oaob&#39;
s=lcs3(x,y)
print(s) #[2, 2, 2, 2]

def lcs4(x,y):
    lenx,leny=len(x),len(y)
    minlen,maxlen=0,0
    if lenx&amp;lt;leny: minlen,maxlen=lenx,leny; x,y=y,x
    else: minlen,maxlen=leny,lenx;
    #s is maxlen * minlen
    s=[0 for j in range(minlen)]
    t=0
    for i in range(maxlen): #so, let x be the longer string!!!
        for j in range(minlen):
            if x[i]==y[j]: s[j]=t+1
            else: s[j]=max(s[j],s[j-1])
            t=s[j]
    return s

x,y=&#39;abcde&#39;,&#39;oaobce&#39;
s=lcs4(x,y)
print(s) #[3, 3, 3, 3, 4]&lt;/pre&gt;

        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 21 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-21-87015-293678f7c.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-21-87015-293678f7c.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>算法题：矩阵链乘问题</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;矩阵链乘问题是最典型的动态规划问题，要理解下面的内容请先阅读&lt;a href=&quot;http://python.jobbole.com/81465/&quot; target=&quot;_blank&quot;&gt;这篇动态规划的总结&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.问题描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;矩阵链乘问题的描述如下，就是说要确定一个完全加括号的形式使得矩阵链乘需要进行的标量计算数目最少，矩阵Ai的维数为pi−1×pi，如果穷举所有可能形式的话，时间复杂度是指数级的！因为该问题满足最优子结构，并且子问题存在重叠，所以我们可以借助动态规划来求解。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/a34199733c6e27f4004e5c5519653cea.jpg&quot; width=&quot;690&quot; height=&quot;581&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.问题分析&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们需要确定一个递归式来将我们要求解的问题表示出来，下面摘自算法导论，介绍地非常详细&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/cf3e4c85f502681ac9282a4d7eaf50f3.jpg&quot; width=&quot;690&quot; height=&quot;451&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;最后给出的递归式如下，就是说我们要如何确定从第i个矩阵到第j个矩阵组成的矩阵链的最优解。如果i和j相等，那么就是一个矩阵，不需要运算；如果i小于j，那么肯定要从它们中间的某个位置分开来，那从哪里分开来呢? 这个我们可以尝试下所有可能的选择，也就是尝试不同的位置k，k满足条件(i &amp;lt;= k &amp;lt; j)，在位置k将矩阵链进行分开，看看它需要的计算次数，然后我们从这些可能的k中选择使得计算次数最小的那个k进行分开，分开了之后我们的问题就变成了2个小问题，确定矩阵链从i到k 和另一个矩阵链从k+1到j的最优解。如果我们一开始设置i=1(第一个矩阵)，j=n(最后一个矩阵)，那么，经过上面的递归即可得到我们需要的解。这就是递归的思想！&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3bd99ed2af439196ed7915fa55deb3ef.jpg&quot; width=&quot;471&quot; height=&quot;66&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.代码实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;根据上面的思想我们很快就可以写出一个递归版本的矩阵链承法的实现代码，输出的结果也没有错，给出的加括号的方式是( ( A1 ( A2 A3 ) ) ( ( A4 A5 ) A6 ) )。[问题的数据是算法导论中的问题的数据，值是30,35,15,5,10,20,25]。&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;def matrixchain_rec(p,i,j):
    if i==j:
        return 0
    for k in range(i,j):
        q=matrixchain_rec(p,i,k)+matrixchain_rec(p,k+1,j)+p[i-1]*p[k]*p[j]
        if q&amp;lt;m[i][j]:
            m[i][j]=q
            s[i][j]=k
    return m[i][j]

def showmatrixchain(s,i,j):
    if i==j:
        print &#39;A%d&#39;%(i),
    else:
        print &#39;(&#39;,
        showmatrixchain(s,i,s[i][j])
        showmatrixchain(s,s[i][j]+1,j)
        print &#39;)&#39;,

n=6
p=[30,35,15,5,10,20,25]
m=[[sys.maxint for i in range(n+1)] for j in range(n+1)]
s=[[0 for i in range(n+1)] for j in range(n+1)]
# pprint.pprint(m)
result=matrixchain_rec(p,1,6)
print(result) #15125
showmatrixchain(s,1,6) #( ( A1 ( A2 A3 ) ) ( ( A4 A5 ) A6 ) )&lt;/pre&gt;
&lt;p&gt;上面的代码运行没有问题，但是，它不够完美！为什么呢? 很明显，矩阵链乘问题子问题存在重叠，下面这张图很形象地显示了哪些子问题被重复计算了，所以我们需要改进，改进的方法就是使用带备忘录的递归形式！&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/1519f3c35bc11109b92847db68909758.jpg&quot; width=&quot;690&quot; height=&quot;185&quot;&gt;&lt;/p&gt;
&lt;p&gt;要改成带备忘录的很简单，但是，这次我们不能直接使用原来的装饰器，因为Python中的dict不能对list对象进行hash，所以我们要简单地修改下我们key值的构建，也很简单，看下代码就明白了：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;from functools import wraps

def memo(func):
    cache={}
    @wraps(func)
    def wrap(*args):
        #build new key!!!
        key=str(args[1])+str(args[2])
        if key not in cache:
            cache[key]=func(*args)
        return cache[key]
    return wrap

@memo
def matrixchain_rec(p,i,j):
    if i==j:
        return 0
    for k in range(i,j):
        q=matrixchain_rec(p,i,k)+matrixchain_rec(p,k+1,j)+p[i-1]*p[k]*p[j]
        if q&amp;lt;m[i][j]:
            m[i][j]=q
            s[i][j]=k
    return m[i][j]

def showmatrixchain(s,i,j):
    if i==j:
        print &#39;A%d&#39;%(i),
    else:
        print &#39;(&#39;,
        showmatrixchain(s,i,s[i][j])
        showmatrixchain(s,s[i][j]+1,j)
        print &#39;)&#39;,

n=6
p=[30,35,15,5,10,20,25]
m=[[sys.maxint for i in range(n+1)] for j in range(n+1)]
s=[[0 for i in range(n+1)] for j in range(n+1)]
# pprint.pprint(m)
result=matrixchain_rec(p,1,6)
print(result) #15125
showmatrixchain(s,1,6) #( ( A1 ( A2 A3 ) ) ( ( A4 A5 ) A6 ) )&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;接下来的一个问题是，我们怎么实现迭代版本呢? 迭代版本关键在于顺序！&lt;/strong&gt;我们怎么保证我们在计算$A{i…j}的最优解时，所有可能的k的选择需要求解的子问题A{i…k}以及A_{(k+1)…j}$是已经求解出来了的呢? 一个简单但是有效的想法就是看矩阵链的长度，我们先计算矩阵链短的最优解，然后再计算矩阵链长的最优解，后者计算时所需要求解的子问题肯定已经求解完了，对不对? 于是就有了迭代版本的实现，需要注意的就是其中的i,j,k的取值范围。&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;import sys
def matrixchain_iter(p):
    n=len(p)-1 #total n matrices 6
    #to solve the problem below, so initialize to n+1!!!
    m=[[0 for i in range(n+1)] for j in range(n+1)]
    s=[[0 for i in range(n+1)] for j in range(n+1)]
    # for i in range(n): #for matrix with len=1
        # m[i][i]=0
    # pprint.pprint(m)
    for l in range(2,n+1): #iterate the length, max is n
        for i in range(1,n-l+2): #i max is n-l+1
            j=i+l-1 #j is always l away from i
            m[i][j]=sys.maxint #initial to infinity
            for k in range(i,j):
                #attention to python array when index &amp;lt; 0!!!
                #solution is using more space with useless values
                q=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]
                if q&amp;lt;m[i][j]:
                    m[i][j]=q
                    s[i][j]=k
        # print(&#39;when len is %d &#39; % (l))
        # pprint.pprint(m)
    return m,s

print(&#39;&#39;)
m,s=matrixchain_iter(p)
print(m[1][6]) #15125
showmatrixchain(s,1,6) #( ( A1 ( A2 A3 ) ) ( ( A4 A5 ) A6 ) )&lt;/pre&gt;
&lt;p&gt;实现的时候需要注意一点，在Python中取list中的值时，如果索引是负值的话会从后面往前数返回对应的元素，而以前我们用其他语言的时候肯定是提示越界了，所以代码中用来存储结果的数数组是(n+1)x(n+1)，而不是nxn的，这样的话就能够保证返回的是0，而不是从后往前数得到的结果。&lt;/p&gt;
&lt;p&gt;得到的数组m如下，m[1,6]就是我们需要的解。&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;[[0, 0, 0, 0, 0, 0, 0],
 [0, 0, 15750, 7875, 9375, 11875, 15125],
 [0, 0, 0, 2625, 4375, 7125, 10500],
 [0, 0, 0, 0, 750, 2500, 5375],
 [0, 0, 0, 0, 0, 1000, 3500],
 [0, 0, 0, 0, 0, 0, 5000],
 [0, 0, 0, 0, 0, 0, 0]]&lt;/pre&gt;
&lt;p&gt;数组s如下：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;[[0, 0, 0, 0, 0, 0, 0],
 [0, 0, 1, 1, 3, 3, 3],
 [0, 0, 0, 2, 3, 3, 3],
 [0, 0, 0, 0, 3, 3, 3],
 [0, 0, 0, 0, 0, 4, 5],
 [0, 0, 0, 0, 0, 0, 5],
 [0, 0, 0, 0, 0, 0, 0]]&lt;/pre&gt;
&lt;p&gt;将这个两个数组旋转下，并且只看上三角部分的数字，就可以得到算法导论中给出的那张三角图形了，非常类似杨辉三角&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 21 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-21-87012-731b58095.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-21-87012-731b58095.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>算法题：顶点覆盖问题</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;顶点覆盖问题可以用几种不同的算法来实现，本篇文章使用的是分支限界法来实现，或许以后会介绍其他的实现算法，嘿嘿。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.问题描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;给定一个N个点M条边的无向图G（点的编号从1至N），问是否存在一个不超过K个点的集合S，使得G中的每条边都至少有一个点在集合S中。&lt;/p&gt;
&lt;p&gt;例如，如下图所示的无向图G（报告中算法分析过程中一直使用下面的图G）&lt;/p&gt;
&lt;p&gt;(1)如果选择包含点1,2,6这3个点的集合S不能满足条件，因为边(3,7)两个端点都不在S中。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/b2e7816e9e2fae094cf88a52cc76df0d.jpg&quot; width=&quot;357&quot; height=&quot;181&quot;&gt;&lt;/p&gt;
&lt;p&gt;(2)如果选择包含点1,2,6,7这4个点的集合S虽然满足条件，但是它使用了4个点，其实可以使用更少的点，如下面(3)所示&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/efd35e9d6a6d57ae05058b79301eae8b.jpg&quot; width=&quot;335&quot; height=&quot;172&quot;&gt;&lt;/p&gt;
&lt;p&gt;(3)如果选择包含点1,3,5这3个点的集合S便满足条件，使得G中的每条边都至少有一个点在集合S中。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/cc7cda1362b07dced9667589422c8d95.jpg&quot; width=&quot;356&quot; height=&quot;168&quot;&gt;&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;2.解题思路&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我的解题思路基于分支定界和贪心两个策略，用一个优先队列维护当前可行的节点，每个节点维护着该节点情况下还可以选择的顶点数目k、需要覆盖的剩余边数e、顶点的状态state、顶点的边数edge等信息，这些节点的排序遵循下面的贪心策略，节点的扩展遵循下面的分支定界策略。总体思路是：&lt;/p&gt;
&lt;p&gt;①将原图数据构造成一个解空间树的节点，利用定界策略判断是否有解，如果无解直接退出，如果有可能有解则插入到优先队列中；&lt;/p&gt;
&lt;p&gt;②若优先队列不为空，那么便从优先队列中取出第一个可行的节点，进入步骤③，如果优先队列为空则退出；&lt;/p&gt;
&lt;p&gt;③判断当前节点是否满足解的条件，如果满足便输出解退出，如果不满足便进入步骤④；&lt;/p&gt;
&lt;p&gt;④检查当前节点是否可以扩展，不能扩展的话便进入②继续循环，如果能扩展的话则扩展，然后验证扩展到左右节点是否有解，将有解的扩展节点插入到优先队列中，然后进入②继续循环。&lt;/p&gt;
&lt;p&gt;下面分别介绍下分支定界和贪心这两个策略：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1)分支定界策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，界的选择。在一个确定的无向图G中，每个顶点的边即确定了，那么对于该无向图中k个顶点能够覆盖的最多的边数e也就可以确定了！只要对顶点按照边的数目降序排列，然后选择前k个顶点，将它们的边数相加即能得到一个边数上界！因为这k个顶点相互之间可能有边存在也可能没有，所以这是个上界，而且有可能达到。以图G为例，各个顶点的边数统计，并采用降序排列的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e8a29c963ea11fad3a96e38f6e780fb6.jpg&quot; width=&quot;165&quot; height=&quot;421&quot;&gt;&lt;/p&gt;
&lt;p&gt;假设取k=3个点，那么有Up(e)=(3+3+2)=8 &amp;gt; 7 条边（7为图G的总边数），也就是说，如果从图G中取3个点，要覆盖8条边是有可能的。但是，如果取k=2个点，那么有Up(e)=(3+3)=6 &amp;lt; 7 条边，说明从图G中取2个点，是不可能覆盖G中的全部7条边的！基于这个上界，可以在分支树中扩展出来的节点进行验证，已知它还可以选择的顶点数目以及还需要覆盖的边的条数，加上顶点的状态（下面会分析说明）即可判断当前节点是否存在解！如果不存在即可进行剪枝了。&lt;/p&gt;
&lt;p&gt;其次，顶点的状态。该策略中顶点有三种状态，分别为已经选择了的状态S1，不选择的状态S2，可以选择的状态S3。其中，不选择的状态S2对应解空间树中的右节点，不选择该节点，然后设置该节点为不选择状态S2。这点很重要，因为有了这个状态，可以使得上界的判断更为精确，因为只能从剩余顶点集中选择那些状态S3的顶点，状态S1和S2都不行，那么上界便会更小，也就更加精确，从而利于剪枝！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)贪心策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;贪心的策略是指可行的结点都是按照还需要覆盖的剩余边数的降序排列，即，每次选择的节点都是可行节点中还需要覆盖的边数最小的那个节点，因为它最接近结果了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3)例子分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以图G为例，此时e=7（要覆盖的边数），取k=3，图G用邻接矩阵保存为全局数据，计算每个顶点的边数，然后降序排列。&lt;/p&gt;
&lt;p&gt;步骤①判断是否可能有解，Up(e)=3+3+2=8&amp;gt;7，可能有解，那么将图G构造成一个解空间树的节点，它包含了还能选择的点数k=3，还需要覆盖的边数e=7，每个顶点的边数以及按边数大小的降序排列（上表），每个顶点的状态（初始时都是可选择的状态S3）。然后，将该节点插入到优先队列中，该优先队列是用最小堆实现的，按照前面的贪心策略对队列中的节点进行降序排列。&lt;/p&gt;
&lt;p&gt;步骤②取出了优先队列中的根节点，很显然，还需要覆盖的边数为7，不为0，所以还不满足条件。接下来要检查是否能够进行扩展，从顶点集合中选择状态为可以选择的顶点中边数最多的点，该点存在为顶点2，接着进行扩展，扩展左节点时将还能选择的点数k-1=2，然后计算选择了该点之后删除了几条未覆盖的边，得到还需要覆盖的边数e=4，然后更新所有其他顶点的边数，并重新排序，最后将顶点2的状态设置为已经选择了；扩展右节点时，只要将顶点2的状态设置为不能选择，还能选择的点数k(=3)，还需要覆盖的边数e(=7)保持不变。扩展完了之后，同样判断左右节点是否可能有解，如果有解，将该节点插入到优先队列中。这里左右节点都有解，那么将左右节点都插入到优先队列中，因为左节点还需要覆盖的边数e=4小于右节点的e=7，所以根据贪心策略，左节点在右节点的前面。上面两个步骤的图示如下，其中标明了顶点状态颜色。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/dd91f854277fc97760608d5dc85ca608.jpg&quot; width=&quot;690&quot; height=&quot;609&quot;&gt;&lt;/p&gt;
&lt;p&gt;算法然后继续进入步骤②，此时取出的是节点是刚才插入的左节点，很显然，还需要覆盖的边数为4，不为0，所以还不满足条件。接下来要检查是否能够进行扩展，从顶点集合中选择状态为可以选择的顶点中边数最多的点，该点存在为顶点3，接着进行扩展，扩展左节点时将还能选择的点数k-1=1，然后计算选择了该点之后删除了几条未覆盖的边，得到还需要覆盖的边数e=2，然后更新所有其他顶点的边数，并重新排序，最后将顶点3的状态设置为已经选择了；扩展右节点时，只要将顶点3的状态设置为不能选择，还能选择的点数k(=3)，还需要覆盖的边数e(=7)保持不变。扩展完了之后，同样判断左右节点是否可能有解，如果有解，将该节点插入到优先队列中。这里左右节点都不可能有解，那么直接进入步骤②继续循环。上面这一步的图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/2ef9178340deab5b77685890f630c4c2.jpg&quot; width=&quot;690&quot; height=&quot;609&quot;&gt;&lt;/p&gt;
&lt;p&gt;算法按照上面的方式不断进行，最后满足条件的分支的过程是：&lt;/p&gt;
&lt;p&gt;①不选择顶点2；②选择顶点3；③选择顶点1；④选择顶点5。&lt;/p&gt;
&lt;p&gt;最后得到的满足条件的解是选择顶点1,3,5。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4)复杂度分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该算法优先队列使用的是最小堆实现的(O(nlgn))，对顶点按照边排序使用的是快速排序算法(O(nlgn))，解空间树的深度最多为顶点数目n，每层都要进行分支定界，所以每层的时间复杂度为O(nlgn)，所以算法总的时间复杂度为O(n^2 lgn)。但是，为了实现分支定界，每个节点保存的信息量较多，空间复杂度较大。(有木有分析错了，我不太会分析复杂度)&lt;/p&gt;
&lt;p&gt;青橙OJ系统的结果为：时间 156ms 空间 1.0MB&lt;/p&gt;
&lt;p&gt;本人对指针领悟能力有限，C++也是一知半解，OJ只能用C或者C++，所以下面的C++代码效率不高，仅供参考，:-)&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;
#define MAX_NODE 101
#define INDEBUG 0
int8_t graph[MAX_NODE][MAX_NODE];//int -&amp;gt; int8_t
//int edges[MAX_NODE];//0 is redudent
//int nodes[MAX_NODE];//the order of node
int t,m,n,k,a,b;
class VCNode {//Vertex Cover Node
public:
    int p;//points can be used
    int e;//edges to cover!!
    int index[MAX_NODE];//the index of each node in array [node], index[k]=i!!
    int edge[MAX_NODE];//MAX_NODE the edge number of each node, edge[i]=j!!
    int node[MAX_NODE];//the order of the node
    int state[MAX_NODE];//the state of each node ** 0 can be used / 1 used / -1 can not be used
//    int graph[MAX_NODE][MAX_NODE];//the graph on the node//no need,just use the global graph
    // node k is in index[k]=i position in array [node]
    // node i has number of edge[i]=j edges
};
class Minheap {//Min Heap
public:
    vector&amp;lt;VCNode&amp;gt; nodes;

    void insert(VCNode node);
    VCNode popmin();
//  void print();
};
void Minheap::insert(VCNode node) {
    nodes.push_back(node);
    //  cout &amp;lt;&amp;lt; &quot;size is &quot; &amp;lt;&amp;lt; nodes.size() &amp;lt;&amp;lt; endl;//
    int curpos = (int)nodes.size() - 1; // current position
    int parent = (curpos - 1) / 2; //parent position
    while (curpos != parent &amp;amp;&amp;amp; parent &amp;gt;= 0) { //parent is still in heap
        if (nodes[parent].e &amp;gt; nodes[curpos].e) { //swap parent and child
            VCNode temp = nodes[parent];
            nodes[parent] = nodes[curpos];
            nodes[curpos] = temp;
        } else {
            break; //no longer level up!!!
        }
        curpos = parent; //when curpos=parent=0, exit!!!
        parent = (curpos - 1) / 2; //relocate the parent position
    }
}
VCNode Minheap::popmin() {
    VCNode node;
    if (nodes.size() &amp;gt; 0) { //have nodes left
        node = nodes[0]; //get the first element
        nodes.erase(nodes.begin()); //remove the first element
        if (nodes.size() &amp;gt; 0) { //at least have one element more
            VCNode last = nodes[nodes.size() - 1]; //get the last element
            nodes.pop_back(); //pop the last element
            nodes.insert(nodes.begin(), last); //put it in the first place
            int csize = (int)nodes.size(); //current size
            int curpos = 0; //current position

            // rebuild the minheap
            while (curpos &amp;lt; (csize / 2)) { //reach to the last parent node!!
                int left = 2 * curpos + 1; //left child
                int right = 2 * curpos + 2; //right child
                int min = left; //min store the min child
                if (right &amp;lt; csize) { //have left and right childs
                    if (nodes[right].e &amp;lt; nodes[left].e) {
                        min = right;
                    }
                }
                if (min &amp;lt; csize) { //min child exist!!
                    if (nodes[min].e &amp;lt; nodes[curpos].e) { //need to swap current position with child
                        VCNode temp = nodes[min];
                        nodes[min] = nodes[curpos];
                        nodes[curpos] = temp;
                    }else { //min child no exits!! exit!!
                        break; //can break now!!
                    }
                }
                curpos = min;
            }
        }
    }
    return node;
}
//void Minheap::print() {
//  cout &amp;lt;&amp;lt; &quot;print heap&quot; &amp;lt;&amp;lt; endl;
//  for (int i = 0; i &amp;lt; (int)nodes.size(); i++) {
//      cout &amp;lt;&amp;lt; &quot;edge: &quot; &amp;lt;&amp;lt; nodes[i].e &amp;lt;&amp;lt; &quot; node: &quot; &amp;lt;&amp;lt; nodes[i].p &amp;lt;&amp;lt; endl;
//  }
//  cout &amp;lt;&amp;lt; &quot;heap end&quot; &amp;lt;&amp;lt; endl;
//}
// print array
void printArray(int a[], int start, int end){
    if (INDEBUG) {
        cout &amp;lt;&amp;lt; &quot;print array form &quot; &amp;lt;&amp;lt; start &amp;lt;&amp;lt; &quot; to &quot; &amp;lt;&amp;lt; end &amp;lt;&amp;lt; endl;
        for (int i=start; i&amp;lt;=end; i++) {
            cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &quot; &quot;;
        }
        cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &quot;print array end&quot; &amp;lt;&amp;lt; endl;
    }
}
// print the graph
void printGraph(int graph[][MAX_NODE]){
    if (INDEBUG) {
        for(int i=1;i&amp;lt;=n;i++){//0 no need
            for(int j=1;j&amp;lt;=n;j++){
                cout &amp;lt;&amp;lt; graph[i][j] &amp;lt;&amp;lt; &quot; &quot;;
            }
            cout &amp;lt;&amp;lt; endl;
        }
    }
}
// partition function for quick sort
int partition2(int a[], int low, int high, int b[]){
    int key = a[high];
    int i=low-1;
    for (int j=low; j&amp;lt;high; j++) {
        if (a[j]&amp;gt;=key) {
            i++;
            swap(a[i], a[j]);
            swap(b[i], b[j]);
        }
    }
    swap(a[high], a[i+1]);
    swap(b[high], b[i+1]);
    return i+1;
}
// quick sort
void quicksort2(int a[], int low, int high, int b[]) {
    if (low &amp;lt; high) {
        int p = partition2(a,low,high, b);
        quicksort2(a, low, p-1, b);
        quicksort2(a, p+1, high, b);
    }
}
// sum of the first k elements with state==0!!!
int sumofkmax(int edges[], int p, int nodes[], int state[]){
    quicksort2(edges, 1, n, nodes);
    int sum=0,count=0;
    // edges[i] corresponse to nodes[i], its state is state[nodes[i]]
    for(int i=1;i&amp;lt;=n;i++){//attention to i range!!
        if (state[nodes[i]]==0) {
            sum+=edges[i];
            count++;
            if (count == p) {//enough!
                break;
            }
        }
    }
    return sum;
}
// verify the current node can be achievable
bool verify(int edges[], int p, int e, int nodes[], int state[]){
    //caculate the sum of the first p max elements in array edges!!
    int sum = sumofkmax(edges, p, nodes, state);
    // edge of nodes[i] is edges[i]!!!
    if(sum &amp;gt;= e){// may be this can be achieved
        return true;
    }
    return false;
}
// build the index of node in array [index]
void buildIndex(int node[],int index[]){
    for (int i=1; i&amp;lt;=n; i++) {
        index[node[i]] = i;
    }
}
// get the next node: state==0 &amp;amp;&amp;amp; order first!!!
int nextNode(int state[], int nodes[]){
    for (int i=1; i&amp;lt;=n; i++) {
        if (state[nodes[i]]==0) {
            return nodes[i];
        }
    }
    return -1;
}
// generate the left child
VCNode genLeft(VCNode curnode, int label){
    VCNode left;//choose node label!
    left.p = curnode.p - 1;//remove one node
    left.e = curnode.e;
    for (int i=0; i&amp;lt;=n; i++) {//first copy all infos
        left.index[i]=curnode.index[i];
        left.state[i]=curnode.state[i];//init node state
        left.edge[i]=curnode.edge[i];//copy edge info
        left.node[i]=curnode.node[i];//copy node info
//        for (int j=0; j&amp;lt;=n; j++) {
//            left.graph[i][j] = curnode.graph[i][j];
//        }
    }
    // following code will not use curnode anymore!!

    ///
    int sum=0;//removed edge
    for (int j=1; j&amp;lt;=n; j++) {
        //new
        if (label &amp;lt; j &amp;amp;&amp;amp; left.state[j]!=1 &amp;amp;&amp;amp; graph[label][j]==1 ) {//row!
            sum++;
//            left.graph[label][j]=0;
            left.edge[left.index[j]]--;//how to cut it down
        }else if(label &amp;gt; j &amp;amp;&amp;amp; left.state[j]!=1 &amp;amp;&amp;amp; graph[j][label]==1 ){ // col
            sum++;
//            left.graph[j][label]=0;
            left.edge[left.index[j]]--;//how to cut it down
        }
    }
    ///

    left.state[label] = 1;//use label directly!
    left.edge[left.index[label]] = 0;//only use index!!
//    cout &amp;lt;&amp;lt; &quot;remove edge sum is &quot; &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;
    quicksort2(left.edge, 1, n, left.node);
    left.e = left.e - sum;//remove some edges
    buildIndex(left.node, left.index);

    if (INDEBUG) {
        cout &amp;lt;&amp;lt; &quot;======== &quot; &amp;lt;&amp;lt; label &amp;lt;&amp;lt; &quot; gen left begin===========&quot; &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; &quot;edge is &quot; &amp;lt;&amp;lt; left.e &amp;lt;&amp;lt; &quot; node is &quot; &amp;lt;&amp;lt; left.p &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; &quot;array edge:&quot; &amp;lt;&amp;lt; endl;
        printArray(left.edge,1,n);
        cout &amp;lt;&amp;lt; &quot;array node:&quot; &amp;lt;&amp;lt; endl;
        printArray(left.node, 1, n);
        cout &amp;lt;&amp;lt; &quot;array index:&quot; &amp;lt;&amp;lt; endl;
        printArray(left.index, 1, n);
        cout &amp;lt;&amp;lt; &quot;array state:&quot; &amp;lt;&amp;lt; endl;
        printArray(left.state, 1, n);
//        printGraph(left.graph);
        cout &amp;lt;&amp;lt; &quot;======== &quot; &amp;lt;&amp;lt; label &amp;lt;&amp;lt; &quot; gen left end===========&quot; &amp;lt;&amp;lt; endl;
    }

    return left;
}
// generate the right child
VCNode genRight(VCNode curnode, int label){
    VCNode right;//choose node label!
    right.p = curnode.p;//remain
    right.e = curnode.e;
    for (int i=0; i&amp;lt;=n; i++) {//first copy all infos
        right.index[i]=curnode.index[i];
        right.state[i]=curnode.state[i];//init node state
        right.edge[i]=curnode.edge[i];//copy edge info
        right.node[i]=curnode.node[i];//copy node info
//        for (int j=0; j&amp;lt;=n; j++) {
//            right.graph[i][j] = curnode.graph[i][j];
//        }
    }
    // following code will not use curnode anymore!!
    right.state[label] = -1;//use label directly!

    if (INDEBUG) {
        cout &amp;lt;&amp;lt; &quot;======== &quot; &amp;lt;&amp;lt; label &amp;lt;&amp;lt; &quot; gen right begin===========&quot; &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; &quot;edge is &quot; &amp;lt;&amp;lt; right.e &amp;lt;&amp;lt; &quot; node is &quot; &amp;lt;&amp;lt; right.p &amp;lt;&amp;lt; endl;
//        cout &amp;lt;&amp;lt; &quot;array edge:&quot; &amp;lt;&amp;lt; endl;
//        printArray(right.edge,1,n);
//        cout &amp;lt;&amp;lt; &quot;array node:&quot; &amp;lt;&amp;lt; endl;
//        printArray(right.node, 1, n);
//        cout &amp;lt;&amp;lt; &quot;array index:&quot; &amp;lt;&amp;lt; endl;
//        printArray(right.index, 1, n);
//        cout &amp;lt;&amp;lt; &quot;array state:&quot; &amp;lt;&amp;lt; endl;
//        printArray(right.state, 1, n);
//        printGraph(right.graph);
        cout &amp;lt;&amp;lt; &quot;======== &quot; &amp;lt;&amp;lt; label &amp;lt;&amp;lt; &quot; gen right end===========&quot; &amp;lt;&amp;lt; endl;
    }

    return right;
}
// greedy find a way to solve VCP
void greedyFind(int edges[], int nodes[]/*, int graph[][MAX_NODE]*/){
    VCNode node;
    node.e = m;
    node.p = k;

    for (int i=0; i&amp;lt;=n; i++) {
        node.index[i]=0;
        node.state[i]=0;//init node state
        node.edge[i]=edges[i];//copy edge info
        node.node[i]=nodes[i];//copy node info
//        for (int j=0; j&amp;lt;=n; j++) {
//            node.graph[i][j] = graph[i][j];
//        }
    }
    buildIndex(node.node, node.index);

    Minheap minheap;
    minheap.insert(node);

    while (minheap.nodes.size() &amp;gt; 0) {
        // get the heap top node to extend
        VCNode curnode = minheap.popmin();

//        if (INDEBUG) {
//            cout &amp;lt;&amp;lt; &quot;...current graph...&quot; &amp;lt;&amp;lt; endl;
//            printGraph(curnode.graph);
//        }

        // validate the current node
        if (curnode.e == 0) {
            int points = k - curnode.e;
            cout &amp;lt;&amp;lt; points &amp;lt;&amp;lt; endl;
            int count = 1;
            for (int i=1; i&amp;lt;=n; i++) {
                if (curnode.state[i]==1) {
                    if(count == points){
                        cout &amp;lt;&amp;lt; i;
                    }else{
                        cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot;;
                    }
                    count++;
                }
            }
            cout &amp;lt;&amp;lt; endl;
            return;
        }

        // generate child nodes
        int label = nextNode(curnode.state, curnode.node);//the label of the node
        if (label != -1) {
            // node i is in index[k] position in array [node]
            // node i has number of edge[i] edges
            VCNode left = genLeft(curnode, label);
            VCNode right = genRight(curnode, label);
            if (verify(left.edge, left.p, left.e, left.node, left.state)) {
//                cout &amp;lt;&amp;lt; &quot;insert &quot; &amp;lt;&amp;lt; label &amp;lt;&amp;lt; &quot; left&quot; &amp;lt;&amp;lt; endl;
                minheap.insert(left);
            }
            if (verify(right.edge, right.p, right.e, right.node, right.state)) {
//                cout &amp;lt;&amp;lt; &quot;insert &quot; &amp;lt;&amp;lt; label &amp;lt;&amp;lt; &quot; right&quot; &amp;lt;&amp;lt; endl;
                minheap.insert(right);
            }
        }

    }

    // if not find, then return -1
    cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;

}
int main() {
//    freopen(&quot;/Volumes/hujiawei/Users/hujiawei/workspace/appleworkspace/algorithmworks/Exp1-2/Exp1-2/in3.txt&quot;, &quot;rt&quot;, stdin);//
    cin &amp;gt;&amp;gt; t;
    while(t--&amp;gt;0){
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;
//        int graph[n+1][MAX_NODE];
        for (int i=0; i&amp;lt;= n; i++) {
            for (int j=0; j&amp;lt;= n; j++) {
                graph[i][j]=0;
            }
        }
        int edges[n+1], nodes[n+1], state[n+1];
        for (int i=0; i&amp;lt;= n; i++) {
            edges[i]=0;
            state[i]=0;
            nodes[i]=i;
        }
        int temp = m;
        while(temp--&amp;gt;0){
            cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
            graph[min(a, b)][max(a,b)]=1;
//          graph[a][b]=1;
//          graph[b][a]=1;//just save half a&amp;lt;=b
            edges[a]++;
            edges[b]++;
        }
        bool flag = verify(edges, k, m, nodes, state);

        if (!flag) {//must not be achieved!!!
            cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
        }else{
            greedyFind(edges,nodes/*,graph*/);
        }
    }

    return 0;
}&lt;/pre&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 21 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-21-87009-b4822702a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-21-87009-b4822702a.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>选择合适的推荐系统模型</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;&lt;img class=&quot;alignright&quot; id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/9de852c7fc29681d649e4da5cb2281e5.jpg&quot; width=&quot;250&quot; height=&quot;270&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们的机器学习工程师一直忙于构建GraphLab farm。这篇博客针对一个特殊的应用难题：怎样从 &lt;a href=&quot;https://dato.com/products/create/docs/graphlab.toolkits.recommender.html?__hstc=8457130.bb311fd08c8f8aff1469489de1cfa928.1429598917018.1429598917018.1429604555369.2&amp;amp;__hssc=8457130.13.1429604555369&amp;amp;__hsfp=4211374419&quot;&gt;GraphLab Create recommender toolkit&lt;/a&gt; 的众多模型和选项中选择一个合适的推荐模型。&lt;/p&gt;
&lt;p&gt;这完全取决于你现有的数据类型以及你评估结果的方式。&lt;/p&gt;
&lt;p&gt;（注意：这里使用的是GraphLab Create 0.9 的API。GraphLab Create 1.0 支持通过&lt;a href=&quot;https://dato.com/products/create/docs/generated/graphlab.recommender.create.html?__hstc=8457130.bb311fd08c8f8aff1469489de1cfa928.1429598917018.1429598917018.1429604555369.2&amp;amp;__hssc=8457130.1315131713151319.1429604555369&amp;amp;__hsfp=4211374419#graphlab.recommender.create&quot;&gt;recommender.create()&lt;/a&gt; 来智能选择推荐模型。你可以通过 &lt;a href=&quot;https://dato.com/products/create/docs/&quot;&gt;1.0 的API文档&lt;/a&gt;查看recommender toolkit中模型的最新说明。此外，这个论坛列出了&lt;a href=&quot;http://forum.dato.com/discussion/610/api-changes-in-graphlab-create-v1-0-toolkits?__hstc=8457130.bb311fd08c8f8aff1469489de1cfa928.1429598917018.1429604555369.1429606046033.3&amp;amp;__hssc=8457130.2.1429606046033&amp;amp;__hsfp=4211374419&quot;&gt;从版本0.9.1到版本1.0的API变动&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;如果你的数据是隐性的，也就是数据中仅有用户和物品间的交互信息（没有用户对物品的打分），那么，你可以选择使用Jaccard相似度的 &lt;a href=&quot;https://dato.com/products/create/docs/generated/graphlab.recommender.item_similarity_recommender.ItemSimilarityRecommender.html?__hstc=8457130.bb311fd08c8f8aff1469489de1cfa928.1429598917018.1429604555369.1429606046033.3&amp;amp;__hssc=8457130.3.1429606046033&amp;amp;__hsfp=4211374419#graphlab.recommender.item_similarity_recommender.ItemSimilarityRecommender&quot;&gt;ItemSimilarityModel&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;# 当数据中仅包含&#39;user_id&#39;和&#39;item_id&#39;两个属性的时候
# recommender.create 方法会自动选择
# `method=‘item_similarity’` and `similarity_type=’jaccard’`
&amp;gt;&amp;gt;&amp;gt; itemsim_jaccard_model = graphlab.recommender.create(data)&lt;/pre&gt;
&lt;p&gt;当数据为隐反馈时，你可以通过增加一个均为1的目标列把数据伪装成显性数据。若要构建追求排序性能的模型，请见下文。&lt;/p&gt;
&lt;p&gt;如果数据是显性的，也就是观测数据中包含用户的真实评分，那么你可以从多个模型中选择。使用cosine或Pearson相似度的ItemSimilarityModel可以包含评分信息。此外，&lt;a href=&quot;https://dato.com/products/create/docs/graphlab.toolkits.recommender.html#factorization-recommenders&quot;&gt;MatrixFactorizationModel&lt;/a&gt;（矩阵分解模型）、&lt;a href=&quot;https://dato.com/products/create/docs/graphlab.toolkits.recommender.html#factorization-recommenders&quot;&gt;FactorizationModel&lt;/a&gt;（分解模型） 以及 &lt;a href=&quot;http://products/create/docs/generated/graphlab.recommender.LinearRegressionModel.html&quot;&gt;LinearRegressionModel&lt;/a&gt;（线性回归模型） 都支持评分预测。&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;# 此时数据中包含 3 列，‘user_id’，‘item_id’ 以及 ‘rating’
&amp;gt;&amp;gt;&amp;gt; itemsim_cosine_model = graphlab.recommender.create(data, 
       target=’rating’, 
       method=’item_similarity’, 
       similarity_type=’cosine’)
&amp;gt;&amp;gt;&amp;gt; factorization_machine_model = graphlab.recommender.create(data, 
       target=’rating’, 
       method=’factorization_model’)&lt;/pre&gt;
&lt;p&gt;如果你的目标是提高排序性能，你可以在设置 ranking_regularization 的情况下使用 ItemSimilarityModel（物品相似度模型）、MatrixFactorizationModel（矩阵分解模型） 、 FactorizationModel（分解模型）。排序正则化选项设置后会随机地选取一些未观测数据并把它们的目标评分设成一个偏负面的值。ranking_regularization 值在0到1之间。该值越大，负样本的权重也就越大。如果你想使用 分解模型来处理隐反馈数据，你应该首先给 SFrame 增加一列全为1的值把它变成显性数据，再将 unobserved_rating_value 设为 0 来运行排序正则化。这里明确地设定 unobserved_raint_value 是有必要的，因为模型默认把未知评分设为已知评分的 5% 分位数；当所有已知评分均为 1 时，它们的 5% 分位数也是 1，不能把它作为未知评分的目标值。&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;# 数据中包含一列真实的评分
&amp;gt;&amp;gt;&amp;gt; ranking_regularization_model = graphlab.recommender.create(data, 
       target=’rating’, 
       method=’matrix_factorization’, 
       ranking_regularization=1.0)

# 数据中包含一列“伪造”的评分，全部为 1
&amp;gt;&amp;gt;&amp;gt; rr_model_for_implicit_data = graphlab.recommender.create(data, 
       target=’rating’, 
       method=’matrix_factorization, 
       ranking_regularization=1, 
       unobserved_rating_value=0)&lt;/pre&gt;
&lt;p&gt;如果你想对评分数据进行评分预测，那么选择MatrixFactorizationModel, FactorizationModel, or LinearRegressionModel的任意一个。从统计学的角度看，这三个模型都是明确地对评分建模的回归模型。换句话说，观测评分被建模为一些项的加权组合，其中权重（包括一些项，也被成为因子）通过训练数据得到。这几个模型都可以很方便地引入用户或物品特征。&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;# 当数据包含一列目标值时，默认的方法是 matrix_factorization
&amp;gt;&amp;gt;&amp;gt; matrix_factorization_model = graphlab.recommender.create(data, 
       target=’rating’)
&amp;gt;&amp;gt;&amp;gt; linear_model = graphlab.recommender.create(data, 
       target=’rating’, 
       method=’linear_model’)
&amp;gt;&amp;gt;&amp;gt; factorization_machine_model = graphlab.recommender.create(data, 
       target=’rating’, 
       method=’factorization_model’)&lt;/pre&gt;
&lt;p&gt;LinearRegressionModel 假设评分是用户特征、物品特征、用户偏置、物品流行度偏置的线性组合。MatrixFactorizationModel 和 FactorizationModel 还可以引入两个向量的内积项，其中一个向量表示用户对一组隐性特征的喜好程度，另一个向量表示物品对这组隐性特征的包含程度。这些通常被称为隐性因子并且可以从观测数据中自动学习得到。FactorizationModel （分解模型）较 MatrixFactorizationModel（矩阵分解模型） 更进一步， 考虑到了这些隐性因子与边际特征的交互影响。一般来说，FactorizationModel（分解模型） 最有效，但也最难训练（由于它的威力和灵活性）。LinearRegressionModel（线性回归模型） 最简单，训练速度也最快，但没有考虑用户物品间的交互作用。&lt;/p&gt;
&lt;p&gt;我们建议你从 &lt;a href=&quot;https://dato.com/products/create/docs/graphlab.toolkits.recommender.html#factorization-recommenders&quot;&gt;MatrixFactorizationModel（矩阵分解模型）&lt;/a&gt; 开始，如果这个模型运行时间过长，可以降级使用 &lt;a href=&quot;http://products/create/docs/generated/graphlab.recommender.LinearRegressionModel.html&quot;&gt;LinearRegressionModel&lt;/a&gt;（线性回归模型）。或者，如果你认为需要使用二阶交互项来加强模型，可以升级使用 &lt;a href=&quot;https://dato.com/products/create/docs/graphlab.toolkits.recommender.html#factorization-recommenders&quot;&gt;FactorizationModel（分解模型）&lt;/a&gt;。注意，这些模型都带有几个正则化参数如：n_factors 和 regularization，这些参数会影响测试时的预测精度。这对于 FactorizationModel&lt;a href=&quot;https://dato.com/products/create/docs/graphlab.toolkits.recommender.html#factorization-recommenders&quot;&gt;（分解模型）&lt;/a&gt; 尤为有用。建议你使用超参数搜索函数 &lt;a href=&quot;https://dato.com/products/create/docs/generated/graphlab.toolkits.model_parameter_search.html#graphlab.toolkits.model_parameter_search&quot;&gt;graphlab.toolkits.model_params_search()&lt;/a&gt; 来调整这些参数。&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;# 这里强调了回归模型中一些有用的参数选项
&amp;gt;&amp;gt;&amp;gt; custom_mf_model = graphlab.recommender.create(data, 
       target=’rating’, 
       n_factors=20, 
       regularization=0.2, 
       linear_regularization=0.1)
&amp;gt;&amp;gt;&amp;gt; custom_fm_model = graphlab.recommender.create(data, 
       target=’rating’, 
       method=’factorization_model’, 
       n_factors=50, 
       regularization=0.5, 
       max_iterations=100)
&amp;gt;&amp;gt;&amp;gt; custom_linear_model = graphlab.recommender.create(data, 
       target=’rating’, 
       method=’linear_model’, 
       regularization=0.01)&lt;/pre&gt;
&lt;p&gt;如果目标评分是二值的，也就是它们的值是赞或踩标签，在使用回归模型（LinearRegressionModel, MatrixFactorizationModel, FactorizationModel）时，设置输入参数‘binary_targets = True’。&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;&amp;gt;&amp;gt;&amp;gt; logistic_regression_model = graphlab.recommender.create(data, 
       target=’rating’, 
       method=’linear_model’, 
       binary_targets=True)&lt;/pre&gt;
&lt;p&gt;使用MatrixFactorizationModel（矩阵分解模型） 和 FactorizationModel （分解模型）训练得到的隐性因子可以作为特征用于其他的任务。在这种情形下，使用非负因子有利于提高可解释性。简单地使用‘nmf=True’作为输入参数，分解类型的模型就会学习非负因子。&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;&amp;gt;&amp;gt;&amp;gt; nmf_model = graphlab.recommender.create(data, 
       target=’rating’, 
       method=’matrix_factorization’, 
       nmf=True)&lt;/pre&gt;
&lt;p&gt;已有数据？数据问题？&lt;/p&gt;
&lt;p&gt;最后，有几个影响推荐系统性能的常见数据问题。第一，如果观测数据非常稀疏，也就是仅包含大量用户的一个或两个观测数据，那么任何一个模型都不会比 popularity 或 item_means 这些基准模型效果好。这种情况下，将稀疏用户和物品剔除后重试也许有用。另外，重新检查数据收集和清理过程，看错误是否源于此处。尽可能对每个用户每个物品获取更多的观测数据。&lt;/p&gt;
&lt;p&gt;另一个经常会遇到的问题是把使用数据当做评分。与显性评分位于一个很好的线性区间（例如，[0, 5]）不同，使用数据可能被严重扭曲。例如，在 Million Song 数据集中，一个用户播放一首歌超过 16000 次。所有的模型都很难应对这种严重扭曲的目标。解决的方法是对使用数据进行归类。例如，把播放次数超过 50 次映射成最高评分 5 。你也可以把播放次数转成二进制，例如播放超高两次的为 1，反之为 0。&lt;/p&gt;
&lt;p&gt;好吧，都记住了吗？是的，我们一半都记不住。下面这幅粗略的信息图一目了然地显示了所有的提示。愉快地探索吧，勇敢地推荐系统研究者！&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/80a4b4486df3643cd0434e03edb63893.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;欲了解更多信息，请查看我们最新的 &lt;a href=&quot;https://dato.com/learn/?__hstc=8457130.bb311fd08c8f8aff1469489de1cfa928.1429598917018.1429604555369.1429606046033.3&amp;amp;__hssc=8457130.5053.1429606046033&amp;amp;__hsfp=4211374419&quot;&gt;copious documentation&lt;/a&gt;，让我们知道你的想法。&lt;/p&gt;

        
        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者： &lt;a href=&quot;http://blog.jobbole.com/author/wuwenmin/&quot;&gt;吴文敏&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a href=&quot;http://blog.jobbole.com/author/wuwenmin/&quot;&gt;
					&lt;/a&gt;
	&lt;/div&gt;
	&lt;p&gt;&lt;/p&gt;
	&lt;p&gt;
		&lt;a style=&quot;text-decoration: none;&quot; href=&quot;http://blog.jobbole.com/author/wuwenmin/&quot;&gt;查看吴文敏的更多文章 »&lt;/a&gt;
	&lt;/p&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
	
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Wed, 20 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-20-86959-580bc7b77.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-20-86959-580bc7b77.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>计算机中的黑魔法：尾递归</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;h1&gt;&lt;span style=&quot;color: #888888&quot;&gt;前言&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;声明：本文是作者在学习SICP有关过程抽象知识的理解，由于书中的语句有些晦涩，所以将作者的理解共享给大家希望帮助一些朋友。原书对尾递归并没有太多介绍，但是这里给出了详细的解释。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888&quot;&gt;目前是凌晨1点48分。嗯，刚刚写完这篇日志。忍不住想说点什么，或许是当一个不好的书托。可能这些内容对于很多人来说是没有用的，他们甚至会鄙视我写的东西，觉得为这些东西花费时间不值得。对于这些人，我想说，每一个对计算机有着浓厚兴趣的人，都有着一个想够彻头彻尾了解每天超过12小时面对的这台机器是如何工作的愿望。像SICP和CSAPP这种书无疑是枯燥的，你可能一天看下来，仔细品读的话只能看三四页，但是如何你能够真正理解这几页书的内涵的话，那么收获将是巨大的。从去年5月份，陈大师推荐我读CSAPP之后，我才真正找到了那种看上去很枯燥，但是一读起来就欲罢不能的书。这类的书读起来都很困难，如果你带着很强的功利性来读的话，是不可能读下去的。我想了想，能够支撑我一天坐在那琢磨这几页书中说的核心意思的力量，就是来源于我真正想了解计算机是怎么工作的，获取这种信息对于我来说是非常快乐的，这种感觉是奇妙的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ab56a77632a24837eb629fed5f2507df.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（图来自 www.cs.uni.edu）&lt;/p&gt;
&lt;h1&gt;函数和计算过程的区别&lt;/h1&gt;
&lt;p&gt;函数一般是指数学上面的一种计算形式，偏向说明语句，描述如何根据给定的一个或者几个参数去计算出一个值。如SICP中关于求一个数的平方根的函数，我们在该函数的说明中可以推断出关于平方根的一些具体性质和一般性的事实，但是我们无从得知计算一个数的平方根的具体方法。你可能会说，求平方根不就是开根号么。可是你有没有想过，[开根号]也仅仅是一个说明性的语句，具体怎么计算你还是不知道的。延伸到计算机当中的函数，其实和数学上面的函数意义是相同的，我们只不过是换成高级程序设计语言来写我们对于一个函数一般性事实的说明，实际上我们并没有给出一个具体的计算过程。比如求平方根，如果我们是调用math.h中的库函数来求的话：sqrt(x*1.0)，这种形式只是一个说明型的语句，我们利用这个语句来指导计算机去计算，但实际上这个函数并没有提供具体的计算过程。计算机当中的解释器就负责把这种说明性语句转化成真正的计算过程(期待到时候写一个解释器哇)。&lt;/p&gt;
&lt;p&gt;其实感觉这两者的区别就和写作文一样，一个是提纲，另外一个是具体的内容。&lt;/p&gt;
&lt;h1&gt;触摸过程的抽象&lt;/h1&gt;
&lt;p&gt;SICP中关于求一个数平方根的问题，使用的是牛顿的逐步逼近法则，不断的去求新的猜测值，直到结果满足一定的精度结束。求平方根是一个大的功能，想要完成这个大的功能还需要一些小的功能来辅助。&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;我们把整个一个大的计算过程分为几个部分，每一个部分都能单独完成其中的一个小功能，他们组合起来又能够完成最终的功能。所谓过程的抽象和C++中的面向对象思想是和相像的，没准都是一个东西，我不太确定，但是过程的抽象说的都是一个意思，就是对创造者来说重要的是过程的实现，而对于使用者来说，过程的抽象可以屏蔽掉内部实现的细节，从而减轻使用者的负担，只关心这个过程的『黑盒』能够做什么。所以这样一来就增加了程序局部的可替换性，因为对于实现一个功能来说，过程的内部实现可以多种多样。&lt;/p&gt;
&lt;h2&gt;抽象1—局部名字&lt;/h2&gt;
&lt;p&gt;大家都知道调用函数或者过程的时候，有的时候需要传递一些合适的参数，在调用的过程中，函数的形式参数的名字对我们来说其实并不重要，相对于使用者来说确实是这样。但是对于过程的设计者来说，形式参数的名字，或者说是局部变量的名字，对于整个过程能够正常的执行就非常重要了。这也是过程抽象当中的一个细节，计算机把一些复杂的东西封装到了内部。&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;为什么说约束变量的名字对于过程的执行是非常重要的呢。很直接的一个理解就是：局部变量可以在作用域内可以屏蔽同名的全局变量，类比一下，约束变量在相应的作用域内会屏蔽同名的自由变量。&lt;/p&gt;
&lt;pre&gt;    (define (good-enough? guess x)
    ((abs (- (square guess) x)) 0.001))&lt;/pre&gt;
&lt;p&gt;举例来讲，在上面这个过程中，guess 和 x 是good-enough?这个过程的两个约束变量，&amp;lt;, abs, -, square都是自由变量。自由变量是和环境相关的，他们已经有了确定的意义来保持他们正常的执行，但是如果现在guess这个约束变量改名为abs，将会导致abs这个自由变量的意义被约束变量屏蔽，过程中出现的abs为约束变量，不在具有自由变量当中求绝对值的功能。&lt;/p&gt;
&lt;p&gt;所以说，对于过程的设计者而言，过程实现中，自由变量和约束变量的名字都在哪些地方用到是一个非常需要注意的地方，一个过程的顺利执行依赖于约束变量和自由变量的名字不同，并且自由变量的意义正确。&lt;/p&gt;
&lt;h2&gt;抽象2—内部定义和块结构&lt;/h2&gt;
&lt;p&gt;这一点的抽象就更加为我们过程的使用者考虑，它也是一种局部的概念，像局部变量一样，只有内部的作用域可以访问并且识别他，作用域之外是不知道作用域内有这个东西的。只不过我们之前抽象的是变量，这次抽象的是过程。&lt;/p&gt;
&lt;p&gt;sicp中的求平方根的过程，和用户交互的仅仅是一个接口sqrt，其中的子过程的具体实现细节都被抽象一个个的【黑箱】。但是对于用户来说，这些实现计算过程的黑箱是没有用的，只会扰乱他们的思维，并且在用户想自定义一个与这些黑箱中的某一个同名的过程的时候是不被允许的（不能在一个作用域内定义两个同名的过程），这些有着具体功能的【黑箱】污染了全局名字环境。&lt;/p&gt;
&lt;p&gt;对于一个结构局部的东西，我们更好的方式是把他们定义在这个结构的内部，而不应该放在全局环境范围内，因为你需要的并不是其他人也需要的，如果其他人不需要这些东西，那么他们的命名就有可能造成过程调用的命名冲突，造成程序混乱。&lt;/p&gt;
&lt;p&gt;scheme支持在过程的内部再定义新的过程，内部新定义的过程只能在内部作用域可见，外部是不知道有内部这些过程的定义的。&lt;/p&gt;
&lt;pre&gt;(define (sqrt x)
    (define (good-enough? guess x)
        (abs (- (square guess) x)) 0.001)) 

    (define (improve guess x)
        (average guess (/ x guess))) 

    (define (sqrt-iter guess x)
        (if (good-enough? guess x) guess
        (sqrt-iter (improve guess x) x))) 

(sqrt-iter 1.0 x))&lt;/pre&gt;
&lt;p&gt;根据上面的例子来看，我们就把求平方根这计算过程中用到的小黑箱一个一个的都定义在了这个过程的内部 ，过程之外看不到他们，这种嵌套的过程定义就叫做块结构。局部化使程序更清晰,减少全局名字,减少相互干扰。除此之外，由于将一些黑箱进行了内部定义之后，还有一处可以改进的地方，就是参数x的使用。由于局部过程的形参都在x的作用域内，我们就不必在局部过程中再传递x了，直接调用即可。相对于局部过程来说，现在的X由原来的约束变量，变为现在的自由变量了。&lt;/p&gt;
&lt;h1&gt;计算过程的多重形态&lt;/h1&gt;
&lt;p&gt;我们可以用不同种类的过程来完成同一件任务，那么在真正的程序设计的时候，我们应该选用哪种方式呢？按照之前数据结构的角度来看，我们有两个指标：时间复杂度和空间复杂度。不同的过程自然有这不同的计算过程，我们应该通过衡量两个不同计算过程的上述的两个指标来确定最终选择哪一个作为最终版本。这就要求我们能够准确的观察到任何一个过程执行的过程和执行的效果，以及执行过程中所耗费的各种资源。&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;在以实例说明递归和迭代的区别之前，首先要明确这样两个概念的区别：&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;假如现在有一个求n的阶乘的需求：我们有正向和逆向两种思路来求得结果&lt;/p&gt;
&lt;h2&gt;反向（线性递归）&lt;/h2&gt;
&lt;p&gt;算法如下：n! = n &lt;em&gt; (n-1)! = n &lt;/em&gt; (n-1) &lt;em&gt; (n-2)!…..2 &lt;/em&gt; 1 = n * (n-1)!&lt;/p&gt;
&lt;p&gt;有了具体的计算进程，我们可以根据它来写一个过程&lt;/p&gt;
&lt;pre&gt;(define (factorial n)
     (if (= n 1)
        1
    (* n (factorial (- n 1)))))&lt;/pre&gt;
&lt;p&gt;PS:可以看出这个过程在定义的时候调用了自身&lt;/p&gt;
&lt;p&gt;假设现在我们想计算（factorial 6），根据shceme的代换模型推导，可以得出如下计算进程图示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/25da0b10dcd44f2b21b9b4f55ce481c5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;从图示中我们可以看出，当我们计算（factorial 6）的时候，根据计算过程的定义，要执行(* 6 (factorial (- 6 1)))。通过这一个复合的表达式我们就可以看出来，（factorial 6）这一步的计算结果并没有计算出来，它需要计算下一个状态来辅助它得出（factorial 6）这一步的计算结果。因为本次的计算没有完成要进行其他的运算来辅助完成，那么本次的运算就算是中断了，既然中断了，我们就需要保存现场，保存此次计算过程目前的状态（变量等等一些资源）以便当下一状态的计算结果出来之后能够顺利的衔接上，从而计算出最终的结果。以后的计算进程仍然是按照这种形式来的，直到遇到边界。&lt;/p&gt;
&lt;p&gt;到此为止，我们就知道，这个计算进程是一个递归计算进程，因为他在计算的进程当中需要耗费资源来保存所需的一些情况和信息。递归的计算过程，想必大家都很熟悉，它是属于一种推迟求值的方式，不能够立即求出最终结果，每一次的计算都依赖于它的子计算状态，直到遇到边界之后，才逐层返回计算结果，最终返回到起点，求出结果。可以说，递归是从后向前推的过程，计算最后一步，也就是最终结果，也许就会需要倒数第一步的结果，那么就计算倒数第一步，以此类推，直到计算到第一步的时候，利用题设条件可以得到第一步的最终结果，然后再把计算结果逐层返回到起点，也就是计算最后一步的位置，得到最终结果。（是深度优先搜索的道理）但是如果计算的次数太多，迭代的层数太深，留给过程的栈空间很有可能会溢出，造成爆栈。&lt;/p&gt;
&lt;p&gt;那么，根据上面的时间和空间复杂度两个指标，我们将评判这个用递归计算阶乘的计算进程的好坏。（其实计算进程就是算法，有木有？！）&lt;/p&gt;
&lt;p&gt;我们可以看到，如果n是6，那么一共要计算12次，如果n是5那么要计算10次，所以相应的时间复杂度大致可以估算为O(N)。从（factorial 6）递归到边界最低端的时候，一共进行了6次迭代，随着n的增加，递归的次数会随n线性增长，所需的内存空间也会线性增长。所以控件复杂度应为O(N)。&lt;/p&gt;
&lt;p&gt;综上所述，整个递归计算进程已经评价完毕，准确的说，这是一个线性递归计算进程。&lt;/p&gt;
&lt;h2&gt;正向（线性迭代）&lt;/h2&gt;
&lt;p&gt;算法：n!就是从1开始一直累乘到n，最终的累乘结果等于n!&lt;/p&gt;
&lt;p&gt;根据这个算法，写出一个过程如下&lt;/p&gt;
&lt;pre&gt;(define (factorial n) 
    (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
    (if ( counter max-count) product
        (fact-iter (* counter product) (+ counter 1)
                max-count)))&lt;/pre&gt;
&lt;p&gt;从上述的过程我们可以看出，它在定义的时候，也是调用了自身。计算（factorial 6）的进算进程图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ecf75d30b77c4e3917accee286c35c89.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据图示可以看出，每一次的计算状态由三个变量来维持，而且每一个状态的计算和其他状态的计算是独立的，各自状态的计算结果不依赖于其他的状态。每一次状态的计算都是干脆利落的执行，下一个状态计算所需要的资源通过参数传递，上一个状态计算完成之后就没有任何用处了，它不必为前一个或者后一个状态来保存什么有用的信息，需要的信息都根据参数传递给新的状态了。而且，在不断计算的过程中，由于把所需要的值的信息一直作为参数传递，一旦得出了最终的结果，不用像递归一样，把计算结果返回给上一个状态，而是直接返回给一开始的调用者。过程的调用都是在栈空间来开辟内存的，根据以上计算特点，上一个状态计算结束之后可以立即销毁之前所用的栈空间，避免了栈溢出。&lt;/p&gt;
&lt;p&gt;这样的计算进程，很容易就可以看出来，时间复杂度O(N)，空间复杂度，因为每次计算只需要保存三个变量，它不随n的变化而变化，则为O（1）,常量级。不仅仅是这个计算过程这样，计算机当中所有的计算的空间复杂度都应该在常数级别下完成，因为内存空间是有限的。&lt;/p&gt;
&lt;p&gt;上述计算进程被称为迭代，如果单就这个实例来说，应该是线性迭代进程。&lt;/p&gt;
&lt;h2&gt;迭代和递归的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在迭代的进程中，每个状态计算所需的信息都保存在了几个变量中，通过参数传递过去，不需要额外的再开辟栈空间来保存一些隐含的信息。但是递归是需要的，还存在着栈溢出的危险。&lt;/li&gt;
&lt;li&gt;在迭代的进程中，如果我们丢失了一些状态的话，可以从任意一个状态开始继续进行计算，因为计算所需要的信息都保存在几个变量中，即使只剩下中间的一个状态，我们也能够根据计算进程把所有丢失的状态全都算出来。但是如果是递归的话，如果某一个状态的信息丢失了，那么即使它的子状态算出了结果返回给它，因为丢失了一些必要的状态信息，使得计算进程是无法进行下去的。&lt;/li&gt;
&lt;li&gt;虽然两者都在定义过程的时候调用了自身，但是很显然，迭代的定义过程属于用递归的方式定义过程。递归属于递归计算进程。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;黑魔法终极奥义：尾递归&lt;/h2&gt;
&lt;p&gt;一般的编程语言都是通过循环等一些复杂的结构来描述迭代的，但是在scheme中却可以用递归的形式来描述迭代。&lt;/p&gt;
&lt;p&gt;观察上面两个求阶乘的过程，我们可以看到。虽然两者都是调用了自身，用了递归的形式来定义整个过程，表面上都属于递归调用，但是，『递归』版本中，在最后的递归调用之后，还需要进行乘n的操作才算作是完成了此次计算，而在 [迭代]版本中，递归的调用属于最后一个方法，末尾的递归调用执行完，此次的计算也就执行完了，属于该过程的最后一个操作，这就是”尾递归”。尾递归相对于正常的递归来说，它的递归调用处于过程最后，之前过程计算积累的信息对于接下来的这次递归调用的最终结果没有任何影响，那么本次过程调用存储在栈内的信息就可以完全清除。把空间留给之后的递归过程使用。所以说，这意味着如果使用尾递归的方式，是可以实现无限递归的。&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;至于把正常递归转化为尾递归的方法，我觉得比较直接的做法就是，正常递归是从后向前考虑，如果写尾递归，那么就把问题从前向后考虑，并且把所需的信息当做参数传递。&lt;/p&gt;
&lt;p&gt;一般来讲，虽然在过程定义上，看起来是递归的，但是实际的计算进程的原理有可能是迭代的，也有可能是递归的，因为，迭代的计算是可以用尾递归来进行定义的。&lt;/p&gt;

        
        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者： &lt;a href=&quot;http://blog.jobbole.com/author/fengzixu/&quot;&gt;fengzi&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a href=&quot;http://blog.jobbole.com/author/fengzixu/&quot;&gt;
			&lt;img src=&quot;/images/jobbole.com/e1037e4e1ba3ce135548c7795f9c150c.jpg&quot; alt=&quot;fengzi&quot; width=&quot;45&quot; height=&quot;80&quot; class=&quot;photo&quot;&gt;		&lt;/a&gt;
	&lt;/div&gt;
	&lt;p&gt;一个普通大学的CS本科生，伪ACmer，喜欢操作系统，喜欢linux,讨厌复制粘贴，喜欢看书，喜欢一切经过思考和积累才能够获得成果的知识。欢迎大家来我的博客逛逛(新浪微博&lt;a href=&quot;http://weibo.com/3626507773&quot;&gt;@徐疯子&lt;/a&gt;)(Blog&lt;a href=&quot;http://fengzixu.net&quot;&gt;疯子徐&#39;s blog&lt;/a&gt;)&lt;/p&gt;
	&lt;p&gt;
		&lt;a style=&quot;text-decoration: none;&quot; href=&quot;http://blog.jobbole.com/author/fengzixu/&quot;&gt;查看fengzi的更多文章 »&lt;/a&gt;
	&lt;/p&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
	
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Tue, 19 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-19-86996-7a00a97f3.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-19-86996-7a00a97f3.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>老鸟向新手讲解各种编程比赛</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;过去十年间我一直在参加各种编程比赛。我参加了很多比赛，更重要的是，我参加了很多不同类型的比赛。我的冒险起始于经典算法，之后我转到了优化问题。目前我主要参加机器学习竞赛（作为兼职），我也参加一些只是为了好玩的比赛。&lt;/p&gt;
&lt;p&gt;考虑到有像我这样广泛经历的人并不多，我想我应该写一个编程（算法?）竞赛流行类型的（相对）简短的总结。这不是一个完整的列表，我只关注了那些最流行的，并且在我看来最有用的竞赛。&lt;/p&gt;
&lt;p&gt;这篇文章的结构是以竞赛类型，而不是竞赛网站为导向的。也就是说，我把有相似特征的网站/竞赛归类，而不是呈现给你们仅仅加了我个人描述的随机网站。由于有些网站提供了几种类型的竞赛，我不得不多次列出它们。&lt;/p&gt;
&lt;p&gt;如果你对编程竞赛的世界感到困惑或者好奇，这篇文章能给你关于这个主题的详尽综述。&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;经典算法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;有时又被称为二元问题或（带贬义地）消遣算法。提供给你问题陈述，你的目标是写一个通常很短的程序：读入输入，处理它并输出计算结果。任何东西都是按给定的问题陈述来的。大部分情况下， 你要提交程序源代码，源代码在远程服务器上编译并运行一些对你隐藏的数据。下面要提到的所有竞赛的共性是：你的程序要么被认为是完全正确的，要么是完全错误的，没有中间结果。&lt;/p&gt;
&lt;p&gt;经典算法竞赛通常是编程竞赛的入门级别。难度从答案显而易见，到只有问题作者知道怎么解答。对于新手程序员，它们提供了小的挑战，是很棒的实践练习。在更高的级别，它们需要高度的专注，很好的长期记忆，解决问题的技巧以及很深的专业知识。如果能在这些竞赛中做好，你会开发出很多可以轻易迁移到计算机科学其他领域的技能。前提是你专注于开发纯粹的技能，而不是把时间花在解决成百上千的问题上以期望今后能遇到类似的问题。（&lt;span style=&quot;color: #808080;&quot;&gt;译者注：即不要用题海战术&lt;/span&gt;）&lt;/p&gt;
&lt;h4&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 20px; font-style: normal; font-weight: bold; line-height: 30px;&quot;&gt;竞赛联盟&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;有两个主要的网站定期举办比赛。第一个是 &lt;a href=&quot;https://www.topcoder.com/community/data-science/&quot;&gt;TopCoder&lt;/a&gt;（以下简称 TC），举办Single Round Matches (SRMs)。第二个是 &lt;a href=&quot;http://codeforces.com/&quot;&gt;CodeForces&lt;/a&gt;（以下简称 CF）。&lt;/p&gt;
&lt;p&gt;这两个网站很相似。一周会举办几次比赛（即将到来的比赛链接：&lt;a href=&quot;http://www.topcoder.com/community/events/&quot;&gt;TC&lt;/a&gt;，&lt;a href=&quot;http://codeforces.com/contests&quot;&gt;CF&lt;/a&gt;）。比赛持续大约2小时。每种比赛都会用几个（TC 是 3 个，CF 是 5 个）为这轮特别准备的原创经典问题（通常，对于所有的比赛都是这样的，但我想澄清这一点）。你只需提交程序源代码，程序会在服务器上远程执行。你的程序如果想要被认定为正确，需要在指定的时间和内存限制下运行，产生正确的输出。美中不足的是，只有在比赛结束后你才知道你的解答是否正确。当这轮结束后，你的排名会得到更新（类似于 ELO 等级系统），这很准确地代表了你目前的水平。赛前参赛者（根据他们当前的排名）会被分到两个不同的赛区，每个赛区使用根据参赛者水平量身定做的题目。另外，赛后你可以看其他人的提交，也会发布题解（解释了问题的正确解答）。所有的题目会添加到练习区，这样你之后就可以去解答那些你在比赛中未能解答的题目。这使得这两个网站成为完美的训练场。&lt;/p&gt;
&lt;p&gt;这些是它们的相似之处，那么不同之处是什么呢？TC 最大的缺点是（除了糟糕的管理，不过那又是另一回事了）它使用一个陈旧的 Java applet 来用于竞赛。尽管这使得参加第一次比赛比它应有的过程更复杂（TC 那设计糟糕的网站对此也没什么帮助），但从长远看来比“HTML5”界面也差不了多少。另一个差别是两个网站的题目的关注点稍有不同。TC 上的任务通常向解决问题倾斜，有时候甚至像谜题，然而 CF 就包含很多基于数据结构的“filler”（缺乏想象力的代名词）问题，但这主要取决于问题作者。基于我的经历，TC问题（平均来说）稍微有趣些，但CF的题目更为多样—主要是因为CF每轮有更多的题目。两种竞赛都有一个特性是提供寻找他人代码中bug的机会（如果你成功找到了会获得额外的分数），但是CF对此的设计很可怕&lt;span style=&quot;color: #008000;&quot;&gt;（译者注：表示对此没什么感受）&lt;/span&gt;，最好就是完全忽略它。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 20px; font-style: normal; font-weight: bold; line-height: 30px;&quot;&gt;年度现场比赛&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有四个大的比赛：&lt;a href=&quot;https://code.google.com/codejam&quot;&gt;Google Code Jam&lt;/a&gt;、&lt;a href=&quot;https://www.facebook.com/hackercup&quot;&gt;Facebook Hacker Cup&lt;/a&gt;、&lt;a href=&quot;https://contest.yandex.com/?lang=en&quot;&gt;Yandex.Algorithm&lt;/a&gt; 和 &lt;a href=&quot;http://tco15.topcoder.com/algorithm/&quot;&gt;TopCoder Open&lt;/a&gt;（算法组）。它们都很相似。为了取得现场比赛资格，你要参加一系列在线资格赛。通常都是采用淘汰赛的形式，在随后的每一轮减少参赛者的数量。通常对参赛者的身份没有限制（除非你的国家不幸在美国的禁止入境名单上）。每一轮时间都很短，在 90 分钟和 3 个小时之间，只考经典的二元问题（&lt;span style=&quot;color: #808080;&quot;&gt;译者注：前面提过了&lt;/span&gt;）。如果你取得了现场赛资格，他们会支付你参加比赛的交通食宿费用。他们也给获胜者奖金，但对于大多数人来说，你能赢得的最重要的东西是旅行本身，或者（通过比赛）在顶级 IT 公司找到工作。&lt;/p&gt;
&lt;p&gt;这些比赛之间有一些小的差别（题目质量、晋级结构、提交系统），但是它们有两个共性：晋级其中任何一个都非常难（如果你没有两年经验，想要取得资格是极不可能的，即使你聪明且专注于此）。另一个是&lt;a href=&quot;http://en.wikipedia.org/wiki/Gennady_Korotkevich&quot;&gt;有个人&lt;/a&gt;（Gennady Korotkevich）在2014年赢了个大满贯。考虑到所有这些竞赛要想赢都有很高不确定性，这是一个难以置信的壮举。&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;span style=&quot;color: #008000;&quot;&gt;&lt;b&gt;伯乐在线补充：&lt;/b&gt;Gennady Korotkevich&lt;b&gt;，&lt;/b&gt;年仅11岁时便参加国际信息学奥林比克竞赛，创造了最年轻选手的记录。在2007-2012年间，总共取得6枚奥赛金牌；2013年美国计算机协会编程比赛冠军队成员；2014年Facebook黑客杯冠军得主。截止目前，稳居俄编程网站Codeforces声望第一的宝座，在TopCoder算法竞赛中暂列榜眼位置。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 20px; font-style: normal; font-weight: bold; line-height: 30px;&quot;&gt;在线判题系统&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;这些有很多了，仅列举一些：&lt;a href=&quot;http://www.spoj.com/&quot;&gt;SPOJ&lt;/a&gt;、&lt;a href=&quot;http://uva.onlinejudge.org/&quot;&gt;UVA&lt;/a&gt;、&lt;a href=&quot;http://acm.timus.ru/&quot;&gt;Timus&lt;/a&gt;。通常，它们主要作为过去的ICPC（&lt;span style=&quot;color: #808080;&quot;&gt;译者注：即 International Collegiate Programming Contest， 国际大学生程序设计竞赛&lt;/span&gt;）竞赛题的存档。&lt;/p&gt;
&lt;p&gt;你在这些网站上花时间原因不外乎那么几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一：你觉得你很不擅长某些类型的题目，因此你在寻找一些很难的特定题目（如果你以成为世界前100为目标，这甚至都不应该发生），而你在其他地方又找不到这些题目。&lt;/li&gt;
&lt;li&gt;二：你参加了一场比赛，那些题目被上传到判题网站，你想继续尝试那些你没有解决的问题或者尝试其他的解题方案。&lt;/li&gt;
&lt;li&gt;三：你的算法课老师很懒，他讨厌他的工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;优化问题&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这种问题的标准例子是&lt;a href=&quot;http://en.wikipedia.org/wiki/Travelling_salesman_problem&quot;&gt;旅行商问题&lt;/a&gt;。这些问题以这样的事实来刻画：根据你的解答质量，你得到不同的分数。它们被（或者至少应该被）设计为不可能获得完美的分数。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;有优化问题的比赛通常持续时间更长，因此相对于经典算法比赛关注于不同的技能集，比如心理耐力、时间管理或开箱即用的问题解决技能。通常，优化问题要求你是个多面手，但是你不必擅长于任何特定领域。它们也更接近于做实际研究，因此如果你想把你的职业生涯与软件开发以外的事绑在一起，尝试下它们是个不错的主意。&lt;/p&gt;
&lt;h4&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 20px; font-style: normal; font-weight: bold; line-height: 30px;&quot;&gt;马拉松比赛&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;不幸的是，没有太多地方可以让你磨练在这个领域的技能。Topcoder有&lt;a href=&quot;http://community.topcoder.com/longcontest/?module=ViewActiveContests&quot;&gt;马拉松比赛&lt;/a&gt;，但是他们不再定期举办比赛，几年前他们还这么做。在马拉松比赛旗下举办的大多数比赛都属于机器学习类（在下面描述），例外是年度Top Coder Open比赛中的马拉松类，现场决赛和资格赛都使用优化问题。有传闻他们想重新举办定期比赛，但到目前为止什么都还没改变。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;幸运的是，尽管没有太多比赛，TopCCoder有过去比赛题目的&lt;a href=&quot;http://community.topcoder.com/longcontest/?module=ViewPractice&quot;&gt;存档&lt;/a&gt;。因此如果你的目标只是更擅长优化题目，你可以练习这些旧题。好处是你可以获得所有的优胜解答，另外在这些过去的比赛对应的论坛通常有个“发布你的方法”的帖子。&lt;/p&gt;
&lt;p&gt;在一些其他的比赛中你也可以遇到优化问题。但不幸的是，我不认为有可以与马拉松比赛相提并论的。这个类别下最流行的比赛大概是 &lt;a href=&quot;http://azspcs.com/&quot;&gt;Al Zimmermann 的编程比赛&lt;/a&gt;，但是那的题目都很浅，不太有趣。&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;机器学习&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;有时被错误地称为数据科学。这是个有大把钱的地方，因为对专长于机器学习的人才有很大需求，至少相比对经典和优化问题人才的需求来说是很大的。&lt;/p&gt;
&lt;p&gt;相比其他类型的比赛，机器学习需要的知识要多得多，通常来说也不那么有趣。尽管如此，这些比赛仍然是目前在这个领域获得一些亲身实践经历的最容易的方式。如果你需要一些动力，记住需要机器学习技能的工作的报酬在整个IT界是最高的那部分。&lt;/p&gt;
&lt;h4&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 20px; font-style: normal; font-weight: bold; line-height: 30px;&quot;&gt;马拉松比赛（再次）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我可能提到上面提过的网站/比赛。Topcoder把优化和机器学习问题结合到一个类别。说得更准确些，在某些时候马拉松比赛类别扩张为包括机器学习比赛。&lt;/p&gt;
&lt;p&gt;Topcoder的机器学习比赛通常只以一种方式呈现。由于整个Topcoder是个众包平台（再加上围绕它构建的社区），客户有时候会有用“简单的”软件竞赛不能解决的问题。在有些情况下，他们处理的问题可以包装成一个机器学习比赛，给表现最好的方案大笔钱。由于机器学习比赛仍然是马拉松比赛，整个提交系统的运行方式是和优化问题完全一样的。唯一的差别是机器学习比赛通常不加入到练习区。&lt;/p&gt;
&lt;h4&gt;Kaggle&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://www.kaggle.com/&quot;&gt;Kaggle&lt;/a&gt;是个很大程度围绕机器学习比赛而建的网站。我将关注于TC和Kaggle的差别。最大的差别是在Kaggle你只提交你的解答的输出，而不是整个程序，这有很多后果。首先，你获得整个数据集，对你可以使用的语言/库没有限制。没有任何时间限制，如果你想（并且支付得起）的话，甚至可以用整个集群来计算结果。由于大家不用提交源代码，在比赛结束后你不能查看解答。另一方面，社区要活跃得多。当比赛还在进行中时，会有很多“练习赛”，在此人们分享他们的解答。Kaggle的比赛时间也长得多（对于有奖金的比赛通常是两个月）。&lt;/p&gt;
&lt;p&gt;总体来说，两个网站各自为稍有不同的目的服务，各有利弊。对于那些对高层知识，而不是各种机器学习技术如何工作的低层内部机制更感兴趣的人来说，Kaggle应该更为友好，然而TC对于有很强算法背景的人来说可能更好。另一种看待这个的方式是，在Kaggle你（通常）使用工具，而在马拉松比赛你（通常）写你自己的工具。&lt;/p&gt;
&lt;h2&gt;欢乐24小时&lt;/h2&gt;
&lt;p&gt;15年前，第一届 &lt;a href=&quot;http://ch24.org/&quot;&gt;Challenge24&lt;/a&gt; 组织起来了。我不会细说它的历史，因为实际上我也所知甚少。但我会把这个比赛描述为“24小时的疯狂”。它是在布达佩斯举办的年度团队比赛。你有大概15道题。题目的范围很广：经典、优化、TCP/IP之上的游戏、计算机视觉、声音分析、谜题，以及难以用语言描述的东西。你把你自己的硬件带到比赛现场，整个比赛是离线完成的。老实说，这是我参加过的最有趣的比赛。即使我上次参加时发烧了，我还是要这么说。&lt;/p&gt;
&lt;p&gt;Challenge24启发了&lt;a href=&quot;https://deadline24.pl/home-en/&quot;&gt;Deadline24&lt;/a&gt;，这反过来又启发了&lt;a href=&quot;http://marathon24.com/&quot;&gt;Marathon24&lt;/a&gt;（两个都是在波兰举行）。它们是Challenge24的简化版，但仍然很有趣。它们没有大量题目，通常只有三个游戏，每轮游戏和比赛同时开始。例如，过去的一个游戏是30个选手同时玩经典的行星游戏。&lt;/p&gt;
&lt;p&gt;由于只有有限数量的队伍会被邀请到决赛，这些比赛都举办在线资格赛。由于这些比赛并没有其他年度比赛那么流行，实际上即使没有任何显著的算法（甚至编程）背景，也很可能获得其中之一的资格。&lt;/p&gt;
&lt;p&gt;还有一个额外的年度比赛值得一提，它和这些24小时比赛有些类似：&lt;a href=&quot;http://ipsc.ksp.sk/&quot;&gt;互联网问题解决比赛&lt;/a&gt;。这个比赛也有很多任务，尽管它们更类似于经典算法。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;其他&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;还有两个大的网站被遗漏了。第一个是&lt;a href=&quot;http://www.codechef.com/&quot;&gt;CodeChef&lt;/a&gt;，有两种不同的月度比赛。两种都是经典算法比赛。另一个是&lt;a href=&quot;https://www.hackerrank.com/domains&quot;&gt;HackerRank&lt;/a&gt;，混合了在线判题系统和举办各种类型一次性比赛的功能。我遗漏它们的原因是，它们都因问题陈述的质量低而闻名（&lt;span style=&quot;color: #808080;&quot;&gt;译者注：译者使用过这两个网站，对此没什么感受&lt;/span&gt;）。考虑到有大量的其他比赛，通常你应该避开它们（尽管有很少的例外）。&lt;/p&gt;
&lt;p&gt;如果你还在读高中，对你来说最重要的比赛是&lt;a href=&quot;http://www.ioinformatics.org/index.shtml&quot;&gt;国际信息学奥林匹克竞赛&lt;/a&gt;。每个国家都有其国家级奥林匹克竞赛和自己的规则。在很多国家，在国家级奥林匹克竞赛中表现优异是进入理想大学最简单和安全的方式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://icpc.baylor.edu/&quot;&gt;国际大学生程序设计竞赛&lt;/a&gt;（ACM/ICPC）是“经典算法”比赛，在这里所有的比赛/网站中历史最为悠久。它是面向学生的团队比赛。每支队由同一大学的3个人组成。ICPC的主要目标是编程在世界范围的普及。这是用复杂的多层获得资格制度和（同样复杂）的合格标准来达成的。这保证了世界总决赛中队伍的多样性。作为取舍，根据你所在的地方，要想晋级世界总决赛，要么是令人吃惊地容易，要么是近乎不可能。专门针对ICPC来练习可能是把你的时间投资在编程竞赛中最坏的方式，因为它提升的技能集是最窄的，唯一的例外是你生活在那些“幸运的”（&lt;span style=&quot;color: #808080;&quot;&gt;译者注：即容易晋级的&lt;/span&gt;）地区。&lt;/p&gt;
&lt;p&gt;鼓励奖要颁给&lt;a href=&quot;https://helloworldopen.com/&quot;&gt;Hello World Open&lt;/a&gt;，因为它创造了年度最大的扯淡比赛，有着很成功的销售计划。如果你仔细看，你会看到在比赛发起后，他们甚至在&lt;a href=&quot;http://en.wikipedia.org/wiki/Competitive_programming#Long-term&quot;&gt;维基&lt;/a&gt;页面加入了他们的链接。我猜如果你制作收入最高的手机app，你会很熟悉这个。说真的，Topcoder应该向他们学习。&lt;/p&gt;
&lt;p&gt;另一个鼓励奖要颁给 &lt;a href=&quot;https://www.imaginecup.com/&quot;&gt;Imagine Cup&lt;/a&gt;。我参加了四次Imagine Cup。两次作为参赛者，一次作为裁判，最后一次作为助手。这些年我看着它从一个聚集多个不同领域（初创，数字艺术，算法/人工智能）的学生的创新年度比赛，到微软产品的傻逼公关。裁判经常是因政治原因被挑选的，绝对不能胜任他们的工作。并且所有没有直接&lt;strong&gt;&lt;/strong&gt;&lt;label&gt;促进&lt;/label&gt;微软产品的类别都停掉了。事实是，Imagine Cup是我参加过的最好的现场赛事。同时，现在我不会推荐任何人参加它们。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://projecteuler.net/&quot;&gt;Project Euler&lt;/a&gt;是一种特别的在线判题系统（偏重数学），这在于你以编程为工具来解决问题，而不在于它本身。如果你真的想在没有时间压力的情况下做一些编程题，我建议你做Project Euler，而不是我提到的其他判题系统。另外，由于它很流行，如果你在某个问题卡住了，在网上找到一些帮助要容易得多。&lt;/p&gt;
&lt;h3&gt;编注：推荐几篇相关文章&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/18653/&quot;&gt;编程竞赛题和逻辑题网站大集合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/78575/&quot;&gt;搞定编程竞赛必知哪10个算法？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/33834/&quot;&gt;参加编程竞赛对实际工作的用处&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

        
        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者： &lt;a href=&quot;http://blog.jobbole.com/author/demolpc/&quot;&gt;demo&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a href=&quot;http://blog.jobbole.com/author/demolpc/&quot;&gt;
					&lt;/a&gt;
	&lt;/div&gt;
	&lt;p&gt;新浪微博：&lt;a href=&quot;http://weibo.com/u/1802379047&quot;&gt;@shuyechengying&lt;/a&gt;&lt;/p&gt;
	&lt;p&gt;
		&lt;a style=&quot;text-decoration: none;&quot; href=&quot;http://blog.jobbole.com/author/demolpc/&quot;&gt;查看demo的更多文章 »&lt;/a&gt;
	&lt;/p&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
	
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Mon, 18 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-18-86799-7596a32e0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-18-86799-7596a32e0.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>一大波你可能不知道的 Linux 网络工具</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;如果要在你的系统上监控网络，那么使用命令行工具是非常实用的，并且对于 Linux 用户来说，有着许许多多现成的工具可以使用，如： nethogs, ntopng, nload, iftop, iptraf, bmon, slurm, tcptrack, cbm, netwatch, collectl, trafshow, cacti, etherape, ipband, jnettop, netspeed 以及 speedometer。&lt;/p&gt;
&lt;p&gt;鉴于世上有着许多的 Linux 专家和开发者，显然还存在其他的网络监控工具，但在这篇教程中，我不打算将它们所有包括在内。&lt;/p&gt;
&lt;p&gt;上面列出的工具都有着自己的独特之处，但归根结底，它们都做着监控网络流量的工作，只是通过各种不同的方法。例如 nethogs 可以被用来展示每个进程的带宽使用情况，以防你想知道究竟是哪个应用在消耗了你的整个网络资源； iftop 可以被用来展示每个套接字连接的带宽使用情况，而像 nload 这类的工具可以帮助你得到有关整个带宽的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) nethogs&lt;/strong&gt;&lt;br&gt;
nethogs 是一个免费的工具，当要查找哪个 PID (注：即 process identifier，进程 ID) 给你的网络流量带来了麻烦时，它是非常方便的。它按每个进程来分组带宽，而不是像大多数的工具那样按照每个协议或每个子网来划分流量。它功能丰富，同时支持 IPv4 和 IPv6，并且我认为，若你想在你的 Linux 主机上确定哪个程序正消耗着你的全部带宽，它是来做这件事的最佳的程序。&lt;/p&gt;
&lt;p&gt;一个 Linux 用户可以使用 nethogs 来显示每个进程的 TCP 下载和上传速率，可以使用命令 nethogs eth0 来监控一个指定的设备，上面的 eth0 是那个你想获取信息的设备的名称，你还可以得到有关正在传输的数据的传输速率信息。&lt;/p&gt;
&lt;p&gt;对我而言， nethogs 是非常容易使用的，或许是因为我非常喜欢它，以至于我总是在我的 Ubuntu 12.04 LTS 机器中使用它来监控我的网络带宽。&lt;/p&gt;
&lt;p&gt;例如要想使用混杂模式来嗅探，可以像下面展示的命令那样使用选项 -p：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;nethogs -p wlan0&lt;/pre&gt;
&lt;p&gt;假如你想更多地了解 nethogs 并深入探索它，那么请毫不犹豫地阅读我们做的关于这个网络带宽监控工具的整个教程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2) nload&lt;/strong&gt;&lt;br&gt;
nload 是一个控制台应用，可以被用来实时地监控网络流量和带宽使用情况，它还通过提供两个简单易懂的图表来对流量进行可视化。这个绝妙的网络监控工具还可以在监控过程中切换被监控的设备，而这可以通过按左右箭头来完成。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/c2f1c78f607470e83a0f313f946a2f71.jpg&quot; width=&quot;690&quot; height=&quot;441&quot;&gt;&lt;/p&gt;
&lt;p&gt;正如你在上面的截图中所看到的那样，由 nload 提供的图表是非常容易理解的。nload 提供了有用的信息，也展示了诸如被传输数据的总量和最小/最大网络速率等信息。&lt;/p&gt;
&lt;p&gt;而更酷的是你只需要直接运行 nload 这个工具就行，这个命令是非常的短小且易记的：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;nload&lt;/pre&gt;
&lt;p&gt;我很确信的是：我们关于如何使用 nload 的详细教程将帮助到新的 Linux 用户，甚至可以帮助那些正寻找关于 nload 信息的老手。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3) slurm&lt;/strong&gt;&lt;br&gt;
slurm 是另一个 Linux 网络负载监控工具，它以一个不错的 ASCII 图来显示结果，它还支持许多按键用以交互，例如 c 用来切换到经典模式， s 切换到分图模式， r 用来重绘屏幕， L 用来启用 TX/RX 灯（注：TX，发送流量；RX，接收流量） ，m 用来在经典分图模式和大图模式之间进行切换， q 退出 slurm。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e7b3b0c277dac16ce10dde70a0f22bb6.jpg&quot; width=&quot;690&quot; height=&quot;430&quot;&gt;&lt;/p&gt;
&lt;p&gt;在网络负载监控工具 slurm 中，还有许多其它的按键可用，你可以很容易地使用下面的命令在 man 手册中学习它们。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;man slurm&lt;/pre&gt;
&lt;p&gt;slurm 在 Ubuntu 和 Debian 的官方软件仓库中可以找到，所以使用这些发行版本的用户可以像下面展示的那样，使用 apt-get 安装命令来轻松地下载它：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;sudo apt-get install slurm&lt;/pre&gt;
&lt;p&gt;我们已经在一个教程中对 slurm 的使用做了介绍，不要忘记和其它使用 Linux 的朋友分享这些知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4) iftop&lt;/strong&gt;&lt;br&gt;
当你想显示连接到网卡上的各个主机的带宽使用情况时，iftop 是一个非常有用的工具。根据 man 手册，iftop 在一个指定的接口或在它可以找到的第一个接口（假如没有任何特殊情况，它应该是一个对外的接口）上监听网络流量，并且展示出一个表格来显示当前的一对主机间的带宽使用情况。&lt;/p&gt;
&lt;p&gt;通过在虚拟终端中使用下面的命令，Ubuntu 和 Debian 用户可以在他们的机器中轻易地安装 iftop：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;sudo apt-get install iftop&lt;/pre&gt;
&lt;p&gt;在你的机器上，可以使用下面的命令通过 yum 来安装 iftop：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;yum -y install iftop&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5) collectl&lt;/strong&gt;&lt;br&gt;
collectl 可以被用来收集描述当前系统状态的数据，并且它支持如下两种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录模式&lt;/li&gt;
&lt;li&gt;回放模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录模式 允许从一个正在运行的系统中读取数据，然后将这些数据要么显示在终端中，要么写入一个或多个文件或一个套接字中。&lt;/p&gt;
&lt;p&gt;回放模式&lt;/p&gt;
&lt;p&gt;根据 man 手册，在这种模式下，数据从一个或多个由记录模式生成的数据文件中读取。&lt;/p&gt;
&lt;p&gt;Ubuntu 和 Debian 用户可以在他们的机器上使用他们默认的包管理器来安装 colletcl。下面的命令将为他们做这个工作：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;sudo apt-get install collectl&lt;/pre&gt;
&lt;p&gt;还可以使用下面的命令来安装 collectl， 因为对于这些发行版本（注：这里指的是用 yum 作为包管理器的发行版本），在它们官方的软件仓库中也含有 collectl：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;yum install collectl&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6) Netstat&lt;/strong&gt;&lt;br&gt;
Netstat 是一个用来监控传入和传出的网络数据包统计数据的接口统计数据命令行工具。它会显示 TCP 连接 (包括上传和下行)，路由表，及一系列的网络接口（网卡或者SDN接口）和网络协议统计数据。&lt;/p&gt;
&lt;p&gt;Ubuntu 和 Debian 用户可以在他们的机器上使用默认的包管理器来安装 netstat。Netsta 软件被包括在 net-tools 软件包中，并可以在 shell 或虚拟终端中运行下面的命令来安装它：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;sudo apt-get install net-tools&lt;/pre&gt;
&lt;p&gt;CentOS, Fedora, RHEL 用户可以在他们的机器上使用默认的包管理器来安装 netstat。Netstat 软件被包括在 net-tools 软件包中，并可以在 shell 或虚拟终端中运行下面的命令来安装它：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;yum install net-tools&lt;/pre&gt;
&lt;p&gt;运行下面的命令使用 Netstat 来轻松地监控网络数据包统计数据：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;netstat&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/6f56487e9f940fe3420c82d984610744.jpg&quot; width=&quot;690&quot; height=&quot;522&quot;&gt;&lt;/p&gt;
&lt;p&gt;更多的关于 netstat 的信息，我们可以简单地在 shell 或终端中键入 man netstat 来了解：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;man netstat&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e1c065436f7f13a9c64a0933ba84b104.jpg&quot; width=&quot;690&quot; height=&quot;522&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7) Netload&lt;/strong&gt;&lt;br&gt;
netload 命令只展示一个关于当前网络荷载和自从程序运行之后传输数据总的字节数目的简要报告，它没有更多的功能。它是 netdiag 软件的一部分。&lt;/p&gt;
&lt;p&gt;我们可以在 fedora 中使用 yum 来安装 Netload，因为它在 fedora 的默认软件仓库中。但假如你运行的是 CentOS 或 RHEL，则我们需要安装 rpmforge 软件仓库。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;# yum install netdiag&lt;/pre&gt;
&lt;p&gt;Netload 是默认仓库中 netdiag 的一部分，我们可以轻易地使用下面的命令来利用 apt 包管理器安装 netdiag：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;$ sudo apt-get install netdiag&lt;/pre&gt;
&lt;p&gt;为了运行 netload，我们需要确保选择了一个正在工作的网络接口的名称，如 eth0, eh1, wlan0, mon0等，然后在 shell 或虚拟终端中运行下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;$ netload wlan2&lt;/pre&gt;
&lt;p&gt;注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8) Nagios&lt;/strong&gt;&lt;br&gt;
Nagios 是一个领先且功能强大的开源监控系统，它使得网络或系统管理员可以在服务器的各种问题影响到服务器的主要事务之前，发现并解决这些问题。 有了 Nagios 系统，管理员便可以在一个单一的窗口中监控远程的 Linux 、Windows 系统、交换机、路由器和打印机等。它会显示出重要的警告并指出在你的网络或服务器中是否出现某些故障，这可以间接地帮助你在问题发生前就着手执行补救行动。&lt;/p&gt;
&lt;p&gt;Nagios 有一个 web 界面，其中有一个图形化的活动监视器。通过浏览网页 http://localhost/nagios/ 或 http://localhost/nagios3/ 便可以登录到这个 web 界面。假如你在远程的机器上进行操作，请使用你的 IP 地址来替换 localhost，然后键入用户名和密码，我们便会看到如下图所展示的信息：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/5c2fe408aae364c18167f19e1fc15a4f.jpg&quot; width=&quot;690&quot; height=&quot;378&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9) EtherApe&lt;/strong&gt;&lt;br&gt;
EtherApe 是一个针对 Unix 的图形化网络监控工具，它仿照了 etherman 软件。它支持链路层、IP 和 TCP 等模式，并支持以太网, FDDI, 令牌环, ISDN, PPP, SLIP 及 WLAN 设备等接口，以及一些封装格式。主机和连接随着流量和协议而改变其尺寸和颜色。它可以过滤要展示的流量，并可从一个文件或运行的网络中读取数据包。&lt;/p&gt;
&lt;p&gt;在 CentOS、Fedora、RHEL 等 Linux 发行版本中安装 etherape 是一件容易的事，因为在它们的官方软件仓库中就可以找到 etherape。我们可以像下面展示的命令那样使用 yum 包管理器来安装它：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;yum install etherape&lt;/pre&gt;
&lt;p&gt;我们也可以使用下面的命令在 Ubuntu、Debian 及它们的衍生发行版本中使用 apt 包管理器来安装 EtherApe ：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;sudo apt-get install etherape&lt;/pre&gt;
&lt;p&gt;在 EtherApe 安装到你的系统之后，我们需要像下面那样以 root 权限来运行 etherape：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;sudo etherape&lt;/pre&gt;
&lt;p&gt;然后， etherape 的 图形用户界面 便会被执行。接着，在菜单上面的 捕捉 选项下，我们可以选择 模式(IP，链路层，TCP) 和 接口。一切设定完毕后，我们需要点击 开始 按钮。接着我们便会看到类似下面截图的东西：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3cb9becaf5111f8dd81ee92853e7a2aa.jpg&quot; width=&quot;636&quot; height=&quot;503&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10) tcpflow&lt;/strong&gt;&lt;br&gt;
tcpflow 是一个命令行工具，它可以捕捉 TCP 连接(流)的部分传输数据，并以一种方便协议分析或除错的方式来存储数据。它重构了实际的数据流并将每个流存储在不同的文件中，以备日后的分析。它能识别 TCP 序列号并可以正确地重构数据流，不管是在重发还是乱序发送状态下。&lt;/p&gt;
&lt;p&gt;通过 apt 包管理器在 Ubuntu 、Debian 系统中安装 tcpflow 是很容易的，因为默认情况下在官方软件仓库中可以找到它。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;$ sudo apt-get install tcpflow&lt;/pre&gt;
&lt;p&gt;我们可以使用下面的命令通过 yum 包管理器在 Fedora 、CentOS 、RHEL 及它们的衍生发行版本中安装 tcpflow：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;# yum install tcpflow&lt;/pre&gt;
&lt;p&gt;假如在软件仓库中没有找到它或不能通过 yum 包管理器来安装它，则我们需要像下面展示的那样从 http://pkgs.repoforge.org/tcpflow/ 上手动安装它：&lt;/p&gt;
&lt;p&gt;假如你运行 64 位的 PC：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;# yum install --nogpgcheck http://pkgs.repoforge.org/tcpflow/tcpflow-0.21-1.2.el6.rf.x86_64.rpm&lt;/pre&gt;
&lt;p&gt;假如你运行 32 位的 PC：&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;# yum install --nogpgcheck http://pkgs.repoforge.org/tcpflow/tcpflow-0.21-1.2.el6.rf.i686.rpm&lt;/pre&gt;
&lt;p&gt;我们可以使用 tcpflow 来捕捉全部或部分 tcp 流量，并以一种简单的方式把它们写到一个可读的文件中。下面的命令就可以完成这个事情，但我们需要在一个空目录中运行下面的命令，因为它将创建诸如 x.x.x.x.y-a.a.a.a.z 格式的文件，运行之后，只需按 Ctrl-C 便可停止这个命令。&lt;/p&gt;
&lt;pre class=&quot;brush: c; gutter: true&quot;&gt;$ sudo tcpflow -i eth0 port 8000&lt;/pre&gt;
&lt;p&gt;注意：请将上面的 eth0 替换为你想捕捉的网卡接口名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11) IPTraf&lt;/strong&gt;&lt;br&gt;
IPTraf 是一个针对 Linux 平台的基于控制台的网络统计应用。它生成一系列的图形，如 TCP 连接的包/字节计数、接口信息和活动指示器、 TCP/UDP 流量故障以及局域网内设备的包/字节计数。&lt;/p&gt;
&lt;p&gt;在默认的软件仓库中可以找到 IPTraf，所以我们可以使用下面的命令通过 apt 包管理器轻松地安装 IPTraf：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo apt-get install iptraf&lt;/pre&gt;
&lt;p&gt;我们可以使用下面的命令通过 yum 包管理器轻松地安装 IPTraf：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;# yum install iptraf&lt;/pre&gt;
&lt;p&gt;我们需要以管理员权限来运行 IPTraf，并带有一个有效的网络接口名。这里，我们的网络接口名为 wlan2，所以我们使用 wlan2 来作为参数：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo iptraf wlan2&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/04da36ada415da6f1be2e08492baf0ce.jpg&quot; width=&quot;679&quot; height=&quot;487&quot;&gt;&lt;/p&gt;
&lt;p&gt;开始通常的网络接口统计，键入：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;# iptraf -g&lt;/pre&gt;
&lt;p&gt;查看接口 eth0 的详细统计信息，使用：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;# iptraf -d eth0&lt;/pre&gt;
&lt;p&gt;查看接口 eth0 的 TCP 和 UDP 监控信息，使用：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;# iptraf -z eth0&lt;/pre&gt;
&lt;p&gt;查看接口 eth0 的包的大小和数目，使用：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;# iptraf -z eth0&lt;/pre&gt;
&lt;p&gt;注意:请将上面的 eth0 替换为你的接口名称。你可以通过运行ip link show命令来检查你的接口。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12) Speedometer&lt;/strong&gt;&lt;br&gt;
Speedometer 是一个小巧且简单的工具，它只用来绘出一幅包含有通过某个给定端口的上行、下行流量的好看的图。&lt;/p&gt;
&lt;p&gt;在默认的软件仓库中可以找到 Speedometer ，所以我们可以使用下面的命令通过 yum 包管理器轻松地安装 Speedometer：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;# yum install speedometer&lt;/pre&gt;
&lt;p&gt;我们可以使用下面的命令通过 apt 包管理器轻松地安装 Speedometer：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo apt-get install speedometer&lt;/pre&gt;
&lt;p&gt;Speedometer 可以简单地通过在 shell 或虚拟终端中执行下面的命令来运行：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ speedometer -r wlan2 -t wlan2&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/9c5541c4d9c7ee198f1fc6b99ad998a1.jpg&quot; width=&quot;690&quot; height=&quot;381&quot;&gt;&lt;/p&gt;
&lt;p&gt;注：请将上面的 wlan2 替换为你想要使用的网络接口名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;13) Netwatch&lt;/strong&gt;&lt;br&gt;
Netwatch 是 netdiag 工具集里的一部分，它也显示当前主机和其他远程主机的连接情况，以及在每个连接中数据传输的速率。&lt;/p&gt;
&lt;p&gt;我们可以使用 yum 在 fedora 中安装 Netwatch，因为它在 fedora 的默认软件仓库中。但若你运行着 CentOS 或 RHEL ， 我们需要安装 rpmforge 软件仓库。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;# yum install netwatch&lt;/pre&gt;
&lt;p&gt;Netwatch 是 netdiag 的一部分，可以在默认的软件仓库中找到，所以我们可以轻松地使用下面的命令来利用 apt 包管理器安装 netdiag：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo apt-get install netdiag&lt;/pre&gt;
&lt;p&gt;为了运行 netwatch， 我们需要在虚拟终端或 shell 中执行下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo netwatch -e wlan2 -nt&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/0648d8336641c10b4e85edf40eae907d.jpg&quot; width=&quot;690&quot; height=&quot;381&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;14) Trafshow&lt;/strong&gt;&lt;br&gt;
Trafshow 同 netwatch 和 pktstat 一样，可以报告当前活动的连接里使用的协议和每个连接中数据传输的速率。它可以使用 pcap 类型的过滤器来筛选出特定的连接。&lt;/p&gt;
&lt;p&gt;我们可以使用 yum 在 fedora 中安装 trafshow ，因为它在 fedora 的默认软件仓库中。但若你正运行着 CentOS 或 RHEL ， 我们需要安装 rpmforge 软件仓库。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;# yum install trafshow&lt;/pre&gt;
&lt;p&gt;Trafshow 在默认仓库中可以找到，所以我们可以轻松地使用下面的命令来利用 apt 包管理器安装它：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo apt-get install trafshow&lt;/pre&gt;
&lt;p&gt;为了使用 trafshow 来执行监控任务，我们需要在虚拟终端或 shell 中执行下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo trafshow -i wlan2&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/a552705a37b039a2b7284f0653834b57.jpg&quot; width=&quot;671&quot; height=&quot;470&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了专门监控 tcp 连接，如下面一样添加上 tcp 参数：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo trafshow -i wlan2 tcp&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/f314d7ea6920bbc8b3f3cfee521d3712.jpg&quot; width=&quot;671&quot; height=&quot;470&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;15) Vnstat&lt;/strong&gt;&lt;br&gt;
与大多数的其他工具相比，Vnstat 有一点不同。实际上它运行着一个后台服务或守护进程，并时刻记录着传输数据的大小。另外，它可以被用来生成一个网络使用历史记录的报告。&lt;/p&gt;
&lt;p&gt;我们需要开启 EPEL 软件仓库，然后运行 yum 包管理器来安装 vnstat。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;# yum install vnstat&lt;/pre&gt;
&lt;p&gt;Vnstat 在默认软件仓库中可以找到，所以我们可以使用下面的命令运行 apt 包管理器来安装它：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo apt-get install vnstat&lt;/pre&gt;
&lt;p&gt;不带有任何选项运行 vnstat 将简单地展示出从该守护进程运行后数据传输的总量。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ vnstat&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/57746c2cd3ec5f712d0eea99160cba22.jpg&quot; width=&quot;606&quot; height=&quot;131&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了实时地监控带宽使用情况，使用 ‘-l’ 选项(live 模式)。然后它将以一种非常精确的方式来展示上行和下行数据所使用的带宽总量，但不会显示任何有关主机连接或进程的内部细节。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ vnstat -l&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/4582b462f5f802171eb01fee0c8fdede.jpg&quot; width=&quot;644&quot; height=&quot;72&quot;&gt;&lt;/p&gt;
&lt;p&gt;完成了上面的步骤后，按 Ctrl-C 来停止，这将会得到如下类型的输出：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/c8e6c68cf2f534a44f227232b05a69c0.jpg&quot; width=&quot;671&quot; height=&quot;487&quot;&gt;&lt;br&gt;
&lt;strong&gt;16) tcptrack&lt;/strong&gt;&lt;br&gt;
tcptrack 可以展示 TCP 连接的状态，它在一个给定的网络端口上进行监听。tcptrack 监控它们的状态并展示出排序且不断更新的列表，包括来源/目标地址、带宽使用情况等信息，这与 top 命令的输出非常类似 。&lt;/p&gt;
&lt;p&gt;鉴于 tcptrack 在软件仓库中，我们可以轻松地在 Debian、Ubuntu 系统中从软件仓库使用 apt 包管理器来安装 tcptrack。为此，我们需要在 shell 或虚拟终端中执行下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo apt-get install tcptrack&lt;/pre&gt;
&lt;p&gt;我们可以通过 yum 在 fedora 中安装它，因为它在 fedora 的默认软件仓库中。但若你运行着 CentOS 或 RHEL 系统，我们需要安装 rpmforge 软件仓库。为此，我们需要运行下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;# wget http://apt.sw.be/redhat/el6/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm
# rpm -Uvh rpmforge-release*rpm
# yum install tcptrack&lt;/pre&gt;
&lt;p&gt;注：这里我们下载了 rpmforge-release 的当前最新版本，即 0.5.3-1，你总是可以从 rpmforge 软件仓库中下载其最新版本，并请在上面的命令中替换为你下载的版本。&lt;/p&gt;
&lt;p&gt;tcptrack 需要以 root 权限或超级用户身份来运行。执行 tcptrack 时，我们需要带上要监视的网络接口 TCP 连接状况的接口名称。这里我们的接口名称为 wlan2，所以如下面这样使用：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;sudo tcptrack -i wlan2&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/c1f91f7fcb32e32ddfbe523ce4e1513c.jpg&quot; width=&quot;671&quot; height=&quot;470&quot;&gt;&lt;/p&gt;
&lt;p&gt;假如你想监控特定的端口，则使用：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;# tcptrack -i wlan2 port 80&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/555d99b9d9706e35be4f0aef4e53264a.jpg&quot; width=&quot;671&quot; height=&quot;470&quot;&gt;&lt;/p&gt;
&lt;p&gt;请替换上面的 80 为你想要监控的端口号。注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;17) CBM&lt;/strong&gt;&lt;br&gt;
CBM （ Color Bandwidth Meter） 可以展示出当前所有网络设备的流量使用情况。这个程序是如此的简单，以至于都可以从它的名称中看出其功能。CBM 的源代码和新版本可以在 http://www.isotton.com/utils/cbm/ 上找到。&lt;/p&gt;
&lt;p&gt;鉴于 CBM 已经包含在软件仓库中，我们可以简单地使用 apt 包管理器从 Debian、Ubuntu 的软件仓库中安装 CBM。为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo apt-get install cbm&lt;/pre&gt;
&lt;p&gt;我们只需使用下面展示的命令来在 shell 窗口或虚拟终端中运行 cbm：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ cbm&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/d6ddcd9d9570c8561139a8e75557d58b.jpg&quot; width=&quot;671&quot; height=&quot;453&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18) bmon&lt;/strong&gt;&lt;br&gt;
Bmon （ Bandwidth Monitoring） ，是一个用于调试和实时监控带宽的工具。这个工具能够检索各种输入模块的统计数据。它提供了多种输出方式，包括一个基于 curses 库的界面，轻量级的HTML输出，以及 ASCII 输出格式。&lt;/p&gt;
&lt;p&gt;bmon 可以在软件仓库中找到，所以我们可以通过使用 apt 包管理器来在 Debian、Ubuntu 中安装它。为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo apt-get install bmon&lt;/pre&gt;
&lt;p&gt;我们可以使用下面的命令来运行 bmon 以监视我们的网络状态：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ bmon&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/9c4ffee24597330f8a38972be62b827d.jpg&quot; width=&quot;671&quot; height=&quot;589&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;19) tcpdump&lt;/strong&gt;&lt;br&gt;
TCPDump 是一个用于网络监控和数据获取的工具。它可以为我们节省很多的时间，并可用来调试网络或服务器的相关问题。它可以打印出在某个网络接口上与布尔表达式相匹配的数据包所包含的内容的一个描述。&lt;/p&gt;
&lt;p&gt;tcpdump 可以在 Debian、Ubuntu 的默认软件仓库中找到，我们可以简单地以 sudo 权限使用 apt 包管理器来安装它。为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo apt -get install tcpdump&lt;/pre&gt;
&lt;p&gt;tcpdump 也可以在 Fedora、CentOS、RHEL 的软件仓库中找到。我们可以像下面一样通过 yum 包管理器来安装它：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;# yum install tcpdump&lt;/pre&gt;
&lt;p&gt;tcpdump 需要以 root 权限或超级用户来运行，我们需要带上我们想要监控的 TCP 连接的网络接口名称来执行 tcpdump 。在这里，我们有 wlan2 这个网络接口，所以可以像下面这样使用：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo tcpdump -i wlan2&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/53d264ac456414fb07d0bb9dbeece31b.jpg&quot; width=&quot;690&quot; height=&quot;500&quot;&gt;&lt;/p&gt;
&lt;p&gt;假如你只想监视一个特定的端口，则可以运行下面的命令。下面是一个针对 80 端口(网络服务器)的例子：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo tcpdump -i wlan2 &#39;port 80&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/0b136b946916009ef37401770de84bea.jpg&quot; width=&quot;690&quot; height=&quot;467&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;20) ntopng&lt;/strong&gt;&lt;br&gt;
[ntopng][20] 是 ntop 的下一代版本。它是一个用于展示网络使用情况的网络探头，在一定程度上它与 top 针对进程所做的工作类似。ntopng 基于 libpcap 并且它以可移植的方式被重写，以达到可以在每一个 Unix 平台 、 MacOSX 以及 Win32 上运行的目的。&lt;/p&gt;
&lt;p&gt;为了在 Debian，Ubuntu 系统上安装 ntopng，首先我们需要安装 编译 ntopng 所需的依赖软件包。你可以通过在一个 shell 窗口或一个虚拟终端中运行下面的命令来安装它们：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo apt-get install libpcap-dev libglib2.0-dev libgeoip-dev redis-server wget libxml2-dev build-essential checkinstall&lt;/pre&gt;
&lt;p&gt;现在，我们需要像下面一样针对我们的系统手动编译 ntopng ：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;$ sudo wget http://sourceforge.net/projects/ntop/files/ntopng/ntopng-1.1_6932.tgz/download
$ sudo tar zxfv ntopng-1.1_6932.tgz
$ sudo cd ntopng-1.1_6932
$ sudo ./configure
$ sudo make
$ sudo make install&lt;/pre&gt;
&lt;p&gt;这样，在你的 Debian 或 Ubuntu 系统上应该已经安装上了你编译的 ntopng 。&lt;/p&gt;
&lt;p&gt;我们已经有了有关 ntopng 的使用方法的教程，它既可以在命令行也可以在 Web 界面中使用，我们可以前往这些教程来获得有关 ntopng 的知识。&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sun, 17 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-17-86954-b52f8b3e4.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-17-86954-b52f8b3e4.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>11个让你吃惊的 Linux 终端命令</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;我已经用了十年的Linux了，通过今天这篇文章我将向大家展示一系列的命令、工具和技巧，我希望一开始就有人告诉我这些，而不是曾在我成长道路上绊住我。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 命令行日常系快捷键&lt;/strong&gt;&lt;br&gt;
如下的快捷方式非常有用，能够极大的提升你的工作效率：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CTRL + U – 剪切光标前的内容&lt;/li&gt;
&lt;li&gt;CTRL + K – 剪切光标至行末的内容&lt;/li&gt;
&lt;li&gt;CTRL + Y – 粘贴&lt;/li&gt;
&lt;li&gt;CTRL + E – 移动光标到行末&lt;/li&gt;
&lt;li&gt;CTRL + A – 移动光标到行首&lt;/li&gt;
&lt;li&gt;ALT + F – 跳向下一个空格&lt;/li&gt;
&lt;li&gt;ALT + B – 跳回上一个空格&lt;/li&gt;
&lt;li&gt;ALT + Backspace – 删除前一个单词&lt;/li&gt;
&lt;li&gt;CTRL + W – 剪切光标前一个单词&lt;/li&gt;
&lt;li&gt;Shift + Insert – 向终端内粘贴文本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么为了让上述内容更易理解来看下面的这行命令。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;sudo apt-get intall programname&lt;/pre&gt;
&lt;p&gt;如你所见，命令中存在拼写错误，为了正常执行需要把“intall”替换成“install”。&lt;/p&gt;
&lt;p&gt;想象现在光标正在行末，我们有很多的方法将她退回单词install并替换它。&lt;/p&gt;
&lt;p&gt;我可以按两次ALT+B这样光标就会在如下的位置（这里用指代光标的位置）。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;sudo apt-get^intall programname&lt;/pre&gt;
&lt;p&gt;现在你可以按两下方向键并将“s”插入到install中去了。&lt;/p&gt;
&lt;p&gt;如果你想将浏览器中的文本复制到终端，可以使用快捷键”shift + insert”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. SUDO !!&lt;/strong&gt;&lt;br&gt;
如果你还不知道这个命令，我觉得你应该好好感谢我，因为如果你不知道的话，那每次你在输入长串命令后看到“permission denied”后一定会痛苦不堪。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sudo !!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何使用sudo !!？很简单。试想你刚输入了如下命令：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;apt-get install ranger&lt;/pre&gt;
&lt;p&gt;一定会出现“Permission denied”，除非你已经登录了足够高权限的账户。&lt;/p&gt;
&lt;p&gt;sudo !! 就会用 sudo 的形式运行上一条命令。所以上一条命令就变成了这样：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;sudo apt-get install ranger&lt;/pre&gt;
&lt;p&gt;如果你不知道什么是sudo，戳这里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 暂停并在后台运行命令&lt;/strong&gt;&lt;br&gt;
我曾经写过一篇如何在终端后台运行命令的指南。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CTRL + Z – 暂停应用程序&lt;/li&gt;
&lt;li&gt;fg – 重新将程序唤到前台&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何使用这个技巧呢?&lt;/p&gt;
&lt;p&gt;试想你正用nano编辑一个文件：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;sudo nano abc.txt&lt;/pre&gt;
&lt;p&gt;文件编辑到一半你意识到你需要马上在终端输入些命令，但是nano在前台运行让你不能输入。&lt;/p&gt;
&lt;p&gt;你可能觉得唯一的方法就是保存文件，退出 nano，运行命令以后在重新打开nano。&lt;/p&gt;
&lt;p&gt;其实你只要按CTRL + Z，前台的命令就会暂停，画面就切回到命令行了。然后你就能运行你想要运行命令，等命令运行完后在终端窗口输入“fg”就可以回到先前暂停的任务。&lt;/p&gt;
&lt;p&gt;有一个尝试非常有趣就是用nano打开文件，输入一些东西然后暂停会话。再用nano打开另一个文件，输入一些什么后再暂停会话。如果你输入“fg”你将回到第二个用nano打开的文件。只有退出nano再输入“fg”，你才会回到第一个用nano打开的文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 使用nohup在登出SSH会话后仍运行命令&lt;/strong&gt;&lt;br&gt;
如果你用ssh登录别的机器时，nohup命令真的非常有用。&lt;/p&gt;
&lt;p&gt;那么怎么使用nohup呢？&lt;/p&gt;
&lt;p&gt;想象一下你使用ssh远程登录到另一台电脑上，你运行了一条非常耗时的命令然后退出了ssh会话，不过命令仍在执行。而nohup可以将这一场景变成现实。&lt;/p&gt;
&lt;p&gt;举个例子，因为测试的需要，我用我的树莓派来下载发行版。我绝对不会给我的树莓派外接显示器、键盘或鼠标。&lt;/p&gt;
&lt;p&gt;一般我总是用SSH从笔记本电脑连接到树莓派。如果我在不用nohup的情况下使用树莓派下载大型文件，那我就必须等待到下载完成后，才能登出ssh会话关掉笔记本。可如果是这样，那我为什么要使用树莓派下文件呢？&lt;/p&gt;
&lt;p&gt;使用nohup的方法也很简单，只需如下例中在nohup后输入要执行的命令即可：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;nohup wget http://mirror.is.co.za/mirrors/linuxmint.com/iso//stable/17.1/linuxmint-17.1-cinnamon-64bit.iso &amp;amp;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5. ‘在’特定的时间运行Linux命令&lt;/strong&gt;&lt;br&gt;
‘nohup’命令在你用SSH连接到服务器，并在上面保持执行SSH登出前任务的时候十分有用。&lt;/p&gt;
&lt;p&gt;想一下如果你需要在特定的时间执行相同的命令，这种情况该怎么办呢？&lt;/p&gt;
&lt;p&gt;命令‘at’就能妥善解决这一情况。以下是‘at’使用示例。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;at 10:38 PM Fri
at&amp;gt; cowsay &#39;hello&#39;
at&amp;gt; CTRL + D&lt;/pre&gt;
&lt;p&gt;上面的命令能在周五下午10时38分运行程序cowsay。&lt;/p&gt;
&lt;p&gt;使用的语法就是‘at’后追加日期时间。当at&amp;gt;提示符出现后就可以输入你想在那个时间运行的命令了。&lt;/p&gt;
&lt;p&gt;CTRL + D 返回终端。&lt;/p&gt;
&lt;p&gt;还有许多日期和时间的格式，都需要你好好翻一翻‘at’的man手册来找到更多的使用方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. Man手册&lt;/strong&gt;&lt;br&gt;
Man手册会为你列出命令和参数的使用大纲，教你如何使用她们。Man手册看起来沉闷呆板。（我思忖她们也不是被设计来娱乐我们的）。&lt;/p&gt;
&lt;p&gt;不过这不代表你不能做些什么来使她们变得漂亮些。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;export PAGER=most&lt;/pre&gt;
&lt;p&gt;你需要安装 ‘most’；她会使你的你的man手册的色彩更加绚丽。&lt;/p&gt;
&lt;p&gt;你可以用以下命令给man手册设定指定的行长：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;export MANWIDTH=80&lt;/pre&gt;
&lt;p&gt;最后，如果你有一个可用的浏览器，你可以使用-H在默认浏览器中打开任意的man页。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;man -H &amp;lt;command&amp;gt;&lt;/pre&gt;
&lt;p&gt;注意啦，以上的命令只有在你将默认的浏览器设置到环境变量$BROWSER中了之后才效果哟。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 使用htop查看和管理进程&lt;/strong&gt;&lt;br&gt;
你用哪个命令找出电脑上正在运行的进程的呢？我敢打赌是‘ps’并在其后加不同的参数来得到你所想要的不同输出。&lt;/p&gt;
&lt;p&gt;安装‘htop’吧！绝对让你相见恨晚。&lt;/p&gt;
&lt;p&gt;htop在终端中将进程以列表的方式呈现，有点类似于Windows中的任务管理器。你可以使用功能键的组合来切换排列的方式和展示出来的项。你也可以在htop中直接杀死进程。&lt;/p&gt;
&lt;p&gt;在终端中简单的输入htop即可运行。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;htop&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;8. 使用ranger浏览文件系统&lt;/strong&gt;&lt;br&gt;
如果说htop是命令行进程控制的好帮手，那么ranger就是命令行浏览文件系统的好帮手。&lt;/p&gt;
&lt;p&gt;你在用之前可能需要先安装，不过一旦安装了以后就可以在命令行输入以下命令启动她：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;ranger&lt;/pre&gt;
&lt;p&gt;在命令行窗口中ranger和一些别的文件管理器很像，但是相比上下结构布局，她是左右结构的，这意味着你按左方向键你将前进到上一个文件夹，而右方向键则会切换到下一个。&lt;/p&gt;
&lt;p&gt;在使用前ranger的man手册还是值得一读的，这样你就可以用快捷键操作ranger了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9. 取消关机&lt;/strong&gt;&lt;br&gt;
无论是在命令行还是图形用户界面关机后，才发现自己不是真的想要关机。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;shutdown -c&lt;/pre&gt;
&lt;p&gt;需要注意的是，如果关机已经开始则有可能来不及停止关机。&lt;/p&gt;
&lt;p&gt;以下是另一个可以尝试命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pkill shutdown&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;10. 杀死挂起进程的简单方法&lt;/strong&gt;&lt;br&gt;
想象一下，你正在运行的应用程序不明原因的僵死了。&lt;/p&gt;
&lt;p&gt;你可以使用‘ps -ef’来找到该进程后杀掉或者使用‘htop’。&lt;/p&gt;
&lt;p&gt;有一个更快、更容易的命令叫做xkill。&lt;/p&gt;
&lt;p&gt;简单的在终端中输入以下命令并在窗口中点击你想杀死的应用程序。&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;xkill&lt;/pre&gt;
&lt;p&gt;那如果整个系统挂掉了怎么办呢？&lt;/p&gt;
&lt;p&gt;按住键盘上的‘alt’和‘sysrq’不放，然后慢慢输入以下键：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;REISUB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样不按电源键你的计算机也能重启了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11. 下载Youtube视频&lt;/strong&gt;&lt;br&gt;
一般来说我们大多数人都喜欢看Youtube的视频，也会通过钟爱的播放器播放Youtube的流媒体。&lt;/p&gt;
&lt;p&gt;如果你需要离线一段时间（比如：从苏格兰南部坐飞机到英格兰南部旅游的这段时间）那么你可能希望下载一些视频到存储设备中，到闲暇时观看。&lt;/p&gt;
&lt;p&gt;你所要做的就是从包管理器中安装youtube-dl。&lt;/p&gt;
&lt;p&gt;你可以用以下命令使用youtube-dl：&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;youtube-dl url-to-video&lt;/pre&gt;
&lt;p&gt;你可以在Youtubu视频页面点击分享链接得到视频的url。只要简单的复制链接在粘帖到命令行就行了（要用shift + insert快捷键哟）。&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Fri, 15 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-15-86948-2f47ad907.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-15-86948-2f47ad907.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>How-old.net 网站是如何运作的？</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;【伯乐在线导读】：最近微软的 How-old.net 网站非常火热，用户在该站上传照片后，它可以测算出照片中人物的性别和年龄。&lt;/p&gt;
&lt;p&gt;有国外网友在 Quora 上问了 How-old.net 的工作原理。下面是参与了该项目的微软项目经理 Eason Wang 的回复。&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/06fe2deada1715c47ffc1c6891cb1088.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（Eason Wang 是 Bing 的资深项目经理，此回答获得了三千三百个点赞）&lt;/p&gt;
&lt;p&gt;我本人就直接参与了这个项目。说实话，这个小网站的走红大大出乎了我的意料。我事后进行了一些为什么会走红的分析并且在 Medium 写了一篇&lt;a href=&quot;https://medium.com/@yushunwang/10-reasons-why-howoldrobot-gets-viral-1a0eb5cb0d96&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;回到主题吧，我的回答分成两个部分。第一个部分会讲讲如何快速地在任意的软件中实现一模一样的功能，第二个部分我会深入一些描述这项技术本身。&lt;/p&gt;
&lt;p&gt;在过去的几年和微软研发部门的合作中，就 Bing 的图像搜索技术而言，我们达到了最好的工业图像理解能力，这项技术迅速延伸到微软的其他产品。目前在 &lt;a href=&quot;https://www.projectoxford.ai/&quot; target=&quot;_blank&quot;&gt;微软牛津项目主页&lt;/a&gt; 上，这项技术对所有的开发者开放。想要在自己的软件中实现一样的功能，你只需要简单地调用一下我们的 web API，就可以以 JSON 格式获取所需的一切信息。你可以尝试着在 &lt;a href=&quot;http://www.projectoxford.ai&quot; target=&quot;_blank&quot;&gt;www.projectoxford.ai&lt;/a&gt; 的这个页面上传一幅图像，它将在数秒内给你结果，脸部坐标、性别和年龄信息都在里面。Face API 只是我们在牛津项目上做的特性的其中一项。还有很多其他的核心功能来帮助打造创新性的应用。微软内部的 API 向大众开放让我感到很兴奋，我知道这会对开发社区起到深远的影响。这让之前看起来不可能的事情变得只用简单地调用一下 web API 就能做到了。#HowOldRobot 只是这些能力的小小展示，Azure 机器学习团队的一个开发人员只用了一天就把它开发出来了。&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/fc0c9674e425846390635ecc96f9394c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（译者注：以下是 API 示例，为 JSON 格式）&lt;/p&gt;
&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;JSON:
[
  {
    &quot;faceId&quot;: &quot;5af35e84-ec20-4897-9795-8b3d4512a1f9&quot;,
    &quot;faceRectangle&quot;: {
      &quot;width&quot;: 60,
      &quot;height&quot;: 60,
      &quot;left&quot;: 276,
      &quot;top&quot;: 43
    },
    &quot;faceLandmarks&quot;: {
      &quot;pupilLeft&quot;: {
        &quot;x&quot;: &quot;295.1&quot;,
        &quot;y&quot;: &quot;56.8&quot;
      },
      &quot;pupilRight&quot;: {
        &quot;x&quot;: &quot;317.9&quot;,
        &quot;y&quot;: &quot;59.6&quot;
      },
      &quot;noseTip&quot;: {
        &quot;x&quot;: &quot;311.6&quot;,
        &quot;y&quot;: &quot;74.7&quot;
      },
      &quot;mouthLeft&quot;: {
        &quot;x&quot;: &quot;291.0&quot;,
        &quot;y&quot;: &quot;86.3&quot;
      },
      &quot;mouthRight&quot;: {
        &quot;x&quot;: &quot;311.6&quot;,
        &quot;y&quot;: &quot;88.6&quot;
      },
      &quot;eyebrowLeftOuter&quot;: {
        &quot;x&quot;: &quot;281.6&quot;,
        &quot;y&quot;: &quot;50.1&quot;
      },
      &quot;eyebrowLeftInner&quot;: {
        &quot;x&quot;: &quot;304.2&quot;,
        &quot;y&quot;: &quot;51.6&quot;
      },
      &quot;eyeLeftOuter&quot;: {
        &quot;x&quot;: &quot;289.1&quot;,
        &quot;y&quot;: &quot;57.1&quot;
      },
      &quot;eyeLeftTop&quot;: {
        &quot;x&quot;: &quot;294.0&quot;,
        &quot;y&quot;: &quot;54.5&quot;
      },
      &quot;eyeLeftBottom&quot;: {
        &quot;x&quot;: &quot;293.0&quot;,
        &quot;y&quot;: &quot;61.0&quot;
      },
      &quot;eyeLeftInner&quot;: {
        &quot;x&quot;: &quot;297.8&quot;,
        &quot;y&quot;: &quot;58.7&quot;
      },
      &quot;eyebrowRightInner&quot;: {
        &quot;x&quot;: &quot;316.0&quot;,
        &quot;y&quot;: &quot;54.2&quot;
      },
      &quot;eyebrowRightOuter&quot;: {
        &quot;x&quot;: &quot;324.7&quot;,
        &quot;y&quot;: &quot;54.2&quot;
      },
      &quot;eyeRightInner&quot;: {
        &quot;x&quot;: &quot;312.9&quot;,
        &quot;y&quot;: &quot;60.9&quot;
      },
      &quot;eyeRightTop&quot;: {
        &quot;x&quot;: &quot;317.8&quot;,
        &quot;y&quot;: &quot;57.7&quot;
      },
      &quot;eyeRightBottom&quot;: {
        &quot;x&quot;: &quot;317.9&quot;,
        &quot;y&quot;: &quot;63.7&quot;
      },
      &quot;eyeRightOuter&quot;: {
        &quot;x&quot;: &quot;322.8&quot;,
        &quot;y&quot;: &quot;60.8&quot;
      },
      &quot;noseRootLeft&quot;: {
        &quot;x&quot;: &quot;304.0&quot;,
        &quot;y&quot;: &quot;60.2&quot;
      },
      &quot;noseRootRight&quot;: {
        &quot;x&quot;: &quot;312.2&quot;,
        &quot;y&quot;: &quot;61.2&quot;
      },
      &quot;noseLeftAlarTop&quot;: {
        &quot;x&quot;: &quot;302.6&quot;,
        &quot;y&quot;: &quot;70.2&quot;
      },
      &quot;noseRightAlarTop&quot;: {
        &quot;x&quot;: &quot;313.0&quot;,
        &quot;y&quot;: &quot;70.0&quot;
      },
      &quot;noseLeftAlarOutTip&quot;: {
        &quot;x&quot;: &quot;298.8&quot;,
        &quot;y&quot;: &quot;76.2&quot;
      },
      &quot;noseRightAlarOutTip&quot;: {
        &quot;x&quot;: &quot;315.2&quot;,
        &quot;y&quot;: &quot;76.6&quot;
      },
      &quot;upperLipTop&quot;: {
        &quot;x&quot;: &quot;307.3&quot;,
        &quot;y&quot;: &quot;84.0&quot;
      },
      &quot;upperLipBottom&quot;: {
        &quot;x&quot;: &quot;306.6&quot;,
        &quot;y&quot;: &quot;86.4&quot;
      },
      &quot;underLipTop&quot;: {
        &quot;x&quot;: &quot;305.5&quot;,
        &quot;y&quot;: &quot;89.6&quot;
      },
      &quot;underLipBottom&quot;: {
        &quot;x&quot;: &quot;304.1&quot;,
        &quot;y&quot;: &quot;94.0&quot;
      }
    },
    &quot;attributes&quot;: {
      &quot;age&quot;: 24,
      &quot;gender&quot;: &quot;female&quot;,
      &quot;headPose&quot;: {
        &quot;roll&quot;: &quot;4.0&quot;,
        &quot;yaw&quot;: &quot;31.3&quot;,
        &quot;pitch&quot;: &quot;0.0&quot;
      }
    }
  }
]&lt;/pre&gt;
&lt;p&gt;How-old.net  这个网站主要依赖于三个关键的技术：&lt;strong&gt;面部检测、性别分类和年龄检测&lt;/strong&gt;。面部检测是另外两个的基础。对于年龄检测和性别检测来说，只是机器学习中很典型的回归和分类问题，涉及到了面部特征的表示、训练数据的采集、回归和分类模型的构建以及模型的优化。这方面有很多的已经发表的论文。如果你有兴趣想进一步了解就告诉我。&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/4d29a5ce351c42267029f553e2efa737.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;另一方面，深度学习和对大规模数据的理解推动了图像理解的突破，为更加智能的系统和程序端口打开了一扇门。你可以看看我最新的关于图像图表如何应用于更进阶场景的博客：&lt;a href=&quot;http://blogs.bing.com/search-quality-insights/2015/04/22/the-image-graph-powering-the-next-generation-of-bing-image-search/&quot; target=&quot;_blank&quot;&gt;http://blogs.bing.com/search-qua…&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;留下你的评论让我改进这个回答，谢谢！&lt;/p&gt;

        
        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者： &lt;a href=&quot;http://blog.jobbole.com/author/aahung/&quot;&gt;aahung&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a href=&quot;http://blog.jobbole.com/author/aahung/&quot;&gt;
					&lt;/a&gt;
	&lt;/div&gt;
	&lt;p&gt;&lt;/p&gt;
	&lt;p&gt;
		&lt;a style=&quot;text-decoration: none;&quot; href=&quot;http://blog.jobbole.com/author/aahung/&quot;&gt;查看aahung的更多文章 »&lt;/a&gt;
	&lt;/p&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
	
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Fri, 15 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-15-86939-260384a33.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-15-86939-260384a33.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>修改Hosts为何不生效，是DNS缓存？</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果浏览器使用了代理工具，修改 Hosts 也不会生效。这里是因为，浏览器会优先考虑代理工具（如添加 pac 文件、SwitchySharp等）的代理，建议调试的时候先关闭这些代理。&lt;/li&gt;
&lt;li&gt;使用 pac 文件代理有的时候部分文件的代理不生效，应该是 pac 对应的代理服务器上，做了部分处理。&lt;/li&gt;
&lt;li&gt;部分浏览器也有 DNS 缓存，如 chrome(chrome://dns)，这是为什么重启浏览器也不生效的原因，一般设定时间为 60s (如 Firefox)。&lt;/li&gt;
&lt;li&gt;浏览器有DNS缓存，系统也会存在 DNS 缓存，有的时候即便在 chrome://dns 清空了浏览器 DNS 缓存，依然不生效，是因为系统 DNS 缓存还未刷新，刷新方式可以看这篇文章。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;相信很多同学都在使用 SwitchHosts/iHosts/Gas Mask 等 Hosts 管理工具，当然也有人直接修改 /etc/hosts 或者 system32/drivers/etc/hosts 文件，而经常遇到的疑问是：咿，刚才不是修改并且保存了么，为何 Chrome 浏览器还不生效呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有人说重启下浏览器就好了，&lt;/li&gt;
&lt;li&gt;有人说清空下缓存 DNS（chrome://net-internals/#DNS）就好了，&lt;/li&gt;
&lt;li&gt;有人说隐私模式下打开就好了，&lt;/li&gt;
&lt;li&gt;有人说等一分钟吧…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结果就是，进入隐私模式的都好了，重启、清空缓存DNS和等一分钟的同学还在继续纠结中。。。&lt;/p&gt;
&lt;p&gt;上面提到的三个工具，SwitchHosts/iHosts/Gas Mask，其实也只有 iHosts 生效了(Mac下)。&lt;/p&gt;
&lt;p&gt;开发过程中我们会无数次的切换 Hosts，如果不知道原理，我们在测试的时候还是很心惊胆战的=_=||&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;修改Hosts不生效的根本原因&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;因为服务器设置了 keep-alive ！次要原因是存在浏览器 DNS 缓存和系统 DNS 缓存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt; Keep-alive 相关文档&lt;/p&gt;
&lt;p&gt;服务器在响应头设置了 Connection: keep-alive （一般的网页都会设置 keep-alive，保持长连接，避免多次连接产生网络消耗）之后，客户端会跟服务器保持长连接，只要长连接不断开，页面在请求的时候就不会重新解析域名！&lt;/p&gt;
&lt;p&gt;我们可以这样来测试：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开一个你至少两分钟没有打开的浏览器（你也可以关闭掉你的浏览器，然后重新打开，记得把所有的 tab 都关了，除了当前 tab ^_^）&lt;/li&gt;
&lt;li&gt;在 hosts 添加 127.0.0.1 www.taobao.com&lt;/li&gt;
&lt;li&gt;新开 tab，打开 www.taobao.com，是不是进不去了 &amp;lt;这里说明 hosts 修改生效了&amp;gt;&lt;/li&gt;
&lt;li&gt;注释掉刚才hosts修改，# 127.0.0.1 www.taobao.com ，再打开 www.taobao.com，很好，正常打开了 &amp;lt;这里说明 hosts 修改也生效了&amp;gt;&lt;/li&gt;
&lt;li&gt;去掉注释符，127.0.0.1 www.taobao.com ，再打开 www.taobao.com，依然可以访问！！！&lt;/li&gt;
&lt;li&gt;Chrome 中进入 chrome://net-internals/#sockets，&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/65f6e1ecce406013f121898b640030de.jpg&quot; width=&quot;690&quot; height=&quot;704&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到淘宝首页中很多域名都是与服务器保持着长连接，点击上方的 close idle sockets 按钮，可以关闭所有的长连接。此时，再去访问 &lt;a href=&quot;http://www.taobao.com/&quot;&gt;www.taobao.com&lt;/a&gt;，是不是进不去了！&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;为何一些修改可以让 “Hosts 生效”&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 重启浏览器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重启浏览器之后，所有的连接（包括长连接）都会断开，自然就生效了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 隐私模式打开&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为隐私模式下不会复用 TCP 连接，新开连接的时候，会重新解析 DNS 域名，自然也生效了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. iHosts 管理器在 Mac 下生效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为我在 Windows 下测试过，貌似没有立即生效。问了 iHosts 的作者@必隆，他告诉我，在修改 hosts 文件的时候，会重启网络服务，这个时候必然会断开所有的 TCP 连接（重启网络服务，差不多相当于先断网再联网…)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 修改之后，等一会儿…&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“等一会儿”，要稍微等久一点，keep-alive 的默认设置是 120s，开发者也有可能增大或者减小这个配置，所以“等一会儿”也是很伤神的=。 =&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-14-86935-643480ab5.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-14-86935-643480ab5.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>防范 DDoS 攻击的 15 个方法</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;为了对抗 DDoS(分布式拒绝服务)攻击，你需要对攻击时发生了什么有一个清楚的理解. 简单来讲，DDoS 攻击可以通过利用服务器上的漏洞，或者消耗服务器上的资源(例如 内存、硬盘等等)来达到目的。&lt;a href=&quot;http://securitywing.com/10-major-types-of-ddos-attacks-and-prevention/&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;DDoS 攻击主要要两大类: 带宽耗尽攻击和资源耗尽攻击&lt;/a&gt;. 为了有效遏制这两种类型的攻击，你可以按照下面列出的步骤来做：&lt;/p&gt;
&lt;p&gt;1. 如果只有几台计算机是攻击的来源，并且你已经确定了这些来源的 IP 地址, 你就在防火墙服务器上放置一份 &lt;a href=&quot;http://securitywing.com/access-control-list/&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;ACL（访问控制列表)&lt;/a&gt; 来阻断这些来自这些 IP 的访问。如果可能的话 将 web 服务器的 IP 地址变更一段时间，但是如果攻击者通过查询你的 DNS 服务器解析到你新设定的 IP，那这一措施及不再有效了。&lt;/p&gt;
&lt;p&gt;2. 如果你确定攻击来自一个特定的国家，可以考虑将来自那个国家的 IP 阻断，至少要阻断一段时间.&lt;/p&gt;
&lt;p&gt;3、监控进入的网络流量。通过这种方式可以知道谁在访问你的网络，可以监控到异常的访问者，可以在事后分析日志和来源IP。在进行大规模的攻击之前，攻击者可能会使用少量的攻击来测试你网络的健壮性。&lt;/p&gt;
&lt;p&gt;4、对付带宽消耗型的攻击来说，最有效（也很昂贵）的解决方案是购买更多的带宽。&lt;/p&gt;
&lt;p&gt;5、也可以使用高性能的负载均衡软件，使用多台服务器，并部署在不同的数据中心。&lt;/p&gt;
&lt;p&gt;6、对web和其他资源使用负载均衡的同时，也使用相同的策略来保护DNS。&lt;/p&gt;
&lt;p&gt;7、优化资源使用提高 web server 的负载能力。例如，使用 apache 可以安装 apachebooster 插件，该插件与 varnish 和 nginx 集成，可以应对突增的流量和内存占用。&lt;/p&gt;
&lt;p&gt;8、使用高可扩展性的 DNS 设备来保护针对 DNS 的 DDOS 攻击。可以考虑购买 Cloudfair 的商业解决方案，它可以提供针对 DNS 或 TCP/IP3 到7层的 DDOS 攻击保护。&lt;/p&gt;
&lt;p&gt;9、启用路由器或防火墙的反IP欺骗功能。在 CISCO 的 ASA 防火墙中配置该功能要比在路由器中更方便。在 ASDM（Cisco Adaptive Security Device Manager）中启用该功能只要点击“配置”中的“防火墙”，找到“anti-spoofing”然后点击启用即可。也可以在路由器中使用 ACL（access control list）来防止 IP 欺骗，先针对内网创建 ACL，然后应用到互联网的接口上。&lt;/p&gt;
&lt;p&gt;10、使用第三方的服务来保护你的网站。有不少公司有这样的服务，提供高性能的基础网络设施帮你抵御拒绝服务攻击。你只需要按月支付几百美元费用就行。&lt;/p&gt;
&lt;p&gt;11、注意服务器的安全配置，避免资源耗尽型的 DDOS 攻击。&lt;/p&gt;
&lt;p&gt;12、听从专家的意见，针对攻击事先做好应对的应急方案。&lt;/p&gt;
&lt;p&gt;13、监控网络和 web 的流量。如果有可能可以配置多个分析工具，例如：Statcounter 和 Google analytics，这样可以更直观了解到流量变化的模式，从中获取更多的信息。&lt;/p&gt;
&lt;p&gt;14、保护好 DNS 避免 DNS 放大攻击。&lt;/p&gt;
&lt;p&gt;15、在路由器上禁用 ICMP。仅在需要测试时开放 ICMP。在配置路由器时也考虑下面的策略：流控，包过滤，半连接超时，垃圾包丢弃，来源伪造的数据包丢弃，SYN 阀值，禁用 ICMP 和 UDP 广播。&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-14-86932-6ab912462.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-14-86932-6ab912462.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>.NET高级工程师面试题之SQL篇</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;&lt;strong&gt;1 题目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这确实是一个真实的面试题，琢磨一下吧！知识不用，就会丢掉，我太依赖各种框架和dll了，已经忘记了最基本的东西。有多久没有写过SQL了，我已经不记得了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;已知表信息如下：&lt;/p&gt;
&lt;p&gt;Department(depID, depName),depID 系编号，DepName系名&lt;/p&gt;
&lt;p&gt;Student(stuID, name, depID) 学生编号，姓名，系编号&lt;/p&gt;
&lt;p&gt;Score(stuID, category, score) 学生编码，科目，成绩&lt;/p&gt;
&lt;p&gt;找出每一个系的最高分，并且按系编号，学生编号升序排列，要求顺序输出以下信息：&lt;/p&gt;
&lt;p&gt;系编号，系名，学生编号，姓名，总分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 实验&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE [test]
GO
/****** Object:  Table [dbo].[Score]    Script Date: 05/11/2015 23:16:23 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[Score](
    [stuID] [int] NOT NULL,
    [category] [varchar](50) NOT NULL,
    [score] [int] NOT NULL
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (1, N&#39;英语&#39;, 80)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (2, N&#39;数学&#39;, 80)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (1, N&#39;数学&#39;, 70)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (2, N&#39;英语&#39;, 89)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (3, N&#39;英语&#39;, 81)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (3, N&#39;数学&#39;, 71)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (4, N&#39;数学&#39;, 91)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (4, N&#39;英语&#39;, 61)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (5, N&#39;英语&#39;, 91)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (6, N&#39;英语&#39;, 89)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (7, N&#39;英语&#39;, 77)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (8, N&#39;英语&#39;, 97)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (9, N&#39;英语&#39;, 57)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (5, N&#39;数学&#39;, 87)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (6, N&#39;数学&#39;, 89)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (7, N&#39;数学&#39;, 80)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (8, N&#39;数学&#39;, 81)
INSERT [dbo].[Score] ([stuID], [category], [score]) VALUES (9, N&#39;数学&#39;, 84)
/****** Object:  Table [dbo].[Department]    Script Date: 05/11/2015 23:16:23 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[Department](
    [depID] [int] IDENTITY(1,1) NOT NULL,
    [depName] [varchar](50) NOT NULL,
PRIMARY KEY CLUSTERED 
(
    [depID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET IDENTITY_INSERT [dbo].[Department] ON
INSERT [dbo].[Department] ([depID], [depName]) VALUES (1, N&#39;计算机&#39;)
INSERT [dbo].[Department] ([depID], [depName]) VALUES (2, N&#39;生物&#39;)
INSERT [dbo].[Department] ([depID], [depName]) VALUES (3, N&#39;数学&#39;)
SET IDENTITY_INSERT [dbo].[Department] OFF
/****** Object:  Table [dbo].[Student]    Script Date: 05/11/2015 23:16:23 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[Student](
    [stuID] [int] IDENTITY(1,1) NOT NULL,
    [stuName] [varchar](50) NOT NULL,
    [deptID] [int] NOT NULL,
PRIMARY KEY CLUSTERED 
(
    [stuID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET IDENTITY_INSERT [dbo].[Student] ON
INSERT [dbo].[Student] ([stuID], [stuName], [deptID]) VALUES (1, N&#39;计算机张三&#39;, 1)
INSERT [dbo].[Student] ([stuID], [stuName], [deptID]) VALUES (2, N&#39;计算机李四&#39;, 1)
INSERT [dbo].[Student] ([stuID], [stuName], [deptID]) VALUES (3, N&#39;计算机王五&#39;, 1)
INSERT [dbo].[Student] ([stuID], [stuName], [deptID]) VALUES (4, N&#39;生物amy&#39;, 2)
INSERT [dbo].[Student] ([stuID], [stuName], [deptID]) VALUES (5, N&#39;生物kity&#39;, 2)
INSERT [dbo].[Student] ([stuID], [stuName], [deptID]) VALUES (6, N&#39;生物lucky&#39;, 2)
INSERT [dbo].[Student] ([stuID], [stuName], [deptID]) VALUES (7, N&#39;数学_yiming&#39;, 3)
INSERT [dbo].[Student] ([stuID], [stuName], [deptID]) VALUES (8, N&#39;数学_haoxue&#39;, 3)
INSERT [dbo].[Student] ([stuID], [stuName], [deptID]) VALUES (9, N&#39;数学_wuyong&#39;, 3)
SET IDENTITY_INSERT [dbo].[Student] OFF
/****** Object:  Default [DF__Departmen__depNa__5441852A]    Script Date: 05/11/2015 23:16:23 ******/
ALTER TABLE [dbo].[Department] ADD  DEFAULT (&#39;&#39;) FOR [depName]
GO
/****** Object:  Default [DF__Score__category__5EBF139D]    Script Date: 05/11/2015 23:16:23 ******/
ALTER TABLE [dbo].[Score] ADD  DEFAULT (&#39;&#39;) FOR [category]
GO
/****** Object:  Default [DF__Score__score__5FB337D6]    Script Date: 05/11/2015 23:16:23 ******/
ALTER TABLE [dbo].[Score] ADD  DEFAULT ((0)) FOR [score]
GO
/****** Object:  Default [DF__Student__stuName__59063A47]    Script Date: 05/11/2015 23:16:23 ******/
ALTER TABLE [dbo].[Student] ADD  DEFAULT (&#39;&#39;) FOR [stuName]
GO
/****** Object:  ForeignKey [FK__Student__deptID__59FA5E80]    Script Date: 05/11/2015 23:16:23 ******/
ALTER TABLE [dbo].[Student]  WITH CHECK ADD FOREIGN KEY([deptID])
REFERENCES [dbo].[Department] ([depID])
GO

准备环境&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3 结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　面试的时候，没有写出来，当时脑袋昏沉沉的。也确实好久没有写复杂的sql语句了。今天花了2到3个小时，终于试出来了。不知道有没有更好的写法？&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;-- 每个系里的最高分的学生信息
SELECT Department.depID, Department.depName, Student.stuID, stuName, Dscore.scores
FROM Department
LEFT JOIN Student
on department.depID = student.deptID
LEFT JOIN (SELECT Score.stuId, SUM(Score) AS scores 
            FROM Score
            GROUP by stuID
) AS Dscore
on Student.stuID = dScore.stuID
where exists    (    
select *
from
(        
 SELECT deptID, MAX(scores) AS topScores
 FROM Student
 LEFT JOIN 
        (
 SELECT stuID,SUM(score) AS scores
 FROM Score
 GROUP BY stuID) AS newScore
 ON Student.stuID = newScore.stuID
 group by deptID) AS depScore
 where Department.depID = depScore.deptID and Dscore.scores=depScore.topScores
 )
 order by Department.depID,Student.stuID;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4 补充&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;看了那么多的评论，自己写的真的不咋样，可惜今天没有时间细细看了，现在还在公司加班！但百度一下的时间还是有滴，So整理一下相关资料先。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）、&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/xhyang110/archive/2009/10/27/1590448.html&quot;&gt;SQL2005四个排名函数（row_number、rank、dense_rank和ntile）的比较&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（2）、关于with as：&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/fygh/archive/2011/08/31/2160266.html&quot;&gt;使用WITH AS提高性能简化嵌套SQL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 5 参考SQL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　正确的答案的结果是一样的，错误的各有各的不同，正确的答案后的性能也各有各的不同，不过呢，暂时没有水平去分析它，但是有空会把这些全部看一遍.谢谢各位啦！【2015-05-13 23:44】&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;1、pursuer.chen  
SELECT B.depID,B.depName,B.stuID ,B.stuName,SUM(A.score )AS SUM_SCORE FROM Score A 
INNER JOIN
(SELECT SA.depID,SA.depName,S.stuID,S.stuName FROM Student S 
INNER JOIN Score SE ON S.stuID=SE.stuID 
INNER JOIN (
SELECT D.depID,D.depName ,MAX(SC.score )AS MX_score FROM Student S INNER JOIN Score SC ON S.stuID=SC.stuID INNER JOIN Department D ON S.deptID=D.depID 
GROUP BY D.depID,D.depName ) SA ON SE.score=SA.MX_score AND S.deptID=SA.depID )
B ON A.stuID=B.stuID 
GROUP BY B.depID,B.depName,B.stuID ,B.stuName
ORDER BY B.depID,B.stuID
结果正确
   计算机    2    计算机李四    169
   生物    4    生物amy    152
   生物    5    生物kity    178
   数学    8    数学_haoxue    178


2、Gamain 正确

WITH cte1 as
(
    SELECT
        DISTINCT
        D.depID,
        D.depName,
        S.stuID,
        S.stuName,
    SUM(Sc.score) OVER (PARTITION BY D.depID,S.stuID) as sumScore
    FROM Department D LEFT JOIN Student S ON D.depID=S.deptID
                      LEFT JOIN Score Sc ON Sc.stuID=S.stuID
), cte2 as
(
    SELECT
        DISTINCT
        depID,
        stuID,
    MAX(sumScore) OVER (PARTITION BY depID) as maxScore
    FROM
    cte1
)
SELECT
    c1.depID,
    c1.depName,
    c1.stuID,
    c1.stuName,
    c1.sumScore
from cte2 c2 INNER JOIN cte1 c1
    ON c1.depID=c2.depID AND c1.stuID=c2.stuID and c1.sumScore=c2.maxScore;

3、飞不动  正确
use test;

select 
e.*
from 
(
select c.depID,c.depName,a.stuID,b.stuName,a.total from 
(select stuID,sum(score) as total from Score group by stuID) a
join Student b on b.stuID=a.stuID
join Department c on c.depID=b.deptID
) e
join 
(select b.deptID,max(a.total) maxScore from 
(select stuID,sum(score) as total from Score group by stuID) a
join Student b on b.stuID=a.stuID
group by b.deptID
) f on e.depID=f.deptID and e.total=f.MaxScore
order by e.depID,e.stuID


4、之路  错误
select 
depID,
depName,
stuId,
stuName,
PerTotalScore
from (
select
stuID,
stuName,
depID,
depName,
PerTotalScore,
ROW_NUMBER() OVER(partition by depID order by PerTotalScore) as RowId
from (
select 
distinct
s.stuID,
s.stuName,
d.depID,
d.depName,
SUM(c.score) OVER(partition by d.depID,s.stuID) as PerTotalScore
from dbo.student s 
JOIN dbo.Department d on s.deptID=d.depID
JOIN dbo.Score c ON s.StuID=c.StuID ) as T ) as TT
WHERE TT.RowId=1
order by depID,stuID
   计算机    1    计算机张三    150
   生物    4    生物amy    152
   数学    9    数学_wuyong    141

5、King兵  正确
WITH a
AS
(SELECT Department.depID, Department.depName, Student.stuID, stuName, Dscore.scores,ROW_NUMBER() OVER(PARTITION BY Department.depID ORDER BY scores DESC) ROWID 
FROM Department
LEFT JOIN Student
on department.depID = student.deptID
LEFT JOIN (SELECT Score.stuId, SUM(Score) AS scores 
FROM Score
GROUP by stuID
) AS Dscore
on Student.stuID = dScore.stuID),
b
AS 
(
SELECT Department.depID, Department.depName, Student.stuID, stuName, Dscore.scores,ROW_NUMBER() OVER(PARTITION BY Department.depID ORDER BY scores DESC) ROWID 
FROM Department
LEFT JOIN Student
on department.depID = student.deptID
LEFT JOIN (SELECT Score.stuId, SUM(Score) AS scores 
FROM Score
GROUP by stuID
) AS Dscore
on Student.stuID = dScore.stuID
)


SELECT depID, depName, stuID, stuName, scores,ROWID FROM a WHERE a.scores = (SELECT MAX(scores) FROM b c WHERE a.depid = c.depid)

6、 怪咖Eric  正确
SELECT  bb.deptID ,
        cc.depName ,
        bb.stuID ,
        bb.stuName ,
        bb.TotalScore
FROM    ( SELECT    * ,
                    RANK() OVER ( PARTITION BY deptID ORDER BY TotalScore DESC ) AS pos
          FROM      ( SELECT    SUM(b.score) AS TotalScore ,
                                a.stuID ,
                                a.stuName ,
                                a.deptID
                      FROM      Student a
                                JOIN Score b ON a.StuID = b.StuID
                      GROUP BY  a.stuID ,
                                a.stuName ,
                                a.deptID
                    ) aa
        ) bb
        JOIN dbo.Department cc ON bb.deptID = cc.depID
        JOIN dbo.Student dd ON bb.stuID = dd.stuID
WHERE   pos = &#39;1&#39;
ORDER BY bb.deptID ,
        bb.stuID
7、Michael Jiang  手写 改后正确

use test;

SELECT D.*
  FROM (
    SELECT de.depID,
           de.depName,
           st.stuID,
           st.stuName,
           sc.score,
           RANK() OVER(
             PARTITION BY st.deptID
             ORDER BY sc.score DESC
           ) rowno
      FROM Student st
      LEFT JOIN Department de
        ON de.depID=st.deptID
      LEFT JOIN (
        SELECT sc.stuID,
               SUM(sc.score) score
          FROM Score sc
         GROUP BY sc.stuID
      ) sc
        ON sc.stuID=st.stuID
  ) D
 WHERE D.rowno = 1 --看错要求，原来只要列出最高分
 ORDER BY D.depID, D.rowno
 
 8、正确 Li.zheng  
 use test;
select * from (
    select
        (select depName from Department where Department.depID = a.depID) as depName,
        (select stuName from Student where Student.stuID = a.stuID) as stuName,
        dense_rank() over(partition by depID order  by sumScore desc) as rank,
        a.sumScore
    from
        (
            select
                c.depID,b.stuid,sum(a.score) as sumScore
            from
                score as a
                inner join Student as b on a.stuid = b.stuid
                inner join Department as c on c.depID = b.deptID
            group by
                c.depID,b.stuid
        ) as a
) as b where b.rank = 1
 
9、下个路口  错误 漏了并列第一
SELECT *
FROM   (
           SELECT s1.stuID,s1.stuName,s1.deptID,t.totalScore,d.depName,
                  ROW_NUMBER() OVER(PARTITION BY d.depID ORDER BY totalScore DESC) AS
                  Rn
           FROM   Student AS s1
                  INNER JOIN (
                           SELECT s.stuID,SUM(s2.score) AS totalScore FROM Student AS s
                                  INNER JOIN Department AS d ON  d.depID = s.deptID
                                  INNER JOIN Score s2 ON s2.stuID = s.stuID
                           GROUP BY s.stuID
                       ) AS t
                       ON  t.stuID = s1.stuID
                  INNER JOIN Department AS d
                       ON  d.depID = s1.deptID
       ) result
WHERE Rn = 1
ORDER BY result.stuID

9、自由_   正确
select d.depID,d.depName,s.stuID,s.stuName,t.score from Department d left join
(select s.stuID,sum(s.score) as score,st.deptID,
rank() over(partition by st.deptID order by sum(s.score) desc) ra from Score s
left join Student st on s.stuID = st.stuID group by s.stuID,st.deptID) t
on d.depID = t.deptID left join Student s on t.stuID = s.stuID
where t.ra = 1 order by d.depID,s.

10、 手写 改了 之后 错误，
use test;
with Combin AS
(
SELECT MAX(score) AS 最高分,deptID AS 系编号,MAX(a.stuID) AS 学生Id FROM Student a LEFT JOIN Score b ON a.stuID=b.stuID
GROUP BY a.deptID 
)

SELECT 
c.系编号,
(SELECT depName FROM Department d WHERE d.depID=c.系编号 ) AS 系名,
c.学生Id AS &#39;学生编号&#39;,
(SELECT stuName FROM Student e WHERE e.stuID=c.学生Id ) AS &#39;姓名&#39;,
c.最高分
FROM Combin c
   计算机    3    计算机王五    89
   生物    6    生物lucky    91
   数学    9    数学_wuyong    97

11、 舍长   正确
use test;

WITH T1 AS (
        SELECT A.DEPID,A.DEPNAME,B.STUID,B.STUNAME,SUM(C.SCORE) AS TotalScore
        FROM Department A
        INNER JOIN Student B
        ON A.DEPID = B.DEPTID
        INNER JOIN Score C
        ON B.STUID = C.STUID
        GROUP BY A.DEPID,A.DEPNAME,B.STUID,B.STUNAME
),
T2 AS (
    SELECT *,RANK() OVER(PARTITION BY DEPID ORDER BY TotalScore DESC) AS RankScore  FROM T1
)
SELECT * FROM T2 WHERE RankScore = 1 ORDER BY DEPID,STUID

12、Ender.Lu   正确
with
tscore as (select stuID ,sum(score) as score from dbo.Score group by stuID),
tinfo as (select Student.deptID ,Department.depName,dbo.Student.stuID,dbo.Student.stuName,tscore.score from dbo.Student
    inner join [dbo].[Department] on dbo.Department.depID = student.deptID
    left join tscore on tscore.stuid = Student.stuID),
trank as (
    select deptID ,depName,stuID,stuName,score ,rank() over(partition by  deptID  order by score desc) as level from tinfo
)
select deptID ,depName,stuID,stuName,score from trank where level = 1 order by deptID ,stuID;

13、McJeremy&amp;amp;Fan   正确
select p.totalscore,p.stuid,p.stuname,p.deptid,x.depname from
(
    select
        dense_rank() over(partition by deptid order by totalscore desc) as num,
        a.totalscore,b.stuid,b.stuname,b.deptid
    from
    (
        select stuid,sum(score) as totalscore from score
        group by stuid
    ) a inner join student b on a.stuid=b.stuid
) as p 
inner join department x on p.deptid=x.depid
where p.num=1

13、清水无大大鱼  正确
with temp as(
select a.deptid,a.stuID,a.stuName,b.score from student a,(select stuID,sum(score)as score from score group by stuID)b where a.stuID=b.stuID)
select d.depID,d.depName,b.stuID,b.stuName,b.score from Department d,(
select * from temp t where t.score=( select max(score) from temp sc where t.deptid=sc.deptid)) b where d.depID=b.deptID order by depID,stuID

14、 BattleHeart  正确
SELECT D.*,DD.depName FROM (
SELECT C.stuID,
C.TotleScore,
C.stuName,
C.deptID,
DENSE_RANK() OVER(PARTITION BY C.deptID ORDER BY C.TotleScore DESC ) nubid 
FROM (SELECT S.stuID,
ST.stuName,
SUM(S.score) AS TotleScore,
ST.deptID 
FROM dbo.Student AS ST 
INNER JOIN dbo.Score AS S ON S.stuID = ST.stuID 
GROUP BY S.stuID,ST.deptID,ST.stuName) AS C) AS D INNER JOIN dbo.Department AS DD
ON DD.depID = D.deptID WHERE D.nubid=1&lt;/pre&gt;

        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-14-86929-20e708697.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-14-86929-20e708697.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>机器学习实战ByMatlab（5）：Logistic Regression</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;什么叫做回归呢？举个例子，我们现在有一些数据点，然后我们打算用一条直线来对这些点进行拟合（该曲线称为最佳拟合曲线），这个拟合过程就被称为回归。&lt;/p&gt;
&lt;p&gt;利用Logistic回归进行分类的主要思想是：&lt;/p&gt;
&lt;p&gt;根据现有数据对分类边界线建立回归公式，以此进行分类。&lt;/p&gt;
&lt;p&gt;这里的”回归“一词源于最佳拟合，表示要找到最佳拟合参数集。训练分类器时的嘴阀就是寻找最佳拟合曲线，使用的是最优化算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于Logistic回归和Sigmoid函数的分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：计算代价不高，易于理解和实现&lt;br&gt;
缺点：容易欠拟合，分类精度可能不高&lt;/p&gt;
&lt;p&gt;使用数据类型：数值型和标称型数据&lt;/p&gt;
&lt;p&gt;Sigmoid函数：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/0db740d1a0ca36068e7dc61899ff88c2.jpg&quot; width=&quot;165&quot; height=&quot;70&quot;&gt;&lt;/p&gt;
&lt;p&gt;波形如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/9a87ddecb06f0f3d75e42ce56164d63f.jpg&quot; width=&quot;311&quot; height=&quot;243&quot;&gt;&lt;/p&gt;
&lt;p&gt;当z为0时，值为0.5，当z增大时，g(z)逼近1，当z减小时，g(z)逼近0&lt;/p&gt;
&lt;p&gt;Logistic回归分类器：&lt;/p&gt;
&lt;p&gt;对每一个特征都乘以一个回归系数，然后把所有结果都相加，再讲这个总和代入Sigmoid函数中，从而得到一个范围在0-1之间的数值。任何大于0.5的数据被分为1，小于0.5的数据被分为0.因此Logistic回归也被看成是一种概率分布。&lt;/p&gt;
&lt;p&gt;分类器的函数形式确定之后，现在的问题就是，如何确定回归系数？&lt;/p&gt;
&lt;p&gt;基于最优化方法的最佳回归系数确定&lt;/p&gt;
&lt;p&gt;Sigmoid函数的输入记为z，由下面公式得出：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/14f57eeaf24ced43b001399de9fde048.jpg&quot; width=&quot;655&quot; height=&quot;70&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果采用向量的写法，则上述公式可以写成：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e740330abd6ca66af4fb4b0d641f5a1d.jpg&quot; width=&quot;231&quot; height=&quot;70&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中向量X就是分类器的输入数据，向量W也就是我们要找到的最佳参数，从而使分类器尽可能更加地精确。接下来将介绍几种需找最佳参数的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;梯度上升法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;梯度上升法的基本思想：&lt;/p&gt;
&lt;p&gt;要找到某函数的最大值，最好的方法是沿着该函数的梯度方向寻找&lt;/p&gt;
&lt;p&gt;这里提一下梯度下降法，这个我们应该会更加熟悉，因为我们在很多代价函数J的优化的时候经常用到它，其基本思想是：&lt;/p&gt;
&lt;p&gt;要找到某函数的最小值，最好的方法是沿着该函数的梯度方向的反方向寻找&lt;/p&gt;
&lt;p&gt;函数的梯度表示方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/08092aba19c17b70b7e4352c322c3deb.jpg&quot; width=&quot;495&quot; height=&quot;297&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/bd1e8e8f7e1bf0030e61e96848faf2be.jpg&quot; width=&quot;690&quot; height=&quot;93&quot;&gt;&lt;/p&gt;
&lt;p&gt;移动方向确定了，移动的大小我们称之为步长，用α表示，用向量来表示的话，梯度下降算法的迭代公式如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e3091bb4b1ff91b26870ecc03dbfcbb8.jpg&quot; width=&quot;417&quot; height=&quot;79&quot;&gt;&lt;/p&gt;
&lt;p&gt;该公式已知被迭代执行，直到某个停止条件位置，比如迭代次数达到某个指定值或者算法的误差小到某个允许的误差范围内。&lt;/p&gt;
&lt;p&gt;注：梯度下降算法中的迭代公式如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/81cbfc30c3da7a117669a02e77577dcf.jpg&quot; width=&quot;417&quot; height=&quot;79&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Matlab 实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;function weight = gradAscent
%%
clc
close all
clear
%%
data = load(&#39;testSet.txt&#39;);
[row , col] = size(data);
dataMat = data(:,1:col-1);
dataMat = [ones(row,1) dataMat] ;
labelMat = data(:,col);
alpha = 0.001;
maxCycle = 500;
weight = ones(col,1);
for i = 1:maxCycle
 h = sigmoid((dataMat * weight)&#39;);
 error = (labelMat - h&#39;);
 weight = weight + alpha * dataMat&#39; * error;
end
figure
scatter(dataMat(find(labelMat(:) == 0),2),dataMat(find(labelMat(:) == 0),3),3);
hold on
scatter(dataMat(find(labelMat(:) == 1),2),dataMat(find(labelMat(:) == 1),3),5);
hold on
x = -3:0.1:3;
y = (-weight(1)-weight(2)*x)/weight(3);
plot(x,y)
hold off
end
function returnVals = sigmoid(inX)
 % 注意这里的sigmoid函数要用点除
 returnVals = 1.0./(1.0+exp(-inX));
end&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;效图如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/d9b27f9e65fdf4e6edab9e9aebac7524.jpg&quot; width=&quot;560&quot; height=&quot;420&quot;&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看到，回归效果还是挺不错的，只有2-4个点分类错误。&lt;/p&gt;
&lt;p&gt;其实这是的梯度上升算法是批量梯度上升算法，每一次更新参数的时候都要讲所有的数据集都代入训练，效果并不好，下面我们将介绍改进版本：随机梯度上升算法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随机梯度上升&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;梯度上升算法在每次更新回归系数时都要遍历整个数据集，该方法在处理100个左右的数据集时尚可，但如果有数十亿样本和成千上万的特征，那么该方法的复杂度就太高了。一种改进方法是一次仅用一个样本点来更新回归系数，该方法就称为随机梯度上升法。由于可以在新样本到来之前对分类器进行增量式更新，因此随机梯度算法是一个在线学习算法。与”在线学习“相对应，一次处理所有数据被称作是”批处理“&lt;/p&gt;
&lt;p&gt;随机梯度上升算法可以写成如下的伪代码：&lt;/p&gt;
&lt;p&gt;所有回归系数初始化为1&lt;br&gt;
对数据集中的每个样本&lt;br&gt;
计算该样本的梯度&lt;br&gt;
使用alpha x gradient 更新回归系数值&lt;br&gt;
返回回归系数值&lt;br&gt;
&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Matlab 代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;function stocGradAscent
%%
%
% Description : LogisticRegression using stocGradAsscent
% Author : Liulongpo
% Time：2015-4-18 10:57:25
%
%%
clc
clear 
close all
%%
data = load(&#39;testSet.txt&#39;);
[row , col] = size(data);
dataMat = [ones(row,1) data(:,1:col-1)];
alpha = 0.01;
labelMat = data(:,col);
weight = ones(col,1);
for i = 1:row
 h = sigmoid(dataMat(i,:)*weight);
 error = labelMat(i) - h;
 dataMat(i,:)
 weight
 weight = weight + alpha * error * dataMat(i,:)&#39;
end
figure
scatter(dataMat(find(labelMat(:)==0),2),dataMat(find(labelMat(:)==0),3),5);
hold on
scatter(dataMat(find(labelMat(:) == 1),2),dataMat(find(labelMat(:) == 1),3),5);
hold on
x = -3:0.1:3;
y = -(weight(1)+weight(2)*x)/weight(3);
plot(x,y)
hold off

end
function returnVals = sigmoid(inX)
 % 注意这里的sigmoid函数要用点除
 returnVals = 1.0./(1.0+exp(-inX));
end&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;效果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/b17298172a463bea826144325ace9f2c.jpg&quot; width=&quot;560&quot; height=&quot;420&quot;&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看出，随机梯度上升算法分类效果并没有上面的的梯度上升算法分类效果好。&lt;/p&gt;
&lt;p&gt;但是直接比较梯度上升算法和随机梯度上升算法是不公平的，前者是在整个数据集上迭代500次得到的结果，后者只是迭代了100次。一个判断算法优劣的可靠方法是看它是否收敛，也就是说求解的参数是否达到了稳定值，是否还会不断变化。&lt;/p&gt;
&lt;p&gt;我们让随机梯度上升算法在整个数据集上运行200次，迭代过程中3个参数的变化如下图：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/15b047844ad1b2cfc3df93a8c1ae0e90.jpg&quot; width=&quot;560&quot; height=&quot;420&quot;&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看到，weight1 最先达到稳定，而weight0和weight2则还需要更多的迭代次数来达到稳定。&lt;/p&gt;
&lt;p&gt;此时的分类器跟之前的梯度上升算法的分类效果差不多，如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/c133b57418f958a863869b816986a2c0.jpg&quot; width=&quot;560&quot; height=&quot;420&quot;&gt;&lt;/p&gt;
&lt;p&gt;但同时我们也可以看到，三个参数都有不同程度的波动。产生这种现象的原因是存在一些不能被正确分类的样本点（数据集并非线性可分），在每次迭代的时候都会引起参数的剧烈变化。我们期望算法能避免来回波动，从而收敛到某个值。另外，算法收敛速度也要加快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;改进的随机梯度上升算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;改进的随机梯度上升算法的主要两个改进点如下：&lt;/p&gt;
&lt;p&gt;1,每一步调整alpha的值，也就是alpha的值是不严格下降的&lt;br&gt;
2.随机采取样本来更新回归参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;matlab代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;function ImproveStocGradAscent
%%
%
% Description : LogisticRegression using stocGradAsscent
% Author : Liulongpo
% Time：2015-4-18 10:57:25
%
%%
clc
clear 
close all
%%
data = load(&#39;testSet.txt&#39;);
[row , col] = size(data);
dataMat = [ones(row,1) data(:,1:col-1)];
%alpha = 0.01;
numIter = 20;
labelMat = data(:,col);
weightVal = zeros(3,numIter*row);
weight = ones(col,1);
j = 0;
for k = 1:numIter
 randIndex = randperm(row);
 for i = 1:row
 % 改进点 1
 alpha = 4/(1.0+i+k)+0.01; 
 j = j+1;
 % 改进点 2 
 h = sigmoid(dataMat(randIndex(i),:)*weight);
 % 改进点 2
 error = labelMat(randIndex(i)) - h;
 % 改进点 2
 weight = weight + alpha * error * dataMat(randIndex(i),:)&#39;;
 weightVal(1,j) = weight(1);
 weightVal(2,j) = weight(2);
 weightVal(3,j) = weight(3);
 end
end
figure
i = 1:numIter*row;
subplot(3,1,1)
plot(i,weightVal(1,:)),title(&#39;weight0&#39;)%,axis([0 numIter*row 0.8 7])
j = 1:numIter*row;
subplot(3,1,2)
plot(j,weightVal(2,:)),title(&#39;weight1&#39;)%,axis([0 numIter*row 0.3 1.2])
k = 1:numIter*row;
subplot(3,1,3)
plot(k,weightVal(3,:)),title(&#39;weight2&#39;)%,axis([0 numIter*row -1.2 -0.1])
figure
scatter(dataMat(find(labelMat(:)==0),2),dataMat(find(labelMat(:)==0),3),5);
hold on
scatter(dataMat(find(labelMat(:) == 1),2),dataMat(find(labelMat(:) == 1),3),5);
hold on
x = -3:0.1:3;
y = -(weight(1)+weight(2)*x)/weight(3);
plot(x,y,&#39;r&#39;)
hold off

end
function returnVals = sigmoid(inX)
 % 注意这里的sigmoid函数要用点除
 returnVals = 1.0./(1.0+exp(-inX));
end&lt;/pre&gt;
&lt;p&gt;改进点 1 中的alpha会随着迭代次数的增加不断减小，但由于代码中常数0.01的存在，alpha不会减少到0。这样做是为了保证在多次迭代之后新数据对于参数的更新还有一定的影响。&lt;/p&gt;
&lt;p&gt;另一点值得注意的就是，alpha每次减少 1/(k+i) ，k 是迭代次数，i是样本的下标。所以 alpha 不是严格下降的。避免参数的严格下降也常见于模拟退火算法等其他优化算法中。&lt;/p&gt;
&lt;p&gt;第二个改进的地方如代码注释中标记的，这里通过随机采取样本来更新回归参数，这样能够减少参数的周期性的波动。&lt;/p&gt;
&lt;p&gt;由于alpha的动态变化，我们可以在开始的时候设置比较大的值，代码中设置0.01，alpha也就是每一次迭代的步长，步长越大，越能够加快参数的收敛速度。然后ahpha会不严格下降，这样就避免了过拟合现象的发生。至于什么是过拟合已经alpha的选取问题将在下面描述。&lt;/p&gt;
&lt;p&gt;迭代20次后效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/a0e4ae063d45fd3473eb5814432b479a.jpg&quot; width=&quot;560&quot; height=&quot;420&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/cf5a7e2c5c831fbb3f1a6e81aafe3689.jpg&quot; width=&quot;560&quot; height=&quot;420&quot;&gt;&lt;/p&gt;
&lt;p&gt;由上图可知，步长alpha动态变化之后，参数的收敛速度加快了很多，这里只是对所有样本数据集迭代20次，weight0 和 weight2很早就收敛。证明了该算法的优异性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习率alpha的选取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们看一下梯度上升算法的核心代码，如下：&lt;/p&gt;
&lt;p&gt;h = sigmoid(dataMat(i,:) * weight);&lt;br&gt;
error = labelMat(i) – h;&lt;br&gt;
weight = weight + alpha * error * dataMat(i,:)’;&lt;/p&gt;
&lt;p&gt;第一行做的就是估计分类，第二行计算当前估计与正确分类之间的差error，第三行根据这个error来更新参数weight。&lt;/p&gt;
&lt;p&gt;我们在迭代的时候，要做的目标就是最小化 error ，我们令 J 代表 error，令向量 θ 代表weight，则很显然，J是θ的函数。这里盗用Standfor 机器学习教程的图，如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/34d404890cc220ccce93fe4236026792.jpg&quot; width=&quot;436&quot; height=&quot;542&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图中的每个箭头就是每一次迭代的更新步长，第一幅图我们看到，在最小化 J(θ) 的时候迭代了很多次，这说明什么？说明我们要走很多步才能到达全局最优点，原因就是我们每一步走的距离太短，走得太慢，也就是我们的alpha设置得太小。但是当我们处于最优点附近的时候，这样有利我们向最优点靠近。&lt;/p&gt;
&lt;p&gt;下图中的每个箭头也代表走一步，我们可以看到，迭代的时候，每一步都没有到达最优点，而是在最优点的附近波动。为什么呢？因为步长太大了嘛，明明就在眼前了，半步或者四分之三步就走到了，你却只能一跨而过，重新再来。但是学习率大的话，在刚开始迭代的时候有利于我们参数的快速收敛，也有利于我们避开局部最小值。&lt;/p&gt;
&lt;p&gt;综合以上两种情况，我们就应该在开始的时候选取较大的学习率，然后不断不严格减小学习率，这样才是最优的选择。&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-14-86922-002be1f0c.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-14-86922-002be1f0c.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>机器学习实战ByMatlab（4）：二分K-means算法</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;前面我们在是实现K-means算法的时候，提到了它本身存在的缺陷：&lt;/p&gt;
&lt;p&gt;1.可能收敛到局部最小值&lt;br&gt;
2.在大规模数据集上收敛较慢&lt;/p&gt;
&lt;p&gt;对于上一篇博文最后说的，当陷入局部最小值的时候，处理方法就是多运行几次K-means算法，然后选择畸变函数J较小的作为最佳聚类结果。这样的说法显然不能让我们接受，我们追求的应该是一次就能给出接近最优的聚类结果。&lt;/p&gt;
&lt;p&gt;其实K-means的缺点的根本原因就是：对K个质心的初始选取比较敏感。质心选取得不好很有可能就会陷入局部最小值。&lt;/p&gt;
&lt;p&gt;基于以上情况，有人提出了二分K-means算法来解决这种情况，也就是弱化初始质心的选取对最终聚类效果的影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二分K-means算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在介绍二分K-means算法之前我们先说明一个定义：SSE（Sum of Squared Error）,也就是误差平方和，它是用来度量聚类效果的一个指标。其实SSE也就是我们在K-means算法中所说的畸变函数：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/92b34e4035fb7a24abf9d0a5c68defb9.jpg&quot; width=&quot;195&quot; height=&quot;52&quot;&gt;&lt;/p&gt;
&lt;p&gt;SSE计算的就是一个cluster中的每个点到质心的平方差，它可以度量聚类的好坏。显然SSE越小，说明聚类效果越好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二分K-means算法的主要思想：&lt;/strong&gt;&lt;br&gt;
首先将所有点作为一个簇，然后将该簇一分为二。之后选择能最大程度降低聚类代价函数（也就是误差平方和）的簇划分为两个簇。以此进行下去，直到簇的数目等于用户给定的数目k为止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二分k均值算法的伪代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将所有数据点看成一个簇&lt;/p&gt;
&lt;p&gt;当簇数目小于k时&lt;/p&gt;
&lt;p&gt;对每一个簇&lt;/p&gt;
&lt;p&gt;计算总误差&lt;/p&gt;
&lt;p&gt;在给定的簇上面进行k-均值聚类（k=2）&lt;/p&gt;
&lt;p&gt;计算将该簇一分为二后的总误差&lt;/p&gt;
&lt;p&gt;选择使得误差最小的那个簇进行划分操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Matlab 实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;function bikMeans
%%
clc
clear
close all
%%
biK = 4;
biDataSet = load(&#39;testSet.txt&#39;);
[row,col] = size(biDataSet);
% 存储质心矩阵
biCentSet = zeros(biK,col);
% 初始化设定cluster数量为1
numCluster = 1;
%第一列存储每个点被分配的质心，第二列存储点到质心的距离
biClusterAssume = zeros(row,2);
%初始化质心
biCentSet(1,:) = mean(biDataSet)
for i = 1:row
 biClusterAssume(i,1) = numCluster;
 biClusterAssume(i,2) = distEclud(biDataSet(i,:),biCentSet(1,:));
end
while numCluster &amp;lt; biK
 minSSE = 10000;
 %寻找对哪个cluster进行划分最好，也就是寻找SSE最小的那个cluster
 for j = 1:numCluster
 curCluster = biDataSet(find(biClusterAssume(:,1) == j),:);
 [spiltCentSet,spiltClusterAssume] = kMeans(curCluster,2);
 spiltSSE = sum(spiltClusterAssume(:,2));
 noSpiltSSE = sum(biClusterAssume(find(biClusterAssume(:,1)~=j),2));
 curSSE = spiltSSE + noSpiltSSE;
 fprintf(&#39;第%d个cluster被划分后的误差为：%f \n&#39; , [j, curSSE])
 if (curSSE &amp;lt; minSSE)
 minSSE = curSSE;
 bestClusterToSpilt = j;
 bestClusterAssume = spiltClusterAssume;
 bestCentSet = spiltCentSet;
 end
 end
 bestClusterToSpilt
 bestCentSet
 %更新cluster的数目
 numCluster = numCluster + 1;
 bestClusterAssume(find(bestClusterAssume(:,1) == 1),1) = bestClusterToSpilt;
 bestClusterAssume(find(bestClusterAssume(:,1) == 2),1) = numCluster;
 % 更新和添加质心坐标
 biCentSet(bestClusterToSpilt,:) = bestCentSet(1,:);
 biCentSet(numCluster,:) = bestCentSet(2,:);
 biCentSet
 % 更新被划分的cluster的每个点的质心分配以及误差
 biClusterAssume(find(biClusterAssume(:,1) == bestClusterToSpilt),:) = bestClusterAssume;
end
figure
%scatter(dataSet(:,1),dataSet(:,2),5)
for i = 1:biK
 pointCluster = find(biClusterAssume(:,1) == i);
 scatter(biDataSet(pointCluster,1),biDataSet(pointCluster,2),5)
 hold on
end
%hold on
scatter(biCentSet(:,1),biCentSet(:,2),300,&#39;+&#39;)
hold off
end
% 计算欧式距离
function dist = distEclud(vecA,vecB)
 dist = sum(power((vecA-vecB),2));
end
% K-means算法
function [centSet,clusterAssment] = kMeans(dataSet,K)
[row,col] = size(dataSet);
% 存储质心矩阵
centSet = zeros(K,col);
% 随机初始化质心
for i= 1:col
 minV = min(dataSet(:,i));
 rangV = max(dataSet(:,i)) - minV;
 centSet(:,i) = repmat(minV,[K,1]) + rangV*rand(K,1);
end
% 用于存储每个点被分配的cluster以及到质心的距离
clusterAssment = zeros(row,2);
clusterChange = true;
while clusterChange
 clusterChange = false;
 % 计算每个点应该被分配的cluster
 for i = 1:row
 % 这部分可能可以优化
 minDist = 10000;
 minIndex = 0;
 for j = 1:K
 distCal = distEclud(dataSet(i,:) , centSet(j,:));
 if (distCal &amp;lt; minDist)
 minDist = distCal;
 minIndex = j;
 end
 end
 if minIndex ~= clusterAssment(i,1) 
 clusterChange = true;
 end
 clusterAssment(i,1) = minIndex;
 clusterAssment(i,2) = minDist;
 end
% 更新每个cluster 的质心
 for j = 1:K
 simpleCluster = find(clusterAssment(:,1) == j);
 centSet(j,:) = mean(dataSet(simpleCluster&#39;,:));
 end
end
end&lt;/pre&gt;
&lt;p&gt;算法迭代过程如下&lt;/p&gt;
&lt;p&gt;biCentSet =&lt;/p&gt;
&lt;p&gt;-0.1036   0.0543&lt;br&gt;
0   0&lt;br&gt;
0   0&lt;br&gt;
0   0&lt;/p&gt;
&lt;p&gt;第1个cluster被划分后的误差为：792.916857&lt;/p&gt;
&lt;p&gt;bestClusterToSpilt =&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;bestCentSet =&lt;/p&gt;
&lt;p&gt;-0.2897 -2.8394&lt;br&gt;
0.0825 2.9480&lt;/p&gt;
&lt;p&gt;biCentSet =&lt;/p&gt;
&lt;p&gt;-0.2897   -2.8394&lt;br&gt;
0.0825   2.9480&lt;br&gt;
0   0&lt;br&gt;
0   0&lt;/p&gt;
&lt;p&gt;第1个cluster被划分后的误差为：409.871545&lt;br&gt;
第2个cluster被划分后的误差为：532.999616&lt;/p&gt;
&lt;p&gt;bestClusterToSpilt =&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;bestCentSet =&lt;/p&gt;
&lt;p&gt;-3.3824   -2.9473&lt;br&gt;
2.8029   -2.7315&lt;/p&gt;
&lt;p&gt;biCentSet =&lt;/p&gt;
&lt;p&gt;-3.3824   -2.9473&lt;br&gt;
0.0825   2.9480&lt;br&gt;
2.8029   -2.7315&lt;br&gt;
0   0&lt;/p&gt;
&lt;p&gt;第1个cluster被划分后的误差为：395.669052&lt;br&gt;
第2个cluster被划分后的误差为：149.954305&lt;br&gt;
第3个cluster被划分后的误差为：393.431098&lt;/p&gt;
&lt;p&gt;bestClusterToSpilt =&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;bestCentSet =&lt;/p&gt;
&lt;p&gt;2.6265   3.1087&lt;br&gt;
-2.4615   2.7874&lt;/p&gt;
&lt;p&gt;biCentSet =&lt;/p&gt;
&lt;p&gt;-3.3824   -2.9473&lt;br&gt;
2.6265   3.1087&lt;br&gt;
2.8029   -2.7315&lt;br&gt;
-2.4615   2.7874&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最终效果图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/27ab9f5dd4bf27992dbc7953e5ad2b9b.jpg&quot; width=&quot;560&quot; height=&quot;420&quot;&gt;&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-14-86914-0cb880bf3.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-14-86914-0cb880bf3.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>机器学习实战ByMatlab（3）：K-means算法</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;K-means算法属于无监督学习聚类算法，其计算步骤还是挺简单的，思想也挺容易理解，而且还可以在思想中体会到EM算法的思想。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;K-means 算法的优缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.优点：容易实现&lt;br&gt;
2.缺点：可能收敛到局部最小值，在大规模数据集上收敛较慢&lt;/p&gt;
&lt;p&gt;使用数据类型：数值型数据&lt;/p&gt;
&lt;p&gt;以往的回归算法、朴素贝叶斯、SVM等都是有类别标签y的，因此属于有监督学习，而K-means聚类算法只有x，没有y&lt;/p&gt;
&lt;p&gt;在聚类问题中，我们的训练样本是&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/6de54833a3afca601563d4b9c4360af3.jpg&quot; width=&quot;260&quot; height=&quot;84&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中每个Xi都是n维实数。&lt;/p&gt;
&lt;p&gt;样本数据中没有了y，K-means算法是将样本聚类成k个簇，具体算法如下：&lt;br&gt;
1、随机选取K个聚类质心点，记为&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/417b9281abd94a733f0cb3c967dbb45a.jpg&quot; width=&quot;456&quot; height=&quot;116&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、重复以下过程直到收敛&lt;/p&gt;
&lt;p&gt;{&lt;br&gt;
对每个样例 i ，计算其应该属于的类：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/75daeda3ab5cc3dbcc808decd0797eee.jpg&quot; width=&quot;586&quot; height=&quot;93&quot;&gt;&lt;/p&gt;
&lt;p&gt;对每个类 j ，重新计算质心：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/95c7433d0b8e0653509f9b6c32b7dff1.jpg&quot; width=&quot;535&quot; height=&quot;205&quot;&gt;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;其中K是我们事先给定的聚类数目，Ci 表示样本 i 与K个聚类中最近的那个类，Ci的值是1到K中的一个，质心uj代表我们对属于同一个类的样本中心的猜测。解释起来就是，&lt;/p&gt;
&lt;p&gt;第一步：天空上的我们随机抽取K个星星作为星团的质心，然后对于每一个星星 i，我们计算它到每一个质心uj的距离，选取其中距离最短的星团作为Ci，这样第一步每个星星都有了自己所属于的星团；&lt;/p&gt;
&lt;p&gt;第二步：对每个星团Ci，我们重新计算它的质心uj（计算方法为对属于该星团的所有点的坐标求平均）不断重复第一步和第二步直到质心变化很小或者是不变。&lt;/p&gt;
&lt;p&gt;然后问题来了，怎么样才算质心变化很小或者是不变？或者说怎么判定？答案就是畸变函数（distortion function），定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/088cf8efb61716e6068dcaf743372025.jpg&quot; width=&quot;690&quot; height=&quot;188&quot;&gt;&lt;/p&gt;
&lt;p&gt;J函数表示每个样本点到其质心的距离平方和，K-means的收敛就是要将 J 调整到最小，假设当前 J 值没有达到最小值，那么可以先固定每个类的质心 uj ，调整每个样例的类别 Ci 来时 J 函数减少。同样，固定 Ci ，调整每个类的质心 uj也可以是 J 减少。这两个过程就是内循环中使 J 单调变小的过程。当 J 减小到最小的时候， u 和 c 也同时收敛。（该过程跟EM算法其实还是挺像的）理论上可能出现多组 u 和 c 使 J 取得最小值，但这种情况实际上很少见。&lt;/p&gt;
&lt;p&gt;由于畸变函数 J 是非凸函数，所以我们不能保证取得的最小值一定是全局最小值，这说明k-means算法质心的初始位置的选取会影响到最后最小值的获取。不过一般情况下，k-means算法达到的局部最优已经满足要求。如果不幸代码陷入局部最优，我们可以选取不同的初始值跑多几遍 k-means 算法，然后选取其中最小的 J 对应的 u 和 c 输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另一种收敛判断：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际我们编写代码的时候，还可以通过判断“每个点被分配的质心是否改变”这个条件来判断聚类是否已经收敛&lt;/p&gt;
&lt;p&gt;而上面所说的畸变函数则可以用来评估收敛的效果，具体将会在下面的实例中体现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Matlab 实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;function kMeans
clc
clear
K = 4;
dataSet = load(&#39;testSet.txt&#39;);
[row,col] = size(dataSet);
% 存储质心矩阵
centSet = zeros(K,col);
% 随机初始化质心
for i= 1:col
 minV = min(dataSet(:,i));
 rangV = max(dataSet(:,i)) - minV;
 centSet(:,i) = repmat(minV,[K,1]) + rangV*rand(K,1);
end
% 用于存储每个点被分配的cluster以及到质心的距离
clusterAssment = zeros(row,2);
clusterChange = true;
while clusterChange
 clusterChange = false;
 % 计算每个点应该被分配的cluster
 for i = 1:row
 % 这部分可能可以优化
 minDist = 10000;
 minIndex = 0;
 for j = 1:K
 distCal = distEclud(dataSet(i,:) , centSet(j,:));
 if (distCal &amp;lt; minDist)
 minDist = distCal;
 minIndex = j;
 end
 end
 if minIndex ~= clusterAssment(i,1) 
 clusterChange = true;
 end
 clusterAssment(i,1) = minIndex;
 clusterAssment(i,2) = minDist;
 end
% 更新每个cluster 的质心
 for j = 1:K
 simpleCluster = find(clusterAssment(:,1) == j);
 centSet(j,:) = mean(dataSet(simpleCluster&#39;,:));
 end
end
figure
%scatter(dataSet(:,1),dataSet(:,2),5)
for i = 1:K
 pointCluster = find(clusterAssment(:,1) == i);
 scatter(dataSet(pointCluster,1),dataSet(pointCluster,2),5)
 hold on
end
%hold on
scatter(centSet(:,1),centSet(:,2),300,&#39;+&#39;)
hold off
end
% 计算欧式距离
function dist = distEclud(vecA,vecB)
 dist = sqrt(sum(power((vecA-vecB),2)));
end&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;这是正常分类的情况，很明显被分为了4个类，不同颜色代表不同的类，cluster的质心为 “ + ”&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/6fd4a0d691e26034cfd26e8a5ee45567.jpg&quot; width=&quot;560&quot; height=&quot;420&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，这只是其中一种情况，很有可能我们会出现下面这种情况：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/6e315d36d815e3724716a7432c76130a.jpg&quot; width=&quot;560&quot; height=&quot;420&quot;&gt;&lt;/p&gt;
&lt;p&gt;这就是上面所说的，K-means的缺点之一，随机初始点的选择可能会让算法陷入局部最优解，这时候我们只需重新运行一次程序即可。&lt;/p&gt;
&lt;p&gt;至于每一个看似都可以正常聚类的情况呢，我们则利用上面所说的“畸变函数”来衡量聚类的效果，当然是J越小聚类效果越好。&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-14-86909-06736bc08.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-14-86909-06736bc08.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>机器学习实战ByMatlab（2）：PCA算法</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;PCA 算法也叫主成分分析（principal components analysis），主要是用于数据降维的。&lt;/p&gt;
&lt;p&gt;为什么要进行数据降维？因为实际情况中我们的训练数据会存在特征过多或者是特征累赘的问题，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个关于汽车的样本数据，一个特征是”km/h的最大速度特征“，另一个是”英里每小时“的最大速度特征，很显然这两个特征具有很强的相关性&lt;/li&gt;
&lt;li&gt;拿到一个样本，特征非常多，样本缺很少，这样的数据用回归去你和将非常困难，很容易导致过度拟合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PCA算法就是用来解决这种问题的，其核心思想就是将 n 维特征映射到 k 维上（k &amp;lt; n），这 k 维是全新的正交特征。我们将这 k 维成为主元，是重新构造出来的 k 维特征，而不是简单地从 n 维特征中取出其余 n-k 维特征。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PCA 的计算过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们得到 2 维数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/cdd0f2aaece4495958e61b71a963e808.jpg&quot; width=&quot;266&quot; height=&quot;390&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中行代表样例，列代表特征，这里有10个样例，每个样例有2个特征，我们假设这两个特征是具有较强的相关性，需要我们对其进行降维的。&lt;/p&gt;
&lt;p&gt;第一步：分别求 x 和 y 的平均值，然后对所有的样例都减去对应的均值&lt;/p&gt;
&lt;p&gt;这里求得 x 的均值为 1.81 ， y 的均值为 1.91，减去均值后得到数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/5adae96b9ba8e9449789454301888ab7.jpg&quot; width=&quot;369&quot; height=&quot;400&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意，此时我们一般应该在对特征进行方差归一化，目的是让每个特征的权重都一样，但是由于我们的数据的值都比较接近，所以归一化这步可以忽略不做&lt;/p&gt;
&lt;p&gt;第一步的算法步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e680a80e1492c83636116d13d5366a51.jpg&quot; width=&quot;377&quot; height=&quot;390&quot;&gt;&lt;/p&gt;
&lt;p&gt;本例中步骤3、4没有做。&lt;/p&gt;
&lt;p&gt;第二步：求特征协方差矩阵&lt;/p&gt;
&lt;p&gt;公式如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/bcbba1735d6ab95f8d3a4787b77ce45b.jpg&quot; width=&quot;452&quot; height=&quot;116&quot;&gt;&lt;/p&gt;
&lt;p&gt;第三步：求解协方差矩阵的特征值和特征向量&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/d9eb0eb5570affd5426458635c15a277.jpg&quot; width=&quot;429&quot; height=&quot;116&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/4cd35fab8cb9de750e17674303fc13c8.jpg&quot; width=&quot;690&quot; height=&quot;105&quot;&gt;&lt;br&gt;
第四步：将特征值从大到小进行排序，选择其中最大的 k 个，然后将其对应的 k 个特征向量分别作为列向量组成特征矩阵&lt;/p&gt;
&lt;p&gt;这里的特征值只有两个，我们选择最大的那个，为： 1.28402771 ，其对应的特征向量为：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/589dec0057c50c25e7ebf2df8ae51fe8.jpg&quot; width=&quot;290&quot; height=&quot;119&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意：matlab 的 eig 函数求解协方差矩阵的时候，返回的特征值是一个特征值分布在对角线的对角矩阵，第 i 个特征值对应于第 i 列的特征向量&lt;/p&gt;
&lt;p&gt;第五步： 将样本点投影到选取的特征向量上&lt;/p&gt;
&lt;p&gt;假设样本列数为 m ，特征数为 n ，减去均值后的样本矩阵为 DataAdjust(m*n),协方差矩阵为 n*n ,选取 k 个特征向量组成后的矩阵为 EigenVectors(n*k)，则投影后的数据 FinalData 为：&lt;/p&gt;
&lt;p&gt;FinalData （m*k） = DataAdjust(m*n) X EigenVectors(n*k)&lt;/p&gt;
&lt;p&gt;得到的结果是：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/95e0d97944d9ff9e767e7ede623d634e.jpg&quot; width=&quot;365&quot; height=&quot;340&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样，我们就将 n 维特征降成了 k 维，这 k 维就是原始特征在 k 维上的投影。&lt;/p&gt;
&lt;p&gt;整个PCA的过程貌似很简单，就是求协方差的特征值和特征向量，然后做数据转换。但为什么协方差的特征向量就是最理想的 k 维向量？这个问题由PCA的理论基础来解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PCA 的理论基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于为什么协方差的特征向量就是 k 维理想特征，有3个理论，分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最大方差理论&lt;/li&gt;
&lt;li&gt;最小错误理论&lt;/li&gt;
&lt;li&gt;坐标轴相关度理论&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里简单描述下最大方差理论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大方差理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;信号处理中认为信号具有较大的方差，噪声有较小的方差，信噪比就是信号与噪声的方差比，越大越好。因此我们认为，最好的 k 为特征既是将 n 维样本点转换为 k 维后，每一维上的样本方差都很大&lt;/p&gt;
&lt;p&gt;PCA 处理图解如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/6a7bbc450bd8f32e2955f6da7e0c704c.jpg&quot; width=&quot;463&quot; height=&quot;425&quot;&gt;&lt;/p&gt;
&lt;p&gt;降维转换后：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/7461f9957de1efb150c566f48278ef49.jpg&quot; width=&quot;684&quot; height=&quot;326&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图中的直线就是我们选取的特征向量，上面实例中PCA的过程就是将空间的2维的点投影到直线上。&lt;/p&gt;
&lt;p&gt;那么问题来了，两幅图都是PCA的结果，哪一幅图比较好呢？&lt;/p&gt;
&lt;p&gt;根据最大方差理论，答案是左边的图，其实也就是样本投影后间隔较大，容易区分。&lt;/p&gt;
&lt;p&gt;其实从另一个角度看，左边的图每个点直线上的距离绝对值之和比右边的每个点到直线距离绝对值之和小，是不是有点曲线回归的感觉？其实从这个角度看，这就是最小误差理论：选择投影后误差最小的直线。&lt;/p&gt;
&lt;p&gt;再回到上面的左图，也就是我们要求的最佳的 u ，前面说了，最佳的 u 也就是最佳的曲线，它能够使投影后的样本方差最大或者是误差最小。&lt;/p&gt;
&lt;p&gt;另外，由于我们前面PCA算法第一步的时候已经执行对样本数据的每一维求均值，并让每个数据减去均值的预处理了，所以每个特征现在的均值都为0，投影到特征向量上后，均值也为0.因此方差为：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/8ad78cbdf9776b16e8434493cc000fa1.jpg&quot; width=&quot;690&quot; height=&quot;116&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后的等式中中间的那部分其实就是样本方差的协方差矩阵（xi 的均值为 0）&lt;br&gt;
&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3603b54626e1a064e4b2df656f4faeac.jpg&quot; width=&quot;690&quot; height=&quot;87&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于 u 是单位向量，得到&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/dcf4fed2c3649a97ad3a30fbe8e32cf0.jpg&quot; width=&quot;240&quot; height=&quot;76&quot;&gt;&lt;/p&gt;
&lt;p&gt;上式两边痛乘以 u，得到：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/f2ac481cf2d0803d45ff15a673f1aad2.jpg&quot; width=&quot;185&quot; height=&quot;76&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; style=&quot;color: #333333;font-style: normal&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/29244fbd9c9134880d2eb8c9d015544b.jpg&quot; width=&quot;424&quot; height=&quot;76&quot;&gt;&lt;/p&gt;
&lt;p&gt;于是我们得到&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/db1b2e32d77b48b2a8c8f94d0adea341.jpg&quot; width=&quot;690&quot; height=&quot;59&quot;&gt;&lt;/p&gt;
&lt;p&gt;最佳投影直线就是特征值 λ 最大是对应的特征向量，其次是 λ 第二大对应的特征向量（求解的到的特征向量都是正交的）。其中 λ 就是我们的方差，也对应了我们前面的最大方差理论，也就是找到能够使投影后方差最大的直线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Matlab 实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;function [lowData,reconMat] = PCA(data,K)
[row , col] = size(data);
meanValue = mean(data);
%varData = var(data,1,1);
normData = data - repmat(meanValue,[row,1]);
covMat = cov(normData(:,1),normData(:,2));%求取协方差矩阵
[eigVect,eigVal] = eig(covMat);%求取特征值和特征向量
[sortMat, sortIX] = sort(eigVal,&#39;descend&#39;);
[B,IX] = sort(sortMat(1,:),&#39;descend&#39;);
len = min(K,length(IX));
eigVect(:,IX(1:1:len));
lowData = normData * eigVect(:,IX(1:1:len));
reconMat = (lowData * eigVect(:,IX(1:1:len))&#39;) + repmat(meanValue,[row,1]); % 将降维后的数据转换到新空间
end&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;调用方式&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;function testPCA
%%
clc
clear
close all
%%
filename = &#39;testSet.txt&#39;;
K = 1;
data = load(filename);
[lowData,reconMat] = PCA(data,K);
figure
scatter(data(:,1),data(:,2),5,&#39;r&#39;)
hold on
scatter(reconMat(:,1),reconMat(:,2),5)
hold off
end&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;效果图&lt;/strong&gt;&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-14-86905-fb0843413.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-14-86905-fb0843413.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>机器学习实战ByMatlab（1）：KNN算法</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;KNN 算法其实简单的说就是“物以类聚”，也就是将新的没有被分类的点分类为周围的点中大多数属于的类。它采用测量不同特征值之间的距离方法进行分类，思想很简单：如果一个样本的特征空间中最为临近（欧式距离进行判断）的K个点大都属于某一个类，那么该样本就属于这个类。这就是物以类聚的思想。&lt;/p&gt;
&lt;p&gt;当然，实际中，不同的K取值会影响到分类效果，并且在K个临近点的选择中，都不加意外的认为这K个点都是已经分类好的了，否则该算法也就失去了物以类聚的意义了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KNN算法的不足点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、当样本不平衡时，比如一个类的样本容量很大，其他类的样本容量很小，输入一个样本的时候，K个临近值中大多数都是大样本容量的那个类，这时可能就会导致分类错误。改进方法是对K临近点进行加权，也就是距离近的点的权值大，距离远的点权值小。&lt;/p&gt;
&lt;p&gt;2、计算量较大，每个待分类的样本都要计算它到全部点的距离，根据距离排序才能求得K个临近点，改进方法是：先对已知样本点进行剪辑，事先去除对分类作用不大的样本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;适用于样本容量比较大的类域的自动分类，而样本容量较小的类域则容易误分&lt;/p&gt;
&lt;p&gt;算法描述：&lt;/p&gt;
&lt;p&gt;1、计算已知类别数据集合汇总的点与当前点的距离&lt;br&gt;
2、按照距离递增次序排序&lt;br&gt;
3、选取与当前点距离最近的K个点&lt;br&gt;
4、确定距离最近的前K个点所在类别的出现频率&lt;br&gt;
5、返回距离最近的前K个点中频率最高的类别作为当前点的预测分类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python 实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;from numpy import *
import operator
def createDataSet():
 group = array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]])
 lables = [&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;B&#39;]
 return group,lables
# KNN 分类算法
def classify0(inx,dataSet,labels,k):
 dataSetSize = dataSet.shape[0] # shape[0]获取行 shape[1] 获取列
 # 第一步，计算欧式距离
 diffMat = tile(inx,(dataSetSize,1)) - dataSet #tile类似于matlab中的repmat，复制矩阵
 sqDiffMat = diffMat ** 2
 sqDistances = sqDiffMat.sum(axis=1)
 distance = sqDistances ** 0.5
 sortedDistIndecies = distance.argsort() # 增序排序
 classCount = {}
 for i in range(k):
 # 获取类别 
 voteIlabel = labels[sortedDistIndecies[i]]
 #字典的get方法，查找classCount中是否包含voteIlabel，是则返回该值，不是则返回defValue，这里是0
 # 其实这也就是计算K临近点中出现的类别的频率，以次数体现
 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1
 # 对字典中的类别出现次数进行排序，classCount中存储的事 key-value，其中key就是label，value就是出现的次数
 # 所以key=operator.itemgetter(1)选中的事value，也就是对次数进行排序
 sortedClassCount = sorted(classCount.iteritems(),key=operator.itemgetter(1),reverse=True)
 #sortedClassCount[0][0]也就是排序后的次数最大的那个label
 return sortedClassCount[0][0]&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;调用方式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;import sys;
sys.path.append(&quot;/home/llp/code/funcdef&quot;)
import KNN
group,labels = KNN.createDataSet();
relust = KNN.classify0([0,0],group,labels,3)
print &#39;the classify relust is :&#39; , relust&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Matlab 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里以一个完整实例呈现，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;function relustLabel = KNN(inx,data,labels,k)
%% 
% inx 为 输入测试数据，data为样本数据，labels为样本标签
%%
[datarow , datacol] = size(data);
diffMat = repmat(inx,[datarow,1]) - data ;
distanceMat = sqrt(sum(diffMat.^2,2));
[B , IX] = sort(distanceMat,&#39;ascend&#39;);
len = min(k,length(B));
relustLabel = mode(labels(IX(1:len)));
end&lt;/pre&gt;
&lt;p&gt;可以看到，整个KNN算法的Matlab代码也就只有6行，比Python少很多，这其中要得益于Matlab成熟的矩阵计算和很多成熟的函数。&lt;/p&gt;
&lt;p&gt;实际调用中，我们利用一个数据集进行测试，该数据集是由1000个样本的3维坐标组成，共分为3个类&lt;/p&gt;
&lt;p&gt;首先可视化我们的数据集，看看它的分布：&lt;/p&gt;
&lt;p&gt;第一维和第二维：可以清晰地看到数据大致上分为 3 类&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/5319aaf2fdbf982b0d520f6ffa30f62a.jpg&quot; width=&quot;560&quot; height=&quot;420&quot;&gt;&lt;/p&gt;
&lt;p&gt;第1维和第3维：从这个角度看，3类的分布就有点重叠了，这是因为我们的视角原因&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/6569e07a74309a072e61f82b7f7b3cd0.jpg&quot; width=&quot;560&quot; height=&quot;420&quot;&gt;&lt;/p&gt;
&lt;p&gt;画出3维，看看它的庐山真面目：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/c74b472931075f5a7454efb36ee1522b.jpg&quot; width=&quot;560&quot; height=&quot;420&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于我们已经编写了KNN代码，接下来我们只需调用就行。了解过机器学习的人都应该知道，很多样本数据在代入算法之前都应该进行归一化，这里我们将数据归一化在[0,1]的区间内，归一化方式如下：&lt;/p&gt;
&lt;p&gt;newData = (oldData-minValue)/(maxValue-minValue)&lt;/p&gt;
&lt;p&gt;其中，maxValue为oldData的最大值，minValue为 oldData 的最小值。&lt;/p&gt;
&lt;p&gt;同时，我们对于1000个数据集，采取10%的数据进行测试，90%的数据进行训练的方式，由于本测试数据之间完全独立，可以随机抽取10%的数据作为测试数据，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;function KNNdatgingTest
%%
clc
clear
close all
%%
data = load(&#39;datingTestSet2.txt&#39;);
dataMat = data(:,1:3);
labels = data(:,4);
len = size(dataMat,1);
k = 4;
error = 0;
% 测试数据比例
Ratio = 0.1;
numTest = Ratio * len;
% 归一化处理
maxV = max(dataMat);
minV = min(dataMat);
range = maxV-minV;
newdataMat = (dataMat-repmat(minV,[len,1]))./(repmat(range,[len,1]));
% 测试
for i = 1:numTest
 classifyresult = KNN(newdataMat(i,:),newdataMat(numTest:len,:),labels(numTest:len,:),k);
 fprintf(&#39;测试结果为：%d 真实结果为：%d\n&#39;,[classifyresult labels(i)])
 if(classifyresult~=labels(i))
 error = error+1;
 end
end
 fprintf(&#39;准确率为：%f\n&#39;,1-error/(numTest))
end&lt;/pre&gt;
&lt;p&gt;当我们选择K为4的时候，准确率为：97%&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KNN进阶&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我们将运用KNN算法实现一个手写识别系统，训练数据集大约2000个样本，每个数字大概有200个样本&lt;br&gt;
测试数据大概有900个样本，由于每个样本都是一个32×32的数字，我们将其转换为1×1024的矩阵，方便我们利用KNN算法&lt;br&gt;
数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/8beb0bb40092bfe629332c92a0ad0ea5.jpg&quot; width=&quot;638&quot; height=&quot;403&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于数据量比较大，加载数据的时候回花一点时间，具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: python; gutter: true&quot;&gt;function handWritingTest
%%
clc
clear
close all
%% 获取目录下的所有txt文件名称
d = dir([&#39;digits/trainingDigits/&#39; &#39;*.txt&#39;]); % struct 类型
dircell = struct2cell(d); %cell 类型
trainSetLen = size(dircell,2);
K = 4;
dataSize = 1024;
trainLabels = zeros(trainSetLen,1);
trainSet = [];
simpleTrainSet = zeros(1,dataSize);
simpleTestSet = zeros(1,dataSize);
%% 加载数据
fprintf(&#39;loading data...&#39;)
for i = 1:trainSetLen
 trainName = dircell(1,i);
 trainFilename = cell2mat(trainName);
 trainLabels(i) = str2num(trainFilename(1));
fid = fopen([&#39;digits/trainingDigits/&#39; trainFilename],&#39;r&#39;);
 traindata = fscanf(fid,&#39;%s&#39;);
 for j = 1:dataSize
 simpleTrainSet(j) = str2num(traindata(j));
 end
 trainSet = [trainSet ; simpleTrainSet];
 fclose(fid);
end
d = dir([&#39;digits/testDigits/&#39; &#39;*.txt&#39;]); % struct 类型
dircell = struct2cell(d); %cell 类型
testSetLen = size(dircell,2);
error = 0;
%% 测试数据
for k = 1:testSetLen
 testName = dircell(1,k);
 testFilename = cell2mat(testName);
 testLabels = str2num(testFilename(1));
fid = fopen([&#39;digits/testDigits/&#39; testFilename],&#39;r&#39;);
 testdata = fscanf(fid,&#39;%s&#39;);
 for j = 1:dataSize
 simpleTestSet(j) = str2num(testdata(j));
 end
 classifyResult = KNN(simpleTestSet,trainSet,trainLabels,K);
 fprintf(&#39;识别数字为：%d 真实数字为：%d\n&#39; , [classifyResult , testLabels])
 if(classifyResult~=testLabels)
 error = error+1;
 end
 fclose(fid);
end
fprintf(&#39;识别准确率为：%f\n&#39;,1-error/testSetLen)
end&lt;/pre&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-14-86901-b3c254ac1.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-14-86901-b3c254ac1.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Elasticsearch 同一索引不同类型下同名字段的映射冲突实例</title>
        <description>

  
  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;这个标题肯定绕晕很多人吧。具体说明一下场景就明白了：Nginx 和 Apache 的访问日志，因为都属于网站访问，所以写入到同一个索引的不同类型下，比方 &lt;code&gt;logstash-accesslog-2015.04.03/nginx&lt;/code&gt; 和 &lt;code&gt;logstash-accesslog-2015.04.03/apache&lt;/code&gt;。既然都是访问日志，肯定很多字段的内容含义是雷同的，比如 clientip, domain, urlpath 等等。其中 nginx 有一个变量叫 &lt;code&gt;$request_time&lt;/code&gt;，apache 有一个变量叫 &lt;code&gt;%T&lt;/code&gt;，乍看上去也是同义的，我就统一命名为 “requestTime” 了。这就是”同一索引(logstash-accesslog-YYYY.MM.DD)下不同类型(nginx,apache)的同名字段(requestTime)”。&lt;/p&gt;
&lt;p&gt;但事实上，这里有个问题：&lt;strong&gt;nginx 中的以秒为单位，是把毫秒算作小数；apache 中的以秒为单位，是真的只记秒钟整数位！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，这两个类型生成的映射在这个字段上是不一致的。nginx 类型的 requestTime 是 &lt;strong&gt;double&lt;/strong&gt;，apache 类型的 requestTime 是 &lt;strong&gt;long&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过平常看起来似乎也没什么影响，写入数据都照常，查看数据的时候默认显示的 JSON 也各自无异。直到我准备用一把 scripted field 的时候，发现计算 &lt;code&gt;doc[&#39;requestTime&#39;].value * 1000&lt;/code&gt; 得到的数都大的吓人！&lt;/p&gt;
&lt;p&gt;因为类似计算之前在只有 nginx 日志入库的时候曾经正确运行过，所以只能是猜测 apache 日志对此造成了影响，但是即使我把请求修改成限定在 nginx 类型数据中进行，结果也没发生变化。&lt;/p&gt;
&lt;p&gt;仔细阅读 scripting module 的文档，其中提到了 &lt;code&gt;doc[&#39;fieldname&#39;].value&lt;/code&gt; 和 &lt;code&gt;_source.fieldname&lt;/code&gt; 两种写法的区别：&lt;strong&gt;前者会利用内存中的数据，而后者强制读取磁盘上 &lt;code&gt;_source&lt;/code&gt; 存储的 JSON 内容，从中释放出相应字段内容。&lt;/strong&gt;莫非是 requestTime 字段跟 &lt;code&gt;_source&lt;/code&gt; JSON 里存的数据确实不一样，而我们平常搜索查看的都是从 JSON 里释放出来的，所以才会如此？&lt;/p&gt;
&lt;p&gt;为了验证我的猜测，做了一个请求测试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# curl es.domain.com:9200/logstash-accesslog-2015.04.03/nginx/_search?q=_id:AUx-QvSBS-dhpiB8_1f1\&amp;amp;pretty -d &#39;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;fields&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;requestTime&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;bodySent&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&quot;script_fields&quot;&lt;/span&gt; : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&quot;test1&quot;&lt;/span&gt; : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&quot;script&quot;&lt;/span&gt; : &lt;span class=&quot;s2&quot;&gt;&quot;doc[\&quot;requestTime\&quot;].value&quot;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,
        &lt;span class=&quot;s2&quot;&gt;&quot;test3&quot;&lt;/span&gt; : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&quot;script&quot;&lt;/span&gt; : &lt;span class=&quot;s2&quot;&gt;&quot;_source.bodySent / _source.requestTime&quot;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,
        &lt;span class=&quot;s2&quot;&gt;&quot;test2&quot;&lt;/span&gt; : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&quot;script&quot;&lt;/span&gt; : &lt;span class=&quot;s2&quot;&gt;&quot;doc[\&quot;requestTime\&quot;].value * 1000&quot;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到的结果如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;took&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;timed_out&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;_shards&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;total&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;56&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;successful&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;56&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;failed&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;hits&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;total&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;max_score&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;hits&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;_index&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;logstash-accesslog-2015.04.03&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;_type&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;nginx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;_id&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;AUx-QvSBS-dhpiB8_1f1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;_score&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;fields&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&quot;test1&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4603039107142836552&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&quot;test2&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;-8646911284551352000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&quot;requestTime&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.54&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&quot;test3&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2444.4444444444443&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&quot;bodySent&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1320&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;果然！直接读取的字段，以及采用 &lt;code&gt;_source.fieldname&lt;/code&gt; 方式读取的内容，都是正确的；而采用 &lt;code&gt;doc[&#39;fieldname&#39;].value&lt;/code&gt; 获取的内存数据，就不对。（0.54 存成 long 型会变成 4603039107142836552。这个 460 还正好能跟 540 凑成 1000，应该是某种特定存法，不过这里我就没深究了）&lt;/p&gt;
&lt;p&gt;再作下一步验证。我们知道，ES 数据的映射是根据第一条数据的类型确定的，之后的数据如何类型跟已经成型的映射不统一，那么写入会失败。现在这个 nginx 和 apache 两个类型在 requestTime 字段上的映射是不一样的，但是内存里却并没有按照映射来处理。那么，我往一个类型下写入另一个类型映射要求的数据，会报错还是会通过呢？&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# curl -XPOST es.domain.com:9200/test/t1/1 -d &#39;{&quot;key&quot;:1}&#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_index&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_type&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;t1&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_id&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_version&quot;&lt;/span&gt;:1,&lt;span class=&quot;s2&quot;&gt;&quot;created&quot;&lt;/span&gt;:true&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# curl -XPOST es.domain.com:9200/test/t2/1 -d &#39;{&quot;key&quot;:2.2}&#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_index&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_type&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;t2&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_id&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_version&quot;&lt;/span&gt;:1,&lt;span class=&quot;s2&quot;&gt;&quot;created&quot;&lt;/span&gt;:true&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# curl -XPOST es.domain.com:9200/test/t1/2 -d &#39;{&quot;key&quot;:2.2}&#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_index&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_type&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;t1&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_id&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;2&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_version&quot;&lt;/span&gt;:1,&lt;span class=&quot;s2&quot;&gt;&quot;created&quot;&lt;/span&gt;:true&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# curl -XPOST es.domain.com:9200/test/t2/2 -d &#39;{&quot;key&quot;:1}&#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_index&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_type&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;t2&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_id&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;2&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_version&quot;&lt;/span&gt;:1,&lt;span class=&quot;s2&quot;&gt;&quot;created&quot;&lt;/span&gt;:true&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# curl -XPOST es.domain.com:9200/test/t1/3 -d &#39;{&quot;key&quot;:&quot;1&quot;}&#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_index&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_type&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;t1&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_id&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;3&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_version&quot;&lt;/span&gt;:1,&lt;span class=&quot;s2&quot;&gt;&quot;created&quot;&lt;/span&gt;:true&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# curl -XPOST es.domain.com:9200/test/t2/3 -d &#39;{&quot;key&quot;:&quot;1&quot;}&#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_index&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_type&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;t2&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_id&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;3&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;_version&quot;&lt;/span&gt;:1,&lt;span class=&quot;s2&quot;&gt;&quot;created&quot;&lt;/span&gt;:true&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# curl -XPOST es.domain.com:9200/test/t2/4 -d &#39;{&quot;key&quot;:&quot;abc&quot;}&#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;error&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;RemoteTransportException[[10.10.10.10][inet[/10.10.10.10:9300]][indices:data/write/index]]; nested: MapperParsingException[failed to parse [key]]; nested: NumberFormatException[For input string: \&quot;abc\&quot;]; &quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;status&quot;&lt;/span&gt;:400&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# curl -XGET es.domain.com:9200/test/_mapping&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mappings&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;t1&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;properties&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;key&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;type&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;long&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}}}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;t2&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;properties&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;key&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;type&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;double&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}}}}}}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果出来了，在映射相互冲突以后，实际数据只要是 numeric detect 能通过的，就都通过了！&lt;/p&gt;
&lt;p&gt;BTW: kibana 4 中，已经会对这种情况以黄色感叹号图标做出提示；而根据官方消息，ES 未来会在 2.0 版正式杜绝这种可能。&lt;/p&gt;
    &lt;hr&gt;
    
    &lt;hr&gt;
  &lt;!-- JiaThis Button BEGIN --&gt;
&lt;div class=&quot;jiathis_style&quot;&gt;
&lt;span class=&quot;jiathis_txt&quot;&gt;分享到：&lt;/span&gt;
&lt;a class=&quot;jiathis_button_tsina&quot;&gt;新浪微博&lt;/a&gt;
&lt;a class=&quot;jiathis_button_weixin&quot;&gt;微信&lt;/a&gt;
&lt;a class=&quot;jiathis_button_renren&quot;&gt;人人网&lt;/a&gt;
&lt;a class=&quot;jiathis_button_ydnote&quot;&gt;有道云笔记&lt;/a&gt;
&lt;a class=&quot;jiathis_button_gmail&quot;&gt;Gmail邮箱&lt;/a&gt;
&lt;a class=&quot;jiathis_button_twitter&quot;&gt;Twitter&lt;/a&gt;
&lt;a class=&quot;jiathis_button_googleplus&quot;&gt;Google+&lt;/a&gt;
&lt;a class=&quot;jiathis_button_hi&quot;&gt;百度空间&lt;/a&gt;
&lt;a class=&quot;jiathis_button_fb&quot;&gt;Facebook&lt;/a&gt;
&lt;a class=&quot;jiathis_button_douban&quot;&gt;豆瓣&lt;/a&gt;
&lt;a href=&quot;http://www.jiathis.com/share?uid=1589850&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;更多&lt;/a&gt;
&lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var jiathis_config={
	data_track_clickback:true,
	summary:&quot;&quot;,
	ralateuid:{
		&quot;tsina&quot;:&quot;1035836154&quot;
	},
	shortUrl:false,
	hideMore:false
}
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://v3.jiathis.com/code/jia.js?uid=1589850&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;!-- JiaThis Button END --&gt;
&lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;
  &lt;/div&gt;

</description>
        <pubDate>Fri, 03 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-04-03-types-mapping-conflict-in-one-index-089c0a17a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-04-03-types-mapping-conflict-in-one-index-089c0a17a.html</guid>
        
        
        <category>chenlinux</category>
        
      </item>
    
      <item>
        <title>Erlang 17.5引入+hpds命令行控制进程默认字典大小</title>
        <description>

			&lt;div style=&quot;margin-top: 15px; font-style: italic&quot;&gt;
&lt;p&gt;&lt;strong&gt;原创文章，转载请注明：&lt;/strong&gt; 转载自&lt;a href=&quot;http://blog.yufeng.info/&quot;&gt;系统技术非业余研究&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接地址:&lt;/strong&gt; &lt;a href=&quot;http://blog.yufeng.info/archives/3202&quot;&gt;Erlang 17.5引入+hpds命令行控制进程默认字典大小&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Erlang 17.5发布引入控制进程默认字典大小的命令行参数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
Erlang/OTP 17.5 has been released&lt;br&gt;
Written by Henrik, 01 Apr 2015&lt;/p&gt;
&lt;p&gt;Some highlights of the release are:&lt;br&gt;
ERTS: Added command line argument option for setting the initial size of process dictionaries.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;源码变化参看： https://github.com/erlang/otp/commit/c7a07bf984739bcc679d800e5383c01e1d07ffa5&lt;br&gt;
文档：https://github.com/erlang/otp/commit/89987ada3c997fd9f1e1f8c8ed73da0394bda4ee&lt;/p&gt;
&lt;p&gt;这个+hpds参数默认是字典有10个槽位，由于典型的Erlang VM内有成千上万的进程，官方又不鼓励使用字典，因为破坏fp语义，所以这些默认的字典占用的内存是浪费掉了。 挑小了对于内存敏感的嵌入式机器还是挺可观的；调大了对字典性能有一定的提升。&lt;/p&gt;
&lt;p&gt;祝玩得开心！&lt;/p&gt;
&lt;div style=&quot;margin-top: 0; margin-bottom: 15px; color: #888888; font-size: 80%; font-style: italic&quot;&gt;
&lt;p&gt;Post Footer automatically generated by &lt;a href=&quot;http://easwy.com/blog/wordpress/wp-posturl/&quot; onclick=&quot;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://easwy.com/blog/wordpress/wp-posturl/&#39;, &#39;wp-posturl plugin&#39;]);&quot; style=&quot;color: #8888FF; text-decoration: underline;&quot;&gt;wp-posturl plugin&lt;/a&gt; for wordpress.&lt;/p&gt;
&lt;/div&gt;

			&lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt;
		

</description>
        <pubDate>Wed, 01 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-04-01-3202-8be7057e8.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-04-01-3202-8be7057e8.html</guid>
        
        
        <category>yufeng</category>
        
      </item>
    
      <item>
        <title>集群引入inet_dist_{listen,connect}_options更精细参数微调</title>
        <description>

			&lt;div style=&quot;margin-top: 15px; font-style: italic&quot;&gt;
&lt;p&gt;&lt;strong&gt;原创文章，转载请注明：&lt;/strong&gt; 转载自&lt;a href=&quot;http://blog.yufeng.info/&quot;&gt;系统技术非业余研究&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接地址:&lt;/strong&gt; &lt;a href=&quot;http://blog.yufeng.info/archives/3199&quot;&gt;集群引入inet_dist_{listen,connect}_options更精细参数微调&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Erlang 17.5版本引入了inet_dist_{listen,connect}_options，对于结点间的互联socket可以有更精细的控制，RPC的时候性能可以微调：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;raimo/inet_tcp_dist-priority-option/OTP-12476:&lt;br&gt;
  Document kernel inet_dist_{listen,connect}_options&lt;br&gt;
  Test kernel inet_dist_{listen,connect}_options&lt;br&gt;
  Implement kernel inet_dist_{listen,connect}_options&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;参看源码：https://github.com/erlang/otp/commit/14ddc5594d74979a15a256a41fba5f1297aeaa1a&lt;/p&gt;
&lt;p&gt;随着Erlang集群和节点上千，节点之间的RPC的开销和延迟就会被放大. 因为每个节点间的互通都是通过tcp, 驱动上也都是gen_tcp所以理论上对于gen_tcp合用的参数都可以设置，在延迟和吞吐量之间来平衡。&lt;/p&gt;
&lt;p&gt;祝玩得开心！&lt;/p&gt;
&lt;div style=&quot;margin-top: 0; margin-bottom: 15px; color: #888888; font-size: 80%; font-style: italic&quot;&gt;
&lt;p&gt;Post Footer automatically generated by &lt;a href=&quot;http://easwy.com/blog/wordpress/wp-posturl/&quot; onclick=&quot;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://easwy.com/blog/wordpress/wp-posturl/&#39;, &#39;wp-posturl plugin&#39;]);&quot; style=&quot;color: #8888FF; text-decoration: underline;&quot;&gt;wp-posturl plugin&lt;/a&gt; for wordpress.&lt;/p&gt;
&lt;/div&gt;

			&lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt;
		

</description>
        <pubDate>Wed, 01 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-04-01-3199-213cc5a8a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-04-01-3199-213cc5a8a.html</guid>
        
        
        <category>yufeng</category>
        
      </item>
    
      <item>
        <title>Erlang 18RC1释出</title>
        <description>

			&lt;div style=&quot;margin-top: 15px; font-style: italic&quot;&gt;
&lt;p&gt;&lt;strong&gt;原创文章，转载请注明：&lt;/strong&gt; 转载自&lt;a href=&quot;http://blog.yufeng.info/&quot;&gt;系统技术非业余研究&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接地址:&lt;/strong&gt; &lt;a href=&quot;http://blog.yufeng.info/archives/3193&quot;&gt;Erlang 18RC1释出&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;三月底，官网宣布Erlang 18RC1公测，参看 &lt;a href=&quot;http://www.erlang.org/news&quot; onclick=&quot;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://www.erlang.org/news&#39;, &#39;这里&#39;]);&quot;&gt;这里&lt;/a&gt;，按照惯例Erlang每年会出一个大版本，从R11开始到现在R18，7年时间我从Erlang的发展历程中见证了一个大型系统的演变过程。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Erlang/OTP 18.0-rc1 is available for testing.&lt;br&gt;
This is an alpha release, which will be followed by a planned beta release in May and a final OTP 18.0 product release in June 2015.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;18.0正式版本6月份会放出， 这个版本很值得期待的内容有以下几点, 参看 &lt;a href=&quot;http://www.erlang-factory.com/static/upload/media/141779976125699otpnewsberlinerlangfactorylite214.pdf&quot; onclick=&quot;_gaq.push([&#39;_trackEvent&#39;,&#39;download&#39;,&#39;http://www.erlang-factory.com/static/upload/media/141779976125699otpnewsberlinerlangfactorylite214.pdf&#39;]);&quot;&gt;News From the OTP TEAM Berlin Erlang Factory Lite 2014&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重点需要解决的：&lt;br&gt;
&lt;a href=&quot;http://blog.yufeng.info/wp-content/uploads/2015/04/f1.jpg&quot;&gt;&lt;img src=&quot;/images/yufeng.info/c06b2971d39a2ba4a60875736f234e28.jpg&quot; alt=&quot;f1&quot; width=&quot;363&quot; height=&quot;566&quot; class=&quot;alignnone size-full wp-image-3194&quot;&gt;&lt;/a&gt;&lt;br&gt;
当期亮点：&lt;br&gt;
&lt;a href=&quot;http://blog.yufeng.info/wp-content/uploads/2015/04/f2.jpg&quot;&gt;&lt;img src=&quot;/images/yufeng.info/88585bc4eac58c52639a76a7ca370bc6.jpg&quot; alt=&quot;f2&quot; width=&quot;374&quot; height=&quot;567&quot; class=&quot;alignnone size-full wp-image-3195&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;长期的：&lt;br&gt;
&lt;a href=&quot;http://blog.yufeng.info/wp-content/uploads/2015/04/f3.jpg&quot;&gt;&lt;img src=&quot;/images/yufeng.info/3254d83a7ca549f82c264f235849af4e.jpg&quot; alt=&quot;f3&quot; width=&quot;389&quot; height=&quot;567&quot; class=&quot;alignnone size-full wp-image-3196&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于这次预发布最大的亮点如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Some highlights of the release are:&lt;/p&gt;
&lt;p&gt;dialyzer: The -dialyzer() attribute can be used for suppressing warnings in a module by specifying functions or warning options. It can also be used for requesting warnings in a module.&lt;br&gt;
erts: The time functionality has been extended. This includes a new API for time, as well as “time warp” modes which alters the behavior when system time changes. You are strongly encouraged to use the new API instead of the old API based on erlang:now/0. erlang:now/0 has been deprecated since it will always be a scalability bottleneck. For more information see the Time and Time Correction chapter of the ERTS User’s Guide. Here is a link http://www.erlang.org/documentation/doc-7.0-rc1/erts-7.0/doc/html/time_correction.html&lt;/p&gt;
&lt;p&gt;erts: Beside the API changes and time warp modes a lot of scalability and performance improvements regarding time management has been made. Examples are:&lt;br&gt;
scheduler specific timer wheels,&lt;br&gt;
scheduler specific BIF timer management,&lt;br&gt;
parallel retrieval of monotonic time and system time on OS:es that support it.&lt;br&gt;
erts: The previously introduced “eager check I/O” feature is now enabled by default.&lt;br&gt;
erts/compiler: enhanced support for maps. Big maps new uses a HAMT (Hash Array Mapped Trie) representation internally which makes them more efficient. There is now also support for variables as map keys.&lt;br&gt;
ssl: Remove default support for SSL-3.0 and added padding check for TLS-1.0 due to the Poodle vulnerability.&lt;br&gt;
ssl: Remove default support for RC4 cipher suites, as they are consider too weak.&lt;br&gt;
stdlib: Allow maps for supervisor flags and child specs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中对定时器的API语义和使用方式做了重新定义，伸缩能力优化做了大量的工作，拆成基于每个调度器的，对于定时器密集型的业务会有很大的性能提升。&lt;br&gt;
具体的参考：Erlang VM Developer Lukas Larsson 做的 &lt;a href=&quot;http://www.erlang-factory.com/sfbay2015/lukas-larsson&quot; onclick=&quot;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://www.erlang-factory.com/sfbay2015/lukas-larsson&#39;, &#39;演讲&#39;]);&quot;&gt;演讲&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;这次解决了定时器的瓶颈，个人最期待的是Multiple poll sets, 这个解决了，性能就完美了！&lt;/p&gt;
&lt;p&gt;祝玩的开心！&lt;/p&gt;
&lt;div style=&quot;margin-top: 0; margin-bottom: 15px; color: #888888; font-size: 80%; font-style: italic&quot;&gt;
&lt;p&gt;Post Footer automatically generated by &lt;a href=&quot;http://easwy.com/blog/wordpress/wp-posturl/&quot; onclick=&quot;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://easwy.com/blog/wordpress/wp-posturl/&#39;, &#39;wp-posturl plugin&#39;]);&quot; style=&quot;color: #8888FF; text-decoration: underline;&quot;&gt;wp-posturl plugin&lt;/a&gt; for wordpress.&lt;/p&gt;
&lt;/div&gt;

			&lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt;
		

</description>
        <pubDate>Wed, 01 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-04-01-3193-fbb19a64b.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-04-01-3193-fbb19a64b.html</guid>
        
        
        <category>yufeng</category>
        
      </item>
    
      <item>
        <title>SQL Server之旅（15）：nolock引发的三级事件的一些思考</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84919/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（1）：那些给我们带来福利的系统视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84923/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（2）：理解万恶的表扫描&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84925/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（3）：解惑那些背了多年聚集索引的人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84927/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（4）：你必须知道的非聚集索引扫描&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84936/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（5）：确实不得不说的DBCC命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84939/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（6）：使用winHex利器加深理解数据页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84942/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（7）：为什么都说状态少的字段不能建索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84945/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（8）：复合索引和include索引到底有多大区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84948/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（9）：看公司这些DBA们设计的这些复合索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84953/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（10）：看看DML操作对索引的影响&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84956/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（11）：简单说说sqlserver的执行计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84959/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（12）：sqltext的参数化处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84962/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（13）：对锁的初步认识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84965/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（14）：深入的探讨锁机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;曾今有件事情让我记忆犹新，那年刚来携程不久，马上就被安排写一个接口，供企鹅公司调用他们员工的差旅信息，然后我就三下五除二的给写好了，上线之后，大概过了一个月。。。DBA那边报告数据库出现大量锁超时，并且及时根据sql的来源将email发到了我们部门，指出sql读取时间过长，并且缺少nolock，影响了大量机票订单入库，然后我就拿着sql去生产环境跑了下，22s。。。花擦。。。项目上线时间太久，版本已经不存在了，无法回滚。。。原本准备撤下接口。。。看了下撤下接口跟加上nolock时间相差不多，最后决定先加上nolock，发布紧急单。。。然后再优化，DBA那边暂时做手工解锁，发上去后，最后就是损失XXXX订单。。。定级为三级事件。然后就是追责，当然这个责任只能有老大们去承担了，出了这次由我引发的事件，我得思考了，出了事情对我不见得全是坏事，起码这次会让我铭记如心，想想也搓，来携程之前根本就不会关注要不要给select指定nolock，这其中也包括自己没遇到过大数据吧，也包括自己的能力有限，只知道有锁这个玩意，细说的话就啥也不知道了，后来才知道携程有个规则，就是很多业务产线所写的select都必须指定nolock，懂一点的人可能会说nolock可以提升性能，如果你这样说，确实是这样，因为数据库的锁是有96字节开销的，没了锁，也就没有你在profile中看到accquired和released痉挛了，当你看完我的事件之后，你可能会意识到，性能提升不是最关心的，最关心就是不要出现死锁，锁等待。。。好了，言归正传，下面我们看看到底在数据库中可以指定多少个锁？？？&lt;/p&gt;
&lt;p&gt;一：到底可以指定多少个锁&lt;/p&gt;
&lt;p&gt;这个问题有意思，我们不需要记，只要你装一个SQL Prompt，有了这个神器，你就知道到底有多少个？如下图：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP TABLE dbo.Person
CREATE TABLE Person(ID INT IDENTITY,NAME CHAR(4000) DEFAULT &#39;xxxxx&#39;)
INSERT INTO dbo.Person DEFAULT VALUES
go 6&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/40456c1fff83e8724f758ad58352aa9a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;一眼扫下去，还是蛮多的，不过你要注意了，那些所谓的XXXLock才是我们需要关注的，根据上面的图，我们大概把锁分个类。。。&lt;/p&gt;
&lt;p&gt;粒度锁：PAGLOCK, TABLOCK, TABLOCKX, ROWLOCK, NOLOCK&lt;/p&gt;
&lt;p&gt;模式锁：HOLDLOCK, UPDLOCK, XLOCK&lt;/p&gt;
&lt;p&gt;接下来我从粒度锁说起：&lt;/p&gt;
&lt;p&gt;1. NOLOCK&lt;/p&gt;
&lt;p&gt;都说nolock是无锁模式的，那到底是怎样的无锁呢？？？到这篇为止，你应该知道，如果不加nolock，我们的表，数据页是附加IS锁的，那接下来我用profile看下两者有什么区别。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8b620967132edd759d01cc9a53465602.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图中，你会看到加上nolock之后，object上面附加了Sch-S锁，这个锁叫做“架构稳定锁”，很简单就是sql编译时附加的一把锁，目的就是防止在编译时，有其他连接修改表结构，而这个锁只与Sch-M锁冲突，与其他锁都兼容，这说明什么？说明其他连接锁住了记录也没关系，我的nolock不跟他们打交道，这样的话，就可能会读到脏数据，不过没关系，携程的很多业务是容许脏数据的，毕竟比锁等待，死锁要强得多，再说nolock读到了其他连接未修改或者未提交的数据，这个概率也比较低，就算遇到了也没关系，一般不会招来客诉的，客人或许再刷下页面，数据或许就正确了，对不对。。。&lt;/p&gt;
&lt;p&gt;2.TABLOCK&lt;/p&gt;
&lt;p&gt;这个还是比较见名识义的，就是附加在table上的锁，也就是表锁了，很恐怖的。。。下面我举个Update的例子，看看前后对比。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4cd100d3b0426e2047a5de9043422a38.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/34b195b7bcd86c0677eb656a56649236.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上面你有没有看到，X锁已经附加到OBJECT上面去了。。。这样的话，其他连接就动不了这个Object了，只能等待。。。&lt;/p&gt;
&lt;p&gt;3.  PAGLOCK&lt;/p&gt;
&lt;p&gt;看了名字你应该也知道，就是附加到页面这个级别的锁，我也举一个Update的例子。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;BEGIN TRAN
UPDATE dbo.Person SET NAME=&#39;aaaaa&#39; WHERE ID=6

BEGIN TRAN
UPDATE dbo.Person WITH(PAGLOCK) SET NAME=&#39;bbbbb&#39; WHERE ID=4&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9b91ba18ad0c221408ad0e5980b8d5a1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ebb9df6c7743fd390deca89e70121218.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上面两个图中，你应该可以看到，原来附加到RID上面的U锁，由于PagLock的提升，现在要附加到Page上面了，这个就是所谓的数据页锁。&lt;/p&gt;
&lt;p&gt;4.TABLOCKX, ROWLOCK&lt;/p&gt;
&lt;p&gt;这两个我就不细说了，TABLOCKX就是直接附加在table上的X锁，你可以通过select看一下。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e4d9e8e3413fed72a24d9f7e5741eb5c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;ROWLOCK的话，默认情况下就是ROWLOCK，比如默认的Update，你会发现RID上被附加的U锁，这个就是行锁。&lt;/p&gt;
&lt;p&gt;5.UPDLOCK&lt;/p&gt;
&lt;p&gt;这个锁还是蛮有意思的，它就是update锁，如果你select下，它会呈现update的锁痉挛效果。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ddadf01448c0f54aa27a69c71e370cc9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;6. XLOCK&lt;/p&gt;
&lt;p&gt;知道了UPDLOCK锁，我想XLOCK你也应该明白了。。。它就是delete锁，即排他锁，我可以让select带上排他锁。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/107ed11bf93b09cc900d3e81f010daec.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;7.HOLDLOCK&lt;/p&gt;
&lt;p&gt;最后一个我也没闹明白，据说是让语句在整个事务中持有锁，然后我就用select和update调试一下。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM dbo.Person(HOLDLOCK)
UPDATE dbo.Person WITH(HOLDLOCK) SET NAME=&#39;bbbbb&#39; WHERE ID=4&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/85eb33a1b41cd841eb0f780df02472b5.jpg&quot;&gt;&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sat, 21 Mar 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-03-21-84967-c981efbcb.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-03-21-84967-c981efbcb.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>SQL Server之旅（14）：深入的探讨锁机制</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84919/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（1）：那些给我们带来福利的系统视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84923/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（2）：理解万恶的表扫描&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84925/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（3）：解惑那些背了多年聚集索引的人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84927/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（4）：你必须知道的非聚集索引扫描&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84936/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（5）：确实不得不说的DBCC命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84939/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（6）：使用winHex利器加深理解数据页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84942/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（7）：为什么都说状态少的字段不能建索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84945/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（8）：复合索引和include索引到底有多大区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84948/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（9）：看公司这些DBA们设计的这些复合索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84953/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（10）：看看DML操作对索引的影响&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84956/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（11）：简单说说sqlserver的执行计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84959/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（12）：sqltext的参数化处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84962/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（13）：对锁的初步认识&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上一篇我只是做了一个堆表让大家初步的认识到锁的痉挛状态，但是在现实世界上并没有这么简单的事情，起码我的表不会没有索引对吧，，，还有就是我的表一定会有很多的连接过来，10:1的读写，很多码农可能都会遇到类似神乎其神的死锁，卡住，读不出来，插不进入等等神仙的事情导致性能低下，这篇我们一起来探讨下。&lt;/p&gt;
&lt;p&gt;一： 当select遇到性能低下的update会怎么样？&lt;/p&gt;
&lt;p&gt;1. 还是使用原始的person表，插入6条数据，由于是4000字节，所以两条数据就是一个数据页，如下图：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP TABLE dbo.Person
CREATE TABLE Person(ID INT IDENTITY,NAME CHAR(4000) DEFAULT &#39;aaaaa&#39;)
--插入6条数据，刚好3个数据页
INSERT INTO dbo.Person DEFAULT VALUES
go 6&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;2. 为了模拟性能低下的Update操作，我们开个显式事务来更新ID=4的记录，并且用profile看一下，如下图：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;BEGIN TRAN
UPDATE dbo.Person SET NAME=&#39;bbbbb&#39; WHERE id=4&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dc449317ca050a60e03c85c02f18d8ed.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 然后我们开下另一个会话连接，读取ID=6的记录会是怎样？？？？好奇吗？？？？&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM Person WHERE ID=6&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/017f2bdb7cddf70bb40c0fd0c3e7c8ca.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上面流程你是否看到，当扫描到89号数据页的slot1槽位的时候卡住了。。。我想你应该知道update正好已经给这条记录加上了X锁。。。如果你够细心，你还会发现，给S锁附加记录的条件是在当引擎发现记录所在的数据页已经附加上了IX锁的情况下，才给该号数据页下的每条记录附加S锁，对吧。。。好了，既然在Profile上面看不到了，我还是有其他办法来判断到底select语句现在处于什么状态。&lt;/p&gt;
&lt;p&gt;4. 使用sys.dm_tran_locks来看当前各个连接持有锁的状态。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT  l.request_session_id,
        DB_NAME(l.resource_database_id),OBJECT_NAME(p.object_id),
        l.resource_description,l.request_type,
        l.request_status,request_mode 
FROM sys.dm_tran_locks AS l
LEFT JOIN sys.partitions AS p
ON l.resource_associated_entity_id=p.hobt_id&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/507a2ec13444033b9ef28d04e9ba7a76.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;仔细观察上图可以看到，当前有51和52号会话，51号在1:89:1槽位上使用了X锁并且没有释放，52号此时也进入了1:89:1中，并且想给该&lt;/p&gt;
&lt;p&gt;RowID附加S锁，但是你也知道S和X锁是排斥的，所以很无奈的一直保持等待状态。&lt;/p&gt;
&lt;p&gt;二：使用索引或许可以帮你逃过一劫&lt;/p&gt;
&lt;p&gt;当你看完上面的讲叙，是不是有点害怕？？？要是在生产环境下出现了这种情况，那我们是不是死的很惨？？？那接下来使用索引是不是真的可以帮我们躲过一劫呢？？？下面跟我一起看一看。&lt;/p&gt;
&lt;p&gt;1. 新建索引index&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;-- 在ID列上建一个index
CREATE INDEX idx_person ON dbo.Person(ID)&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;2. 然后我们看下数据页的分布情况，可以看到下图中78,89,90是表数据页，93号为索引数据页。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DBCC TRACEON(2588,3604)
DBCC IND(Ctrip,Person,-1)&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ce867dc2a1d5883c33c476330534e726.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 麻蛋的，继续执行上面的那个慢update&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;BEGIN TRAN
UPDATE dbo.Person SET NAME=&#39;bbbbb&#39; WHERE id=4&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;4. 激动人心的时刻来了，由于数据太少，所以我这里强制让引擎执行我创建的索引，看看结果怎样？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/97bd9599a8821e0ccb32c77a26931fda.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;居然没卡住？？？现在是不是有一股强烈的好奇心来了，狗狗狗。。。马上开启profile，看看到底都发生了什么？？？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0eece3c88582f3f431ede8e3ba9dec2d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;仔细看完这个图，是不是觉得很有意思呢？？？具体步骤如下：&lt;/p&gt;
&lt;p&gt;第一步：给表（Object）加上IS锁。&lt;/p&gt;
&lt;p&gt;第二步：因为要走索引，给93号索引数据页加上IS锁。&lt;/p&gt;
&lt;p&gt;第三步：找到93号索引数据页的目标key，给这个key加上S锁，有人可能就会问了。。。这个key不就是6嘛，为什么这个key=(61005a25560e)，你要是太好奇我可以告诉你，年轻人说话不要太屌，每行索引记录都有一个散列值，这个值就是根据索引的几个字段散列出来的，好处就是防止你的索引长度过大，导致锁这个记录的时候太耗费锁空间了。。。。如果你还是不太相信的话，我用DBCC给你看一看。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a3d63c50e02e538eafd785d5df01bb3c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;第四步：根据这个key直接跳到存放记录的90号数据页中，万幸的是update的记录刚好不在90号数据页中。。。。就这样躲过一劫了。。。然后select顺利的读取到了该读的记录，最后释放相关的IS锁。&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sat, 21 Mar 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-03-21-84965-cd13654ef.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-03-21-84965-cd13654ef.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>SQL Server之旅（13）：对锁的初步认识</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84919/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（1）：那些给我们带来福利的系统视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84923/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（2）：理解万恶的表扫描&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84925/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（3）：解惑那些背了多年聚集索引的人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84927/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（4）：你必须知道的非聚集索引扫描&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84936/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（5）：确实不得不说的DBCC命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84939/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（6）：使用winHex利器加深理解数据页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84942/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（7）：为什么都说状态少的字段不能建索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84945/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（8）：复合索引和include索引到底有多大区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84948/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（9）：看公司这些DBA们设计的这些复合索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84953/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（10）：看看DML操作对索引的影响&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84956/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（11）：简单说说sqlserver的执行计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/84959/&quot; target=&quot;_blank&quot;&gt;SQL Server之旅（12）：sqltext的参数化处理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;终于这个系列快结束了，马上又要过年了，没什么心情写博客。。。作为一个开发人员，锁机制也是我们程序员必须掌握的东西，很久之前在学习锁的时候，都是教科书上怎么说，然后我怎么背，缺少一个工具让我们眼见为实。。。如果这样的话，学习一个东西就很容易忘记。。。因为这些都是你背诵过来的。。。这篇的话我就来分享一个工具来帮助我们学习锁。&lt;/p&gt;
&lt;p&gt;一：到底都有哪些锁&lt;/p&gt;
&lt;p&gt;学习锁之前，必须要知道锁大概有几种？？？通常情况下作为码农我们只需知道如下几个锁即可。。。&lt;/p&gt;
&lt;p&gt;1.S（Share）锁&lt;/p&gt;
&lt;p&gt;为了方便理解，我们可以直接这么认为，当在select的时候在表，数据页，记录上加上共享锁。&lt;/p&gt;
&lt;p&gt;2.X(Exclusive) 锁&lt;/p&gt;
&lt;p&gt;我们在delete数据的时候会在记录上附加X锁，我们知道X锁并不与其他的锁兼容。如果其他的锁与其遭遇，就会处于等待，后续我们再说。&lt;/p&gt;
&lt;p&gt;3.U(Update)锁&lt;/p&gt;
&lt;p&gt;顾名思义，我们在Update的时候，在寻找记录的过程中，会逐一的给记录附加U锁，如果找到了目标记录的话，则会将U锁转化为X锁。。。&lt;/p&gt;
&lt;p&gt;4.I （Intent）锁&lt;/p&gt;
&lt;p&gt;这个就是所谓的意向锁，一般都是给表和数据页附加的锁，好处就是防止被其他连接修改表结构。&lt;/p&gt;
&lt;p&gt;二：天下无敌的SqlServer Profile&lt;/p&gt;
&lt;p&gt;这个工具我想大家都明白，它的监视能力真的是无所不能。。。锁的痉挛状态也全在它的掌握之中。&lt;/p&gt;
&lt;p&gt;1. 首先我做一个Person表，Name字段设定4000字节，这样一个数据页可以容纳2条数据，如下图：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP TABLE dbo.Person
CREATE TABLE Person(ID INT IDENTITY,NAME CHAR(4000) DEFAULT &#39;aaaaa&#39;)
--插入6条，生成3个数据页
INSERT INTO dbo.Person DEFAULT VALUES
go 6&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;2. 下面我们看看数据在数据页的分布情况。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/844a3d8f8cff39c01e705d6905706662.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 然后我们开启Profile，在“事件选择”的Events中选择”Lock:Acquired“和”Lock:Released“ ，然后运行，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4da4c5769333a1039ef24ea7012b0ca6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;三：使用测试数据&lt;/p&gt;
&lt;p&gt;1. 首先我执行一个简单的 SELECT * FROM dbo.Person，看看表/数据页/记录的加锁情况。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8e52025c2a4c2b658f208c6d21cf0142.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，select执行的大概步骤如下：&lt;/p&gt;
&lt;p&gt;第一步：给表（Object）加上IS（意向共享锁）。&lt;/p&gt;
&lt;p&gt;第二步：先给1:78号数据页加IS锁，扫描78号数据页，然后释放IS锁。&lt;/p&gt;
&lt;p&gt;第三步：同样的道理扫描之后的数据页。&lt;/p&gt;
&lt;p&gt;第四步：最后释放表的IS锁，结束整个锁流程。&lt;/p&gt;
&lt;p&gt;看完上面的一系列的Lock:Acquired 和 Lock:Released的话，你有没有发现一个问题，不是说好给记录（RID）加上S锁么？？？这里没加，是因为引擎进入78号数据页的时候，未发现它存在IU锁或者IX锁。。。所以。。。这个属于锁的组合，后续会说。&lt;/p&gt;
&lt;p&gt;2. 接下来用UPDATE dbo.Person SET NAME=’bbbbb’ WHERE ID=3来看看update的整个过程，乍一看，Profile捕获到的记录还是比较多的，下面具体看图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1465f0a5659f23f95fbf333882d286a4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一步： 给表(Object)加上IX锁，&lt;/p&gt;
&lt;p&gt;第二步： 给数据页(1:78)数据页分配IU锁。然后开始逐一扫描78号数据页的RID记录，进入前就Acquired，退出后就Released，当扫&lt;/p&gt;
&lt;p&gt;描完78号数据页的所有RID后，再释放78号数据页的IU锁，进入下一个数据页。。。&lt;/p&gt;
&lt;p&gt;第三步： 我们发现ID=3是在89号数据页上，当引擎扫到该RID之后，我们观察到89号的数据页由IU锁变成了IX锁，并且把1:89:0（slot&lt;/p&gt;
&lt;p&gt;为0的记录）由U锁变成X锁，变成X锁后，就排斥了其他所有的锁，这时候就可以进行Update操作了。&lt;/p&gt;
&lt;p&gt;第四步： 后面就继续90号数据页，步骤类似，第二步和第三步。&lt;/p&gt;
&lt;p&gt;不知道细心的你有没有发现，在Released Object之前我们才释放1:89:0的X锁，然后释放89号数据页的IX锁，这说明什么？？？说明这个Update是贯穿于这个事务的，不像Select操作中，扫完一个数据页就释放一个数据页。&lt;/p&gt;
&lt;p&gt;3. 最后再看一个DELETE FROM dbo.Person WHERE ID=3 的操作。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a8a9e8535f9c250affee2f099d07ad2c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;大概扫了一下上面的图，或许你感觉和Update操作大差不差，会扫描数据页中的每个记录并加上U锁。当在1:89:0槽位中找到了目标记录后，然后将U锁转化为X锁，具体可以参考Update。&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sat, 21 Mar 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-03-21-84962-38022b53b.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-03-21-84962-38022b53b.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>SSD阵列卡方案优化：考虑使用RAID 50替代RAID 10</title>
        <description>

                &lt;p&gt;大家都知道SSD成本比较高，而不少用户在考虑可用性时都会选用RAID 10作阵列，这样无疑又增加了成本。然而RAID 10的可用性也并非百分百完美。为了能够平衡可用性和成本，因此最近一直在研究性价比更高的RAID 50，它提供了接近RAID 10的可用性并且接近RAID 5的成本，像是在高可用的RAID 10和低成本的RAID 5之间的取了一个平衡点。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;为了能够直观了解不同RAID类型下的故障可用性，我们首先做个简单的可用性分析（以8盘RAID 10的同等容量作对比）：&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff1493;&quot;&gt;&lt;strong&gt;&lt;em&gt;RAID 50中：4块盘组成单组RAID 5，然后两组RAID 5再组成RAID 0最后得到8块盘的RAID 50&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://noops.me/wp-content/uploads/2015/03/ssd_r50_r10_01b.png&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-1814&quot; alt=&quot;ssd_r50_r10_01b&quot; src=&quot;/images/noops.me/b7a8f8186619a74d8ca16ffc5c982e7f.jpg&quot; width=&quot;459&quot; height=&quot;167&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1块盘的容错概率都是100%，可见磁盘阵列最基本的能力就是容错，然而不同级别的阵列能够提供的数据保护能力也是不同的；&lt;/li&gt;
&lt;li&gt;从第2块盘开始除了RAID 6能够提供100%的故障可用性以外，其他包括RAID 10在内都不能提供完美的解决方案。同时我们可以发现RAID 5的容错能力是四者中最差的，但是要达到同样容量所需要的盘数量也是最少的，如果故障运维较为及时的话RAID 5是一个性价比较高的方案，不然在第一块盘故障后至阵列修复期间如果发生第二块盘故障就会导整个阵列故障（数据全部丢失），这就是风险所在；&lt;/li&gt;
&lt;li&gt;RAID 6当然是较为可靠的方案，但是它要牺牲两块盘的容量并且性能也较差（后面有性能测试说明），所以要权衡性能和可用性；&lt;/li&gt;
&lt;li&gt;当然重点还是RAID 10和50：我们发现50在第二块盘故障时的可用概率和10比较接近，由于上述案例中只有两组RAID 5因此只能提供至最多两块盘的容错，如果RAID 5的组数量更多的话能够容错的盘数也将更多，且可用概率也会更高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们以9块盘RAID 50（3组RAID 5）为例作分析（达到相同容量的RAID 10需要12块盘）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://noops.me/wp-content/uploads/2015/03/ssd_r50_r10_02.png&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-1815&quot; alt=&quot;ssd_r50_r10_02&quot; src=&quot;/images/noops.me/85140272ee47dbe53b7813bdd637bf4d.jpg&quot; width=&quot;307&quot; height=&quot;169&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再以12块盘RAID 50（4组RAID 5）为例作分析（达到相同容量的RAID 10需要16块盘）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://noops.me/wp-content/uploads/2015/03/ssd_r50_r10_03.png&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-1816&quot; alt=&quot;ssd_r50_r10_03&quot; src=&quot;/images/noops.me/7e4d9cce79f553ccab159d779f53c3e6.jpg&quot; width=&quot;307&quot; height=&quot;169&quot;&gt;&lt;/a&gt;&lt;br&gt;
上面对比中RAID  50已经能够容忍第3甚至第4块盘的故障，只是可用性相比RAID 10低了些，但是两者都不能达到完美的100%，所以权衡可用性和成本RAID 50还是有相当大的优势。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;接下来看看性能，为了能够很好地分析性能，我们沿用了第一组对比方案的作性能分析：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://noops.me/wp-content/uploads/2015/03/ssd_r50_r10_04.png&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-1817&quot; alt=&quot;ssd_r50_r10_04&quot; src=&quot;/images/noops.me/03e74be5800b80634e0ecb27f6f24fff.jpg&quot; width=&quot;727&quot; height=&quot;505&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 随机读分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理论上认为R10性能最好，真实测试数据显示4K、8K数据块下R5、R50、R6的性能都要优于R10；&lt;/li&gt;
&lt;li&gt;当数据块增大到16K、32K时，R10的多盘优势才被逐渐体现出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;随机写分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4K由于R50、R5由于有大量校验计算一定程度上影响了性能，但随着数据块逐渐增大，盘数量的优势也显现出来。当数据块达到和超过8K时，R50性能全面超越了R10；&lt;/li&gt;
&lt;li&gt;R10由于存在R1的写同步问题，因此只有4块盘在支撑并发写，随着数据块的增大，R50和R5的多盘性能优势开始发挥。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;混合随机读写分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;得益多盘和无校验计算，混合读写R10领先；R50其次，和R10相差27%，性能也较为接近，R5和R50性能为线性关系，R6性能最差。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;顺序读分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于不存在校验计算，顺序读性能基本上由盘的数量决定；R50和R10性能也较为接近，同盘数的R6和R50性能相当，而盘数较少的R5性能相对前三者要弱一些，符合预期。至于为何R10性能无法线性增加，主要是因为阵列卡本身的性能限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;顺序写分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序写R5被优化得最好；R50由于需要同时计算两次校验因此损失了一些性能，和R10性能相当，当数据块达到512K时，多盘优势进一步体现出来了，拉开了与R10的差距；R6由于校验和计算的实现较为复杂，顺序写性能也是最差的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;再来看看这些阵列方案的性能和容错特性：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://noops.me/wp-content/uploads/2015/03/ssd_r50_r10_05.png&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-1818&quot; alt=&quot;ssd_r50_r10_05&quot; src=&quot;/images/noops.me/0d52479a1014c38911fdb7ed580ad820.jpg&quot; width=&quot;729&quot; height=&quot;220&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性能测试结论：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能测试显示，相同容量的R50和R10性能接近：其中小块文件的随机读R50要全面好于R10，随机写4K虽然R50和R10差距在28%，但是块增大后R50要全面优于R10。顺序读写方面，R50和R10十分接近。&lt;/li&gt;
&lt;li&gt;容错方面，R50接近R10：第二块盘容错率R50十分接近R10，两者相差30%。R10的优势主要是在有一定的概率提供第三、甚至第四块磁盘的容错率，但是考虑到并非100%容错，因此从容错角度来看R50虽然和R10有一些差距，但也已体现出较好的容错率，至少优于R5。而且R50搭配灵活，甚至可以指定3组R5以达到最大3块磁盘的容错；&lt;/li&gt;
&lt;li&gt;成本方面，R50有很大优势：按这个配置计算R50只有R10的3/4。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RAID 50提供了接近RAID 10性能、可用性以及接近RAID 5成本的特性，具有较好的整体性价比优势，所以考虑使用RAID 50替换RAID 10把！&lt;/p&gt;
            

</description>
        <pubDate>Mon, 16 Mar 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-03-16--p=1805-d72c2bfc7.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-03-16--p=1805-d72c2bfc7.html</guid>
        
        
        <category>noops</category>
        
      </item>
    
      <item>
        <title>iOS 开发中的争议（一）</title>
        <description>
&lt;p&gt;&lt;img src=&quot;/images/devtang.com/55fd98dc11f4b601e9f027686df46905.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;打算分享一些有争议的话题，并且表达一下我的看法。这是该系列的第一篇，我想讨论的是：类的成员变量应该如何定义？&lt;/p&gt;

&lt;p&gt;在 Objective-C 的语言的早期，类的私有成员变量是只能定义在 .h 的头文件里面的。像如下这样：&lt;/p&gt;

&lt;figure class=&quot;code&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;
&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController : UIViewController {
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;    @private
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;    NSInteger _value;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;


&lt;p&gt;之后，苹果改进了 Objective-C，允许在 .m 里面添加一个特殊的匿名 Category，即没有名字的 Category，来实现增加类的成员变量。像如下这样：&lt;/p&gt;

&lt;figure class=&quot;code&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;
&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic) NSInteger value;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;


&lt;p&gt;这样的好处是，这些变量在头文件中被彻底隐藏起来了，不用暴露给使用者。&lt;/p&gt;

&lt;p&gt;接着，在 2013 年的 WWDC 中，苹果进一步改进了 Objective-C，允许在 .m 的
&lt;code&gt;@implementation&lt;/code&gt; 中直接添加类的私有成员变量。像如下这样：&lt;/p&gt;

&lt;figure class=&quot;code&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;
&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController {
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;    NSInteger _value;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;


&lt;p&gt;于是，大家对于如何定义私有的成员变量上就产生的分歧。许多人喜欢用匿名的 Category 的方式来定义私有成员变量。但是，我个人更推荐在 &lt;code&gt;@implementation&lt;/code&gt; 中直接添加类的私有成员变量。下面我做一些解释。&lt;/p&gt;

&lt;h3&gt;历史原因&lt;/h3&gt;

&lt;p&gt;首先早期的 iOS 程序员一定知道，在 2011 年 ARC 被推出之前，Objective-C 是需要手工地管理引用计数的。而对类的所有私有成员使用 &lt;code&gt;self.property&lt;/code&gt; 的形式，就可以使编译器为我们自动生成管理引用计数的代码。在 2012 年前，这个 feature 还需要使用 &lt;code&gt;@synthesize&lt;/code&gt; 关键字来启用的。于是，苹果通过在代码规范中推荐和强调使用 &lt;code&gt;self.property&lt;/code&gt; 的编程习惯，来让大家避免在内存管理中遇到问题。而在 ARC 时代，这个编程习惯带来的优势不再存在了，因为编译器会自动为我们管理引用计数，我们只需要关心不要造成循环引用问题就行了。&lt;/p&gt;

&lt;h2&gt;省心省事&lt;/h2&gt;

&lt;p&gt;刚刚说到，在类中完全使用 &lt;code&gt;_property&lt;/code&gt; 的方式来访问私有成员变量，是不会有内存管理上的问题的。但是使用 &lt;code&gt;self.property&lt;/code&gt; 的方式来访问私有变量是不是也是一样不会有内存管理上的问题呢？确实也是，但是有一点需要注意：我们最好不要在 init 和 dealloc 中使用 &lt;code&gt;self.property&lt;/code&gt; 的方式来访问成员变量，这一点是写在苹果的官方文档里的，我在以前的文章里也介绍过。(见：&lt;a href=&quot;http://blog.devtang.com/blog/2011/08/10/do-not-use-accessor-in-init-and-dealloc-method/&quot;&gt;《不要在init和dealloc函数中使用accessor》&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;所以，如果你用 &lt;code&gt;self.property&lt;/code&gt; 来访问私有成员变量。那么你需要注意，在 init 和 dealloc 中不使用这种方式。这其实对程序员来说是一个负担，你需要不停提醒自己有没有犯错。如果你使用完全的 &lt;code&gt;_property&lt;/code&gt; 的方式来访问私有成员变量，就不用想这一类问题了。&lt;/p&gt;

&lt;h2&gt;关于隐藏&lt;/h2&gt;

&lt;p&gt;大家知道，&lt;code&gt;self.property&lt;/code&gt; 其实是调用了类的 &lt;code&gt;[self property]&lt;/code&gt; 方法，所以这其实是有一层方法调用的隐藏，很多时候，我们需要延迟初使化一个类成员的时候，就会把这个成员的初使化方法写在这个 &lt;code&gt;[self property]&lt;/code&gt; 方法的实现中。&lt;/p&gt;

&lt;p&gt;那么问题来了，当你在阅读别人代码时，看到 &lt;code&gt;self.property&lt;/code&gt; 的时候，你会想：这里会不会有一些隐藏的函数实现？于是你需要跳转到其方法实现中去查找。但是在实际开发中，大部分的 property 其实是使用编译器自动生成的 Getter 和 Setter 方法，于是你会找不到实现，这个时候，你才知道：“哦，原来这段代码并没有做自定义的成员初使化工作”。&lt;/p&gt;

&lt;p&gt;这种默认的隐藏在代码中多了，会影响代码的阅读和维护。其实大部分的类成员变量都需要在类初使化方法中赋值，大部分的 UIViewController 的成员变量，都需要在 &lt;code&gt;viewDidLoad&lt;/code&gt; 方法中赋值。那既然这样，不如直接在相应的方法中用一个名为 &lt;code&gt;setupProperty&lt;/code&gt; 方法直接进行初使化。这样的好处是，代码的可读性更好了，&lt;code&gt;self.property&lt;/code&gt; 只有需要延迟初使化的情况下才被使用。&lt;/p&gt;

&lt;p&gt;关于这个还有一个小故事，我之前 Review 过一个同事的 iOS 端代码，那个同事喜欢把 table view 的数据另外封装成一个类，而我觉得这些数据其实就是一个数组，没必要进行这一层封装，最终我们争论了比较久。我的观点是，一切隐藏都是对代码复杂性的增加，除非它带来了好处，例如达到了代码复用，提高了代码的可维护性等，否则，没有好处的封装只会给代码阅读理解带来成本。就我现在的经历中，大部分的 table view 的数据都可以放在一个数组中，没必要把这个数组封装起来，另外提供一套操作这个数组数据的方法。&lt;/p&gt;

&lt;h2&gt;简短的代码更易读&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;_property&lt;/code&gt; 的写法比 &lt;code&gt;self.property&lt;/code&gt; 更短，也更简单。我认为这样写出来的代码更方便阅读。&lt;/p&gt;

&lt;h2&gt;执行速度更快，IPA体积更小&lt;/h2&gt;

&lt;p&gt;我之前从来没想到过这两者之间的速度和应用体积会有很大差别。不过一个同行（来自国外著名的社交网络公司）告诉我，他们公司发现二者还是有不小的差距，如果你们的应用需要做一些深度优化，可以考虑一下把 &lt;code&gt;self.property&lt;/code&gt; 换成 &lt;code&gt;_property&lt;/code&gt;。但我觉得，大部分应用都应该是不需要做这种深度优化的。&lt;/p&gt;

&lt;h2&gt;KVO 和 KVC&lt;/h2&gt;

&lt;p&gt;是的，如果用 &lt;code&gt;_property&lt;/code&gt; 这种写法，就不能使用 KVO 和 KVC 了。但是我得反问一下，在一个类的内部，KVO 自己的私有成员变量算是一个好设计吗？我们讲类要”高内聚，低耦合”，KVO 是为了实现观察者模式，让对象之间相互解耦的。如果把 KVO 用在类的内部，KVO 自己的私有成员，我认为其实这不是一个很好的设计。&lt;/p&gt;

&lt;h2&gt;Computed Properties&lt;/h2&gt;

&lt;p&gt;在 Swift 中，引入了 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID259&quot;&gt;Computed Properties&lt;/a&gt; 的概念，其实这在 Objective-C 中也有，只是没有专门给它名字。如果一个 property 我们提供了对应的 &lt;code&gt;setter&lt;/code&gt; 和 &lt;code&gt;getter&lt;/code&gt;，并且没有直接使用其对应的 _property 变量，那么这个 property 就是所谓的 Computed Properties。&lt;/p&gt;

&lt;p&gt;是的，在类的内部如果直接使用 &lt;code&gt;_property&lt;/code&gt; 形式，也无法使用 Computed Properties 了，但我认为这影响不大。其实 Computed Properties 也就是一层对数据存取的封装，我们另外实现两个函数，分别对应数据的 &lt;code&gt;setter&lt;/code&gt; 和 &lt;code&gt;getter&lt;/code&gt; 功能，就可以达到同样的效果。&lt;/p&gt;

&lt;h2&gt;循环引用问题&lt;/h2&gt;

&lt;p&gt;微博上的&lt;a href=&quot;http://weibo.com/n/%E7%8E%8B_%E6%99%93%E7%A3%8A?from=feed&amp;amp;loc=at&quot;&gt;@王_晓磊&lt;/a&gt;在评论中提到：直接用私有变量有个需要特别注意的地方，在 block 里直接写 &lt;code&gt;_property&lt;/code&gt; 相当于 &lt;code&gt;self-&amp;gt;_property&lt;/code&gt;，虽然没写 self，但是暗含了对 self 的retain，容易造成循环引用。要记得用 weakSelf/strongSelf 大法。&lt;/p&gt;

&lt;p&gt;这一点确实是被很多人忽视的，所以我也一并写在这里，感谢他的补充。&lt;/p&gt;

&lt;h2&gt;写在最后&lt;/h2&gt;

&lt;p&gt;其实我上面提到的这些问题都是小问题，影响不大。但是代码风格的统一却是大问题。所以不管你们项目中使用的是 &lt;code&gt;self.property&lt;/code&gt; 风格还是 &lt;code&gt;_property&lt;/code&gt; 风格，问题都不大，但是如果你们同时使用这两种风格，那么就非常不好了。&lt;/p&gt;

&lt;p&gt;希望我的这篇文章能让大家了解到在这方面的争论，也希望大家能够在这一点上，在公司内部达成统一。&lt;/p&gt;

</description>
        <pubDate>Sun, 15 Mar 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-03-15-ios-dev-controversy-1-e14ce42f9.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-03-15-ios-dev-controversy-1-e14ce42f9.html</guid>
        
        
        <category>devtang</category>
        
      </item>
    
      <item>
        <title>spark streaming 接收 kafka 数据示例</title>
        <description>

  
  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;上个月曾经试过了用 spark streaming 读取 logstash 启动的 TCP Server 的数据。不过如果你有多台 logstash 的时候，这种方式就比较难办了 —— 即使你给 logstash 集群申请一个 VIP，也很难确定说转发完全符合。所以一般来说，更多的选择是采用 kafka 等队列方式由 spark streaming 去作为订阅者获取数据。&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;环境部署&lt;/h2&gt;
&lt;p&gt;这里只讲 kafka 单机的部署。只是示例嘛：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd kafka_2.10-0.8.2.0/bin/
./zookeeper-server-start.sh ../config/zookeeper.properties &amp;amp;
./kafka-server-start.sh --daemon ../config/server.properties
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;section-1&quot;&gt;数据转发&lt;/h2&gt;
&lt;p&gt;保持跟之前示例的连贯性，这里继续用 logstash 发送数据到 kafka。&lt;/p&gt;
&lt;p&gt;首先创建一个 kafka 的 topic：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic logstash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后到 logstash 里，修改配置为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;input {
    file { path =&amp;gt; &quot;/var/log/*.log&quot; }
}
filter {
    ruby {
        code =&amp;gt; &quot;event[&#39;lineno&#39;] = 100 * rand(Math::E..Math::PI)&quot;
    }
}
output {
    kafka {
        broker_list =&amp;gt; &quot;127.0.0.1:9092&quot;
        topic_id =&amp;gt; &quot;logstash&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;spark-streaming-&quot;&gt;spark streaming 处理的代码：&lt;/h2&gt;
&lt;p&gt;处理效果跟之前示例依然保持一致，就不重复贴冗余的函数了，只贴最开始的处理部分：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.SparkConf&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.SparkContext&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.SparkContext._&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.streaming.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StreamingContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.streaming.StreamingContext._&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.streaming.kafka.KafkaUtils&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.json4s._&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.json4s.jackson.JsonMethods._&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LogStash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;formats&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DefaultFormats&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LogStashV1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;message:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;path:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;host:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;lineno:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@timestamp&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;args:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zkQuorum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topics&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topicMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topics&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;,&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toMap&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sparkConf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SparkConf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setMaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;local[2]&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setAppName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;LogStash&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SparkContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sparkConf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ssc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StreamingContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lines&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KafkaUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ssc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zkQuorum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topicMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;_2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lines&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;extract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LogStashV1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ssc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ssc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;awaitTermination&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面有一些跟网上常见资料不一样的地方。&lt;/p&gt;
&lt;p&gt;第一个，&lt;code&gt;import org.apache.spark.streaming.kafka._&lt;/code&gt; 并不会导出 &lt;code&gt;KafkaUtils&lt;/code&gt;，必须明确写明才行。
第二个，之前示例里用了 scala 核心自带的 JSON 模块。但是这次我把 lineno 字段从整数改成浮点数后，发现 &lt;code&gt;JSON.parseFull()&lt;/code&gt; 有问题。虽然我在 scala 的 repl 里测试没问题，但是写在 spark 里的时候，它并不像文档所说的”总是尝试解析成 Double 类型”，而是一直尝试用 &lt;code&gt;Integer.parseInteger()&lt;/code&gt; 方法来解析。哪怕我明确定义 &lt;code&gt;JSON.globalNumberParser = {input:String =&amp;gt; Float.parseFloat(input)}&lt;/code&gt; 都不起作用。&lt;/p&gt;
&lt;p&gt;所以，最后这里改用了 &lt;a href=&quot;http://json4s.org&quot;&gt;json4s 库&lt;/a&gt;。据称这也是 scala 里性能和功能最好的 JSON 库。&lt;/p&gt;
&lt;p&gt;json4s 库默认解析完后，不是标准的 Map、List 等对象，而是它自己的 JObject、JList、JString 等。想要转换成标准 scala 对象，需要调用 &lt;code&gt;.values&lt;/code&gt; 才对。不过我这个示例里没有这么麻烦，而是直接采用 &lt;code&gt;.extract&lt;/code&gt; 就变成了 cast class 对象了。非常简便。&lt;/p&gt;
&lt;p&gt;另一个需要点出来的变动是：因为采用 &lt;code&gt;.extract&lt;/code&gt;，所以 cast class 里的参数命名必须跟 JSON 里的 key 完全对应上。而我们都知道 logstash 里有几个特殊的字段，叫 &lt;code&gt;@timestamp&lt;/code&gt; 和 &lt;code&gt;@version&lt;/code&gt; 。这个 “@” 是不能直接裸字符的，所以要用反引号(&lt;strong&gt;`&lt;/strong&gt;)包括起来。&lt;/p&gt;
&lt;h2 id=&quot;sbt-&quot;&gt;sbt 打包&lt;/h2&gt;
&lt;p&gt;sbt 打包也需要有所变动。spark streaming 的核心代码中，并不包含 kafka 的代码。还跟之前那样 &lt;code&gt;sbt package&lt;/code&gt; 的话，就得另外指定 kafka 的 jar 地址才能运行了。更合适的办法，是打包一个完全包含的 jar 包。这就用到 &lt;a href=&quot;https://github.com/sbt/sbt-assembly&quot;&gt;sbt-assembly 扩展&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;刚刚收到的消息，spark 1.3 版发布 beta 了，spark streaming 会内置对 kafka 的底层直接支持。或许以后不用这么麻烦？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;sbt-assembly 使用起来特别简单，尤其是当你使用的 sbt 版本比较新(大于 0.13.6) 的时候。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;添加扩展&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在项目的 &lt;code&gt;project/&lt;/code&gt; 目录下创建一个 &lt;code&gt;plugins.sbt&lt;/code&gt; 文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;addSbtPlugin(&quot;com.eed3si9n&quot; % &quot;sbt-assembly&quot; % &quot;0.13.0&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体的版本选择，看官方 README 的 &lt;a href=&quot;https://github.com/sbt/sbt-assembly#setup&quot;&gt;Setup 部分&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;添加新增依赖模块&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在可以去修改我们项目的 &lt;code&gt;build.sbt&lt;/code&gt; 了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;LogStash&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1.0&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scalaVersion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;2.10.4&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;libraryDependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;org.apache.spark&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;spark-core&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1.2.0&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;provided&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;org.apache.spark&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;spark-sql&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1.2.0&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;provided&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;org.apache.spark&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;spark-streaming&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1.2.0&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;provided&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;org.apache.spark&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;spark-streaming-kafka&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1.2.0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;org.json4s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;json4s-native&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;3.2.10&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;org.json4s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;json4s-jackson&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;3.2.10&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的。新版本的 sbt-assembly 完全不需要单独修改 &lt;code&gt;build.sbt&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;需要注意，因为我们这次是需要把各种依赖全部打包到一起，这个可能会导致一些文件相互有冲突。比如我们用 spark-submit 提交任务，有关 spark 的核心文件，本身里面就已经有了的，那么就需要额外通过 &lt;code&gt;% &quot;provided&quot;&lt;/code&gt; 指明这部分会另外提供，不需要打进去。这样运行的时候就不会有问题了。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;打包&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;采用 sbt-assembly 后的打包命令是：&lt;code&gt;sbt assembly&lt;/code&gt;。注意输出的结果，会是直接读取 &lt;code&gt;build.sbt&lt;/code&gt; 里的 &lt;code&gt;name&lt;/code&gt; 变量，不做处理。，我们之前定义的叫 “LogStash Project”，&lt;code&gt;sbt package&lt;/code&gt; 命令自动会转换成全小写且空格改成中横线的格式 &lt;em&gt;logstash-project_2.10-1.0.jar&lt;/em&gt;。但是 &lt;code&gt;sbt assembly&lt;/code&gt; 就会打包成 &lt;em&gt;LogStash Project-assembly-1.0.jar&lt;/em&gt; 包。这个空格在走 spark-submit 提交的时候是有问题的。所以这里需要把 name 改成一个不会中断的字符串。。。&lt;/p&gt;
    &lt;hr&gt;
    
    &lt;hr&gt;
  &lt;!-- JiaThis Button BEGIN --&gt;
&lt;div class=&quot;jiathis_style&quot;&gt;
&lt;span class=&quot;jiathis_txt&quot;&gt;分享到：&lt;/span&gt;
&lt;a class=&quot;jiathis_button_tsina&quot;&gt;新浪微博&lt;/a&gt;
&lt;a class=&quot;jiathis_button_weixin&quot;&gt;微信&lt;/a&gt;
&lt;a class=&quot;jiathis_button_renren&quot;&gt;人人网&lt;/a&gt;
&lt;a class=&quot;jiathis_button_ydnote&quot;&gt;有道云笔记&lt;/a&gt;
&lt;a class=&quot;jiathis_button_gmail&quot;&gt;Gmail邮箱&lt;/a&gt;
&lt;a class=&quot;jiathis_button_twitter&quot;&gt;Twitter&lt;/a&gt;
&lt;a class=&quot;jiathis_button_googleplus&quot;&gt;Google+&lt;/a&gt;
&lt;a class=&quot;jiathis_button_hi&quot;&gt;百度空间&lt;/a&gt;
&lt;a class=&quot;jiathis_button_fb&quot;&gt;Facebook&lt;/a&gt;
&lt;a class=&quot;jiathis_button_douban&quot;&gt;豆瓣&lt;/a&gt;
&lt;a href=&quot;http://www.jiathis.com/share?uid=1589850&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;更多&lt;/a&gt;
&lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var jiathis_config={
	data_track_clickback:true,
	summary:&quot;&quot;,
	ralateuid:{
		&quot;tsina&quot;:&quot;1035836154&quot;
	},
	shortUrl:false,
	hideMore:false
}
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://v3.jiathis.com/code/jia.js?uid=1589850&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;!-- JiaThis Button END --&gt;
&lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;
  &lt;/div&gt;

</description>
        <pubDate>Sat, 14 Mar 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-03-14-spark-streaming-kafka-10a43f834.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-03-14-spark-streaming-kafka-10a43f834.html</guid>
        
        
        <category>chenlinux</category>
        
      </item>
    
  </channel>
</rss>
