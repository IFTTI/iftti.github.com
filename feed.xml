<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IT技术干货</title>
    <description>[IT技术干货iftti.com] @KernelHacks</description>
    <link>http://iftti.com/</link>
    <atom:link href="http://iftti.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 04 Jun 2015 13:26:32 +0800</pubDate>
    <lastBuildDate>Thu, 04 Jun 2015 13:26:32 +0800</lastBuildDate>
    <generator>Jekyll v2.2.0</generator>
    
      <item>
        <title>我的MYSQL学习心得（9） ： 索引</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87340/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（7） ： 查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87345/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（8） ： 插入 更新 删除&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一篇《我的MYSQL学习心得（九）》将会讲解MYSQL的索引&lt;/p&gt;
&lt;p&gt;索引是在存储引擎中实现的，因此每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。&lt;/p&gt;
&lt;p&gt;根据存储引擎定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。&lt;/p&gt;
&lt;p&gt;大多数存储引擎有更高的限制。MYSQL中索引的存储类型有两种：BTREE和HASH，具体和表的存储引擎相关；&lt;/p&gt;
&lt;p&gt;MYISAM和InnoDB存储引擎只支持BTREE索引；MEMORY和HEAP存储引擎可以支持HASH和BTREE索引&lt;/p&gt;
&lt;p&gt;索引的优点：&lt;/p&gt;
&lt;p&gt;1、通过创建唯一索引，保证数据库表每行数据的唯一性&lt;/p&gt;
&lt;p&gt;2、大大加快数据查询速度&lt;/p&gt;
&lt;p&gt;3、在使用分组和排序进行数据查询时，可以显著减少查询中分组和排序的时间&lt;/p&gt;
&lt;p&gt;索引的缺点：&lt;/p&gt;
&lt;p&gt;1、维护索引需要耗费数据库资源&lt;/p&gt;
&lt;p&gt;2、索引需要占用磁盘空间，索引文件可能比数据文件更快达到最大文件尺寸&lt;/p&gt;
&lt;p&gt;3、当对表的数据进行增删改的时候，因为要维护索引，速度会受到影响&lt;/p&gt;
&lt;p&gt;索引的分类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、普通索引和唯一索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主键索引是一种特殊的唯一索引，不允许有空值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、单列索引和复合索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单列索引只包含单个列&lt;/p&gt;
&lt;p&gt;复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、全文索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在&lt;/p&gt;
&lt;p&gt;CHAR、VARCHAR、TEXT类型列上创建。MYSQL只有MYISAM存储引擎支持全文索引&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、空间索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，&lt;/p&gt;
&lt;p&gt;分别是GEOMETRY、POINT、LINESTRING、POLYGON。&lt;/p&gt;
&lt;p&gt;MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须&lt;/p&gt;
&lt;p&gt;将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建&lt;/p&gt;
&lt;p&gt;以上的索引在&lt;strong&gt;SQLSERVER&lt;/strong&gt;里都支持&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE table_name[col_name data type]
[unique|fulltext|spatial][index|key][index_name](col_name[length])[asc|desc]&lt;/pre&gt;
&lt;p&gt;unique|fulltext|spatial为可选参数，分别表示唯一索引、全文索引和空间索引；&lt;/p&gt;
&lt;p&gt;index和key为同义词，两者作用相同，用来指定创建索引&lt;/p&gt;
&lt;p&gt;col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择；&lt;/p&gt;
&lt;p&gt;index_name指定索引的名称，为可选参数，如果不指定，MYSQL默认col_name为索引值；&lt;/p&gt;
&lt;p&gt;length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；&lt;/p&gt;
&lt;p&gt;asc或desc指定升序或降序的索引值存储&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;普通索引&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE book (
  bookid INT NOT NULL,
  bookname VARCHAR (255) NOT NULL,
  AUTHORS VARCHAR (255) NOT NULL,
  info VARCHAR (255) NULL,
  COMMENT VARCHAR (255) NULL,
  year_publication YEAR NOT NULL,
  INDEX (year_publication)
) ;&lt;/pre&gt;
&lt;p&gt;使用SHOW CREATE TABLE查看表结构&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE `book` (
  `bookid` INT(11) NOT NULL,
  `bookname` VARCHAR(255) NOT NULL,
  `authors` VARCHAR(255) NOT NULL,
  `info` VARCHAR(255) DEFAULT NULL,
  `comment` VARCHAR(255) DEFAULT NULL,
  `year_publication` YEAR(4) NOT NULL,
  KEY `year_publication` (`year_publication`)
) ENGINE=MYISAM DEFAULT CHARSET=latin1&lt;/pre&gt;
&lt;p&gt;可以发现，book表的year_publication字段成功建立了索引其索引名字为year_publication&lt;/p&gt;
&lt;p&gt;我们向表插入一条数据，然后使用EXPLAIN语句查看索引是否有在使用&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO BOOK VALUES(12,&#39;NIHAO&#39;,&#39;NIHAO&#39;,&#39;文学&#39;,&#39;henhao&#39;,1990)

EXPLAIN SELECT * FROM book WHERE year_publication=1990&lt;/pre&gt;
&lt;p&gt;因为语句比较简单，系统判断有可能会用到索引或者全文扫描&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b303b083754eba03e0397a7714fb765d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;EXPLAIN语句输出结果的各个行的解释如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;select_type：&lt;/strong&gt; 表示查询中每个select子句的类型（简单 OR复杂）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;type：&lt;/strong&gt;表示MySQL在表中找到所需行的方式，又称“访问类型”，常见类型如下：（从上至下，效果依次变好）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;possible_keys&lt;/strong&gt; ：指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;key：&lt;/strong&gt; 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;key_len&lt;/strong&gt; ：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ref&lt;/strong&gt; ：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rows&lt;/strong&gt; ：表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Extra&lt;/strong&gt; ：包含不适合在其他列中显示但十分重要的额外信息 如using where，using index&lt;/p&gt;
&lt;p&gt;参考：&lt;a title=&quot;http://www.cnblogs.com/SQLSERVERZOUQI/p/3737199.html&quot; href=&quot;http://www.cnblogs.com/SQLSERVERZOUQI/p/3737199.html&quot; target=&quot;_blank&quot;&gt;MySQL学习系列2–MySQL执行计划分析EXPLAIN&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;唯一索引列的值必须唯一，但允许有空值。如果是复合索引则列值的组合必须唯一&lt;/p&gt;
&lt;p&gt;建表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t1
(
 id INT NOT NULL,
 NAME CHAR(30) NOT NULL,
 UNIQUE INDEX UniqIdx(id)&lt;/pre&gt;
&lt;p&gt;SHOW CREATE TABLE t1 查看表结构&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE TABLE t1&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt; CREATE TABLE `t1` (                                                                                                                        
          `id` int(11) NOT NULL,                                                                                                                   
          `name` char(30) NOT NULL,                                                                                                                
          UNIQUE KEY `UniqIdx` (`id`)                                                                                                              
        ) ENGINE=MyISAM DEFAULT CHARSET=utf8&lt;/pre&gt;
&lt;p&gt;可以看到id字段上已经成功建立了一个名为UniqIdx的唯一索引&lt;/p&gt;
&lt;p&gt;创建复合索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t3 (
  id INT NOT NULL,
  NAME CHAR(30) NOT NULL,
  age INT NOT NULL,
  info VARCHAR (255),
  INDEX MultiIdx (id, NAME, age (100))
)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE TABLE t3

CREATE TABLE `t3` (                                                                                                                                                                                             
          `id` int(11) NOT NULL,                                                                                                                                                                                        
          `NAME` char(30) NOT NULL,                                                                                                                                                                                     
          `age` int(11) NOT NULL,                                                                                                                                                                                       
          `info` varchar(255) DEFAULT NULL,                                                                                                                                                                             
          KEY `MultiIdx` (`id`,`NAME`,`age`)                                                                                                                                                                            
        ) ENGINE=MyISAM DEFAULT CHARSET=utf8&lt;/pre&gt;
&lt;p&gt;由结果可以看到id,name,age字段上已经成功建立了一个名为MultiIdx的复合索引&lt;/p&gt;
&lt;p&gt;我们向表插入两条数据&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO t3(id ,NAME,age,info) VALUES(1,&#39;小明&#39;,12,&#39;nihao&#39;),(2,&#39;小芳&#39;,16,&#39;nihao&#39;)&lt;/pre&gt;
&lt;p&gt;使用EXPLAIN语句查看索引使用情况&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;EXPLAIN SELECT * FROM t3 WHERE id=1 AND NAME=&#39;小芳&#39;&lt;/pre&gt;
&lt;p&gt;可以看到  &lt;strong&gt;possible_keys&lt;/strong&gt;和 &lt;strong&gt;key&lt;/strong&gt; 为MultiIdx证明使用了复合索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;    id  select_type  table   type    possible_keys  key       key_len  ref            rows  Extra      
------  -----------  ------  ------  -------------  --------  -------  -----------  ------  -----------
     1  SIMPLE       t3      ref     MultiIdx       MultiIdx  94       const,const       1  Using where&lt;/pre&gt;
&lt;p&gt;如果我们只指定name而不指定id&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;EXPLAIN SELECT * FROM t3 WHERE  NAME=&#39;小芳&#39;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;    id  select_type  table   type    possible_keys  key     key_len  ref       rows  Extra      
------  -----------  ------  ------  -------------  ------  -------  ------  ------  -----------
     1  SIMPLE       t3      ALL     (NULL)         (NULL)  (NULL)   (NULL)       2  Using where&lt;/pre&gt;
&lt;p&gt;结果跟SQLSERVER一样，也是不走索引， &lt;strong&gt;possible_keys&lt;/strong&gt;和&lt;strong&gt;key&lt;/strong&gt;都为NULL&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;全文索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FULLTEXT索引可以用于全文搜索。只有MYISAM存储引擎支持FULLTEXT索引，并且只支持CHAR、VARCHAR和TEXT类型&lt;/p&gt;
&lt;p&gt;全文索引不支持过滤索引。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t4 (
  id INT NOT NULL,
  NAME CHAR(30) NOT NULL,
  age INT NOT NULL,
  info VARCHAR (255),
  FULLTEXT INDEX FulltxtIdx (info)
) ENGINE = MYISAM&lt;/pre&gt;
&lt;p&gt;由于MYSQL5.6默认存储引擎为InnoDB，这里创建表的时候要修改表的存储引擎为MYISAM，不然创建索引会出错&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE TABLE t4&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Table   Create Table                                                                                                                                                                                                    
------  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
t4      CREATE TABLE `t4` (                                                                                                                                                                                             
          `id` int(11) NOT NULL,                                                                                                                                                                                        
          `name` char(30) NOT NULL,                                                                                                                                                                                     
          `age` int(11) NOT NULL,                                                                                                                                                                                       
          `info` varchar(255) DEFAULT NULL,                                                                                                                                                                             
          FULLTEXT KEY `FulltxtIdx` (`info`)                                                                                                                                                                            
        ) ENGINE=MyISAM DEFAULT CHARSET=utf8&lt;/pre&gt;
&lt;p&gt;由结果可以看到，info字段上已经成功建立名为FulltxtIdx的FULLTEXT索引。&lt;/p&gt;
&lt;p&gt;全文索引非常适合大型数据集合&lt;/p&gt;
&lt;p&gt;在SQLSERVER里使用全文索引比MYSQL还要复杂&lt;/p&gt;
&lt;p&gt;详细可以参考下面两篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/lyhabc/archive/2012/08/05/2623795.html&quot; href=&quot;http://www.cnblogs.com/lyhabc/archive/2012/08/05/2623795.html&quot; target=&quot;_blank&quot;&gt;关于SQLSERVER的全文目录跟全文索引的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/chegan/archive/2005/08/02/205756.html&quot; href=&quot;http://www.cnblogs.com/chegan/archive/2005/08/02/205756.html&quot; target=&quot;_blank&quot;&gt;[SQLSERVER]SQL中的全文检索(转邹建)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;空间索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;空间索引必须在 MYISAM类型的表中创建，而且空间类型的字段必须为&lt;strong&gt;非空&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建表t5&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t5
(g GEOMETRY NOT NULL ,SPATIAL INDEX spatIdx(g))ENGINE=MYISAM&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE TABLE t5

TABLE   CREATE TABLE                                                                                                   
------  ---------------------------------------------------------------------------------------------------------------
t5      CREATE TABLE `t5` (                                                                                            
          `g` GEOMETRY NOT NULL,                                                                                       
          SPATIAL KEY `spatIdx` (`g`)                                                                                  
        ) ENGINE=MYISAM DEFAULT CHARSET=utf8&lt;/pre&gt;
&lt;p&gt;可以看到，t5表的g字段上创建了名称为spatIdx的空间索引。注意创建时指定空间类型字段值的非空约束&lt;/p&gt;
&lt;p&gt;并且表的存储引擎为MYISAM&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;已经存在的表上创建索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在已经存在的表中创建索引，可以使用ALTER TABLE或者CREATE INDEX语句&lt;/p&gt;
&lt;p&gt;1、使用ALTER TABLE语句创建索引，语法如下&lt;/p&gt;
&lt;p&gt;ALTER TABLE table_name ADD [UNIQUE|FULLTEXT|SPATIAL][INDEX|KEY]&lt;/p&gt;
&lt;p&gt;[index_name](col_name[length],…)[ASC|DESC]&lt;/p&gt;
&lt;p&gt;与创建表时创建索引的语法不同，在这里使用了ALTER TABLE和ADD关键字，ADD表示向表中添加索引&lt;/p&gt;
&lt;p&gt;在t1表中的name字段上建立NameIdx普通索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE t1 ADD INDEX NameIdx(NAME)&lt;/pre&gt;
&lt;p&gt;添加索引之后，使用SHOW INDEX语句查看指定表中创建的索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW INDEX FROM t1

TABLE   Non_unique  Key_name  Seq_in_index  Column_name  COLLATION  Cardinality  Sub_part  Packed  NULL    Index_type  COMMENT  Index_comment
------  ----------  --------  ------------  -----------  ---------  -----------  --------  ------  ------  ----------  -------  -------------
t1               0  UniqIdx              1  id           A                    0    (NULL)  (NULL)          BTREE                             
t1               1  NameIdx              1  NAME         A               (NULL)    (NULL)  (NULL)          BTREE&lt;/pre&gt;
&lt;p&gt;各个参数的含义&lt;/p&gt;
&lt;p&gt;1、TABLE：要创建索引的表&lt;/p&gt;
&lt;p&gt;2、Non_unique：索引非唯一，1代表是非唯一索引，0代表唯一索引&lt;/p&gt;
&lt;p&gt;3、Key_name：索引的名称&lt;/p&gt;
&lt;p&gt;4、Seq_in_index：该字段在索引中的位置，单列索引该值为1，复合索引为每个字段在索引定义中的顺序&lt;/p&gt;
&lt;p&gt;5、Column_name：定义索引的列字段&lt;/p&gt;
&lt;p&gt;6、Sub_part：索引的长度&lt;/p&gt;
&lt;p&gt;7、NULL：该字段是否能为空值&lt;/p&gt;
&lt;p&gt;8、Index_type：索引类型&lt;/p&gt;
&lt;p&gt;可以看到，t1表已经存在了一个唯一索引&lt;/p&gt;
&lt;p&gt;在t3表的age和info字段上创建复合索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE t3 ADD INDEX t3AgeAndInfo(age,info)&lt;/pre&gt;
&lt;p&gt;使用SHOW INDEX查看表中的索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW INDEX FROM t3&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Table   Non_unique  Key_name      Seq_in_index  Column_name  Collation  Cardinality  Sub_part  Packed  Null    Index_type  Comment  Index_comment
------  ----------  ------------  ------------  -----------  ---------  -----------  --------  ------  ------  ----------  -------  -------------
t3               1  MultiIdx                 1  id           A               (NULL)    (NULL)  (NULL)          BTREE                             
t3               1  MultiIdx                 2  NAME         A               (NULL)    (NULL)  (NULL)          BTREE                             
t3               1  MultiIdx                 3  age          A               (NULL)    (NULL)  (NULL)          BTREE                             
t3               1  t3AgeAndInfo             1  age          A               (NULL)    (NULL)  (NULL)          BTREE                             
t3               1  t3AgeAndInfo             2  info         A               (NULL)    (NULL)  (NULL)  YES     BTREE&lt;/pre&gt;
&lt;p&gt;可以看到表中的字段的顺序，第一个位置是age，第二个位置是info，info字段是可空字段&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f43a17002244b0c7693125ac65e0e4ba.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e84c50cedafa28082e4ba63dcb8947be.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;创建表t6，在t6表上创建全文索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t6
(
  id INT NOT NULL,
  info CHAR(255)
)ENGINE= MYISAM;&lt;/pre&gt;
&lt;p&gt;注意修改ENGINE参数为MYISAM，MYSQL默认引擎InnoDB不支持全文索引&lt;/p&gt;
&lt;p&gt;使用ALTER TABLE语句在info字段上创建全文索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE t6 ADD FULLTEXT INDEX infoFTIdx(info)&lt;/pre&gt;
&lt;p&gt;使用SHOW INDEX查看索引情况&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW INDEX FROM t6&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Table   Non_unique  Key_name   Seq_in_index  Column_name  Collation  Cardinality  Sub_part  Packed  Null    Index_type  Comment  Index_comment
------  ----------  ---------  ------------  -----------  ---------  -----------  --------  ------  ------  ----------  -------  -------------
t6               1  infoFTIdx             1  info         (NULL)          (NULL)    (NULL)  (NULL)  YES     FULLTEXT&lt;/pre&gt;
&lt;p&gt;创建表t7，并在空间数据类型字段g上创建名称为spatIdx的空间索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t7(g GEOMETRY NOT NULL)ENGINE=MYISAM;&lt;/pre&gt;
&lt;p&gt;使用ALTER TABLE在表t7的g字段建立空间索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE t7 ADD SPATIAL INDEX spatIdx(g)&lt;/pre&gt;
&lt;p&gt;使用SHOW INDEX查看索引情况&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW INDEX FROM t7&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Table   Non_unique  Key_name  Seq_in_index  Column_name  Collation  Cardinality  Sub_part  Packed  Null    Index_type  Comment  Index_comment
------  ----------  --------  ------------  -----------  ---------  -----------  --------  ------  ------  ----------  -------  -------------
t7               1  spatIdx              1  g            A               (NULL)        32  (NULL)          SPATIAL&lt;/pre&gt;
&lt;p&gt;2、使用CREATE INDEX语句创建索引，语法如下&lt;/p&gt;
&lt;p&gt;CREATE [UNIQUE|FULLTEXT|SPATIAL]  INDEX index_name&lt;/p&gt;
&lt;p&gt;ON table_name(col_name[length],…)  [ASC|DESC]&lt;/p&gt;
&lt;p&gt;可以看到CREATE INDEX语句和ALTER INDEX语句的基本语法一样，只是关键字不同。&lt;/p&gt;
&lt;p&gt;我们建立一个book表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE book (
  bookid INT NOT NULL,
  bookname VARCHAR (255) NOT NULL,
  AUTHORS VARCHAR (255) NOT NULL,
  info VARCHAR (255) NULL,
  COMMENT VARCHAR (255) NULL,
  year_publication YEAR NOT NULL
)&lt;/pre&gt;
&lt;p&gt;建立普通索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE INDEX BkNameIdx ON book(bookname)&lt;/pre&gt;
&lt;p&gt;建立唯一索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE UNIQUE INDEX UniqidIdx ON book(bookId)&lt;/pre&gt;
&lt;p&gt;建立复合索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE INDEX BkAuAndInfoIdx ON book(AUTHORS(20),info(50))&lt;/pre&gt;
&lt;p&gt;建立全文索引，我们drop掉t6表，重新建立t6表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP TABLE IF EXISTS t6

CREATE TABLE t6
(
  id INT NOT NULL,
  info CHAR(255)
)ENGINE= MYISAM;

CREATE FULLTEXT INDEX infoFTIdx ON t6(info);&lt;/pre&gt;
&lt;p&gt;建立空间索引，我们drop掉t7表，重新建立t7表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP TABLE IF EXISTS t7

CREATE TABLE t7(g GEOMETRY NOT NULL)ENGINE=MYISAM;

CREATE SPATIAL INDEX spatIdx  ON t7(g)&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;删除索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MYSQL中使用ALTER TABLE或者DROP INDEX语句来删除索引，两者实现相同功能&lt;/p&gt;
&lt;p&gt;1、使用ALTER TABLE删除索引&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;p&gt;ALTER TABLE table_name DROP INDEX index_name&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE book DROP INDEX UniqidIdx&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE TABLE book&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;Table   Create Table                                                                                                                                                                                                                                                                                                                                                      
------  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
book    CREATE TABLE `book` (                                                                                                                                                                                                                                                                                                                                             
          `bookid` int(11) NOT NULL,                                                                                                                                                                                                                                                                                                                                      
          `bookname` varchar(255) NOT NULL,                                                                                                                                                                                                                                                                                                                               
          `authors` varchar(255) NOT NULL,                                                                                                                                                                                                                                                                                                                                
          `info` varchar(255) DEFAULT NULL,                                                                                                                                                                                                                                                                                                                               
          `comment` varchar(255) DEFAULT NULL,                                                                                                                                                                                                                                                                                                                            
          `year_publication` year(4) NOT NULL,                                                                                                                                                                                                                                                                                                                            
          KEY `BkNameIdx` (`bookname`),                                                                                                                                                                                                                                                                                                                                   
          KEY `BkAuAndInfoIdx` (`authors`(20),`info`(50))                                                                                                                                                                                                                                                                                                                 
        ) ENGINE=MyISAM DEFAULT CHARSET=utf8&lt;/pre&gt;
&lt;p&gt;可以看到，book表中已经没有名为UniqidIdx的唯一索引，删除索引成功&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：AUTO_INCREMENT约束字段的唯一索引不能被删除！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、使用DROP INDEX 语句删除索引&lt;/p&gt;
&lt;p&gt;DROP INDEX index_name ON table_name&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DROP INDEX BkAuAndInfoIdx ON book&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW CREATE TABLE book;

Table   Create Table                                                                                                                                                                                                                                                                                                   
------  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
book    CREATE TABLE `book` (                                                                                                                                                                                                                                                                                          
          `bookid` int(11) NOT NULL,                                                                                                                                                                                                                                                                                   
          `bookname` varchar(255) NOT NULL,                                                                                                                                                                                                                                                                            
          `authors` varchar(255) NOT NULL,                                                                                                                                                                                                                                                                             
          `info` varchar(255) DEFAULT NULL,                                                                                                                                                                                                                                                                            
          `comment` varchar(255) DEFAULT NULL,                                                                                                                                                                                                                                                                         
          `year_publication` year(4) NOT NULL,                                                                                                                                                                                                                                                                         
          KEY `BkNameIdx` (`bookname`)                                                                                                                                                                                                                                                                                 
        ) ENGINE=MyISAM DEFAULT CHARSET=utf8&lt;/pre&gt;
&lt;p&gt;可以看到，复合索引BkAuAndInfoIdx已经被删除了&lt;/p&gt;
&lt;p&gt;提示：删除表中的某列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。&lt;/p&gt;
&lt;p&gt;如果索引中的所有列都被删除，则整个索引将被删除！！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节介绍了MYSQL中的索引，索引语句的创建和删除和一些简单用法，希望对大家有帮助&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87348&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87348votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87348&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 04 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-04-87348-24a09a32c.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-04-87348-24a09a32c.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（8） ： 插入 更新 删除</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87340/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（7） ： 查询&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一篇《我的MYSQL学习心得（八）》将会讲解MYSQL的插入、更新和删除语句&lt;/p&gt;
&lt;p&gt;同样的，只会讲解跟SQLSERVER不同的地方&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将多行查询结果插入到表中&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO table_name1(column_list1) SELECT (column_list2) FROM table_name2 WHERE (condition)&lt;/pre&gt;
&lt;p&gt;INSERT INTO SELECT 在&lt;strong&gt;SQLSERVER&lt;/strong&gt;里也是支持的&lt;/p&gt;
&lt;p&gt;table_name1指定待插入数据的表；column_list1指定待插入表中要插入数据的哪些列；table_name2指定插入数据是从&lt;/p&gt;
&lt;p&gt;哪个表中查询出来的；column_list2指定数据来源表的查询列，该列表必须和column_list1列表中的字段个数相同，数据类型相同；&lt;/p&gt;
&lt;p&gt;condition指定SELECT语句的查询条件&lt;/p&gt;
&lt;p&gt;从person_old表中查询所有的记录，并将其插入到person表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE person (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  NAME CHAR(40) NOT NULL DEFAULT &#39;&#39;,
  age INT NOT NULL DEFAULT 0,
  info CHAR(50) NULL,
  PRIMARY KEY (id)
)

CREATE TABLE person_old (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  NAME CHAR(40) NOT NULL DEFAULT &#39;&#39;,
  age INT NOT NULL DEFAULT 0,
  info CHAR(50) NULL,
  PRIMARY KEY (id)
)

INSERT INTO person_old
VALUES (11,&#39;Harry&#39;,20,&#39;student&#39;),(12,&#39;Beckham&#39;,31,&#39;police&#39;)

SELECT * FROM person_old&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/09fabba930296c8b98d475f836b9d20b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，插入记录成功，person_old表现在有两条记录。接下来将person_oldperson_old表中的所有记录插入到person表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO person(id,NAME,age,info)
SELECT id,NAME,age,info FROM person_old;

SELECT * FROM person&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5dfb0a618d41670d35c12349425441c1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到数据转移成功，这里的id字段为自增的主键，在插入时要保证该字段值的唯一性，如果不能确定，可以插入的时候忽略该字段，&lt;/p&gt;
&lt;p&gt;只插入其他字段的值&lt;/p&gt;
&lt;p&gt;如果再执行一次就会出错&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dc7e53e53af44f79cbb6c80354d2afea.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;MYSQL和SQLSERVER的区别：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区别一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当要导入的数据中有重复值的时候，MYSQL会有三种方案&lt;/p&gt;
&lt;p&gt;方案一：使用 ignore 关键字&lt;br&gt;
方案二：使用 replace into&lt;br&gt;
方案三：ON DUPLICATE KEY UPDATE&lt;/p&gt;
&lt;p&gt;第二和第三种方案这里不作介绍，因为比较复杂，而且不符合要求，这里只讲第一种方案&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;TRUNCATE TABLE person

TRUNCATE TABLE persona_old 

INSERT INTO person_old
VALUES (11,&#39;Harry&#39;,20,&#39;student&#39;),(12,&#39;Beckham&#39;,31,&#39;police&#39;)

##注意下面这条insert语句是没有ignore关键字的
INSERT  INTO person(id,NAME,age,info)
SELECT id,NAME,age,info FROM person_old;

INSERT INTO person_old 
VALUES (13,&#39;kay&#39;,26,&#39;student&#39;)

##注意下面这条insert语句是有ignore关键字的
INSERT IGNORE INTO person(id,NAME,age,info)
SELECT id,NAME,age,info FROM person_old;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6bf8e08daca8360b8f265f61edc4d11e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/96a99a18a228ff9a7a7e599f3770714d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到插入成功&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQLSERVER&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SQLSERVER这边，如果要忽略重复键，需要在建表的时候指定 WITH (IGNORE_DUP_KEY = ON) ON [PRIMARY]&lt;/p&gt;
&lt;p&gt;这样在插入重复值的时候，SQLSERVER第一次会保留值，第二次发现有重复值的时候，SQLSERVER就会忽略掉&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区别二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插入自增列时的区别&lt;/p&gt;
&lt;p&gt;SQLSERVER需要使用 SET IDENTITY_INSERT 表名 ON 才能把自增字段的值插入到表中，如果不加 SET IDENTITY_INSERT 表名 ON&lt;/p&gt;
&lt;p&gt;则在插入数据到表中时，不能指定自增字段的值，则id字段不能指定值，SQLSERVER会自动帮你自动增加一&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERTINTO person(NAME,age,info) VALUES (&#39;feicy&#39;,33,&#39;student&#39;)&lt;/pre&gt;
&lt;p&gt;而MYSQL则不需要，而且自由度非常大&lt;/p&gt;
&lt;p&gt;你可以将id字段的值指定为NULL，MYSQL会自动帮你增一&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERTINTO person(id,NAME,age,info) VALUES (NULL,&#39;feicy&#39;,33,&#39;student&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b5c1cf5d0ccf1d5420123b2ce5b34f3c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;也可以指定值&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT IGNORE INTO person(id,NAME,age,info) VALUES (16,&#39;tom&#39;,88,&#39;student&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/919f120d40a62c085650a2814dd6d5bb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;也可以不写id的值，MYSQL会自动帮你增一&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT IGNORE INTO person(NAME,age,info) VALUES (&#39;amy&#39;,12,&#39;bb&#39;)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a3cc6e24cd90921727b0c1595b7ba64a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;你可以指定id字段的值也可以不指定，指定的时候只要当前id字段列没有你正在插入的那个值就可以，即没有重复值就可以&lt;/p&gt;
&lt;p&gt;自由度非常大，而且无须指定 SET IDENTITY_INSERT 表名 ON 选项&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区别三&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;唯一索引的NULL值重复问题&lt;/p&gt;
&lt;p&gt;MYSQL&lt;/p&gt;
&lt;p&gt;在MYSQL中UNIQUE 索引将会对null字段失效&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;insert into test(a) values(null)

insert into test(a) values(null)&lt;/pre&gt;
&lt;p&gt;上面的插入语句是可以重复插入的（联合唯一索引也一样）&lt;/p&gt;
&lt;p&gt;SQLSERVER&lt;/p&gt;
&lt;p&gt;SQLSERVER则不行&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE person (
  id INT  NOT NULL IDENTITY(1,1),
  NAME CHAR(40)  NULL DEFAULT &#39;&#39;,
  age INT NOT NULL DEFAULT 0,
  info CHAR(50) NULL,
  PRIMARY KEY (id)
)

CREATE UNIQUE INDEX IX_person_unique ON [dbo].[person](name)

INSERT INTO [dbo].[person]
        ( [NAME], [age], [info] )
VALUES  ( NULL, -- NAME - char(40)
          1, -- age - int
          &#39;aa&#39;  -- info - char(50)
          ),
          ( NULL, -- NAME - char(40)
          2, -- age - int
          &#39;bb&#39;  -- info - char(50)
          )&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;消息 2601，级别 14，状态 1，第 1 行
不能在具有唯一索引“IX_person_unique”的对象“dbo.person”中插入重复键的行。重复键值为 (&amp;lt;NULL&amp;gt;)。
语句已终止。&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更新比较简单，就不多说了&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;UPDATE person SET info =&#39;police&#39; WHERE id BETWEEN 14 AND 17

SELECT * FROM person&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/af11cc5f6e3a26b848a968cade650386.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除person表中一定范围的数据&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DELETE FROM  person  WHERE id BETWEEN 14 AND 17

SELECT * FROM person&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5b016dd565ee6e3c1a014c081ff509ef.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果要删除表的所有记录可以使用下面的两种方法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;##方法一
DELETE     FROM person

##方法二
TRUNCATE TABLE  person&lt;/pre&gt;
&lt;p&gt;跟SQLSERVER一样，TRUNCATE TABLE会比DELETE FROM TABLE 快&lt;/p&gt;
&lt;p&gt;MYISAM引擎下的测试结果，30行记录&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/68874e86427f5ed4cec4d57f20335565.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/75380d42a6a4e41b7130a81c298744dc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1dfc40ff095ea900869e5f7c51224f35.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;跟SQLSERVER一样，执行完TRUNCATE TABLE后，自增字段重新从一开始。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;################################
INSERT IGNORE INTO person(id,NAME,age,info)
SELECT id,NAME,age,info FROM person_old;

SELECT * FROM person

TRUNCATE TABLE  person

INSERT IGNORE INTO person(NAME,age,info) VALUES (&#39;amy&#39;,12,&#39;bb&#39;)

SELECT * FROM person&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/205107df6d91ecb896c03b0cd1e0b7e7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当你刚刚truncate了表之后执行下面语句就会看到重新从一开始&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW TABLE STATUS LIKE &#39;person&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e6c5c1d733173aaf6594c7b31771a517.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节介绍了MYSQL里的的插入、更新和删除，并且比较了与SQLSERVER的区别，特别是MYSQL里插入语句的灵活性&lt;/p&gt;
&lt;p&gt;刚刚开始从SQLSERVER转过来可能会有一些不适应&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.2cto.com/database/201308/234179.html&quot; href=&quot;http://www.2cto.com/database/201308/234179.html&quot; target=&quot;_blank&quot;&gt;mysql忽略主键冲突、避免重复插入的几种方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.it118.org/specials/c9fba99e-4401-49cf-8256-ac3c1a34c0d9/5bf5f814-8a57-4a77-a607-709083cba0aa.htm&quot; href=&quot;http://www.it118.org/specials/c9fba99e-4401-49cf-8256-ac3c1a34c0d9/5bf5f814-8a57-4a77-a607-709083cba0aa.htm&quot; target=&quot;_blank&quot;&gt;SQLSERVER忽略重复键进行数据导入的解决方案&lt;/a&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87345&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87345votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87345&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 04 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-04-87345-5164ec302.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-04-87345-5164ec302.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（7） ： 查询</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87327/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（5） ： 运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87337/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（6） ： 函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个《我的MYSQL学习心得》系列里面，我一直都把MYSQL跟SQLSERVER进行比较，相互进行比较是学习一样东西比较好的方法&lt;/p&gt;
&lt;p&gt;比较出大家的异同点，从而加深记忆&lt;/p&gt;
&lt;p&gt;这一篇《我的MYSQL学习心得（七）》也是一样，相同的地方略略带过，不同的地方我会给出例子，谢谢大家的支持o(∩_∩)o&lt;/p&gt;
&lt;p&gt;这一节主要介绍MYSQL里的基本查询（&lt;a title=&quot;http://dev.mysql.com/doc/refman/5.1/zh/preface.html&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/preface.html&quot; target=&quot;_blank&quot;&gt;MYSQL官方参考手册&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;MySQL中select的基本语法形式：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;select 属性列表
from 表名和视图列表
[where 条件表达式]
[group by 属性名[having 条件表达式]]
[order by 属性名[asc|desc]]
[limit &amp;lt;offset&amp;gt;,row count]&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;where子句：按照“条件表达式”指定的条件进行查询。&lt;/p&gt;
&lt;p&gt;group by子句：按照“属性名”指定的字段进行分组。&lt;/p&gt;
&lt;p&gt;having子句：有group by才能having子句，只有满足“条件表达式”中指定的条件的才能够输出。&lt;/p&gt;
&lt;p&gt;group by子句通常和count()、sum()等聚合函数一起使用。&lt;/p&gt;
&lt;p&gt;order by子句：按照“属性名”指定的字段进行排序。排序方式由“asc”和“desc”两个参数指出，默认是按照“asc”来排序，即升序。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;建立测试表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建测试表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE fruits
(
  f_id CHAR(10)  NOT NULL,
  s_id INT NOT NULL,
  f_name  CHAR(255)  NOT NULL,
  f_price DECIMAL(8,2) NOT NULL,
  PRIMARY KEY(f_id)
)&lt;/pre&gt;
&lt;p&gt;插入测试数据&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO fruits(f_id,s_id,f_name,f_price)
VALUES(&#39;a1&#39;,101,&#39;apple&#39;,5.2),
(&#39;b1&#39;,102,&#39;blackberry&#39;,5.2),
(&#39;bs1&#39;,105,&#39;orange&#39;,5.2),
(&#39;bs2&#39;,103,&#39;melon&#39;,5.2),
(&#39;t1&#39;,106,&#39;banana&#39;,5.2);&lt;/pre&gt;
&lt;p&gt;使用select语句查询f_id字段的数据&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT f_id,f_name FROM fruits&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ae561734b7827920de9540b636aa2489.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：MYSQL中SQL语句是不区分大小写的，因此select和SELECT作用是相同的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这一点跟SQLSERVER是一样的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用查询&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE fruits
(
  f_id CHAR(10)  NOT NULL,
  s_id INT NOT NULL,
  f_name  CHAR(255)  NOT NULL,
  f_price DECIMAL(8,2) NOT NULL,
  PRIMARY KEY(f_id)
)&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;带like的字符匹配查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、百分号通配符“%”，匹配任意长度的字符，甚至包括零字符&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT f_id,f_name FROM fruits WHERE f_name LIKE &#39;b%y&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/96c71b347e44828e68c3ec9bb5432fd8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、下划线通配符“_”,一次只能匹配任意一个字符&lt;/p&gt;
&lt;p&gt;下面语句有四个下划线&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT f_id,f_name FROM fruits WHERE f_name LIKE &#39;____n&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1794b429b479f3ae76bca4be2b15226d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;同样，在SQLSERVER里面也是有的&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE [sss]
GO
SELECT * FROM [dbo].[aaa] WHERE [name] LIKE &#39;s_____&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a64c7060bbe515a2185a59a3d82ebb23.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;查询空值&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE customers
(
  c_id INT  NOT NULL AUTO_INCREMENT,
  c_name CHAR(25) NOT NULL,
  c_city  CHAR(50)   NULL,
  PRIMARY KEY(c_id)
)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO customers(c_name,c_city)
VALUES(&#39;liming&#39;,&#39;china&#39;),
(&#39;hongfang&#39;,NULL)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM customers WHERE c_city IS NULL&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0d94fbc3e1b3d5c21d198289074a9101.jpg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM customers WHERE c_city IS NOT NULL&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f54500dffbae1246e043132028d6e0f1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;AND、OR、DISTINCT关键字&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT f_id,f_name FROM fruits WHERE f_name LIKE &#39;____n&#39; AND f_id=&#39;bs2&#39;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT f_id,f_name FROM fruits WHERE f_name LIKE &#39;____n&#39; OR f_id=&#39;bs2&#39;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT DISTINCT s_id FROM fruits&lt;/pre&gt;
&lt;p&gt;GROUP BY&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT s_id ,COUNT(1) AS total FROM fruits GROUP BY s_id&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b3d8dc3036bab6b786b2f4245af5a380.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;再插入两条记录&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO fruits(f_id,s_id,f_name,f_price)
VALUES(&#39;a6&#39;,101,&#39;cherry&#39;,6),
(&#39;a8&#39;,102,&#39;coconut&#39;,7)&lt;/pre&gt;
&lt;p&gt;如果要查看每个供应商提供的水果的种类的名称，MYSQL中可以在GROUP BY中使用GROUP_CONCAT()函数，&lt;/p&gt;
&lt;p&gt;将每个分组中各个字段的值显示出来&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT s_id,GROUP_CONCAT(f_name) AS NAMES FROM fruits GROUP BY s_id&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ab469e0303dc3638e053e17ccaeb9683.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;SQLSERVER是没有GROUP_CONCAT()函数的，SQLSERVER要达到同样效果需要使用xml函数，MYSQL这方面做得非常好&lt;/p&gt;
&lt;p&gt;having：过滤分组&lt;/p&gt;
&lt;p&gt;根据s_id对fruits表中的数据进行分组，并显示水果种类大于1的分组信息&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT s_id ,GROUP_CONCAT(f_name) AS NAMES FROM fruits GROUP BY s_id HAVING COUNT(f_name)&amp;gt;1&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2bee1f7b73b24ce598d926bc14282eeb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在group by中使用with rollup&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT s_id ,COUNT(1) AS total FROM fruits GROUP BY s_id WITH ROLLUP&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7a18a39dce88c88aeb90b6743ed7db91.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;增加了最后一行，7表示total列的所有值的总和&lt;/p&gt;
&lt;p&gt;而rollup关键字在SQLSERVER里面也有，详见：&lt;a title=&quot;http://www.cnblogs.com/lyhabc/p/3280634.html&quot; href=&quot;http://www.cnblogs.com/lyhabc/p/3280634.html&quot; target=&quot;_blank&quot;&gt;SQLSERVER中的ALL、PERCENT、CUBE关键字、ROLLUP关键字和GROUPING函数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的！&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;limit限制查询结果的数量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SQLSERVER中是使用&lt;strong&gt;TOP&lt;/strong&gt;关键字，而在MYSQL中是使用&lt;strong&gt;LIMIT&lt;/strong&gt;关键字&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;LIMIT[位置偏移量]，行数&lt;/pre&gt;
&lt;p&gt;第一个“位置偏移量”参数指示MYSQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”&lt;/p&gt;
&lt;p&gt;将会从表中第一条记录开始（第一条记录的位置偏移量是0，第二天记录的位置偏移量是1……以此类推）&lt;/p&gt;
&lt;p&gt;第二个参数“行数”指示返回的记录条数&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b4ab7943f78fd3e8111c860b9c5932a3.jpg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits LIMIT 4,3&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8808e0652fdcc17373f12fdd1ba2114d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面结果返回从第5条记录行（因为从0开始数）开始之后的3条记录&lt;/p&gt;
&lt;p&gt;注意：在MYSQL5.6中可以使用 LIMIT 4 OFFSET 3 ，意思是获取从第5行记录开始的3条记录，和 LIMIT 4,3 返回的结果是一样的&lt;/p&gt;
&lt;p&gt;在SQLSERVER2012里面开始支持类似MYSQL的这种语法，但是需要按某一列先排序，而不像MYSQL那样不用按照某一列排序&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE [sss]
GO

CREATE TABLE fruits
(
    f_id CHAR(10) NOT NULL ,
    s_id INT NOT NULL ,
    f_name CHAR(255) NOT NULL ,
    f_price DECIMAL(8, 2) NOT NULL ,
    PRIMARY KEY ( f_id )
)

INSERT  INTO fruits
        ( f_id ,
          s_id ,
          f_name ,
          f_price
        )
        SELECT  &#39;a1&#39; ,
                101 ,
                &#39;apple&#39; ,
                5.2
        UNION ALL
        SELECT  &#39;b1&#39; ,
                102 ,
                &#39;blackberry&#39; ,
                5.2
        UNION ALL
        SELECT  &#39;bs1&#39; ,
                105 ,
                &#39;orange&#39; ,
                5.2
        UNION ALL
        SELECT  &#39;bs2&#39; ,
                103 ,
                &#39;melon&#39; ,
                5.2
        UNION ALL
        SELECT  &#39;t1&#39; ,
                106 ,
                &#39;banana&#39; ,
                5.2
        UNION ALL
        SELECT  &#39;a6&#39; ,
                101 ,
                &#39;cherry&#39; ,
                6
        UNION ALL
        SELECT  &#39;a8&#39; ,
                102 ,
                &#39;coconut&#39; ,
                7&lt;/pre&gt;
&lt;p&gt;先按s_id排序，然后返回第5行开始的3条记录&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT  *
FROM    [dbo].[fruits]
ORDER BY [s_id] ASC
        OFFSET 4 ROWS
FETCH NEXT 3 ROWS ONLY;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d292be1939ee7f1a25b331a45f9305ff.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;虽然没有MYSQL那么方便，不过也算是一种进步，而对于OFFSET FETCH NEXT的性能可以参考宋沄剑的文章：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/CareySon/archive/2012/03/09/2387825.html#top&quot; href=&quot;http://www.cnblogs.com/CareySon/archive/2012/03/09/2387825.html#top&quot; target=&quot;_blank&quot;&gt;SQL Server2012 T-SQL对分页的增强尝试&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;子查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子查询&lt;/strong&gt;这个特性从&lt;strong&gt;MYSQL4.1&lt;/strong&gt;开始引入。&lt;/p&gt;
&lt;p&gt;插入测试数据&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE tbl1(num1 INT NOT NULL);
CREATE TABLE tbl2(num2 INT NOT NULL)

INSERT INTO tbl1 VALUES(1),(4),(13),(27);
INSERT INTO tbl2 VALUES(6),(14),(11),(20)&lt;/pre&gt;
&lt;p&gt;ANY关键字接在一个比较操作符的后面，表示若与子查询返回的任何值比较为TRUE，则返回TRUE&lt;/p&gt;
&lt;p&gt;返回tbl2表的所有num2列，然后将tbl1中的num1的值与之进行比较，只要大于num2的任何一个值，即为符合查询条件的结果&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT num1 FROM tbl1 WHERE num1&amp;gt;ANY(SELECT num2 FROM tbl2)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/54d1d343f9a723838d2e1c4ef8e61e40.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;ALL关键字接在一个比较操作符的后面，表示与子查询返回的所有值比较为TRUE，则返回TRUE&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT num1 FROM tbl1 WHERE num1&amp;gt;ALL(SELECT num2 FROM tbl2)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7d1cacd1d652ff6f7c73685788dd0a7e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;SQLSERVER&lt;/strong&gt;中也可以使用ANY和ALL关键字&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE [sss]
GO
CREATE TABLE tbl1(num1 INT NOT NULL)
CREATE TABLE tbl2(num2 INT NOT NULL)

INSERT INTO tbl1 VALUES(1),(4),(13),(27)
INSERT INTO tbl2 VALUES(6),(14),(11),(20)

SELECT num1 FROM tbl1 WHERE num1&amp;gt;ANY(SELECT num2 FROM tbl2)
SELECT num1 FROM tbl1 WHERE num1&amp;gt;ALL(SELECT num2 FROM tbl2)&lt;/pre&gt;
&lt;p&gt;结果是一样的&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e9bf1355920f676c1e6ab76d95b90171.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;合并查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用UNION关键字，合并结果时，两个查询对应的列数和数据类型必须相同。&lt;/p&gt;
&lt;p&gt;各个SELECT语句之间使用UNION或UNION ALL关键字分隔&lt;/p&gt;
&lt;p&gt;UNION：执行的时候删除重复的记录，所有返回的行都是唯一的&lt;/p&gt;
&lt;p&gt;UNION ALL：不删除重复行也不对结果进行自动排序&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT s_id,f_name,f_price    
FROM fruits
WHERE f_price&amp;lt;9.0
UNION 
SELECT s_id,f_name,f_price
FROM fruits
WHERE s_id IN (101,103)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/41af7c24f3ffe44d0e81644227c142c7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一个查询把f_price小于9.0的记录查询出来，第二个查询把s_id为101和103的记录查询处理&lt;/p&gt;
&lt;p&gt;因为f_price小于9.0的记录里有些记录的s_id是102、105、106，这些结果不会被去掉会跟第二个查询进行合并&lt;/p&gt;
&lt;p&gt;所以最终的结果会有s_id为102、105、106的记录&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;正则表达式查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正则表达式在&lt;strong&gt;SQLSERVER&lt;/strong&gt;里面是没有的，但是在MYSQL里不单只有，而且功能也比较丰富&lt;/p&gt;
&lt;p&gt;MYSQL中使用REGEXP关键字指定正则表达式的字符匹配模式&lt;/p&gt;
&lt;p&gt;1、查询以特定字符或字符串开头的记录&lt;/p&gt;
&lt;p&gt;字符“^”匹配以特定字符或者字符串开头的文本&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;^b&#39;&lt;/pre&gt;
&lt;p&gt;返回f_name字段以b开头的记录&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2ebeb2b809c204aab52f76de11729d71.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、查询以特定字符或字符串结尾的记录&lt;/p&gt;
&lt;p&gt;字符“$”匹配以特定字符或者字符串结尾的文本&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;y$&#39;&lt;/pre&gt;
&lt;p&gt;返回f_name字段以y结尾的记录&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3060ac4a8482566be87a91b6ad79d975.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5bf217763e5f665fc5834b841fe12d67.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3、用符号“.”来代替字符串中的任意一个字符&lt;/p&gt;
&lt;p&gt;字符“.”匹配任意一个字符&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;a.g&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e4332e28119f8390d1921407b732bebc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;a和g两个字母之间包含单个字符，orange符合要求&lt;/p&gt;
&lt;p&gt;4、使用“*”和“+”来匹配多个字符&lt;/p&gt;
&lt;p&gt;星号“*”匹配前面的字符任意多次，包括0次。加号“+”匹配前面的字符至少一次&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;^ba*&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/381e9e42644dde28934d611a5126a050.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;blackberry和banana符合要求，b开头，a匹配任意多次，不管出现的顺序在哪里&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;^ba+&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/658c0d71007a951dd2407b86795e494e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;“a+”匹配字母“a”至少一次，只有banana满足匹配条件&lt;/p&gt;
&lt;p&gt;5、匹配指定字符串&lt;/p&gt;
&lt;p&gt;正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符“|”隔开&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;on|ap&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0684a46eedc5221b460ccdf5b15edee5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到apple 、melon 、coconut 3个值中都包含有字符串“on”和“ap”，满足匹配条件&lt;/p&gt;
&lt;p&gt;6、匹配指定字符中的任意一个&lt;/p&gt;
&lt;p&gt;方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_name REGEXP &#39;[ot]&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/70343a46c2a95d62d1e8b54c8a2f5644.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;方括号[]还可以指定数值集合&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE s_id REGEXP &#39;[456]&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/53ad94c26b2ff17b0c262746119e1283.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;s_id字段值中有3个数字中的1个即为匹配记录字段&lt;/p&gt;
&lt;p&gt;[456]也可以写成[4-6]即指定集合区间&lt;/p&gt;
&lt;p&gt;7、匹配指定字符以外的字符&lt;/p&gt;
&lt;p&gt;“[^字符集合]”匹配不在指定集合中的任何字符&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT * FROM fruits WHERE f_id REGEXP &#39;[^a-e1-2]&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/85adc18f7cdebad4a196bddbbf9516cc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;返回开头不在a-e  1-2字母的记录，例如a1，b1这些记录就不符合要求&lt;/p&gt;
&lt;p&gt;8、使用{n,} 或者{n,m}来指定字符串连续出现的次数&lt;/p&gt;
&lt;p&gt;“字符串{n,}”，表示至少匹配n次前面的字符；“字符串{n,m}”表示匹配前面的字符串不少于n次，不多于m次。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt; SELECT * FROM fruits WHERE f_name REGEXP &#39;b{1,}&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/21c11cf6d5bef8ab166447aaafbf43b4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;至少匹配1次字母b，blackberry和banana都符合要求&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt; SELECT * FROM fruits WHERE f_name REGEXP &#39;ba{1,3}&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6d3a8f427364a03979c3453f5b547f8d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;“ba”字符串最少出现一次，最多三次，banana这个字符串符合要求&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节介绍了MYSQL里的查询，并且比较了与SQLSERVER的区别，特别是MYSQL里的正则查询灵活多变&lt;/p&gt;
&lt;p&gt;这一点比SQLSERVER略为优胜&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87340&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87340votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87340&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 04 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-04-87340-ab5cf6ef0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-04-87340-ab5cf6ef0.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（5） ： 运算符</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87324/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（4） ： 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MYSQL中的运算符很多，这一节主要讲MYSQL中有的，而SQLSERVER没有的运算符&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;安全等于运算符（&amp;lt;=&amp;gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个操作符和=操作符执行相同的比较操作，不过&amp;lt;=&amp;gt;可以用来判断NULL值。&lt;/p&gt;
&lt;p&gt;在两个操作数均为NULL时，其返回值为1而不为NULL；&lt;/p&gt;
&lt;p&gt;而当一个操作数为NULL时，其返回值为0而不为NULL。&lt;/p&gt;
&lt;p&gt;下面分别是 SELECT NULL &amp;lt;=&amp;gt;1   SELECT 1&amp;lt;=&amp;gt;0  SELECT NULL &amp;lt;=&amp;gt;NULL 的执行结果&lt;/p&gt;
&lt;p&gt;在两个操作数均为NULL时，其返回值为1而不为NULL；&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4b835e4e9259147e5588cdd09018ae6e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/248c214c40bf10fc9da4c3f988b64cbd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/011ee95bc4b90f9b349f51026ce5cd17.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;LEAST运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法格式为：LEAST（值1,值2,…值n），其中值n表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。&lt;/p&gt;
&lt;p&gt;假如任意一个自变量为NULL，则LEAST()的返回值为NULL&lt;/p&gt;
&lt;p&gt;使用LEAST运算符进行大小判断，SQL语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT LEAST(2,0),LEAST(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;),LEAST(10,NULL)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c04c8e5fdf1b5851bfa0d741319b077e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由结果可以看到，当参数中是整数或者浮点数时，LEAST将返回其中最小的值；&lt;/p&gt;
&lt;p&gt;当参数为字符串时，返回字母中顺序最靠前的字符；&lt;/p&gt;
&lt;p&gt;当比较值列表中有NULL时，不能判断大小，返回值为NULL&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;GREATEST运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法格式为： GREATEST(值1，值2，…值n)，其中n表示参数列表中有n个值。&lt;/p&gt;
&lt;p&gt;在有两个或多个参数的情况下，返回最大值。&lt;/p&gt;
&lt;p&gt;假如任意一个自变量为NULL，则GREATEST()的返回值为NULL&lt;/p&gt;
&lt;p&gt;使用GREATEST运算符进行大小判断，SQL语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT GREATEST(2,0),GREATEST(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;),GREATEST(10,NULL)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/560166a778071d3de91925438cb18183.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；&lt;/p&gt;
&lt;p&gt;当参数为字符串时，返回字母中顺序最靠后的字符；&lt;/p&gt;
&lt;p&gt;当比较值列表中有NULL时，不能判断大小，返回值为NULL&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;REGEXP 运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SQLSERVER里是没有正则函数或者运算符的，MYSQL在这方面的确比较完善&lt;/p&gt;
&lt;p&gt;用来匹配字符串，语法格式为：expr REGEXP  匹配条件，如果expr满足匹配条件，返回1；&lt;/p&gt;
&lt;p&gt;如果不满足，则返回0；&lt;/p&gt;
&lt;p&gt;若expr或匹配条件任意一个为NULL，则结果为NULL&lt;/p&gt;
&lt;p&gt;常用的几种通配符：&lt;/p&gt;
&lt;p&gt;（1）’^&#39;匹配以该字符后面的字符开头的字符串&lt;/p&gt;
&lt;p&gt;（2）’$&#39;匹配以该字符后面的字符结尾的字符串&lt;/p&gt;
&lt;p&gt;（3）’.&#39;匹配任何一个单字符&lt;/p&gt;
&lt;p&gt;（4）’[...]‘匹配在方括号内的任何字符。例如，“[abc]” 匹配a、b或c。&lt;/p&gt;
&lt;p&gt;字符的范围可以使用一个’-&#39;，“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字&lt;/p&gt;
&lt;p&gt;（5）’*’ 匹配零个或多个在他前面的字符。例如，“x*”匹配任何数量的’*&#39;字符，“[0-9]*”匹配任何数量的数字，&lt;/p&gt;
&lt;p&gt;而“.*”匹配任何数量的任何字符。&lt;/p&gt;
&lt;p&gt;使用REGEXP  运算符进行字符串匹配运算，SQL语句如下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT &#39;ssky&#39; REGEXP &#39;^s&#39;,&#39;ssky&#39; REGEXP &#39;y$&#39; ,&#39;ssky&#39; REGEXP &#39;.sky&#39;,&#39;ssky&#39; REGEXP &#39;[ab]&#39;;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/77b45156fbeb05e637c267df12e5ee95.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由结果可以看到，指定匹配字符串为ssky。&lt;/p&gt;
&lt;p&gt;‘^s’表示匹配任何以字母s开头的字符串，因此满足匹配条件，返回1；&lt;/p&gt;
&lt;p&gt;‘y$’表示匹配任何以字母y结尾的字符串，因此满足匹配条件，返回1；&lt;/p&gt;
&lt;p&gt;‘.sky’表示匹配任何以sky结尾，字符长度为4的字符串，因此满足匹配条件，返回1；&lt;/p&gt;
&lt;p&gt;‘^s’表示匹配任何以字母s开头的字符串，因此满足匹配条件，返回1；&lt;/p&gt;
&lt;p&gt;‘[ab]‘表示匹配任何包含字母a或者b的字符串，指定字符串中没有字母a也没有字母b，因此不满足匹配条件，返回0；&lt;/p&gt;
&lt;p&gt;TIPS：正则表达式是一个可以进行复杂查询的强大工具，相对于LIKE字符串匹配，他可以使用更多的通配符类型&lt;/p&gt;
&lt;p&gt;查询结果更加灵活。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;逻辑运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;逻辑与运算符：AND或者&amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;逻辑或运算符：OR或者||&lt;/p&gt;
&lt;p&gt;上面两个运算符就不说了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在SQLSERVER里，与运算符是AND或者&amp;amp; ；&lt;/strong&gt;&lt;strong&gt;或运算符是OR或者|&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://sqlfool.com/2009/02/bitwise-operations/&quot; href=&quot;http://sqlfool.com/2009/02/bitwise-operations/&quot; target=&quot;_blank&quot;&gt;http://sqlfool.com/2009/02/bitwise-operations/&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--DROP TABLE myTable
CREATE Table myTable
(
      id            int identity(1,1)
    , item          varchar(10)
    , attributes    int
);
 
Insert Into myTable
Select &#39;Broccoli&#39;, 200 Union All
Select &#39;Tomato&#39;, 193 Union All
Select &#39;Car&#39;, 276 Union All
Select &#39;Ball&#39;, 292;

DECLARE @statusLookup Table
(
      attribute int
    , value     varchar(10)
);
 
Insert Into @statusLookup
Select 1, &#39;Red&#39; Union All
Select 4, &#39;Blue&#39; Union All
Select 8, &#39;Green&#39; Union All
Select 16, &#39;Metal&#39; Union All
 
Select 32, &#39;Plastic&#39; Union All
Select 64, &#39;Plant&#39; Union All
Select 128, &#39;Edible&#39; Union All
Select 256, &#39;Non-Edible&#39;;
 
Select a.item, b.value
From myTable a
Cross Join @statusLookup b
Where a.attributes &amp;amp; b.attribute &amp;lt;&amp;gt; 0
Order By a.item
    , b.value&lt;/pre&gt;
&lt;p&gt;异或运算符：XOR&lt;/p&gt;
&lt;p&gt;当任意一个操作数为NULL时，返回值为NULL;对于非NULL的操作数，如果两个操作数都是非0值或者都是0值，则返回结果为0；&lt;/p&gt;
&lt;p&gt;如果一个为0值，另一个为非0值，返回结果为1&lt;/p&gt;
&lt;p&gt;使用异或运算符XOR进行逻辑判断，SQL语句如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SELECT 1 XOR 1, 0 XOR 0,1 XOR 0,1 XOR NULL,1 XOR 1 XOR 1&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1b4823dea97d373f6caf8f7613b451bb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由结果可以看到‘1 XOR 1’和‘0 XOR 0’中运算符两边的操作数都为非零值，或者都是零值，因此返回0；&lt;/p&gt;
&lt;p&gt;’1 XOR 0′中两边的操作数，一个为0值，另一个为非0值，返回结果为1；&lt;/p&gt;
&lt;p&gt;’1 XOR NULL’中有一个操作数为NULL，返回结果为NULL；&lt;/p&gt;
&lt;p&gt;’1 XOR 1 XOR 1′中有多个操作数，运算符相同，因此运算符从左到右依次计算，’1 XOR 1′的结果为0，再与1进行异或运算，因此结果为1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIPS: a XOR b的计算等同于(a AND (NOT b))或者(NOT a AND ( b))&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;位运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于比较少用到，这里只做简单介绍&lt;/p&gt;
&lt;p&gt;位运算符是用来对二进制字节中的位进行测试、移位或者测试处理&lt;/p&gt;
&lt;p&gt;MYSQL中提供的位运算有&lt;/p&gt;
&lt;p&gt;按位或(|)&lt;/p&gt;
&lt;p&gt;按位与(&amp;amp;)&lt;/p&gt;
&lt;p&gt;按位异或(^)&lt;/p&gt;
&lt;p&gt;按位左移(&amp;lt;&amp;lt;)&lt;/p&gt;
&lt;p&gt;按位右移(&amp;gt;&amp;gt;)&lt;/p&gt;
&lt;p&gt;按位取反(~)：反转所有比特&lt;/p&gt;
&lt;p&gt;TIPS：可以使用BIN()=binary函数查看一个十进制数的二进制表示&lt;/p&gt;
&lt;p&gt;例如20这个数字 SELECT BIN(20)&lt;/p&gt;
&lt;p&gt;二进制表示为：10100&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/815f99cfacd9228c1e878ce10e6ae582.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;同样 sqlserver也是有位运算符的，但是没有mysql那么多，如下&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DECLARE @i BIT
SET @i=0
SELECT @i | 3 AS &#39;按位或&#39;
SELECT @i &amp;amp; 3 AS &#39;按位与&#39;
SELECT @i ^ 3 AS &#39;按位异或&#39;
SELECT ~@i AS &#39;非&#39;

SET @i=1
SELECT ~@i AS &#39;非&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d252552ed4e03e2afb69bcc6b8005bd1.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;特别提示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某一些MYSQL中的特殊字符需要用转义字符才能插入数据库，否则产生意料之外的结果。&lt;/p&gt;
&lt;p&gt;下面的特殊字符需要在输入时加反斜线符号开头&lt;/p&gt;
&lt;p&gt;输入单引号需要：\’&lt;/p&gt;
&lt;p&gt;输入双引号需要：\”&lt;/p&gt;
&lt;p&gt;输入反斜杠：\\&lt;/p&gt;
&lt;p&gt;输入回车符：\r&lt;/p&gt;
&lt;p&gt;输入换行符：\n&lt;/p&gt;
&lt;p&gt;输入制表符：\tab&lt;/p&gt;
&lt;p&gt;输入退格符：\b&lt;/p&gt;
&lt;p&gt;在插入这些特殊字符到数据库之前一定要进行转义处理&lt;/p&gt;
&lt;p&gt;在SQLSERVER里，这些特殊字符不是在前面加反斜杠\，而是加单引号’&lt;/p&gt;
&lt;p&gt;例如插入一个单引号，加了反斜杠，插入成功&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO table_1(NAME) VALUES(&#39;\&#39;&#39;)

SELECT * FROM table_1&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9088b1b9387a4a8fd179bbb80d23cd8c.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节简单介绍了MYSQL里的一些运算符和特殊字符，并且比较了与SQLSERVER的区别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87327&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87327votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87327&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Wed, 03 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-03-87327-81bd46d12.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-03-87327-81bd46d12.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（4） ： 数据类型</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87322/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（3） ： 查看字段长度&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;MYSQL&lt;/strong&gt;里的BLOB数据类型&lt;/p&gt;
&lt;p&gt;BLOB是一个二进制大对象，用来存储可变数量的数据。BLOB类型分为4种：TinyBlob、Blob、MediumBlob、LongBlob，&lt;/p&gt;
&lt;p&gt;这几个类型之间的唯一区别是在存储文件的最大大小上不同。&lt;/p&gt;
&lt;p&gt;MySQL的四种BLOB类型     类型 大小(单位：字节)&lt;/p&gt;
&lt;p&gt;TinyBlob                            最大 255&lt;br&gt;
Blob                                  最大 65K&lt;br&gt;
MediumBlob                       最大 16M&lt;br&gt;
LongBlob                           最大 4G&lt;/p&gt;
&lt;p&gt;BLOB列存储的是二进制字符串（字节字符串）；TEXT列存储的是非二进制字符串（字符字符串）。&lt;/p&gt;
&lt;p&gt;BLOB列没有字符集，并且排序和比较基于列值字节的数值；TEXT列有一个字符集，并且根据字符集对值进行排序和比较&lt;/p&gt;
&lt;p&gt;BLOB是二进制字符串，TEXT是非二进制字符串，两者均可存放大容量的信息。&lt;strong&gt;BLOB主要存储图片、音频信息等&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;而TEXT只能存储文本文件。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;SQLSERVER&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQLSERVER并没有BLOB数据类型，只有大型对象数据类型（BLOB）：&lt;/p&gt;
&lt;p&gt;text,ntext,image,nvarchar(max),varchar(max),varbinary(max)和xml数据类型&lt;/p&gt;
&lt;p&gt;这些数据类型的数据都存放在LOB类型的数据页面里&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他类型&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;第11章：列类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#column-type-overview&quot;&gt;11.1. 列类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-type-overview&quot;&gt;11.1.1. 数值类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#date-and-time-type-overview&quot;&gt;11.1.2. 日期和时间类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#string-type-overview&quot;&gt;11.1.3. 字符串类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-types&quot;&gt;11.2. 数值类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#date-and-time-types&quot;&gt;11.3. 日期和时间类型&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#datetime&quot;&gt;11.3.1. DATETIME、DATE和TIMESTAMP类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#time&quot;&gt;11.3.2. TIME类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#year&quot;&gt;11.3.3. YEAR类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#y2k-issues&quot;&gt;11.3.4. Y2K事宜和日期类型&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#string-types&quot;&gt;11.4. String类型&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#char&quot;&gt;11.4.1. CHAR和VARCHAR类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#binary-varbinary&quot;&gt;11.4.2. BINARY和VARBINARY类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#blob&quot;&gt;11.4.3. BLOB和TEXT类型&lt;code&gt;&lt;/code&gt;&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#enum&quot;&gt;11.4.4. ENUM类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#set&quot;&gt;11.4.5. SET类型&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements&quot;&gt;11.5. 列类型存储需求&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#choosing-types&quot;&gt;11.6. 选择正确的列类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#other-vendor-column-types&quot;&gt;11.7. 使用来自其他数据库引擎的列类型&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;p&gt;MySQL支持多种列类型：数值类型、日期/时间类型和字符串(字符)类型。本章首先对这些列类型进行了概述，然后更加详细地描述了各种列的类型，以及列类型存储需求的总结。概述很简单。关于具体列类型的详细信息应查阅详细的描述，例如指定值时允许使用的格式。&lt;/p&gt;
&lt;p&gt;MySQL支持处理空间数据的扩展名。关于空间类型的信息参见&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/spatial-extensions-in-mysql.html&quot;&gt;第19章：&lt;/a&gt;&lt;a title=&quot;Chapter 19. Spatial Extensions in MySQL&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/spatial-extensions-in-mysql.html&quot;&gt;&lt;em&gt;MySQL中的空间扩展&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;几种列类型描述使用了下述惯例：&lt;/p&gt;
&lt;p&gt;·         &lt;em&gt;M&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;表示最大显示宽度。最大有效显示宽度是255。&lt;/p&gt;
&lt;p&gt;·         &lt;em&gt;D&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;适用于浮点和定点类型，并表示小数点后面的位数。最大可能的值是30，但不应大于&lt;em&gt;M&lt;/em&gt;-2。&lt;/p&gt;
&lt;p&gt;·         方括号(‘[’和‘]’)表示可选部分。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;column-type-overview&quot;&gt;&lt;/a&gt;11.1. 列类型概述&lt;/h2&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-type-overview&quot;&gt;11.1.1. 数值类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#date-and-time-type-overview&quot;&gt;11.1.2. 日期和时间类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#string-type-overview&quot;&gt;11.1.3. 字符串类型概述&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;p&gt;&lt;a name=&quot;id2844482&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;numeric-type-overview&quot;&gt;&lt;/a&gt;11.1.1. 数值类型概述&lt;/h3&gt;
&lt;p&gt;下面为数值列类型的概述。详细信息参见&lt;a title=&quot;11.2. Numeric Types&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-types&quot;&gt;11.2节，“数值类型”&lt;/a&gt;。列存储需求参见&lt;a title=&quot;11.5. Column Type Storage Requirements&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements&quot;&gt;11.5节，“列类型存储需求”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;M&lt;/em&gt;指示最大显示宽度。最大有效显示宽度是255。显示宽度与存储大小或类型包含的值的范围无关，相关描述见&lt;a title=&quot;11.2. Numeric Types&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-types&quot;&gt;11.2节，“数值类型”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果为一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性。&lt;/p&gt;
&lt;p&gt;SERIAL是BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE的一个别名。&lt;/p&gt;
&lt;p&gt;在整数列定义中，SERIAL DEFAULT VALUE是NOT NULL AUTO_INCREMENT UNIQUE的一个别名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt;应当清楚，当使用在整数值（其中一个是UNSIGNED类型）之间使用减号时，结果是无符号。参见&lt;a title=&quot;12.8. Cast Functions and Operators&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/functions.html#cast-functions&quot;&gt;12.8节，“Cast函数和操作符”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;·         BIT[(&lt;em&gt;M&lt;/em&gt;)]&lt;/p&gt;
&lt;p&gt;位字段类型。&lt;em&gt;M&lt;/em&gt;表示每个值的位数，范围为从1到64。如果&lt;em&gt;M&lt;/em&gt;被省略， 默认为1。&lt;/p&gt;
&lt;p&gt;·         TINYINT[(&lt;em&gt;M&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;很小的整数。带符号的范围是-128到127。无符号的范围是0到255。&lt;/p&gt;
&lt;p&gt;·         BOOL，BOOLEAN&lt;/p&gt;
&lt;p&gt;是TINYINT(1)的同义词。zero值被视为假。非zero值视为真。&lt;/p&gt;
&lt;p&gt;在将来，将根据标准SQL引入完全布尔类型的处理。&lt;/p&gt;
&lt;p&gt;·         SMALLINT[(&lt;em&gt;M&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;小的整数。带符号的范围是-32768到32767。无符号的范围是0到65535。&lt;/p&gt;
&lt;p&gt;·         MEDIUMINT[(&lt;em&gt;M&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;中等大小的整数。带符号的范围是-8388608到8388607。无符号的范围是0到16777215。&lt;/p&gt;
&lt;p&gt;·         INT[(&lt;em&gt;M&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;普通大小的整数。带符号的范围是-2147483648到2147483647。无符号的范围是0到4294967295。&lt;/p&gt;
&lt;p&gt;·         INTEGER[(&lt;em&gt;M&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;这是INT的同义词。&lt;/p&gt;
&lt;p&gt;·         BIGINT[(&lt;em&gt;M&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;大整数。带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615。&lt;/p&gt;
&lt;p&gt;应清楚BIGINT列的下述内容：&lt;/p&gt;
&lt;p&gt;o        使用带符号的BIGINT或DOUBLE值进行所有算法，因此除了位函数，不应使用大于9223372036854775807(63位)的无符号的大整数! 如果这样做，结果中的最后几位可能出错，这是由于将BIGINT值转换为DOUBLE进行四舍五入时造成的错误。&lt;/p&gt;
&lt;p&gt;MySQL可以在以下情况下处理BIGINT：&lt;/p&gt;
&lt;p&gt;§         当使用整数在一个BIGINT列保存大的无符号的值时。&lt;/p&gt;
&lt;p&gt;§         在MIN(&lt;em&gt;col_name&lt;/em&gt;)或MAX(&lt;em&gt;col_name&lt;/em&gt;)中，其中&lt;em&gt;col_name&lt;/em&gt;指BIGINT列。&lt;/p&gt;
&lt;p&gt;§         使用操作符(+，-，*等等)并且两个操作数均为整数时。&lt;/p&gt;
&lt;p&gt;o        总是可以使用一个字符串在BIGINT列中保存严格整数值。在这种情况下，MySQL执行字符串-数字转换，其间不存在双精度表示。&lt;/p&gt;
&lt;p&gt;o        当两个操作数均为整数值时，-、+和* 操作符使用BIGINT算法。这说明如果乘两个大整数(或来自返回整数的函数)，当结果大于9223372036854775807时，会得到意想不到的结果。&lt;/p&gt;
&lt;p&gt;·         FLOAT[(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;小(单精度)浮点数。允许的值是-3.402823466E+38到-1.175494351E-38、0和1.175494351E-38到3.402823466E+38。这些是理论限制，基于IEEE标准。实际的范围根据硬件或操作系统的不同可能稍微小些。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;M&lt;/em&gt;是小数纵位数，&lt;em&gt;D&lt;/em&gt;是小数点后面的位数。如果&lt;em&gt;M&lt;/em&gt;和&lt;em&gt;D&lt;/em&gt;被省略，根据硬件允许的限制来保存值。单精度浮点数精确到大约7位小数位。&lt;/p&gt;
&lt;p&gt;如果指定UNSIGNED，不允许负值。&lt;/p&gt;
&lt;p&gt;使用浮点数可能会遇到意想不到的问题，因为在MySQL中的所有计算用双精度完成。参见&lt;a title=&quot;A.5.7. Solving Problems with No Matching Rows&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/problems.html#no-matching-rows&quot;&gt;A.5.7节，“解决与不匹配行有关的问题”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;·         DOUBLE[(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;普通大小(双精度)浮点数。允许的值是-1.7976931348623157E+308到-2.2250738585072014E-308、0和2.2250738585072014E-308到 1.7976931348623157E+308。这些是理论限制，基于IEEE标准。实际的范围根据硬件或操作系统的不同可能稍微小些。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;M&lt;/em&gt;是小数总位数，&lt;em&gt;D&lt;/em&gt;是小数点后面的位数。如果&lt;em&gt;M&lt;/em&gt;和&lt;em&gt;D&lt;/em&gt;被省略，根据硬件允许的限制来保存值。双精度浮点数精确到大约15位小数位。&lt;/p&gt;
&lt;p&gt;如果指定UNSIGNED，不允许负值。&lt;/p&gt;
&lt;p&gt;·         DOUBLE PRECISION[(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)] [UNSIGNED] [ZEROFILL], REAL[(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;为DOUBLE的同义词。除了：如果SQL服务器模式包括REAL_AS_FLOAT选项，REAL是FLOAT的同义词而不是DOUBLE的同义词。&lt;/p&gt;
&lt;p&gt;·         FLOAT(&lt;em&gt;p&lt;/em&gt;) [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;浮点数。&lt;em&gt;p&lt;/em&gt;表示精度（以位数表示），但MySQL只使用该值来确定是否结果列的数据类型为FLOAT或DOUBLE。如果&lt;em&gt;p&lt;/em&gt;为从0到24，数据类型变为没有&lt;em&gt;M&lt;/em&gt;或&lt;em&gt;D&lt;/em&gt;值的FLOAT。如果&lt;em&gt;p&lt;/em&gt;为从25到53，数据类型变为没有&lt;em&gt;M&lt;/em&gt;或&lt;em&gt;D&lt;/em&gt;值的DOUBLE。结果列范围与本节前面描述的单精度FLOAT或双精度DOUBLE数据类型相同。&lt;/p&gt;
&lt;p&gt;FLOAT(&lt;em&gt;p&lt;/em&gt;)语法与ODBC兼容。&lt;/p&gt;
&lt;p&gt;·         DECIMAL[(&lt;em&gt;M&lt;/em&gt;[,&lt;em&gt;D&lt;/em&gt;])] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;压缩的“严格”定点数。&lt;em&gt;M&lt;/em&gt;是小数位数(精度)的总数，&lt;em&gt;D&lt;/em&gt;是小数点(标度)后面的位数。小数点和(负数)的‘-’符号不包括在&lt;em&gt;M&lt;/em&gt;中。如果&lt;em&gt;D&lt;/em&gt;是0，则值没有小数点或分数部分。DECIMAL整数最大位数(&lt;em&gt;M&lt;/em&gt;)为65。支持的十进制数的最大位数(&lt;em&gt;D&lt;/em&gt;)是30。如果&lt;em&gt;D&lt;/em&gt;被省略， 默认是0。如果&lt;em&gt;M&lt;/em&gt;被省略， 默认是10。&lt;/p&gt;
&lt;p&gt;如果指定UNSIGNED，不允许负值。&lt;/p&gt;
&lt;p&gt;所有DECIMAL列的基本计算(+，-，*，/)用65位精度完成。&lt;/p&gt;
&lt;p&gt;·         DEC[(&lt;em&gt;M&lt;/em&gt;[,&lt;em&gt;D&lt;/em&gt;])] [UNSIGNED] [ZEROFILL], NUMERIC[(&lt;em&gt;M&lt;/em&gt;[,&lt;em&gt;D&lt;/em&gt;])] [UNSIGNED] [ZEROFILL], FIXED[(&lt;em&gt;M&lt;/em&gt;[,&lt;em&gt;D&lt;/em&gt;])] [UNSIGNED] [ZEROFILL]&lt;/p&gt;
&lt;p&gt;是DECIMAL的同义词。FIXED同义词适用于与其它服务器的兼容性。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;date-and-time-type-overview&quot;&gt;&lt;/a&gt;11.1.2. 日期和时间类型概述&lt;/h3&gt;
&lt;p&gt;本节综合讨论了临时列类型。详细信息，参见&lt;a title=&quot;11.3. Date and Time Types&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#date-and-time-types&quot;&gt;11.3节，“日期和时间类型”&lt;/a&gt;。列存储需求参见&lt;a title=&quot;11.5. Column Type Storage Requirements&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements&quot;&gt;11.5节，“列类型存储需求”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;·         DATE&lt;/p&gt;
&lt;p&gt;日期。支持的范围为’1000-01-01′到’9999-12-31′。MySQL以’YYYY-MM-DD’格式显示DATE值，但允许使用字符串或数字为DATE列分配值。&lt;/p&gt;
&lt;p&gt;·         DATETIME&lt;/p&gt;
&lt;p&gt;日期和时间的组合。支持的范围是’1000-01-01 00:00:00′到’9999-12-31 23:59:59′。MySQL以’YYYY-MM-DD HH:MM:SS’格式显示DATETIME值，但允许使用字符串或数字为DATETIME列分配值。&lt;/p&gt;
&lt;p&gt;·         TIMESTAMP[(&lt;em&gt;M&lt;/em&gt;)]&lt;/p&gt;
&lt;p&gt;时间戳。范围是’1970-01-01 00:00:00′到2037年。&lt;/p&gt;
&lt;p&gt;TIMESTAMP列用于INSERT或UPDATE操作时记录日期和时间。如果你不分配一个值，表中的第一个TIMESTAMP列自动设置为最近操作的日期和时间。也可以通过分配一个NULL值，将TIMESTAMP列设置为当前的日期和时间。&lt;/p&gt;
&lt;p&gt;TIMESTAMP值返回后显示为’YYYY-MM-DD HH:MM:SS’格式的字符串，显示宽度固定为19个字符。如果想要获得数字值，应在TIMESTAMP 列添加+0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注释：&lt;/strong&gt;MySQL 4.1以前使用的TIMESTAMP格式在MySQL 5.1中不支持；关于旧格式的信息参见&lt;em&gt;MySQL 4.1 参考手册&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;·         TIME&lt;/p&gt;
&lt;p&gt;时间。范围是’-838:59:59′到’838:59:59′。MySQL以’HH:MM:SS’格式显示TIME值，但允许使用字符串或数字为TIME列分配值。&lt;/p&gt;
&lt;p&gt;·         YEAR[(2|4)]&lt;/p&gt;
&lt;p&gt;两位或四位格式的年。默认是四位格式。在四位格式中，允许的值是1901到2155和0000。在两位格式中，允许的值是70到69，表示从1970年到2069年。MySQL以YYYY 格式显示YEAR值，但允许使用字符串或数字为YEAR列分配值。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;string-type-overview&quot;&gt;&lt;/a&gt;11.1.3. 字符串类型概述&lt;/h3&gt;
&lt;p&gt;本节综合讨论了字符串列类型。详细信息参见&lt;a title=&quot;11.4. String Types&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#string-types&quot;&gt;11.4节，“String类型”&lt;/a&gt;。列存储需求参见&lt;a title=&quot;11.5. Column Type Storage Requirements&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements&quot;&gt;11.5节，“列类型存储需求”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在某些情况中，MySQL可以将一个字符串列更改为不同于CREATE TABLE或ALTER TABLE语句中所给出的类型。参见&lt;a title=&quot;13.1.5.1. Silent Column Specification Changes&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/sql-syntax.html#silent-column-changes&quot;&gt;13.1.5.1节，“沉寂的列规格变更”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;MySQL 5.1字符串数据类型包括部分在MySQL 4.1之前的版本中没有的特性：&lt;/p&gt;
&lt;p&gt;·         许多字符串数据类型的列定义可以包括指定字符集的CHARACTER SET属性，也可能包括校对规则。(CHARSET是CHARACTER SET的一个同义词）。这些属性适用于CHAR、VARCHAR、TEXT类型、ENUM和SET。例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t
(
  c1 CHAR(20) CHARACTER SET utf8,
  c2 CHAR(20) CHARACTER SET latin1 COLLATE  latin1_bin
);&lt;/pre&gt;
&lt;p&gt;该表定义创建了一个名为c1的列，具有一个utf8字符集和该字符集的默认 校对规则，和一个名为c2的列以及latin1字符集和该字符集的二元 校对规则。二元校对规则对大小写不敏感。&lt;/p&gt;
&lt;p&gt;·         MySQL 5.1用字符单位解释在字符列定义中的长度规范。(以前的一些MySQL版本以字节解释长度）。&lt;/p&gt;
&lt;p&gt;·         对于CHAR、VARCHAR和TEXT类型，BINARY属性可以为列分配该列字符集的 校对规则。&lt;/p&gt;
&lt;p&gt;·         字符列的排序和比较基于分配给列的字符集。在以前的版本中，排序和比较基于服务器字符集的校对规则。对于CHAR和VARCHAR 列，你可以用BINARY属性声明列让排序和 校对规则使用当前的字符代码值而不是词汇顺序。&lt;/p&gt;
&lt;p&gt;关于MySQL 5.1中字符集的支持，参见&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/charset.html&quot;&gt;第10章：&lt;/a&gt;&lt;a title=&quot;Chapter 10. Character Set Support&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/charset.html&quot;&gt;&lt;em&gt;字符集支持&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;·         [NATIONAL] CHAR(&lt;em&gt;M&lt;/em&gt;) [BINARY| ASCII | UNICODE]&lt;/p&gt;
&lt;p&gt;固定长度字符串，当保存时在右侧填充空格以达到指定的长度。&lt;em&gt;M&lt;/em&gt;表示列长度。&lt;em&gt;M&lt;/em&gt;的范围是0到255个字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注释：&lt;/strong&gt;当检索CHAR值时尾部空格被删除。&lt;/p&gt;
&lt;p&gt;如果想要将某个CHAR的长度设为大于255，执行的CREATE TABLE或ALTER TABLE语句将失败并提示错误：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; CREATE TABLE c1 (col1 INT, col2 CHAR(500));
ERROR 1074 (42000): Column length too big for column &#39;col&#39; (max = 255); use BLOB or TEXT instead
mysql&amp;gt; SHOW CREATE TABLE c1;
ERROR 1146 (42S02): Table &#39;test.c1&#39; doesn&#39;t exist&lt;/pre&gt;
&lt;p&gt;CHAR是CHARACTER的简写。NATIONAL CHAR(或其等效短形式NCHAR)是标准的定义CHAR列应使用 默认字符集的SQL方法。这在MySQL中为默认值。&lt;/p&gt;
&lt;p&gt;BINARY属性是指定列字符集的二元 校对规则的简写。排序和比较基于数值字符值。&lt;/p&gt;
&lt;p&gt;列类型CHAR BYTE是CHAR BINARY的一个别名。这是为了保证兼容性。&lt;/p&gt;
&lt;p&gt;可以为CHAR指定ASCII属性。它分配latin1字符集。&lt;/p&gt;
&lt;p&gt;可以为CHAR指定UNICODE属性。它分配ucs2字符集。&lt;/p&gt;
&lt;p&gt;MySQL允许创建类型CHAR(0)的列。这主要用于必须有一个列但实际上不使用值的旧版本的应用程序相兼容。当你需要只能取两个值的列时也很好：没有定义为NOT NULL的一个CHAR(0)列只占用一位，只可以取值NULL和”(空字符串)。&lt;/p&gt;
&lt;p&gt;·         CHAR&lt;/p&gt;
&lt;p&gt;这是CHAR(1)的同义词。&lt;/p&gt;
&lt;p&gt;·         [NATIONAL] VARCHAR(&lt;em&gt;M&lt;/em&gt;) [BINARY]&lt;/p&gt;
&lt;p&gt;变长字符串。&lt;em&gt;M&lt;/em&gt; 表示最大列长度。&lt;em&gt;M&lt;/em&gt;的范围是0到65,535。(VARCHAR的最大实际长度由最长的行的大小和使用的字符集确定。最大&lt;em&gt;有效&lt;/em&gt;长度是65,532字节）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注释：&lt;/strong&gt;MySQL 5.1遵从标准SQL规范，并且不删除VARCHAR值的尾部空格。&lt;/p&gt;
&lt;p&gt;VARCHAR是字符VARYING的简写。&lt;/p&gt;
&lt;p&gt;BINARY属性是指定列的字符集的二元 校对规则的简写。排序和比较基于数值字符值。&lt;/p&gt;
&lt;p&gt;VARCHAR保存时用一个字节或两个字节长的前缀+数据。如果VARCHAR列声明的长度大于255，长度前缀是两个字节。&lt;/p&gt;
&lt;p&gt;·         BINARY(&lt;em&gt;M&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;BINARY类型类似于CHAR类型，但保存二进制字节字符串而不是非二进制字符串。&lt;/p&gt;
&lt;p&gt;·         VARBINARY(&lt;em&gt;M&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;VARBINARY类型类似于VARCHAR类型，但保存二进制字节字符串而不是非二进制字符串。&lt;/p&gt;
&lt;p&gt;·         TINYBLOB&lt;/p&gt;
&lt;p&gt;最大长度为255(2&lt;sup&gt;8&lt;/sup&gt;–1)字节的BLOB列。&lt;/p&gt;
&lt;p&gt;·         TINYTEXT&lt;/p&gt;
&lt;p&gt;最大长度为255(2&lt;sup&gt;8&lt;/sup&gt;–1)字符的TEXT列。&lt;/p&gt;
&lt;p&gt;·         BLOB[(&lt;em&gt;M&lt;/em&gt;)]&lt;/p&gt;
&lt;p&gt;最大长度为65,535(2&lt;sup&gt;16&lt;/sup&gt;–1)字节的BLOB列。&lt;/p&gt;
&lt;p&gt;可以给出该类型的可选长度&lt;em&gt;M&lt;/em&gt;。如果给出，则MySQL将列创建为最小的但足以容纳&lt;em&gt;M&lt;/em&gt;字节长的值的BLOB类型。&lt;/p&gt;
&lt;p&gt;·         TEXT[(&lt;em&gt;M&lt;/em&gt;)]&lt;/p&gt;
&lt;p&gt;最大长度为65,535(2&lt;sup&gt;16&lt;/sup&gt;–1)字符的TEXT列。&lt;/p&gt;
&lt;p&gt;可以给出可选长度&lt;em&gt;M&lt;/em&gt;。则MySQL将列创建为最小的但足以容纳&lt;em&gt;M&lt;/em&gt;字符长的值的TEXT类型。&lt;/p&gt;
&lt;p&gt;·         MEDIUMBLOB&lt;/p&gt;
&lt;p&gt;最大长度为16,777,215(2&lt;sup&gt;24&lt;/sup&gt;–1)字节的BLOB列。&lt;/p&gt;
&lt;p&gt;·         MEDIUMTEXT&lt;/p&gt;
&lt;p&gt;最大长度为16,777,215(2&lt;sup&gt;24&lt;/sup&gt;–1)字符的TEXT列。&lt;/p&gt;
&lt;p&gt;·         LONGBLOB&lt;/p&gt;
&lt;p&gt;最大长度为4,294,967,295或4GB(2&lt;sup&gt;32&lt;/sup&gt;–1)字节的BLOB列。LONGBLOB列的最大&lt;em&gt;有效&lt;/em&gt;(允许的)长度取决于客户端/服务器协议中配置最大包大小和可用的内存。&lt;/p&gt;
&lt;p&gt;·         LONGTEXT&lt;/p&gt;
&lt;p&gt;最大长度为4,294,967,295或4GB(2&lt;sup&gt;32&lt;/sup&gt;–1)字符的TEXT列。LONGTEXT列的最大&lt;em&gt;有效&lt;/em&gt;(允许的)长度取决于客户端/服务器协议中配置最大包大小和可用的内存。&lt;/p&gt;
&lt;p&gt;·         ENUM(‘&lt;em&gt;value1&lt;/em&gt;‘,’&lt;em&gt;value2&lt;/em&gt;‘,…)&lt;/p&gt;
&lt;p&gt;枚举类型。只能有一个值的字符串，从值列’&lt;em&gt;value1&lt;/em&gt;‘，’&lt;em&gt;value2&lt;/em&gt;‘，…，NULL中或特殊 ”错误值中选出。ENUM列最多可以有65,535个截然不同的值。ENUM值在内部用整数表示。&lt;/p&gt;
&lt;p&gt;·         SET(‘&lt;em&gt;value1&lt;/em&gt;‘,’&lt;em&gt;value2&lt;/em&gt;‘,…)&lt;/p&gt;
&lt;p&gt;一个设置。字符串对象可以有零个或多个值，每个值必须来自列值’&lt;em&gt;value1&lt;/em&gt;‘，’&lt;em&gt;value2&lt;/em&gt;‘，…SET列最多可以有64个成员。SET值在内部用整数表示。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;numeric-types&quot;&gt;&lt;/a&gt;11.2. 数值类型&lt;/h2&gt;
&lt;p&gt;MySQL支持所有标准SQL数值数据类型。这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。&lt;/p&gt;
&lt;p&gt;BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。&lt;/p&gt;
&lt;p&gt;作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。&lt;/p&gt;
&lt;table id=&quot;table1&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;字节&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;最小值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;最大值&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;(带符号的/无符号的)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;(带符号的/无符号的)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TINYINT&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-128&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;-32768&lt;/td&gt;
&lt;td&gt;32767&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;65535&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;-8388608&lt;/td&gt;
&lt;td&gt;8388607&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;16777215&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-2147483648&lt;/td&gt;
&lt;td&gt;2147483647&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;4294967295&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BIGINT&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-9223372036854775808&lt;/td&gt;
&lt;td&gt;9223372036854775807&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;18446744073709551615&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;MySQL还支持选择在该类型关键字后面的括号内指定整数值的显示宽度(例如，INT(4))。该可选显示宽度规定用于显示宽度小于指定的列宽度的值时从左侧填满宽度。&lt;/p&gt;
&lt;p&gt;显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。&lt;/p&gt;
&lt;p&gt;当结合可选扩展属性ZEROFILL使用时， 默认补充的空格用零代替。例如，对于声明为INT(5) ZEROFILL的列，值4检索为00004。请注意如果在整数列保存超过显示宽度的一个值，当MySQL为复杂联接生成临时表时会遇到问题，因为在这些情况下MySQL相信数据适合原列宽度。&lt;/p&gt;
&lt;p&gt;所有整数类型可以有一个可选(非标准)属性UNSIGNED。当你想要在列内只允许非负数和该列需要较大的上限数值范围时可以使用无符号值。&lt;/p&gt;
&lt;p&gt;浮点和定点类型也可以为UNSIGNED。同数类型，该属性防止负值保存到列中。然而，与整数类型不同的是，列值的上范围保持不变。&lt;/p&gt;
&lt;p&gt;如果为一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性。&lt;/p&gt;
&lt;p&gt;对于浮点列类型，在MySQL中单精度值使用4个字节，双精度值使用8个字节。&lt;/p&gt;
&lt;p&gt;FLOAT类型用于表示近似数值数据类型。SQL标准允许在关键字FLOAT后面的括号内选择用位指定精度(但不能为指数范围)。MySQL还支持可选的只用于确定存储大小的精度规定。0到23的精度对应FLOAT列的4字节单精度。24到53的精度对应DOUBLE列的8字节双精度。&lt;/p&gt;
&lt;p&gt;MySQL允许使用非标准语法：FLOAT(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)或REAL(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)或DOUBLE PRECISION(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)。这里，“(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)”表示该值一共显示&lt;em&gt;M&lt;/em&gt;位整数，其中&lt;em&gt;D&lt;/em&gt;位位于小数点后面。例如，定义为FLOAT(7,4)的一个列可以显示为-999.9999。MySQL保存值时进行四舍五入，因此如果在FLOAT(7,4)列内插入999.00009，近似结果是999.0001。&lt;/p&gt;
&lt;p&gt;MySQL将DOUBLE视为DOUBLE PRECISION(非标准扩展)的同义词。MySQL还将REAL视为DOUBLE PRECISION(非标准扩展)的同义词，除非SQL服务器模式包括REAL_AS_FLOAT选项。&lt;/p&gt;
&lt;p&gt;为了保证最大可能的可移植性，需要使用近似数值数据值存储的代码应使用FLOAT或DOUBLE PRECISION，不规定精度或位数。&lt;/p&gt;
&lt;p&gt;DECIMAL和NUMERIC类型在MySQL中视为相同的类型。它们用于保存必须为确切精度的值，例如货币数据。当声明该类型的列时，可以(并且通常要)指定精度和标度；例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;salary DECIMAL(5,2)&lt;/pre&gt;
&lt;p&gt;在该例子中，5是精度，2是标度。精度表示保存值的主要位数，标度表示小数点后面可以保存的位数。&lt;/p&gt;
&lt;p&gt;在MySQL 5.1中以二进制格式保存DECIMAL和NUMERIC值。&lt;/p&gt;
&lt;p&gt;标准SQL要求salary列能够用5位整数位和两位小数保存任何值。因此，在这种情况下可以保存在salary列的值的范围是从-999.99到999.99。&lt;/p&gt;
&lt;p&gt;在标准SQL中，语法DECIMAL(&lt;em&gt;M&lt;/em&gt;)等价于DECIMAL(&lt;em&gt;M&lt;/em&gt;,0)。同样，语法DECIMAL等价于DECIMAL(&lt;em&gt;M&lt;/em&gt;,0)，可以通过计算确定&lt;em&gt;M&lt;/em&gt;的值。在MySQL 5.1中支持DECIMAL和NUMERIC数据类型的变量形式。&lt;em&gt;M&lt;/em&gt;默认值是10。&lt;/p&gt;
&lt;p&gt;DECIMAL或NUMERIC的最大位数是65，但具体的DECIMAL或NUMERIC列的实际范围受具体列的精度或标度约束。如果此类列分配的值小数点后面的位数超过指定的标度允许的范围，值被转换为该标度。(具体操作与操作系统有关，但一般结果均被截取到允许的位数）。&lt;/p&gt;
&lt;p&gt;BIT数据类型可用来保存位字段值。BIT(&lt;em&gt;M&lt;/em&gt;)类型允许存储&lt;em&gt;M&lt;/em&gt;位值。&lt;em&gt;M&lt;/em&gt;范围为1到64。&lt;/p&gt;
&lt;p&gt;要指定位值，可以使用b’&lt;em&gt;value&lt;/em&gt;‘符。&lt;em&gt;value&lt;/em&gt;是一个用0和1编写的二进制值。例如，b’111′和b’100000000′分别表示7和128。参见&lt;a title=&quot;9.1.5. Bit-Field Values&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/language-structure.html#bit-field-values&quot;&gt;9.1.5节，“位字段值”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果为BIT(M)列分配的值的长度小于&lt;em&gt;M&lt;/em&gt;位，在值的左边用0填充。例如，为BIT(6)列分配一个值b’101′，其效果与分配b’000101′相同。&lt;/p&gt;
&lt;p&gt;当要在一个数值列内保存一个超出该列允许范围的值时，MySQL的操作取决于此时有效的SQL模式。如果模式未设置，MySQL将值裁剪到范围的相应端点，并保存裁减好的值。但是，如果模式设置为traditional(“严格模式”)，超出范围的值将被拒绝并提示错误，并且根据SQL标准插入会失败。参见&lt;a title=&quot;5.3.2. The Server SQL Mode&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode&quot;&gt;5.3.2节，“SQL服务器模式”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果INT列是UNSIGNED，列范围的大小相同，但其端点会变为到0和4294967295。如果你试图保存-9999999999和9999999999，以非严格模式保存到列中的值是0和4294967296。&lt;/p&gt;
&lt;p&gt;如果在浮点或定点列中分配的值超过指定(或默认)精度和标度规定的范围，MySQL以非严格模式保存表示范围相应端点的值。&lt;/p&gt;
&lt;p&gt;当MySQL没有工作在严格模式时，对于ALTER TABLE、LOAD DATA INFILE、UPDATE和多行INSERT语句，由于裁剪发生的转换将报告为警告。当MySQL工作在严格模式时，这些语句将失败，并且部分或全部值不会插入或更改，取决于是否表为事务表和其它因素。详情参见&lt;a title=&quot;5.3.2. The Server SQL Mode&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode&quot;&gt;5.3.2节，“SQL服务器模式”&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;date-and-time-types&quot;&gt;&lt;/a&gt;11.3. 日期和时间类型&lt;/h2&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#datetime&quot;&gt;11.3.1. DATETIME、DATE和TIMESTAMP类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#time&quot;&gt;11.3.2. TIME类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#year&quot;&gt;11.3.3. YEAR类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#y2k-issues&quot;&gt;11.3.4. Y2K事宜和日期类型&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;p&gt;&lt;a name=&quot;id2849193&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2849203&quot;&gt;&lt;/a&gt;表示时间值的DATE和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。每个时间类型有一个有效值范围和一个“零”值，当指定不合法的MySQL不能表示的值时使用“零”值。TIMESTAMP类型有专有的自动更新特性，将在后面描述。&lt;/p&gt;
&lt;p&gt;如果试图插入一个不合法的日期，MySQL将给出警告或错误。可以使用ALLOW_INVALID_DATES SQL模式让MySQL接受某些日期，例如’1999-11-31′。当你想要保存一个“可能错误的”用户已经在数据库中指定(例如，以web形式)用于将来处理的值时很有用。在这种模式下，MySQL只验证月范围为从0到12，日范围为从0到31。这些范围可以包括零，因为MySQL允许在DATE或DATETIME列保存日/月和日是零的日期。这在应用程序需要保存一个你不知道确切日期的生日时非常有用。在这种情况下，只需要将日期保存为’1999-00-00′或’1999-01-00′。如果保存此类日期，DATE_SUB()或DATE_ADD等需要完整日期的函数不会得到正确的结果。(如果你不想在日期中出现零，可以使用NO_ZERO_IN_DATE SQL模式)。&lt;/p&gt;
&lt;p&gt;MySQL还允许将’0000-00-00′保存为“伪日期”(如果不使用NO_ZERO_DATE SQL模式)。这在某些情况下比使用NULL值更方便(并且数据和索引占用的空间更小)。&lt;/p&gt;
&lt;p&gt;将sql_mode系统变量设置为相应模式值，可以更确切你想让MySQL支持哪种日期。参见&lt;a title=&quot;5.3.2. The Server SQL Mode&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode&quot;&gt;5.3.2节，“SQL服务器模式”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当使用日期和时间类型时应记住以下几点：&lt;/p&gt;
&lt;p&gt;·         MySQL以标准输出格式检索给定日期或时间类型的值，但它尽力解释你指定的各种输入值格式(例如，当你指定一个分配给或与日期或时间类型进行比较的值时)。只支持下面章节中描述的格式。期望你能提供有效值。如果你使用其它格式的值会发生意想不到的结果。&lt;/p&gt;
&lt;p&gt;·         包含两位年值的日期会令人模糊，因为世纪不知道。MySQL使用以下规则解释两位年值：&lt;/p&gt;
&lt;p&gt;o        70-99范围的年值转换为1970-1999。&lt;/p&gt;
&lt;p&gt;o        00-69范围的年值转换为2000-2069。&lt;/p&gt;
&lt;p&gt;·         尽管MySQL尝试解释几种格式的值，日期总是以年-月-日顺序(例如，’98-09-04′)，而不是其它地方常用的月-日-年或日-月-年顺序(例如，’09-04-98′，’04-09-98′)。&lt;/p&gt;
&lt;p&gt;·         如果值用于数值上下文中，MySQL自动将日期或时间类型的值转换为数字，反之亦然。&lt;/p&gt;
&lt;p&gt;·         当 MySQL遇到一个日期或时间类型的超出范围或对于该类型不合法的值时(如本节开始所描述)，它将该值转换为该类的“零”值。一个例外是超出范围的TIME值被裁剪到TIME范围的相应端点。&lt;/p&gt;
&lt;p&gt;下面的表显示了各类“零”值的格式。请注意如果启用NO_ZERO_DATE SQL模式，使用这些值会产生警告。&lt;/p&gt;
&lt;table id=&quot;table2&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;列类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;
&lt;strong&gt;“&lt;/strong&gt;&lt;strong&gt;零&lt;/strong&gt;&lt;strong&gt;”值&lt;/strong&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DATETIME&lt;/td&gt;
&lt;td&gt;’0000-00-00 00:00:00′&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DATE&lt;/td&gt;
&lt;td&gt;’0000-00-00′&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIMESTAMP&lt;/td&gt;
&lt;td&gt;00000000000000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;’00:00:00′&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;·         “零”值是特殊值，但你可以使用表内显示的值显式保存或引用它们。你也可以使用值’0′或0来保存或引用，写起来更容易。&lt;/p&gt;
&lt;p&gt;·         MyODBC中使用的“零”日期或时间值在MyODBC 2.50.12和以上版本中被自动转换为NULL，因为ODBC不能处理此类值。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;datetime&quot;&gt;&lt;/a&gt;11.3.1. DATETIME、DATE和TIMESTAMP类型&lt;/h3&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#timestamp-4-1&quot;&gt;11.3.1.1. 自MySQL 4.1以来的TIMESTAMP属性&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;p&gt;&lt;a name=&quot;id2849637&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2849646&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2849655&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2849664&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2849677&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2849689&quot;&gt;&lt;/a&gt;DATETIME、DATE和TIMESTAMP类型是相关的。该节描述了它们的特征，它们的相似点和不同点。&lt;/p&gt;
&lt;p&gt;当你需要同时包含日期和时间信息的值时则使用DATETIME类型。MySQL以’YYYY-MM-DD HH:MM:SS’格式检索和显示DATETIME值。支持的范围为’1000-01-01 00:00:00′到’9999-12-31 23:59:59′。(“支持”表示尽管先前的值可能工作，但没有保证)。&lt;/p&gt;
&lt;p&gt;当你只需要日期值而不需要时间部分时应使用DATE类型。MySQL用’YYYY-MM-DD’格式检索和显示DATE值。支持的范围是’1000-01-01′到 ’9999-12-31′。&lt;/p&gt;
&lt;p&gt;TIMESTAMP列类型的属性不固定，取决于MySQL版本和服务器运行的SQL模式。这些属性将在本节后面描述。&lt;/p&gt;
&lt;p&gt;可以使用任何常见格式指定DATETIME、DATE和TIMESTAMP值：&lt;/p&gt;
&lt;p&gt;·         ’YYYY-MM-DD HH:MM:SS’或’YY-MM-DD HH:MM:SS’格式的字符串。允许“不严格”语法：任何标点符都可以用做日期部分或时间部分之间的间割符。例如，’98-12-31 11:30:45′、’98.12.31 11+30+45′、’98/12/31 11*30*45′和’98@12@31 11^30^45′是等价的。&lt;/p&gt;
&lt;p&gt;·         ’YYYY-MM-DD’或’YY-MM-DD’格式的字符串。这里也允许使用“不严格的”语法。例如，’98-12-31′、’98.12.31′、’98/12/31′和’98@12@31′是等价的。&lt;/p&gt;
&lt;p&gt;·         ’YYYYMMDDHHMMSS’或’YYMMDDHHMMSS’格式的没有间割符的字符串，假定字符串对于日期类型是有意义的。例如，’19970523091528′和’970523091528′被解释为’1997-05-23 09:15:28′，但’971122129015′是不合法的(它有一个没有意义的分钟部分)，将变为’0000-00-00 00:00:00′。&lt;/p&gt;
&lt;p&gt;·         ’YYYYMMDD’或’YYMMDD’格式的没有间割符的字符串，假定字符串对于日期类型是有意义的。例如，’19970523′和’970523′被解释为 ’1997-05-23′，但’971332′是不合法的(它有一个没有意义的月和日部分)，将变为’0000-00-00′。&lt;/p&gt;
&lt;p&gt;·         YYYYMMDDHHMMSS或YYMMDDHHMMSS格式的数字，假定数字对于日期类型是有意义的。例如，19830905132800和830905132800被解释为 ’1983-09-05 13:28:00′。&lt;/p&gt;
&lt;p&gt;·         YYYYMMDD或YYMMDD格式的数字，假定数字对于日期类型是有意义的。例如，19830905和830905被解释为’1983-09-05′。&lt;/p&gt;
&lt;p&gt;·         函数返回的结果，其值适合DATETIME、DATE或者TIMESTAMP上下文，例如NOW()或CURRENT_DATE。&lt;/p&gt;
&lt;p&gt;无效DATETIME、DATE或者TIMESTAMP值被转换为相应类型的“零”值(’0000-00-00 00:00:00′、’0000-00-00′或者00000000000000)。&lt;/p&gt;
&lt;p&gt;对于包括日期部分间割符的字符串值，如果日和月的值小于10，不需要指定两位数。’1979-6-9′与’1979-06-09′是相同的。同样，对于包括时间部分间割符的字符串值，如果时、分和秒的值小于10，不需要指定两位数。’1979-10-30 1:2:3′与’1979-10-30 01:02:03′相同。&lt;/p&gt;
&lt;p&gt;数字值应为6、8、12或者14位长。如果一个数值是8或14位长，则假定为YYYYMMDD或YYYYMMDDHHMMSS格式，前4位数表示年。如果数字 是6或12位长，则假定为YYMMDD或YYMMDDHHMMSS格式，前2位数表示年。其它数字被解释为仿佛用零填充到了最近的长度。&lt;/p&gt;
&lt;p&gt;指定为非限定符字符串的值使用给定的长度进行解释。如果字符串为8或14字符长，前4位数表示年。否则，前2位数表示年。从左向右解释字符串内出现的各部分，以发现年、月、日、小时、分和秒值。这说明不应使用少于6字符的字符串。例如，如果你指定’9903′，认为它表示1999年3月，MySQL将在你的表内插入一个“零”日期值。这是因为年和月值是99和03，但日部分完全丢失，因此该值不是一个合法的日期。但是，可以明显指定一个零值来代表缺少的月或日部分。例如，可以使用’990300′来插入值’1999-03-00′。&lt;/p&gt;
&lt;p&gt;在一定程度上，可以将一个日期类型的值分配给一个不同的日期类型。但是，值可能会更改或丢失一些信息：&lt;/p&gt;
&lt;p&gt;·         如果你为一个DATETIME或TIMESTAMP对象分配一个DATE值，结果值的时间部分被设置为’00:00:00′，因为DATE值未包含时间信息。&lt;/p&gt;
&lt;p&gt;·         如果你为一个DATE对象分配一个DATETIME或TIMESTAMP值，结果值的时间部分被删除，因为DATE值未包含时间信息。&lt;/p&gt;
&lt;p&gt;·         记住尽管可以使用相同的格式指定DATETIME、DATE和TIMESTAMP值，不同类型的值的范围却不同。例如，TIMESTAMP值不能早于1970或晚于2037。这说明一个日期，例如’1968-01-01′，虽然对于DATETIME或DATE值是有效的，但对于TIMESTAMP值却无效，如果分配给这样一个对象将被转换为0。&lt;/p&gt;
&lt;p&gt;当指定日期值时请注意某些缺陷：&lt;/p&gt;
&lt;p&gt;·         指定为字符串的值允许的非严格格式可能会欺骗。例如，值’10:11:12′由于‘:’间割符看上去可能象时间值，但如果用于日期上下文值则被解释为年’2010-11-12′。值’10:45:15′被转换为’0000-00-00′因为’45′不是合法月。&lt;/p&gt;
&lt;p&gt;·         在非严格模式，MySQL服务器只对日期的合法性进行基本检查：年、月和日的范围分别是1000到9999、00到12和00到31。任何包含超出这些范围的部分的日期被转换成’0000-00-00′。请注意仍然允许你保存非法日期，例如’2002-04-31′。要想确保不使用严格模式时日期有效，应检查应用程序。&lt;/p&gt;
&lt;p&gt;在严格模式，非法日期不被接受，并且不转换。&lt;/p&gt;
&lt;p&gt;详细信息参见&lt;a title=&quot;5.3.2. The Server SQL Mode&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode&quot;&gt;5.3.2节，“SQL服务器模式”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;·         包含两位年值的日期会令人模糊，因为世纪不知道。MySQL使用以下规则解释两位年值：&lt;/p&gt;
&lt;p&gt;o        00-69范围的年值转换为2000-2069。&lt;/p&gt;
&lt;p&gt;o        70-99范围的年值转换为1970-1999。&lt;/p&gt;
&lt;h4&gt;
&lt;a name=&quot;timestamp-4-1&quot;&gt;&lt;/a&gt;11.3.1.1. 自MySQL 4.1以来的TIMESTAMP属性&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;注释：在&lt;/strong&gt;旧版本的MySQL中(4.1之前)，TIMESTAMP列类型的属性在许多方面于本节所描述的大大不同。如果你需要对旧的TIMESTAMP数据进行转化以便在MySQL 5.1中工作，详情请参见&lt;em&gt;MySQL 4.1 参考手册&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;TIMESTAMP列的显示格式与DATETIME列相同。换句话说，显示宽度固定在19字符，并且格式为YYYY-MM-DD HH:MM:SS。&lt;/p&gt;
&lt;p&gt;MySQL服务器也可以以MAXDB模式运行。当服务器以该模式运行时，TIMESTAMP与DATETIME相等。也就是说，如果创建表时服务器以MAXDB模式运行，TIMESTAMP列创建为DATETIME列。结果是，该列使用DATETIME显示格式，有相同的值范围，并且没有自动对当前的日期和时间进行初始化或更新。&lt;/p&gt;
&lt;p&gt;要想启用MAXDB模式，在启动服务器时使用–sql-mode=MAXDB服务器选项或在运行时通过设置全局sql_mode变量将SQL服务器模式设置为MAXDB：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SET GLOBAL sql_mode=MAXDB；&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;客户端可以按照下面方法让服务器为它的连接以MAXDB模式运行：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SET SESSION sql_mode=MAXDB;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;MySQL不接受在日或月列包括一个零或包含非法日期值的时间戳值。该规则的唯一例外是特殊值’0000-00-00 00:00:00′。&lt;/p&gt;
&lt;p&gt;你可以非常灵便地确定什么时候初始化和更新TIMESTAMP和对哪些列进行初始化和更新：&lt;/p&gt;
&lt;p&gt;·         你可以将当前的时间戳指定为默认值和自动更新的值。但只能选择一个，或者两者都不选。(不可能一个列选择一个行为而另一个列选择另一个行为）。&lt;/p&gt;
&lt;p&gt;·         你可以指定哪个TIMESTAMP列自动初始化或更新为当前的日期和时间。不再需要为第1个TIMESTAMP列。&lt;/p&gt;
&lt;p&gt;请注意下面讨论所信息只适用于创建时未启用MAXDB模式的表的TIMESTAMP列。(如上所述，MAXDB模式使列创建为DATETIME列）。控制TIMESTAMP列的初始化和更新的规则如下所示：&lt;/p&gt;
&lt;p&gt;·         如果一个表内的第1个TIMESTAMP列指定为一个DEFAULT值，则不能忽略。 默认值可以为CURRENT_TIMESTAMP或常量日期和时间值。&lt;/p&gt;
&lt;p&gt;·         DEFAULT NULL与第1个&lt;em&gt;TIMESTAMP&lt;/em&gt; 列的DEFAULT CURRENT_TIMESTAMP相同。对于其它TIMESTAMP列，DEFAULT NULL被视为DEFAULT 0。&lt;/p&gt;
&lt;p&gt;·         表内的任何一个TIMESTAMP列可以设置为自动初始化为当前时间戳和/或更新。&lt;/p&gt;
&lt;p&gt;·         在CREATE TABLE语句中，可以用下面的任何一种方式声明第1个TIMESTAMP列：&lt;/p&gt;
&lt;p&gt;o        用DEFAULT CURRENT_TIMESTAMP和ON UPDATE CURRENT_TIMESTAMP子句，列为默认值使用当前的时间戳，并且自动更新。&lt;/p&gt;
&lt;p&gt;o        不使用DEFAULT或ON UPDATE子句，与DEFAULT CURRENT_TIMESTAMP ON UPDATECURRENT_TIMESTAMP相同。&lt;/p&gt;
&lt;p&gt;o        用DEFAULT CURRENT_TIMESTAMP子句不用ON UPDATE子句，列为默认值使用当前的时间戳但是不自动更新。&lt;/p&gt;
&lt;p&gt;o        不用DEFAULT子句但用ON UPDATE CURRENT_TIMESTAMP子句，列有默认值0并自动更新。&lt;/p&gt;
&lt;p&gt;o        用常量DEFAULT值，列有给出的 默认值。如果列有一个ON UPDATE CURRENT_TIMESTAMP子句，它自动更新，否则不。&lt;/p&gt;
&lt;p&gt;换句话说，你可以为初始值和自动更新的值使用当前的时间戳，或者其中一个使用，或者两个皆不使用。(例如，你可以指定ON UPDATE来启用自动更新而不让列自动初始化）。&lt;/p&gt;
&lt;p&gt;·         在DEFAULT和ON UPDATE子句中可以使用CURRENT_TIMESTAMP、CURRENT_TIMESTAMP()或者NOW()。它们均具有相同的效果。&lt;/p&gt;
&lt;p&gt;两个属性的顺序并不重要。如果一个TIMESTAMP列同时指定了DEFAULT和ON UPDATE，任何一个可以在另一个的前面。&lt;/p&gt;
&lt;p&gt;例子，下面这些语句是等效的：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t (ts TIMESTAMP);
CREATE TABLE t (ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t (ts TIMESTAMP ON UPDATE CURRENT_TIMESTAMP DEFAULT CURRENT_TIMESTAMP);&lt;/pre&gt;
&lt;p&gt;·         要为TIMESTAMP列而不是第1列指定自动默认或更新，必须通过将第1个TIMESTAMP列显式分配一个常量DEFAULT值来禁用自动初始化和更新。(例如，DEFAULT 0或DEFAULT’2003-01-01 00:00:00′)。然后，对于其它TIMESTAMP列，规则与第1个TIMESTAMP列相同，例外情况是不能忽略DEFAULT和ON UPDATE子句。如果这样做，则不会自动进行初始化或更新。&lt;/p&gt;
&lt;p&gt;例如：下面这些语句是等效的：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t (
    ts1 TIMESTAMP DEFAULT 0,
    ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                  ON UPDATE CURRENT_TIMESTAMP);&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t (
    ts1 TIMESTAMP DEFAULT 0,
    ts2 TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                  DEFAULT CURRENT_TIMESTAMP);&lt;/pre&gt;
&lt;p&gt;可以对每个连接设置当前的时区，相关描述参见&lt;a title=&quot;5.10.8. MySQL Server Time Zone Support&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#time-zone-support&quot;&gt;5.10.8节，“MySQL服务器时区支持”&lt;/a&gt;。TIMESTAMP值以UTC格式保存，存储时对当前的时区进行转换，检索时再转换回当前的时区。只要时区设定值为常量，便可以得到保存时的值。如果保存一个TIMESTAMP值，应更改时区然后检索该值，它与你保存的值不同。这是因为在两个方向的转换中没有使用相同的时区。当前的时区可以用作time_zone系统变量的值。&lt;/p&gt;
&lt;p&gt;可以在TIMESTAMP列的定义中包括NULL属性以允许列包含NULL值。例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t
(
  ts1 TIMESTAMP NULL DEFAULT NULL,
  ts2 TIMESTAMP NULL DEFAULT 0,
  ts3 TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP
);&lt;/pre&gt;
&lt;p&gt;如果未指定NULL属性，将列设置为NULL设置则会将它设置为当前的时间戳。请注意允许NULL值的TIMESTAMP列不会采用当前的时间戳，除非要么其 默认值定义为CURRENT_TIMESTAMP，或者NOW()或CURRENT_TIMESTAMP被插入到该列内。换句话说，只有使用如下定义创建，定义为 NULL的TIMESTAMP列才会自动更新：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t (ts NULLDEFAULT CURRENT_TIMESTAMP)；&lt;/pre&gt;
&lt;p&gt;否则-也就是说，如果使用NULL而不是DEFAULT TIMESTAMP来定义TIMESTAMP列，如下所示…&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE t1 (ts NULL DEFAULT NULL);
CREATE TABLE t2 (ts NULL DEFAULT &#39;0000-00-00 00:00:00&#39;);&lt;/pre&gt;
&lt;p&gt;…则必须显式插入一个对应当前日期和时间的值。例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;INSERT INTO t1 VALUES (NOW());
INSERT INTO t2 VALUES (CURRENT_TIMESTAMP);&lt;/pre&gt;
&lt;h3&gt;
&lt;a name=&quot;time&quot;&gt;&lt;/a&gt;11.3.2. TIME类型&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2851158&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2851167&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MySQL以’HH:MM:SS’格式检索和显示TIME值(或对于大的小时值采用’HHH:MM:SS’格式)。TIME值的范围可以从’-838:59:59′到’838:59:59′。小时部分会因此大的原因是TIME类型不仅可以用于表示一天的时间(必须小于24小时)，还可能为某个事件过去的时间或两个事件之间的时间间隔(可以大于24小时，或者甚至为负)。&lt;/p&gt;
&lt;p&gt;你可以用各种格式指定TIME值：&lt;/p&gt;
&lt;p&gt;·         ’D HH:MM:SS.fraction’格式的字符串。还可以使用下面任何一种“非严格”语法：’HH:MM:SS.fraction’、’HH:MM:SS’、’HH:MM’、’D HH:MM:SS’、’D HH:MM’、’D HH’或’SS’。这里D表示日，可以取0到34之间的值。请注意MySQL还不保存分数。&lt;/p&gt;
&lt;p&gt;·         ’HHMMSS’格式的没有间割符的字符串，假定是有意义的时间。例如，’101112′被理解为’10:11:12′，但’109712′是不合法的(它有一个没有意义的分钟部分)，将变为’00:00:00′。&lt;/p&gt;
&lt;p&gt;·         HHMMSS格式的数值，假定是有意义的时间。例如，101112被理解为’10:11:12′。下面格式也可以理解：SS、MMSS、HHMMSS、HHMMSS.fraction。请注意MySQL还不保存分数。&lt;/p&gt;
&lt;p&gt;·         函数返回的结果，其值适合TIME上下文，例如CURRENT_TIME。&lt;/p&gt;
&lt;p&gt;对于指定为包括时间部分间割符的字符串的TIME值，如果时、分或者秒值小于10，则不需要指定两位数。’8:3:2′与’08:03:02′相同。&lt;/p&gt;
&lt;p&gt;为TIME列分配简写值时应注意。没有冒号，MySQL解释值时假定最右边的两位表示秒。(MySQL解释TIME值为过去的时间而不是当天的时间）。例如，你可能认为’1112′和1112表示’11:12:00′(11点过12分)，但MySQL将它们解释为’00:11:12′(11分，12 秒)。同样，’12′和12 被解释为 ’00:00:12′。相反，TIME值中使用冒号则肯定被看作当天的时间。也就是说，’11:12′表示’11:12:00′，而不是’00:11:12′。&lt;/p&gt;
&lt;p&gt;超出TIME范围但合法的值被裁为范围最接近的端点。例如，’-850:00:00′和’850:00:00′被转换为’-838:59:59′和’838:59:59′。&lt;/p&gt;
&lt;p&gt;无效TIME值被转换为’00:00:00′。请注意由于’00:00:00′本身是一个合法TIME值，只从表内保存的一个’00:00:00′值还不能说出原来的值是 ’00:00:00′还是不合法的值。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;year&quot;&gt;&lt;/a&gt;11.3.3. YEAR类型&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2851517&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2851526&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;YEAR类型是一个单字节类型用于表示年。&lt;/p&gt;
&lt;p&gt;MySQL以YYYY格式检索和显示YEAR值。范围是1901到2155。&lt;/p&gt;
&lt;p&gt;可以指定各种格式的YEAR值：&lt;/p&gt;
&lt;p&gt;·         四位字符串，范围为’1901′到’2155′。&lt;/p&gt;
&lt;p&gt;·         四位数字，范围为1901到2155。&lt;/p&gt;
&lt;p&gt;·         两位字符串，范围为’00′到’99′。’00′到’69′和’70′到’99′范围的值被转换为2000到2069和1970到1999范围的YEAR值。&lt;/p&gt;
&lt;p&gt;·         两位整数，范围为1到99。1到69和70到99范围的值被转换为2001到2069和1970到1999范围的YEAR值。请注意两位整数范围与两位字符串范围稍有不同，因为你不能直接将零指定为数字并将它解释为2000。你必须将它指定为一个字符串’0′或’00′或它被解释为0000。&lt;/p&gt;
&lt;p&gt;·         函数返回的结果，其值适合YEAR上下文，例如NOW()。&lt;/p&gt;
&lt;p&gt;非法YEAR值被转换为0000。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;y2k-issues&quot;&gt;&lt;/a&gt;11.3.4. Y2K事宜和日期类型&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2851772&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2851779&quot;&gt;&lt;/a&gt;MySQL本身对于2000年(Y2K)是安全的(参见&lt;a title=&quot;1.4.5. Year 2000 Compliance&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/introduction.html#year-2000-compliance&quot;&gt;1.4.5节，“2000年兼容性”&lt;/a&gt;)，但输入给MySQL的值可能不安全。任何包含两位年值的输入都会令人模糊，因为世纪不知道。这些值必须解释为四位形式，因为MySQL内部使用四位来保存年。&lt;/p&gt;
&lt;p&gt;对于DATETIME、DATE、TIMESTAMP和YEAR类型，MySQL使用以下规则解释含模糊年值的日期：&lt;/p&gt;
&lt;p&gt;·         00-69范围的年值转换为2000-2069。&lt;/p&gt;
&lt;p&gt;·         70-99范围的年值转换为1970-1999。&lt;/p&gt;
&lt;p&gt;请记住这些规则只是合理猜测数据值表示什么。如果MySQL使用的启发不能产生正确的值，你应提供包含四位年值的确切输入。&lt;/p&gt;
&lt;p&gt;ORDER BY可以正确排序有两位年的TIMESTAMP或YEAR值。&lt;/p&gt;
&lt;p&gt;部分函数如MIN()和MAX()将TIMESTAMP或YEAR转换为一个数字。这说明使用有两位年值的值，这些函数不能工作正确。在这种情况下的修复方法是将TIMESTAMP或YEAR转换为四位年格式或使用MIN(DATE_ADD(TIMESTAMP,INTERVAL 0 DAYS))。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;string-types&quot;&gt;&lt;/a&gt;11.4. String类型&lt;/h2&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#char&quot;&gt;11.4.1. CHAR和VARCHAR类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#binary-varbinary&quot;&gt;11.4.2. BINARY和VARBINARY类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#blob&quot;&gt;11.4.3. BLOB和TEXT类型&lt;code&gt;&lt;/code&gt;&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#enum&quot;&gt;11.4.4. ENUM类型&lt;/a&gt;&lt;/dt&gt;
&lt;dt&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#set&quot;&gt;11.4.5. SET类型&lt;/a&gt;&lt;/dt&gt;
&lt;/dl&gt;
&lt;p&gt;字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;char&quot;&gt;&lt;/a&gt;11.4.1. CHAR和VARCHAR类型&lt;/h3&gt;
&lt;p&gt;CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。&lt;/p&gt;
&lt;p&gt;CHAR和VARCHAR类型声明的长度表示你想要保存的最大字符数。例如，CHAR(30)可以占用30个字符。&lt;/p&gt;
&lt;p&gt;CHAR列的长度固定为创建表时声明的长度。长度可以为从0到255的任何值。当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。&lt;/p&gt;
&lt;p&gt;VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值。(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。&lt;/p&gt;
&lt;p&gt;同CHAR对比，VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。&lt;/p&gt;
&lt;p&gt;VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。&lt;/p&gt;
&lt;p&gt;如果分配给CHAR或VARCHAR列的值超过列的最大长度，则对值进行裁剪以使其适合。如果被裁掉的字符不是空格，则会产生一条警告。如果裁剪非空格字符，则会造成错误(而不是警告)并通过使用严格SQL模式禁用值的插入。参见&lt;a title=&quot;5.3.2. The Server SQL Mode&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode&quot;&gt;5.3.2节，“SQL服务器模式”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面的表显示了将各种字符串值保存到CHAR(4)和VARCHAR(4)列后的结果，说明了CHAR和VARCHAR之间的差别：&lt;/p&gt;
&lt;table id=&quot;table3&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CHAR(4)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;存储需求&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;VARCHAR(4)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;存储需求&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;”&lt;/td&gt;
&lt;td&gt;‘    ’&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;td&gt;”&lt;/td&gt;
&lt;td&gt;1个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘ab’&lt;/td&gt;
&lt;td&gt;‘ab  ’&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;td&gt;‘ab ‘&lt;/td&gt;
&lt;td&gt;3个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘abcd’&lt;/td&gt;
&lt;td&gt;‘abcd’&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;td&gt;‘abcd’&lt;/td&gt;
&lt;td&gt;5个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘abcdefgh’&lt;/td&gt;
&lt;td&gt;‘abcd’&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;td&gt;‘abcd’&lt;/td&gt;
&lt;td&gt;5个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;请注意上表中最后一行的值只适用&lt;em&gt;不使用严格模式&lt;/em&gt;时；如果MySQL运行在严格模式，超过列长度不的值&lt;em&gt;不&lt;em&gt;保存&lt;/em&gt;&lt;/em&gt;，并且会出现错误。&lt;/p&gt;
&lt;p&gt;从CHAR(4)和VARCHAR(4)列检索的值并不总是相同，因为检索时从CHAR列删除了尾部的空格。通过下面的例子说明该差别：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;CREATE TABLE vc (v VARCHAR(4), c CHAR(4));
&amp;lt;/strong&amp;gt;Query OK, 0 rows affected (0.02 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;INSERT INTO vc VALUES (&#39;ab  &#39;, &#39;ab  &#39;);
&amp;lt;/strong&amp;gt;Query OK, 1 row affected (0.00 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT CONCAT(v, &#39;+&#39;), CONCAT(c, &#39;+&#39;) FROM vc;
&amp;lt;/strong&amp;gt;+----------------+----------------+
| CONCAT(v, &#39;+&#39;) | CONCAT(c, &#39;+&#39;) |
+----------------+----------------+
| ab  +          | ab+            |
+----------------+----------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;根据分配给列的字符集校对规则对CHAR和VARCHAR列中的值进行排序和比较。&lt;/p&gt;
&lt;p&gt;请注意所有MySQL校对规则属于PADSPACE类。这说明在MySQL中的所有CHAR和VARCHAR值比较时不需要考虑任何尾部空格。例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;CREATE TABLE names (myname CHAR(10), yourname VARCHAR(10));
&amp;lt;/strong&amp;gt;Query OK, 0 rows affected (0.09 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;INSERT INTO names VALUES (&#39;Monty &#39;, &#39;Monty &#39;);
&amp;lt;/strong&amp;gt;Query OK, 1 row affected (0.00 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT myname = &#39;Monty  &#39;, yourname = &#39;Monty  &#39; FROM names;
&amp;lt;/strong&amp;gt;+--------------------+----------------------+
| myname = &#39;Monty  &#39; | yourname = &#39;Monty  &#39; |
+--------------------+----------------------+
|                  1 |                    1 |
+--------------------+----------------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;请注意所有MySQL版本均如此，并且它不受SQL服务器模式的影响。&lt;/p&gt;
&lt;p&gt;对于尾部填充字符被裁剪掉或比较时将它们忽视掉的情形，如果列的索引需要唯一的值，在列内插入一个只是填充字符数不同的值将会造成复制键值错误。&lt;/p&gt;
&lt;p&gt;CHAR BYTE是CHAR BINARY的别名。这是为了保证兼容性。&lt;/p&gt;
&lt;p&gt;ASCII属性为CHAR列分配latin1字符集。UNICODE属性分配ucs2字符集。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;binary-varbinary&quot;&gt;&lt;/a&gt;11.4.2. BINARY和VARBINARY类型&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2852527&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852536&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852545&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852558&quot;&gt;&lt;/a&gt;BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。&lt;/p&gt;
&lt;p&gt;BINARY和VARBINARY允许的最大长度一样，如同CHAR和VARCHAR，不同的是BINARY和VARBINARY的长度是字节长度而不是字符长度。&lt;/p&gt;
&lt;p&gt;BINARY和VARBINARY数据类型不同于CHAR BINARY和VARCHAR BINARY数据类型。对于后一种类型，BINARY属性不会将列视为二进制字符串列。相反，它致使使用列字符集的二元 校对规则，并且列自身包含非二进制字符字符串而不是二进制字节字符串。例如CHAR(5) BINARY被视为CHAR(5) CHARACTER SET latin1 COLLATE latin1_bin，假定默认字符集是latin1。这不同于BINARY(5)，它保存5字节二进制字符串，没有字符集或 校对规则。&lt;/p&gt;
&lt;p&gt;当保存BINARY值时，在它们右边填充值以达到指定长度。填充值是0×00(零字节)。插入值时在右侧添加0×00 on，并且选择时不删除尾部的字节。比较时所有字节很重要，包括ORDER BY和DISTINCT操作。比较时0×00字节和空格是不同的，0×00&amp;lt;空格。&lt;/p&gt;
&lt;p&gt;例如：对于一个BINARY(3)列，当插入时 ’a&#39; 变为 ’a ’。’a&#39;插入时变为’a&#39;。当选择时两个插入的值均不更改。&lt;/p&gt;
&lt;p&gt;对于VARBINARY，插入时不填充字符，选择时不裁剪字节。比较时所有字节很重要，包括ORDER BY和DISTINCT操作。比较时0×00字节和空格是不同的，0×00&amp;lt;空格。&lt;/p&gt;
&lt;p&gt;对于尾部填充字符被裁剪掉或比较时将它们忽视掉的情形，如果列的索引需要唯一的值，在列内插入一个只是填充字符数不同的值将会造成复制键值错误。&lt;/p&gt;
&lt;p&gt;如果你计划使用这些数据类型来保存二进制数据并且需要检索的值与保存的值完全相同，应考虑前面所述的填充和裁剪特征。下面的例子说明了用0×00填充的BINARY值如何影响列值比较：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;CREATE TABLE t (c BINARY(3));
&amp;lt;/strong&amp;gt;Query OK, 0 rows affected (0.01 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;INSERT INTO t SET c = &#39;a&#39;;
&amp;lt;/strong&amp;gt;Query OK, 1 row affected (0.01 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT HEX(c), c = &#39;a&#39;, c = &#39;a&#39; from t;
&amp;lt;/strong&amp;gt;+--------+---------+-------------+
| HEX(c) | c = &#39;a&#39; | c = &#39;a&#39; |
+--------+---------+-------------+
| 610000 |       0 |           1 |
+--------+---------+-------------+
1 row in set (0.09 sec)&lt;/pre&gt;
&lt;p&gt;如果检索的值必须与指定进行存储而没有填充的值相同，最好使用BLOB数据类型。&lt;/p&gt;
&lt;p&gt;创建表时，MySQL可以默默更改BINARY或VARBINARY列的类型。参见&lt;a title=&quot;13.1.5.1. Silent Column Specification Changes&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/sql-syntax.html#silent-column-changes&quot;&gt;13.1.5.1节，“沉寂的列规格变更”&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;blob&quot;&gt;&lt;/a&gt;11.4.3. BLOB和TEXT类型&lt;code&gt;&lt;/code&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2852869&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852878&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852887&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852900&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852912&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2852921&quot;&gt;&lt;/a&gt;BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同。&lt;/p&gt;
&lt;p&gt;有4种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些对应4种BLOB类型，有相同的最大长度和存储需求。&lt;/p&gt;
&lt;p&gt;参见&lt;a title=&quot;11.5. Column Type Storage Requirements&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements&quot;&gt;11.5节，“列类型存储需求”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;BLOB 列被视为二进制字符串(字节字符串)。TEXT列被视为非二进制字符串(字符字符串)。BLOB列没有字符集，并且排序和比较基于列值字节的数值值。TEXT列有一个字符集，并且根据字符集的 校对规则对值进行排序和比较。&lt;/p&gt;
&lt;p&gt;在TEXT或BLOB列的存储或检索过程中，不存在大小写转换。&lt;/p&gt;
&lt;p&gt;当未运行在严格模式时，如果你为BLOB或TEXT列分配一个超过该列类型的最大长度的值值，值被截取以保证适合。如果截掉的字符不是空格，将会产生一条警告。使用严格SQL模式，会产生错误，并且值将被拒绝而不是截取并给出警告。参见&lt;a title=&quot;5.3.2. The Server SQL Mode&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode&quot;&gt;5.3.2节，“SQL服务器模式”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在大多数方面，可以将BLOB列视为能够足够大的VARBINARY列。同样，可以将TEXT列视为VARCHAR列。BLOB和TEXT在以下几个方面不同于VARBINARY和VARCHAR：&lt;/p&gt;
&lt;p&gt;·         当保存或检索BLOB和TEXT列的值时不删除尾部空格。(这与VARBINARY和VARCHAR列相同）。&lt;/p&gt;
&lt;p&gt;请注意比较时将用空格对TEXT进行扩充以适合比较的对象，正如CHAR和VARCHAR。&lt;/p&gt;
&lt;p&gt;·         对于BLOB和TEXT列的索引，必须指定索引前缀的长度。对于CHAR和VARCHAR，前缀长度是可选的。参见&lt;a title=&quot;7.4.3. Column Indexes&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/optimization.html#indexes&quot;&gt;7.4.3节，“列索引”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;·         BLOB和TEXT列不能有 默认值。&lt;/p&gt;
&lt;p&gt;LONG和LONG VARCHAR对应MEDIUMTEXT数据类型。这是为了保证兼容性。如果TEXT列类型使用BINARY属性，将为列分配列字符集的二元 校对规则。&lt;/p&gt;
&lt;p&gt;MySQL连接程序/ODBC将BLOB值定义为LONGVARBINARY，将TEXT值定义为LONGVARCHAR。&lt;/p&gt;
&lt;p&gt;由于BLOB和TEXT值可能会非常长，使用它们时可能遇到一些约束：&lt;/p&gt;
&lt;p&gt;·         当排序时只使用该列的前max_sort_length个字节。max_sort_length的 默认值是1024；该值可以在启动&lt;strong&gt;mysqld&lt;/strong&gt;服务器时使用–max_sort_length选项进行更改。参见&lt;a title=&quot;5.3.3. Server System Variables&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-system-variables&quot;&gt;5.3.3节，“服务器系统变量”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;运行时增加max_sort_length的值可以在排序或组合时使更多的字节有意义。任何客户端可以更改其会话max_sort_length变量的值：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SET max_sort_length = 2000;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT id, comment FROM &amp;lt;em&amp;gt;tbl_name
&amp;lt;/em&amp;gt;&amp;lt;/strong&amp;gt;    -&amp;amp;gt; &amp;lt;strong&amp;gt;ORDER BY comment;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;当你想要使超过max_sort_length的字节有意义，对含长值的BLOB或TEXT列使用GROUP BY或ORDER BY的另一种方式是将列值转换为固定长度的对象。标准方法是使用SUBSTRING函数。例如，下面的语句对comment列的2000个字节进行排序：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT id, SUBSTRING(comment,1,2000) FROM &amp;lt;em&amp;gt;tbl_name
&amp;lt;/em&amp;gt;&amp;lt;/strong&amp;gt;    -&amp;amp;gt; &amp;lt;strong&amp;gt;ORDER BY SUBSTRING(comment,1,2000);&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;·         BLOB或TEXT对象的最大大小由其类型确定，但在客户端和服务器之间实际可以传递的最大值由可用内存数量和通信缓存区大小确定。你可以通过更改max_allowed_packet变量的值更改消息缓存区的大小，但必须同时修改服务器和客户端程序。例如，可以使用 &lt;strong&gt;mysql&lt;/strong&gt;和&lt;strong&gt;mysqldump&lt;/strong&gt;来更改客户端的max_allowed_packet值。参见&lt;a title=&quot;7.5.2. Tuning Server Parameters&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/optimization.html#server-parameters&quot;&gt;7.5.2节，“调节服务器参数”&lt;/a&gt;、&lt;a title=&quot;8.3. mysql — The MySQL Command-Line Tool&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/client-side-scripts.html#mysql&quot;&gt;8.3节，“mysql：MySQL命令行工具”&lt;/a&gt;和&lt;a title=&quot;8.8. mysqldump — A Database Backup Program&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/client-side-scripts.html#mysqldump&quot;&gt;8.8节，“mysqldump：数据库备份程序”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;每个BLOB或TEXT值分别由内部分配的对象表示。这与其它列类型形成对比，后者是当打开表时为每1列分配存储引擎。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;enum&quot;&gt;&lt;/a&gt;11.4.4. ENUM类型&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2853488&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2853497&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ENUM是一个字符串对象，其值来自表创建时在列规定中显式枚举的一列值。&lt;/p&gt;
&lt;p&gt;在某些情况下，ENUM值也可以为空字符串(”)或NULL：&lt;/p&gt;
&lt;p&gt;·         如果你将一个非法值插入ENUM(也就是说，允许的值列之外的字符串)，将插入空字符串以作为特殊错误值。该字符串与“普通”空字符串不同，该字符串有数值值0。后面有详细讨论。&lt;/p&gt;
&lt;p&gt;·         如果将ENUM列声明为允许NULL，NULL值则为该列的一个有效值，并且 默认值为NULL。如果ENUM列被声明为NOT NULL，其默认值为允许的值列的第1个元素。&lt;/p&gt;
&lt;p&gt;每个枚举值有一个索引：&lt;/p&gt;
&lt;p&gt;·         来自列规定的允许的值列中的值从1开始编号。&lt;/p&gt;
&lt;p&gt;·         空字符串错误值的索引值是0。这说明你可以使用下面的SELECT语句来找出分配了非法ENUM值的行：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;·    mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT * FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt; WHERE &amp;lt;em&amp;gt;enum_col&amp;lt;/em&amp;gt;=0;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;·         NULL值的索引是NULL。&lt;/p&gt;
&lt;p&gt;例如，定义为ENUM的列(‘one’，’two’，’three’)可以有下面所示任何值。还显示了每个值的索引：&lt;/p&gt;
&lt;table id=&quot;table4&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;索引&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;”&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘one’&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘two’&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘three’&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;枚举最多可以有65,535个元素。&lt;/p&gt;
&lt;p&gt;当创建表时，ENUM成员值的尾部空格将自动被删除。&lt;/p&gt;
&lt;p&gt;当检索时，保存在ENUM列的值使用列定义中所使用的大小写来显示。请注意可以为ENUM列分配字符集和 校对规则。对于二进制或大小写敏感的校对规则，当为列分配值时应考虑大小写。&lt;/p&gt;
&lt;p&gt;如果在数值上下文中检索一个ENUM值，将返回列值的索引。例如，你可以这样从ENUM列搜索数值值：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT &amp;lt;em&amp;gt;enum_col&amp;lt;/em&amp;gt;+0 FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt;;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;如果将一个数字保存到ENUM列，数字被视为索引，并且保存的值是该索引对应的枚举成员。(但是，这不适合LOAD DATA，它将所有输入视为字符串）。不建议使用类似数字的枚举值来定义一个ENUM列，因为这很容易引起混淆。例如，下面的列含有字符串值’0′、’1′和’2′的枚举成员，但数值索引值为1、2和3：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;numbers ENUM(&#39;0&#39;,&#39;1&#39;,&#39;2&#39;)&lt;/pre&gt;
&lt;p&gt;根据枚举成员在列定义中列出的顺序对ENUM值进行排序。(换句话说，ENUM值根据索引编号进行排序）。例如，对于ENUM(‘a’，’b&#39;)，’a&#39;排在’b&#39;前面，但对于ENUM(‘b’，’a&#39;)，’b&#39;排在’a&#39;前面。空字符串排在非空字符串前面，并且NULL值排在所有其它枚举值前面。要想防止意想不到的结果，按字母顺序规定ENUM列。还可以使用GROUP BY  CAST(col AS CHAR)或GROUP BY  CONCAT(col)来确保按照词汇对列进行排序而不是用索引数字。&lt;/p&gt;
&lt;p&gt;如果你想要确定一个ENUM列的所有可能的值，使用SHOW COLUMNS FROM &lt;em&gt;tbl_name&lt;/em&gt; LIKE &lt;em&gt;enum_col&lt;/em&gt;，并解析输出中第2列的ENUM定义。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;set&quot;&gt;&lt;/a&gt;11.4.5. SET类型&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;id2853953&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2853962&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SET是一个字符串对象，可以有零或多个值，其值来自表创建时规定的允许的一列值。指定包括多个SET成员的SET列值时各成员之间用逗号(‘,’)间隔开。这样SET成员值本身不能包含逗号。&lt;/p&gt;
&lt;p&gt;例如，指定为SET(‘one’, ‘two’) NOT NULL的列可以有下面的任何值：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;&#39;&#39;
&#39;one&#39;
&#39;two&#39;
&#39;one,two&#39;&lt;/pre&gt;
&lt;p&gt;SET最多可以有64个不同的成员。&lt;/p&gt;
&lt;p&gt;当创建表时，SET成员值的尾部空格将自动被删除。&lt;/p&gt;
&lt;p&gt;当检索时，保存在SET列的值使用列定义中所使用的大小写来显示。请注意可以为SET列分配字符集和 校对规则。对于二进制或大小写敏感的校对规则，当为列分配值时应考虑大小写。&lt;/p&gt;
&lt;p&gt;MySQL用数字保存SET值，所保存值的低阶位对应第1个SET成员。如果在数值上下文中检索一个SET值，检索的值的位设置对应组成列值的SET成员。例如，你可以这样从一个SET列检索数值值：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT &amp;lt;em&amp;gt;set_col&amp;lt;/em&amp;gt;+0 FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt;;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;如果将一个数字保存到SET列中，数字中二进制表示中的位确定了列值中的SET成员。对于指定为SET(‘a’,&#39;b’,&#39;c’,&#39;d’)的列，成员有下面的十进制和二进制值：&lt;/p&gt;
&lt;table id=&quot;table5&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SET&lt;strong&gt;成员&lt;/strong&gt;
&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;十进制值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;二进制值&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘a’&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘b’&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘c’&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘d’&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果你为该列分配一个值9，其二进制形式为1001，因此第1个和第4个SET值成员’a&#39;和’d&#39;被选择，结果值为 ’a,d’。&lt;/p&gt;
&lt;p&gt;对于包含多个SET元素的值，当插入值时元素所列的顺序并不重要。在值中一个给定的元素列了多少次也不重要。当以后检索该值时，值中的每个元素出现一次，根据表创建时指定的顺序列出元素。例如，假定某个列指定为SET(‘a’,&#39;b’,&#39;c’,&#39;d’)：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;CREATE TABLE myset (col SET(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;));&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;插入值’a,d’、’d,a’、’a,d,d’、’a,d,a’和’d,a,d’:&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;INSERT INTO myset (col) VALUES 
&amp;lt;/strong&amp;gt;-&amp;amp;gt; (&#39;a,d&#39;), (&#39;d,a&#39;), (&#39;a,d,a&#39;), (&#39;a,d,d&#39;), (&#39;d,a,d&#39;);
Query OK, 5 rows affected (0.01 sec)
Records: 5  Duplicates: 0  Warnings: 0&lt;/pre&gt;
&lt;p&gt;当检索时所有这些值显示为 ’a,d’：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT col FROM myset;
&amp;lt;/strong&amp;gt;+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------
5 rows in set (0.04 sec)&lt;/pre&gt;
&lt;p&gt;如果将SET列设置为一个不支持的值，则该值被忽略并发出警告：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;INSERT INTO myset (col) VALUES (&#39;a,d,d,s&#39;);
&amp;lt;/strong&amp;gt;Query OK, 1 row affected, 1 warning (0.03 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SHOW WARNINGS;
&amp;lt;/strong&amp;gt;+---------+------+------------------------------------------+
| Level   | Code | Message                                  |
+---------+------+------------------------------------------+
| Warning | 1265 | Data truncated for column &#39;col&#39; at row 1 |
+---------+------+------------------------------------------+
1 row in set (0.04 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT col FROM myset;
&amp;lt;/strong&amp;gt;+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
6 rows in set (0.01 sec)&lt;/pre&gt;
&lt;p&gt;SET值按数字顺序排序。NULL值排在非NULL SET值的前面。&lt;/p&gt;
&lt;p&gt;通常情况，可以使用FIND_IN_SET()函数或LIKE操作符搜索SET值：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT * FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt; WHERE FIND_IN_SET(&#39;&amp;lt;em&amp;gt;value&amp;lt;/em&amp;gt;&#39;,&amp;lt;em&amp;gt;set_col&amp;lt;/em&amp;gt;)&amp;amp;gt;0;
&amp;lt;/strong&amp;gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT * FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt; WHERE &amp;lt;em&amp;gt;set_col&amp;lt;/em&amp;gt; LIKE &#39;%&amp;lt;em&amp;gt;value&amp;lt;/em&amp;gt;%&#39;;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;第1个语句找出&lt;em&gt;SET_col&lt;/em&gt;包含&lt;em&gt;value&lt;/em&gt; set成员的行。第2个类似，但有所不同：它在其它地方找出&lt;em&gt;set_col&lt;/em&gt;包含&lt;em&gt;value&lt;/em&gt;的行，甚至是在另一个SET成员的子字符串中。&lt;/p&gt;
&lt;p&gt;下面的语句也是合法的：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT * FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt; WHERE &amp;lt;em&amp;gt;set_col&amp;lt;/em&amp;gt; &amp;amp;amp; 1;
&amp;lt;/strong&amp;gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;SELECT * FROM &amp;lt;em&amp;gt;tbl_name&amp;lt;/em&amp;gt; WHERE &amp;lt;em&amp;gt;set_col&amp;lt;/em&amp;gt; = &#39;&amp;lt;em&amp;gt;val1&amp;lt;/em&amp;gt;,&amp;lt;em&amp;gt;val2&amp;lt;/em&amp;gt;&#39;;&amp;lt;/strong&amp;gt;&lt;/pre&gt;
&lt;p&gt;第1个语句寻找包含第1个set成员的值。第2个语句寻找一个确切匹配的值。应注意第2类的比较。将set值与’&lt;em&gt;val1&lt;/em&gt;,&lt;em&gt;val2&lt;/em&gt;‘比较返回的结果与同’&lt;em&gt;val2&lt;/em&gt;,&lt;em&gt;val1&lt;/em&gt;‘比较返回的结果不同。指定值时的顺序应与在列定义中所列的顺序相同。&lt;/p&gt;
&lt;p&gt;如果想要为SET列确定所有可能的值，使用SHOW COLUMNS FROM &lt;em&gt;tbl_name&lt;/em&gt; LIKE &lt;em&gt;set_col&lt;/em&gt;并解析输出中第2列的SET定义。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;storage-requirements&quot;&gt;&lt;/a&gt;11.5. 列类型存储需求&lt;/h2&gt;
&lt;p&gt;&lt;a name=&quot;id2854549&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2854559&quot;&gt;&lt;/a&gt;根据类别列出了MySQL支持的每个列类型的存储需求。&lt;/p&gt;
&lt;p&gt;MyISAM表中行的最大大小为65,534字节。每个BLOB和TEXT列 账户只占其中的5至9个字节。&lt;/p&gt;
&lt;p&gt;如果MyISAM表包括变长列类型，记录格式也是可变长度。当创建表时，在某些条件下，MySQL可以将一个列从变长类型改为固定长度的类型或反之亦然。详细信息参见&lt;a title=&quot;13.1.5.1. Silent Column Specification Changes&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/sql-syntax.html#silent-column-changes&quot;&gt;13.1.5.1节，“沉寂的列规格变更”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数值类型存储需求&lt;/strong&gt;&lt;/p&gt;
&lt;table id=&quot;table6&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;列类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;存储需求&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TINYINT&lt;/td&gt;
&lt;td&gt;1个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td&gt;2个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;td&gt;3个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT, INTEGER&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BIGINT&lt;/td&gt;
&lt;td&gt;8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLOAT(&lt;em&gt;p&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;如果0 &amp;lt;= &lt;em&gt;p&lt;/em&gt; &amp;lt;= 24为4个字节, 如果25 &amp;lt;= &lt;em&gt;p&lt;/em&gt; &amp;lt;= 53为8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLOAT&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DOUBLE [PRECISION], item REAL&lt;/td&gt;
&lt;td&gt;8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DECIMAL(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;), NUMERIC(&lt;em&gt;M&lt;/em&gt;,&lt;em&gt;D&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;变长；参见下面的讨论&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BIT(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;大约(&lt;em&gt;M&lt;/em&gt;+7)/8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;DECIMAL(和NUMERIC)的存储需求与具体版本有关：&lt;/p&gt;
&lt;p&gt;使用二进制格式将9个十进制(基于10)数压缩为4个字节来表示DECIMAL列值。每个值的整数和分数部分的存储分别确定。每个9位数的倍数需要4个字节，并且“剩余的”位需要4个字节的一部分。下表给出了超出位数的存储需求：&lt;/p&gt;
&lt;table id=&quot;table7&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;剩余的&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;字节&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;位数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;数目&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;日期和时间类型的存储需求&lt;/strong&gt;&lt;/p&gt;
&lt;table id=&quot;table8&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;列类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;存储需求&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DATE&lt;/td&gt;
&lt;td&gt;3个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DATETIME&lt;/td&gt;
&lt;td&gt;8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIMESTAMP&lt;/td&gt;
&lt;td&gt;4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;3个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt;1个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;字符串类型的存储需求&lt;/strong&gt;&lt;/p&gt;
&lt;table id=&quot;table9&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;列类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;存储需求&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CHAR(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;M&lt;/em&gt;个字节，0 &amp;lt;= &lt;em&gt;M&lt;/em&gt; &amp;lt;= 255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VARCHAR(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;L&lt;/em&gt;+1个字节，其中&lt;em&gt;L&lt;/em&gt; &amp;lt;= &lt;em&gt;M &lt;/em&gt;且0 &amp;lt;= &lt;em&gt;M&lt;/em&gt; &amp;lt;= 65535(参见下面的注释)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BINARY(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;M&lt;/em&gt;个字节，0 &amp;lt;= &lt;em&gt;M&lt;/em&gt; &amp;lt;= 255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VARBINARY(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;L&lt;/em&gt;+1个字节，其中&lt;em&gt;L&lt;/em&gt; &amp;lt;= &lt;em&gt;M &lt;/em&gt;且0 &amp;lt;= &lt;em&gt;M&lt;/em&gt; &amp;lt;= 255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TINYBLOB, TINYTEXT&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;L&lt;/em&gt;+1个字节，其中&lt;em&gt;L&lt;/em&gt; &amp;lt; 2&lt;sup&gt;8&lt;/sup&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BLOB, TEXT&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;L&lt;/em&gt;+2个字节，其中&lt;em&gt;L&lt;/em&gt; &amp;lt; 2&lt;sup&gt;16&lt;/sup&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUMBLOB, MEDIUMTEXT&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;L&lt;/em&gt;+3个字节，其中&lt;em&gt;L&lt;/em&gt; &amp;lt; 2&lt;sup&gt;24&lt;/sup&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONGBLOB, LONGTEXT&lt;/td&gt;
&lt;td&gt;
&lt;em&gt;L&lt;/em&gt;+4个字节，其中&lt;em&gt;L&lt;/em&gt; &amp;lt; 2&lt;sup&gt;32&lt;/sup&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ENUM(‘&lt;em&gt;value1&lt;/em&gt;‘,’&lt;em&gt;value2&lt;/em&gt;‘,…)&lt;/td&gt;
&lt;td&gt;1或2个字节，取决于枚举值的个数(最多65,535个值)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SET(‘&lt;em&gt;value1&lt;/em&gt;‘,’&lt;em&gt;value2&lt;/em&gt;‘,…)&lt;/td&gt;
&lt;td&gt;1、2、3、4或者8个字节，取决于set成员的数目(最多64个成员)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;VARCHAR、BLOB和TEXT类是变长类型。每个类型的存储需求取决于列值的实际长度(用前面的表中的&lt;em&gt;L&lt;/em&gt;表示)，而不是该类型的最大可能的大小。例如，VARCHAR(10)列可以容纳最大长度为10的字符串。实际存储需求是字符串(&lt;em&gt;L&lt;/em&gt;)的长度，加上一个记录字符串长度的字节。对于字符串’abcd’，&lt;em&gt;L&lt;/em&gt;是4，存储需要5个字节。&lt;/p&gt;
&lt;p&gt;对于CHAR、VARCHAR和TEXT类型，前面的表中的值&lt;em&gt;L&lt;/em&gt;和&lt;em&gt;M&lt;/em&gt;应解释为字符数目，并且列定义中的这些类型的长度表示字符数目。例如，要想保存一个TINYTEXT值需要&lt;em&gt;L&lt;/em&gt;字符+ 1个字节。&lt;/p&gt;
&lt;p&gt;要想计算用于保存具体CHAR、VARCHAR或者TEXT列值的字节数，需要考虑该列使用的字符集。在具体情况中，当使用Unicode时，必须记住所有Unicode字符使用相同的字节数。为了细分用于不同类Unicode字符使用的存储，参见&lt;a title=&quot;10.5. Unicode Support&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/charset.html#charset-unicode&quot;&gt;10.5节，“Unicode支持”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注释：&lt;/strong&gt;VARCHAR列的&lt;em&gt;有效&lt;/em&gt;最大长度为65,532字符。&lt;/p&gt;
&lt;p&gt;NDBCLUSTER引擎只支持固定宽度的列。这说明MySQL簇中的表中的VARCHAR列的行为如同类型CHAR(不同的是每个记录仍然有一个额外字节空间)。例如，在Cluster表中，声明为VARCHAR(100)的列中的&lt;em&gt;每个&lt;/em&gt;记录存储时将占用101个字节，无论实际存储的记录中的字符串的长度为多少。&lt;/p&gt;
&lt;p&gt;BLOB和TEXT类需要 1、2、3或者4个字节来记录列值的长度，取决于该类的最大可能的长度。参见&lt;a title=&quot;11.4.3. The BLOB and TEXT Types&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#blob&quot;&gt;11.4.3节，“BLOB和TEXT类型&lt;code&gt;&lt;/code&gt;”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在NDB Cluster存储引擎中，TEXT和BLOB列的实施是不同的，其中TEXT列中的每个记录由两个单独部分组成。一个是固定大小(256字节)，并且实际上保存在原表中。另一个包括超出256字节的任何数据，保存在隐含的表中。第2个表中的记录总是2,000字节长。这说明如果&lt;em&gt;size&lt;/em&gt;&amp;lt;= 256，TEXT列的大小为256(其中&lt;em&gt;size&lt;/em&gt;表示记录的大小)；否则，大小是256 +&lt;em&gt;size&lt;/em&gt;+(2000–(&lt;em&gt;size&lt;/em&gt;–256)%2000)。&lt;/p&gt;
&lt;p&gt;ENUM对象的大小由不同的枚举值的数目确定。枚举用一个字节，可以有255个可能的值。当枚举的值位于256和65,535之间时，用两个字节。参见&lt;a title=&quot;11.4.4. The ENUM Type&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#enum&quot;&gt;11.4.4节，“ENUM类型”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;SET对象的大小由不同的set成员的数量确定。如果set大小是&lt;em&gt;N&lt;/em&gt;，对象占(&lt;em&gt;N&lt;/em&gt;+7)/8个字节，四舍五入到1、2、3、4或者8个字节。SET最多可以有64个成员。参见&lt;a title=&quot;11.4.5. The SET Type&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#set&quot;&gt;11.4.5节，“SET类型”&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;choosing-types&quot;&gt;&lt;/a&gt;11.6. 选择正确的列类型&lt;/h2&gt;
&lt;p&gt;&lt;a name=&quot;id2855781&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2855792&quot;&gt;&lt;/a&gt;为了优化存储，在任何情况下均应使用最精确的类型。例如，如果列的值的范围为从1到99999，若使用整数，则MEDIUMINT UNSIGNED是好的类型。在所有可以表示该列值的类型中，该类型使用的存储最少。&lt;/p&gt;
&lt;p&gt;用精度为65位十进制数(基于10)对DECIMAL 列进行所有基本计算(+、-、*、/)。参见&lt;a title=&quot;11.1.1. Overview of Numeric Types&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-type-overview&quot;&gt;11.1.1节，“数值类型概述”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;使用双精度操作对DECIMAL值进行计算。如果准确度不是太重要或如果速度为最高优先级，DOUBLE类型即足够了。为了达到高精度，可以转换到保存在BIGINT中的定点类型。这样可以用64位整数进行所有计算，根据需要将结果转换回浮点值。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;other-vendor-column-types&quot;&gt;&lt;/a&gt;11.7. 使用来自其他数据库引擎的列类型&lt;/h2&gt;
&lt;p&gt;&lt;a name=&quot;id2855869&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2855879&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2855890&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2855900&quot;&gt;&lt;/a&gt;&lt;a name=&quot;id2855912&quot;&gt;&lt;/a&gt;为了使用由其它卖方编写的SQL执行代码，MySQL按照下表所示对列类型进行映射。通过这些映射，可以很容易地从其它数据库引擎将表定义导入到MySQL中：&lt;/p&gt;
&lt;table id=&quot;table10&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;其它卖方类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;MySQL类型&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BOOL,&lt;/td&gt;
&lt;td&gt;TINYINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;TINYINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CHAR VARYING(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;VARCHAR(&lt;em&gt;M&lt;/em&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DEC&lt;/td&gt;
&lt;td&gt;DECIMAL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIXED&lt;/td&gt;
&lt;td&gt;DECIMAL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLOAT4&lt;/td&gt;
&lt;td&gt;FLOAT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLOAT8&lt;/td&gt;
&lt;td&gt;DOUBLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT1&lt;/td&gt;
&lt;td&gt;TINYINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT2&lt;/td&gt;
&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT3&lt;/td&gt;
&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT4&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT8&lt;/td&gt;
&lt;td&gt;BIGINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONG VARBINARY&lt;/td&gt;
&lt;td&gt;MEDIUMBLOB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONG VARCHAR&lt;/td&gt;
&lt;td&gt;MEDIUMTEXT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONG&lt;/td&gt;
&lt;td&gt;MEDIUMTEXT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MIDDLEINT&lt;/td&gt;
&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NUMERIC&lt;/td&gt;
&lt;td&gt;DECIMAL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在创建表时对列类型进行映射，然后原来的类型定义被丢弃。如果你使用其它卖方的类型创建一个表，然后执行DESCRIBE &lt;em&gt;tbl_name&lt;/em&gt;语句，MySQL使用等效的MySQL类型来报告表的结构。例如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;CREATE TABLE t (a BOOL, b FLOAT8, c LONG, d NUMERIC);
&amp;lt;/strong&amp;gt;Query OK, 0 rows affected (0.08 sec)&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;amp;gt; &amp;lt;strong&amp;gt;DESCRIBE t;
&amp;lt;/strong&amp;gt;+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| a     | tinyint(1)    | YES  |     | NULL    |       
&amp;lt;span style=&quot;font-family: Monaco, Consolas, &#39;Andale Mono&#39;, &#39;DejaVu Sans Mono&#39;, monospace; font-style: normal;&quot;&amp;gt;| b     | double        | YES  |     | NULL    |       |
&amp;lt;/span&amp;gt;| c     | mediumtext    | YES  |     | NULL    |       |
| d     | decimal(10,0) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
4 rows in set (0.00 sec)&lt;/pre&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87324&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87324votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87324&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Wed, 03 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-03-87324-2984cd4fb.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-03-87324-2984cd4fb.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Tmux 入门介绍</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;有关 Tmux 的教程多达 4257 篇，这个数还是我粗略统计的。而我这篇入门教程的目的是让你从“我去，Tmux 是神马”极速地转变到“Tmux 真牛B”！&lt;/p&gt;
&lt;p&gt;那么，我们就开始吧！&lt;/p&gt;
&lt;h2&gt;为什么要用 Tmux&lt;/h2&gt;
&lt;p&gt;tmux 在很多方面都很有用。就我而言，由于 tmux 允许随时随地断开或重新接入会话（Session），所以最大的作用就是在远程服务器上持久地保存工作状态。&lt;/p&gt;
&lt;p&gt;例如，你可以在服务器上新建一个会话并命名为“nodeapi”，然后用它来挖掘 node REST API 的漏洞（这是我现在的项目）。或者假设你正在咖啡店里工作，需要编译一些代码，而编译要花费 2 个小时才能完成（如果是和我一起工作的话），这时你又不得不离开咖啡店。如果使用了 tmux，你就可以轻松地断开当前的会话，并于稍后方便时重新接入该会话，继续工作。&lt;/p&gt;
&lt;p&gt;这真是太方便了。&lt;/p&gt;
&lt;p&gt;“如何使用 tmux 才能打开多个会话，如何在会话中打开多个标签（Tab），如何在标签中打开多个窗口（Window），又如何在窗口中打开多个窗格（Pane）”，也许有些人对这些操作更感兴趣。而我很少这样做的，因为我不喜欢打开太多的——实际上是尽可能少地打开——这些东西。因此，这篇入门教程主要讲解的也是作为简单的可持久化远程会话模型的 tmux。&lt;/p&gt;
&lt;h3&gt;远程操作计算机的生活方式&lt;/h3&gt;
&lt;p&gt;机动性是 tmux 带给用户的最大价值。有很多开发者都是在服务器上进行所有工作的，他们只需从某处连接上服务器就可以开始工作了。有了 tmux（或者其他类似的工具），你就可以先坐在旧金山的某个咖啡店里开始在服务器上进行构建的工作，然后断开会话去赶飞机，待飞机降落到纽约市后再继续进行刚才的工作。&lt;/p&gt;
&lt;p&gt;tmux 带来的另一个好处是在移动办公中，作为客户端的计算机变得不再那么重要了。只需要升级你的笔记本，然后从版本库中克隆出 vim 和 tmux 的配置文件，就可以再次回到配置最优的操作环境了。而且这一切只需要短短的几分钟。&lt;/p&gt;
&lt;p&gt;总之，这些就是人们喜爱 tmux 的原因。当然即使你的生活不是四处奔波，也一样能体验到 tmux 带来的好处。&lt;/p&gt;
&lt;h4&gt;那么 screen 呢？&lt;/h4&gt;
&lt;p&gt;问得好。tmux 和 screen 很像，但比 screen 更好。要问好在哪里，简单的回答就是虽然与 screen 的功能相同，但是 tmux 设计得更好。screen 虽然可用，但是很不稳定。&lt;/p&gt;
&lt;p&gt;以下是一些 tmux 超越 screen 的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;screen 的项目大体上已经终止了，并且代码中有大量的问题&lt;/li&gt;
&lt;li&gt;tmux 是一个活跃的项目，并且其代码库经常进行更新&lt;/li&gt;
&lt;li&gt;tmux 使用的是真正的客户端/服务器模型，而 screen 只是模拟了这种模型的行为&lt;/li&gt;
&lt;li&gt;tmux 同时支持 emacs 和 vim 的快捷键&lt;/li&gt;
&lt;li&gt;tmux 支持自动重命名窗口&lt;/li&gt;
&lt;li&gt;tmux 可以高度的脚本化&lt;/li&gt;
&lt;li&gt;tmux 的窗口分割功能更加先进&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些优点已经足够了吧，开始使用 tmux 吧。&lt;/p&gt;
&lt;h2&gt;基础&lt;/h2&gt;
&lt;p&gt;首先要告诉诸位的是 tmux 中的一个全局的快捷键开关，开关开启后就可以通过快捷键完成很多任务。&lt;/p&gt;
&lt;h3&gt;tmux 的快捷键&lt;/h3&gt;
&lt;p&gt;tmux 默认使用 &lt;code&gt;Ctrl-b&lt;/code&gt; 作为激活快捷键的开关，开关开启后就可以通过快捷键迅速调用大量的功能。下面就给出一些基本功能的调用方法：&lt;/p&gt;
&lt;p&gt;首先按下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ Ctrl-b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来就可以按下一些后面将会讲解的快捷键了。不过先不要着急，可以先为能方便地使用组合键 &lt;code&gt;Ctrl-b&lt;/code&gt; 做一点准备。不妨在操作系统中将键盘上的 CAPSLOCK 键映射为 Ctrl 键，这样当需要按下这个组合键时，小拇指的移动就可以更加舒服了。&lt;/p&gt;
&lt;h3&gt;运行 tmux&lt;/h3&gt;
&lt;p&gt;好了，下面让我们从运行 tmux 开始。首先选择一台你希望在断开会话后依然可以重新接入的计算机（对我来说这通常是远程服务器），然后在上面运行如下的命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ tmux&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;很简单对吧。这样就开启了一个 tmux 的会话，你可以断开这个会话并在稍后再重新接入。&lt;/p&gt;
&lt;h3&gt;显示所有会话&lt;/h3&gt;
&lt;p&gt;由于 tmux 的理念是可以开启多个会话，并且可以自由地断开会话后重新接入，为此我们需要首先能看到可用的会话。有两种方法可以实现这个目的：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;# Via shortcut (by default Ctrl-b)
# 使用快捷键（默认为 Ctrl-b）

$ Ctrl-b s&lt;/pre&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;# Via tmux command
# 使用 tmux 的子命令

$ tmux ls&lt;/pre&gt;
&lt;p&gt;上面两种方法的效果相同，都可以得到类似下面的结果：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;0: 1 windows (created Thu Nov 28 06:12:52 2013) [80x24] (attached)&lt;/pre&gt;
&lt;h3&gt;新建会话&lt;/h3&gt;
&lt;p&gt;下面我们就来新建一个会话。可以使用 &lt;code&gt;new&lt;/code&gt; 命令新建会话，并且该命令允许以参数的形式传递一个会话名。我的建议是在新建时要提供一个会话名以便于日后管理。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ tmux new -s session-name&lt;/pre&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;# Without naming the new session (not recommended) 
# 新建会话但并不指定名字 (不推荐这样做) 

$ tmux new&lt;/pre&gt;
&lt;h3&gt;接入一个之前的会话&lt;/h3&gt;
&lt;p&gt;既然我们已经创建了多个带有名称的会话，那么就可以随时接入了，有几种方法可以实现接入会话：&lt;/p&gt;
&lt;p&gt;可以简单地输入 &lt;code&gt;tmux a&lt;/code&gt; 命令，这样可以接入第一个可用的会话：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ tmux a&lt;/pre&gt;
&lt;p&gt;或者可以通过参数指定一个想接入的会话：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$ tmux a -t session-name&lt;/pre&gt;
&lt;h3&gt;从会话中断开&lt;/h3&gt;
&lt;p&gt;可以使用 &lt;code&gt;detach&lt;/code&gt; 命令断开已有的会话（因此才会有稍后重新接入会话这么一说）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ tmux detach&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以使用快捷键断开会话：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ Ctrl-b d&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;关闭会话&lt;/h3&gt;
&lt;p&gt;要关闭会话的话，可以使用如下的命令，该命令和接入会话时所使用的命令很像：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ tmux kill-session -t session-name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提示：关闭窗口时也可以使用类似的命令，只不过要把 kill-session 换成 kill-window。另外，还可以使用 tmux killall 同时关闭 tmux。&lt;/p&gt;
&lt;h2&gt;配置&lt;/h2&gt;
&lt;p&gt;与其他工具一样，一旦配置好了 tmux，使用起来就将会非常顺手。下面就给出几个通常需要配置的项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tmux 的主要快捷键&lt;/li&gt;
&lt;li&gt;屏幕下方的状态条&lt;/li&gt;
&lt;li&gt;自定义的各种快捷键&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我使用了一些相当简单的配置：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;# Set a Ctrl-b shortcut for reloading your tmux config
#设置 Ctrl-b 快捷键，用于重新加载 tmux 的配置文件&lt;/pre&gt;
&lt;p&gt;access log，error log和system log。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;bind r source-file ~/.tmux.conf

# Rename your terminals
# 重命名终端
set -g set-titles on
set -g set-titles-string &#39;#(whoami)::#h::#(curl ipecho.net/plain;echo)&#39;

# Status bar customization
# 自定义状态条
set -g status-utf8 on
set -g status-bg black
set -g status-fg white
set -g status-interval 5
set -g status-left-length 90
set -g status-right-length 60
set -g status-left &quot;#[fg=Green]#(whoami)#[fg=white]::#[fg=blue]
(hostname -s)#[fg=white]::##[fg=yellow]#(curl ipecho.net/plain;echo)&quot;

set -g status-justify left
set -g status-right &#39;#[fg=Cyan]#S #[fg=white]%a %d %b %R&#39;&lt;/pre&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;这里有一点值得注意，我使用了 ipecho.net 而不是 icanhazip 来获取计算机当前的 IP 地址（IPv4）。虽然也有很多教程在使用 icanhazip，但是凭我的经验，ipecho.net 的速度更快，更稳定。&lt;/p&gt;
&lt;p&gt;提示：如果你感兴趣，可以来&lt;a href=&quot;https://raw.github.com/danielmiessler/tmux/master/.tmux.config&quot;&gt;这里&lt;/a&gt;查看我使用的最新配置。&lt;/p&gt;
&lt;h2&gt;高级功能&lt;/h2&gt;
&lt;p&gt;我平时常用的功能就是这些了。不过，我也会使用一些 tmux 中更强大的功能。&lt;/p&gt;
&lt;h3&gt;窗口和窗格&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1fb698917561cd076c0b7ad86e73bb07.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这些高级功能之一就是 tmux 可以将一个会话分割成若干个称为窗口（Window）和窗格（Pane）的相互分离的组件。这种逻辑上的分割使用户可以轻松安排各种各样的操作。&lt;/p&gt;
&lt;p&gt;下面就来看一看这几个概念之间的关系。&lt;/p&gt;
&lt;h4&gt;层次结构&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d0c3ee25486c9efee1a6b1f043acfa7e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，一个会话（Session）可以包含多个窗口，一个窗口（Window）可以包含多个窗格（Pane）。这就是我对这些概念的简单理解。当然如果诸位有更权威或者更实用的解释，我很乐意洗耳恭听。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会话适用于分别管理大的工作内容，例如日常工作，实验或是系统管理，都可以分别在一个会话中进行。&lt;/li&gt;
&lt;li&gt;窗口适用于分别管理这些大工作中的项目。例如，在用于实验的会话中可能有一叫做 noderestapi 的窗口用于调试 node REST API，有一个叫做 lua 的窗口用于调试 lua 脚本。&lt;/li&gt;
&lt;li&gt;窗格适用于查看当前的项目。例如，在系统管理的会话中有一个叫做 logs 的窗口，在这个窗口中可以打开多个窗格分别用于查看 access log，error log和system log。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们也可以在会话中直接创建窗格，而不需要先创建一个窗口。我有时也会这样做。当阅读完“层次结构”这一小节，希望我的这种做法没有听起来那样恐怖。正如我在一开始谈到的，我更倾向于简化 tmux 的使用。&lt;/p&gt;
&lt;h4&gt;在窗格间移动光标&lt;/h4&gt;
&lt;p&gt;虽然有默认的在窗格间移动光标的方法，但是我并不清楚是什么。因为我习惯用 vim，所以我会用&lt;code&gt;h&lt;/code&gt;，&lt;code&gt;j&lt;/code&gt;，&lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;l&lt;/code&gt; 键在窗格间移动光标。为此，要加入如下的配置：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;# Remap window(pane?) navigation to vim
# 用 vim 的方式在窗格间移动光标
unbind-key j
bind-key j select-pane -D
unbind-key k
bind-key k select-pane -U
unbind-key h
bind-key h select-pane -L
unbind-key l
bind-key l select-pane -R&lt;/pre&gt;
&lt;h2&gt;&lt;strong&gt;建议&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;以下几条建议也许会有助于诸位的 tmux 之旅：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尽可能少打开会话和窗口。人类没有我们自认为的那样善于处理多任务。虽然打开 47 个窗格显得很强大，但是这并没有我们想象的那样实用。&lt;/li&gt;
&lt;li&gt;当确实要使用窗口和窗格时，花一点时间为它们起个有意义的名字。这非常有用，如果只是用 0、1、2 这样的名字，切换会话或窗口时就会非常麻烦。&lt;/li&gt;
&lt;li&gt;从基础的配置、操作开始使用 tmux，别一上来就把自己搞糊涂了。我曾遇到过很多人，他们花费了大量的时间配置 vim 或 tmux，而最终带来的结果却是不但把自己绕进去了，而且项目也没有进展。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;快捷键参考&lt;/h2&gt;
&lt;p&gt;按下 &lt;code&gt;Ctrl-b&lt;/code&gt; 后的快捷键如下：&lt;/p&gt;
&lt;h3&gt;基础&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;?&lt;/code&gt; 获取帮助信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;会话管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;s&lt;/code&gt; 列出所有会话&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;$&lt;/code&gt; 重命名当前的会话&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;d&lt;/code&gt; 断开当前的会话&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;窗口管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;c&lt;/code&gt; 创建一个新窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;,&lt;/code&gt; 重命名当前窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;w&lt;/code&gt; 列出所有窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;%&lt;/code&gt; 水平分割窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;&quot;&lt;/code&gt; 竖直分割窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;n&lt;/code&gt; 选择下一个窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;p&lt;/code&gt; 选择上一个窗口&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;0~9&lt;/code&gt; 选择0~9对应的窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;窗格管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;%&lt;/code&gt; 创建一个水平窗格&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;&quot;&lt;/code&gt; 创建一个竖直窗格&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;h&lt;/code&gt; 将光标移入左侧的窗格*&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;j&lt;/code&gt; 将光标移入下方的窗格*&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;l&lt;/code&gt; 将光标移入右侧的窗格*&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;k&lt;/code&gt; 将光标移入上方的窗格*&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;q&lt;/code&gt; 显示窗格的编号&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;o&lt;/code&gt; 在窗格间切换&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;}&lt;/code&gt; 与下一个窗格交换位置&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;{&lt;/code&gt; 与上一个窗格交换位置&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;!&lt;/code&gt; 在新窗口中显示当前窗格&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;x&lt;/code&gt; 关闭当前窗格&amp;gt; 要使用带“*”的快捷键需要提前配置，配置方法可以参考上文的“在窗格间移动光标”一节。——译者注&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;t&lt;/code&gt; 在当前窗格显示时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;希望这篇文章有助于你理解 tmux。&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;h2&gt;参考资源&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;The man page.&lt;/li&gt;
&lt;li&gt;A thousand other great tutorials.&lt;/li&gt;
&lt;li&gt;man 手册&lt;/li&gt;
&lt;li&gt;大量精彩教程&lt;/li&gt;
&lt;/ol&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87278&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87278votetotal&quot;&gt;3&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87278&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者：&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/jackalhu&quot;&gt;JackalHu&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/jackalhu&quot;&gt;
			&lt;img src=&quot;/images/jobbole.com/ca44b272678408d3e2650ac448de62da.jpg&quot;&gt;
		&lt;/a&gt;
	&lt;/div&gt;

    &lt;div class=&quot;author-bio-info&quot;&gt;

        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            热爱编程，关注设计模式，致力于提升软件开发的质量。新浪微博：@Jackal-Hu        &lt;/span&gt;
        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            &lt;a href=&quot;http://www.jobbole.com/members/jackalhu&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 个人主页&lt;/a&gt; ·
            &lt;a href=&quot;http://blog.jobbole.com/author/jackalhu/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;/i&gt; 我的文章&lt;/a&gt; ·
            &lt;a title=&quot;声望值&quot; target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/jackalhu/reputation/&quot;&gt;&lt;i class=&quot;fa fa-graduation-cap&quot;&gt;&lt;/i&gt; 12&lt;/a&gt;        &lt;/span&gt;
    &lt;/div&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Wed, 03 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-03-87278-b045c7e69.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-03-87278-b045c7e69.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（3） ： 查看字段长度</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/87318/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（2） ：数据类型宽度&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看字段的长度&lt;/p&gt;
&lt;p&gt;SQLSERVER&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE [sss]
GO
SELECT LEN([NAME]) FROM [dbo].[aa]&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/da5a96602d04f656783bf0334f084e96.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;MYSQL&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE tmp13(vb VARBINARY(10))

INSERT INTO tmp13 (vb) VALUES(12)

SELECT LENGTH(vb) FROM tmp13

INSERT INTO tmp13 (vb) VALUES(1212)&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3ee043584e99c291376d93edfa699b40.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87322&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87322votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87322&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Tue, 02 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-02-87322-7895b7eca.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-02-87322-7895b7eca.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（2） ：数据类型宽度</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/87315/&quot; target=&quot;_blank&quot;&gt;我的MYSQL学习心得（1） ：简单语法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显示宽度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MYSQL中的整数型数据类型都可以指定显示宽度，而SQLSERVER不行&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/52584b83be4cf89eed43ca5e76558f40.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;创建一个表&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE tb_emp( id BIGINT(1))&lt;/pre&gt;
&lt;p&gt;id字段的数据类型为BIGINT(1)，注意到后面的数字1，这表示的是该数据类型指定的显示宽度，指定能够显示的数值中数字的个数。&lt;/p&gt;
&lt;p&gt;例如，假设声明一个INT类型的字段 YEAR INT(4)&lt;/p&gt;
&lt;p&gt;该声明指明，在year字段中的数据一般只显示4位数字的宽度。&lt;/p&gt;
&lt;p&gt;在SQLSERVER里是会报错的&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;CREATE TABLE abc
(id INT(11))&lt;/pre&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;消息 2716，级别 16，状态 1，第 1 行
第 1 个列、参数或变量: 不能对数据类型 int 指定列宽。&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;显示宽度和数据类型的取值范围是无关的。显示宽度只是指明MYSQL最大可能显示的数字个数，数值的位数小于指定的宽度时会有空格填充&lt;/p&gt;
&lt;p&gt;如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能显示出来。&lt;/p&gt;
&lt;p&gt;例如，向year字段插入一个数值19999，当使用select查询的时候，MYSQL显示的将是完整带有5位数字的19999，而不是4位数字的值&lt;/p&gt;
&lt;p&gt;如果不指定显示宽度，则MYSQL为每一种类型指定默认的宽度值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tips：显示宽度只用于显示，并不能限制取值范围和占用空间，例如：INT(3)会占用4个字节的存储空间，并且允许的最大值也不会是999，而是INT整型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所允许的最大值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87318&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87318votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87318&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Tue, 02 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-02-87318-c51ed6871.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-02-87318-c51ed6871.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的MYSQL学习心得（1） ：简单语法</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;使用MYSQL有一段时间了，由于公司使用SQLSERVER和MYSQL，而且服务器数量和数据库数量都比较多&lt;/p&gt;
&lt;p&gt;管理起来比较吃力，在学习MYSQL期间我一直跟SQLSERVER进行对比&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/073ad65b33de539089ece62792e25176.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一期主要是学习MYSQL的基本语法，陆续还有第二、第三、第四期，大家敬请期待o(∩_∩)o&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;语法的差异&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我这里主要说语法的不同&lt;/p&gt;
&lt;p&gt;1、默认约束&lt;/p&gt;
&lt;p&gt;区别：mysql里面DEFAULT关键字后面是不用加括号的&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--sqlserver
CREATE TABLE emp
(
id INT DEFAULT(12)
)

--mysql
CREATE TABLE emp
(
id INT DEFAULT 12
)&lt;/pre&gt;
&lt;p&gt;2、设置自增列&lt;/p&gt;
&lt;p&gt;MYSQL的自增列一定要是有索引的列，设置种子值要在表的后面设置&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--设置自增列
--sqlserver
CREATE TABLE emp
    (
      id INT IDENTITY(1, 1)
    )

--mysql
-- 设置自增ID从N开始
CREATE TABLE emp (
ID INT  PRIMARY KEY AUTO_INCREMENT
) AUTO_INCREMENT = 100 ; --（设置自增ID从100开始）&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;设置自增列的步长，可以分为全局级别和会话级别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果是会话级别，那么当用户新建一个会话的时候，那么步长又回到了全局级别，所以mysql的步长跟sqlserver的步长有很大的不同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mysql不能设置为表级别的步长！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql服务器维护着2种mysql的系统参数（系统变量）：全局变量（global variables）和会话变量（session variables）。&lt;/p&gt;
&lt;p&gt;它们的含义与区别如其各占的名称所示，session variables是在session级别的，对其的变更只会影响到本session；global variables是系统级别的，&lt;/p&gt;
&lt;p&gt;对其的变更会影响所有新session（变更时已经存在session不受影响）至下次mysql server重启动。&lt;/p&gt;
&lt;p&gt;注意它的变更影响不能跨重启，要想再mysql server重启时也使用新的值，那么就只有通过在命令行指定变量选项或者更改选项文件来指定，&lt;/p&gt;
&lt;p&gt;而通过SET变更是达不到跨重启的。&lt;br&gt;
每一个系统变量都有一个默认值，这个默认值是在编译mysql系统的时候确定的。&lt;/p&gt;
&lt;p&gt;对系统变量的指定，一般可以在server启动的时候在命令行指定选项或者通过选项文件来指定&lt;/p&gt;
&lt;p&gt;当然，大部分的系统变量，可以在系统的运行时，通过set命令指定其值。&lt;/p&gt;
&lt;p&gt;查看系统当前默认的自增列种子值和步长值&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;SHOW GLOBAL VARIABLES LIKE &#39;auto_incre%&#39;; -- 全局变量&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/515d84a6bba4d40f338af9807bb2daa1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;问：如果有一张表，里面有个字段为id的自增主键，当已经向表里面插入了10条数据之后，删除了id为8，9，10的数据，再把mysql重启，&lt;/p&gt;
&lt;p&gt;之后再插入一条数据，那么这条数据的id值应该是多少，是8，还是11？&lt;br&gt;
答：如果表的类型为MyISAM，那么是11。如果表的类型为InnoDB，则id为8。&lt;br&gt;
这是因为两种类型的存储引擎所存储的最大ID记录的方式不同，MyISAM表将最大的ID记录到了数据文件里，重启mysql自增主键的最大ID值也不会丢失；&lt;br&gt;
而InnoDB则是把最大的ID值记录到了内存中，所以重启mysql或者对表进行了OPTIMIZE操作后，最大ID值将会丢失。&lt;/p&gt;
&lt;p&gt;顺便说一下MYSQL获取当前表的自增值的四种方法&lt;/p&gt;
&lt;p&gt;1、 SELECT MAX(id) FROM person   针对特定表&lt;/p&gt;
&lt;p&gt;2、 SELECT LAST_INSERT_ID()  函数   针对任何表&lt;/p&gt;
&lt;p&gt;3、 SELECT @@identity    针对任何表&lt;/p&gt;
&lt;p&gt;@@identity 是表示的是最近一次向具有identity属性(即自增列)的表插入数据时对应的自增列的值，是系统定义的全局变量。&lt;/p&gt;
&lt;p&gt;一般系统定义的全局变量都是以@@开头，用户自定义变量以@开头。&lt;/p&gt;
&lt;p&gt;使用@@identity的前提是在进行insert操作后，执行select @@identity的时候连接没有关闭，否则得到的将是NULL值。&lt;/p&gt;
&lt;p&gt;4.  SHOW TABLE STATUS LIKE ’person’&lt;/p&gt;
&lt;p&gt;如果针对特定表，建议使用这一种方法&lt;/p&gt;
&lt;p&gt;得出的结果里边对应表名记录中有个Auto_increment字段，里边有下一个自增ID的数值就是当前该表的最大自增ID.&lt;/p&gt;
&lt;p&gt;3、查看表定义&lt;/p&gt;
&lt;p&gt;SQLSERVER&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;EXEC sp_help &#39;emp&#39;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2fc9236d72e5d7c2ac94176a5670c5c0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;MYSQL&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;DESC emp&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9c48f0e1001e302d594e264faf8ea316.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、修改表名&lt;/p&gt;
&lt;p&gt;修改表名也有差异，将表emp改为emp2&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--sqlserver
EXEC sys.[sp_rename] @objname = N&#39;emp&#39;, -- nvarchar(1035)
    @newname = &#39;emp2&#39; -- sysname

--mysql
ALTER TABLE emp RENAME emp2&lt;/pre&gt;
&lt;p&gt;5、修改字段的数据类型&lt;/p&gt;
&lt;p&gt;将id字段的int类型改为bigint&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--sqlserver
ALTER TABLE [dbo].[emp2] ALTER COLUMN [ID] BIGINT

--mysql
ALTER TABLE emp2 MODIFY id BIGINT&lt;/pre&gt;
&lt;p&gt;6、修改字段名&lt;/p&gt;
&lt;p&gt;MYSQL里修改字段名的时候需要加上字段的数据类型否则会报错，而CHANGE也可以只修改数据类型，实现和MODIFY同样的效果&lt;/p&gt;
&lt;p&gt;方法是将SQL语句中的“新字段名”和“旧字段名”设置为相同的名称，只改变“数据类型”&lt;/p&gt;
&lt;p&gt;改变数据类型，例如刚才那个例子，将id列改为bigint数据类型&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE emp2 CHANGE id id BIGINT&lt;/pre&gt;
&lt;p&gt;修改字段名&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--sqlserver
EXEC sys.[sp_rename] @objname = N&#39;emp2.id&#39;, -- nvarchar(1035)
    @newname = &#39;iid&#39;, -- sysname
    @objtype = &#39;column&#39; -- varchar(13)

--mysql
ALTER TABLE emp2 CHANGE id iid BIGINT&lt;/pre&gt;
&lt;p&gt;7、添加字段&lt;/p&gt;
&lt;p&gt;添加字段的语法差不多，但是MYSQL里可以使用&lt;strong&gt;FIRST&lt;/strong&gt;和&lt;strong&gt;AFTER&lt;/strong&gt;关键字指定添加的字段的位置&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--sqlserver
ALTER TABLE [dbo].[emp2] ADD NAME NVARCHAR(200) NULL 

--mysql
ALTER TABLE emp2 ADD NAME NVARCHAR(200)  NULL&lt;/pre&gt;
&lt;p&gt;8、删除字段&lt;/p&gt;
&lt;p&gt;MYSQL删除字段不需要添加COLUMN关键字的&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--sqlserver
ALTER TABLE [dbo].[emp2] DROP COLUMN NAME 

--mysql
ALTER TABLE emp2 DROP NAME&lt;/pre&gt;
&lt;p&gt;9、删除外键约束&lt;/p&gt;
&lt;p&gt;MYSQL跟SQLSERVER删除约束的方法也有很大的区别&lt;/p&gt;
&lt;p&gt;在SQLSERVER里面，无论是唯一约束，check约束还是外键约束都可以使用下面的SQL语句来删除掉&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;ALTER TABLE 表名 DROP CONSTRAINT 约束名&lt;/pre&gt;
&lt;p&gt;但是MYSQL里面，如果是外键约束，需要使用 DROP FOREIGN KEY，如果是主键约束需要使用DROP PRIMARY KEY，有点麻烦&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--sqlserver
ALTER TABLE dbo.emp2 DROP CONSTRAINT fk_emp_dept

--mysql
--删除外键约束
ALTER TABLE emp2 DROP FOREIGN KEY fk_emp_dept
--删除主键约束
ALTER TABLE emp2 DROP PRIMARY KEY pk_emp_dept&lt;/pre&gt;
&lt;p&gt;10、删除表&lt;/p&gt;
&lt;p&gt;删除表的语法两个都是一样的&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--sqlserver
DROP TABLE [dbo].[emp2]

--mysql
DROP TABLE emp2&lt;/pre&gt;
&lt;p&gt;但是如果要同时删除多个表或者删除之前要先判断一下，MYSQL就方便多了&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--sqlserver
IF (OBJECT_ID(&#39;dbo.emp2&#39;) IS NOT NULL )
DROP TABLE [dbo].[emp2]

--mysql
DROP TABLE IF EXISTS emp1 ,emp2&lt;/pre&gt;
&lt;p&gt;SQLSERVER需要一张一张表判断，然后一张一张表drop&lt;/p&gt;
&lt;p&gt;MYSQL就不一样，语法非常简洁： DROP TABLE IF EXISTS emp1 ,emp2&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这篇文章只是简单介绍了一下MYSQL跟SQLSERVER的&lt;strong&gt;语法方面的差异&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以后会写更多关于MYSQL跟SQLERVER差异的文章，和我这段时间使用MYSQL期间的一些心得，大家敬请期待o(∩_∩)o&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不对的地方，欢迎大家拍砖o(∩_∩)o &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2014-7-16补充&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;USE test;
-- myisam引擎
CREATE TABLE TEST(
ID int unsigned not null auto_increment,
name varchar(10) not null,
  key(name,id))engine=MYISAM auto_increment=100
;

-- innodb引擎
CREATE TABLE TESTIdentity(
ID int unsigned   not null auto_increment,
NID INT UNSIGNED ,
name varchar(10) not null,
  key(id))engine=INNODB auto_increment=100
;

--或者主键
CREATE TABLE TESTIdentity(
ID int unsigned   not null auto_increment,
NID INT UNSIGNED ,
name varchar(10) not null,
  key(id))engine=INNODB auto_increment=100
;

[Database4]
ErrorCode: -2147467259, Number: 1075
ErrorMessage: Incorrect table definition; there can be only one auto column and it must be defined as a key

alter table TESTIdentity modify column nid int auto_increment;&lt;/pre&gt;
&lt;p&gt;无论&lt;strong&gt;innodb引擎还是MYISAM引擎&lt;/strong&gt;的表中，只能有一个自增列，并且自增列一定是索引列，无论是二级索引还是主键索引&lt;/p&gt;
&lt;p&gt;这里跟SQLSERVER是不一样，SQLSERVER允许一张表有多个自增列，并且不需要在自增列上创建索引&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87315&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87315votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87315&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt; 1 收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Tue, 02 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-06-02-87315-2546ac9c0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-06-02-87315-2546ac9c0.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈排队论</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;&lt;strong&gt;伯乐在线补充：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;排队论（Queueing Theory），或称随机服务系统理论、排队理论，是数学运筹学的分支学科。它是研究服务系统中排队现象随机规律的学科。广泛应用于电信，交通工程，计算机网络、生产、运输、库存等各项资源共享的随机服务系统，和工厂，商店，办公室和医院的设计。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/db130ebc669e4bf5d84aa70a4935e266.jpg&quot; width=&quot;630&quot; height=&quot;309&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;（天通苑地铁早高峰入口处的排队。&lt;a href=&quot;http://weibo.com/2093492691/AzRN2u33Z&quot; target=&quot;_blank&quot;&gt;图来自网友老歌&lt;/a&gt; ）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在社会到处都有队列，队列无处不在。比如生活中的超市与机场，到工作中的Web服务器和数据库。因此，研究一下队列行为，还是很有帮助的。&lt;/p&gt;
&lt;p&gt;问题在于排队行为实际上与我们直觉相背离。在实际生活中碰到的大多数排队现象，通常都是在充满不确定性和随机性的情况下发生的。这就是统计概率领域的话题了，而人类的思维能力无法很直观的来处理它。&lt;/p&gt;
&lt;p&gt;在排队论领域有一些工具可以规避这种问题：一种结合可视化的计量方法可以弥补我们直觉上的不足。这篇文章会讨论一些我在阅读排队论时发现的比较有趣的东西。&lt;/p&gt;
&lt;h2&gt;产品开发中的排队&lt;/h2&gt;
&lt;p&gt;本文中提出的大多数观点都是基于 Donald G. Reinertsen 的《产品开发流程的原理 | &lt;a href=&quot;http://www.amazon.com/The-Principles-Product-Development-Flow/dp/1935401009&quot;&gt;The Principles of Product Development Flow&lt;/a&gt;》，顺便说一句，这本算是我所看过的关于产品开发流程写得最好的书。&lt;/p&gt;
&lt;p&gt;在这本书中，Reinertsen 检查了在开发新产品时，组织可能会面临的挑战，并给出了一种计量经济学框架来应对这些挑战。这个框架系统性的推翻了我们在管理产品开发时的一些固有理念。比如说“应该消除方差”、“系统应该满负荷运转”以及“集中化控制有好处”等。这些都被基于经济原理的新观点所取代，而不再基于业务原理和个人直觉。&lt;/p&gt;
&lt;p&gt;在 Reinertsen 的书中，其中心主题有一条就是关于排队的重要性。具体来说，Reinertsen 多次提到这样的现象：产品管理员往往忽略排队的问题，而只关注到时间线和效率。当然，对时间线和效率的度量对我们是有帮助，但是对于那些高度不确定的活动，比如产品开发来说，我们其实可以做的更好。队列就是一个更好的度量工具。最起码，它们非常重要，不容忽视。&lt;/p&gt;
&lt;p&gt;虽然在 Reinertsen 的书中这些观点都应用于产品开发领域，不过许多观点同样也同样适用于其他出现排队和随机性的场合。比如说交通管理、百货商店以及饭店的厨房，还有服务器资源管理和软件架构等。接下来，我们详细阐述。&lt;/p&gt;
&lt;h2&gt;马尔可夫过程&lt;/h2&gt;
&lt;p&gt;就像我们之前所讨论的， 真实世界中产生排队的环境中同样也存在随机性。然而，我们不会讨论关于随机性的内容。在我们推论排队的过程中，所使用的最有用的工具就是基于随机性建模的马尔可夫过程。&lt;/p&gt;
&lt;p&gt;马尔可夫过程是一段时间内随机事件的集合，具有以下两种独特而有趣的属性：&lt;/p&gt;
&lt;p&gt;1&lt;span style=&quot;font-family: 宋体;&quot;&gt;、下一个事件迟早会发生&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span style=&quot;font-family: 宋体;&quot;&gt;、将来事件的发生不依赖于之前的事件，即无后效性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下图描绘出一段时间内的马尔可夫过程：&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d878ad881a4956ee39615bc38b22f13d.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;(原图为交互图，可在原文查看)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;马尔可夫过程和泊松过程都很适合用来给真实世界中的事件建模，其中泊松过程是一种连续时间的特殊马尔可夫过程。 我们可以用它们来模拟事件加入排队队列这一过程。&lt;/p&gt;
&lt;p&gt;当我们使用马尔可夫过程来给入队事件建模时，&lt;span style=&quot;font-family: 宋体;&quot;&gt;比如说上报&lt;/span&gt;&lt;span style=&quot;font-family: Verdana;&quot;&gt;bug&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、餐馆的订单、&lt;/span&gt;&lt;span style=&quot;font-family: Verdana;&quot;&gt;HTTP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;请求等，都可以通过绘制累积图来表示：&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0a2575f8e4215e7aa169d61a95f39942.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;(原图为交互图，可在原文查看)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这种图每次都会重新模拟一条新的马尔科夫链。不过，它的总体形状是一样的。&lt;/p&gt;
&lt;h2&gt;可视化队列&lt;/h2&gt;
&lt;p&gt;马尔可夫过程自身并不能形成排队，它只是一堆持续增长的任务。不过可以通过结合两种马尔可夫过程来制造出排队：其中到达过程不断产生任务，服务过程处理这些任务。&lt;/p&gt;
&lt;p&gt;虽然服务过程也可以建模为马尔可夫过程，但它与到达过程却并不一样：当队列是空的情况下，服务过程什么事都不做。没有消费者，就没有什么事情需要做的。当任务到达的时候，服务过程会遵循马尔可夫过程准则来提供服务。&lt;/p&gt;
&lt;p&gt;我们可以将两种过程叠加来绘制到达过程和服务过程：&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f6f70bd9dbcd5e3fa3b3e2199961158d.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;(原图为交互图，可在原文查看)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果我们将图中的到达过程去掉，剩下的就是到达过程与服务过程之间的那一小块区域。也就是队列：&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/30b2f981ca62260e4c437d0a73f3e9fb.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;(原图为交互图，可在原文查看)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这种可视化工具被称为累积流程图，非常适用于展示排队情况。其本质就是绘制出队列大小随着时间推移发生的变化，具有下面这些非常有用的属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于任意时间变量 t&lt;span style=&quot;font-family: 宋体;&quot;&gt;，线条高度就代表当前时间的队列大小&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;对于任意队列大小 &lt;span style=&quot;font-family: &#39;Times New Roman&#39;;&quot;&gt;y&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，图中长条的宽度代表系统中完成单元任务所需要的时间，这个时间由任务在队列中的等待时间和处理时间合并而成。&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;到达过程的边缘坡度（上面的那条斜线）表现了系统对队列的加入请求。&lt;/li&gt;
&lt;li&gt;服务过程的边缘坡度（下面）展现出服务过程处理任务的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;产能利用率最大化的问题&lt;/h2&gt;
&lt;p&gt;在了解可视化队列的机制之后，我们再来仔细看看这些数据究竟代表什么意思。上图中展示了具有相同频率的到达过程和服务过程而形成的排队。服务的能力与入队请求相匹配。&lt;/p&gt;
&lt;p&gt;乍一看，创建这样一个队列似乎很合理：因为毕竟资源很昂贵，所以要将资源与请求准确的匹配——不多不少。让程序员或者客服人员闲坐着没有任何意义，对吧？&lt;/p&gt;
&lt;p&gt;然而，如果你仔细看这种资源匹配产生的排队情况，你可能会注意到那些相对较宽的部分，这是由于服务进程被困在某个非常慢的任务上时，又有连续不断的任务请求加入而形成的。而且，这种情况并不会很快缓解。&lt;/p&gt;
&lt;p&gt;这种现象被称为diffusion，大多数人都无法凭直觉来感知它（当然其中并不包括我——作者）：如果你将到达进程和服务进程的资源相匹配，你期望的可能是队列大小尽可能的接近0.&lt;span style=&quot;font-family: 宋体;&quot;&gt;但是实际情况不是这样。只要一个耗时的任务就可以使得队列增长的很快，而且它还不会立即“自我修正”为空。排队时间迅速飙升。客户们在着急的等待，&lt;/span&gt;&lt;span style=&quot;font-family: Verdana;&quot;&gt;bug&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;报告堆积如山。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;我们可以通过一些统计数据来更进一步了解这种情况：&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/398f5cd2e3dae47e5e545f076bb81216.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;(原图为交互图，可在原文查看)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过每一次的模拟情况，我们收集到了一些数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产能利用率——服务进程的工作时间（非空闲状态）。如图中所示，如果两种过程的资源能力匹配，这个值接近于100%&lt;span style=&quot;font-family: 宋体;&quot;&gt;。&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;非阻塞状态百分比——服务进程非阻塞状态的时间（可立即工作的状态）。值为“100% – &lt;span style=&quot;font-family: 宋体;&quot;&gt;产能利用率&lt;/span&gt;”（几乎为0）.&lt;/li&gt;
&lt;li&gt;队列中平均任务数——队列中等待被处理的任务平均数。可由公式估算”(产能利用率)2 / (1 – 产能利用率)” 。由于服务进程工作时间接近于&lt;span style=&quot;font-family: Verdana;&quot;&gt;100%&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，导致队列大小成指数级增长。&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;排队时间百分比——相对于任务的整个周期时间来说，在队列中时间的所占百分比。它的值约等于产能利用率。这是一个非常值得注意的现象：如果你的系统产能负载率达到&lt;span style=&quot;font-family: Verdana;&quot;&gt;95%&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，那么对每个任务来说，它的整个生命周期有&lt;/span&gt;&lt;span style=&quot;font-family: Verdana;&quot;&gt;95%&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的时间都将会在排队中度过。&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;增加额外产能&lt;/h2&gt;
&lt;p&gt;如果我们能将服务过程和到达过程的资源匹配程度做一些变化，那么这些数据看起来就会大有不同。&lt;/p&gt;
&lt;p&gt;例如，如果我们给服务过程增加额外产能，那么上文提到的麻烦就会减弱不少：排队时间所占百分比下降，而且服务进程能很轻松的应对系统负载。即使发生了卡顿的情况，也可以很快清理这种问题。&lt;/p&gt;
&lt;p&gt;不过，随之而来的问题是产能利用率下降了。当排队时间降低，产能利用率也会随之降低。我们会多出许多闲置的资源：&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8b2fc3686acb18f9779159bb9ce787ae.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;(原图为交互图，可在原文查看)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同时兼有较高产能利用率和较少排队时间的情况几乎是不太可能出现的。在上面的模拟情境中，我们对服务频率和到达频率做出的不同组合，通常会出现要么产能利用率过低要么排队时间太长的情况。当然，由于过程的随机性，我们偶尔也会得到幸运之神的光顾。不过仅靠运气不是长远之计。&lt;/p&gt;
&lt;h2&gt;消除可变性&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;如果你处于这样一种困境——由于可变队列中排队时间与产能利用率不可兼得，从而无法达到预期目标。&lt;/span&gt;那么或许尝试去消除过程中的随机性会有所帮助？&lt;/p&gt;
&lt;p&gt;当然， 说起来容易做起来难。怎样保证准确预测到达请求呢？你能控制客户的到来或者控制&lt;span style=&quot;font-family: Verdana;&quot;&gt;http&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;请求吗？你该怎样安排工作任务从而使得每个任务花费时间是确定的呢？这些事情听起来挺吸引人，但是事实上很难以实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而且在某些情况下，消除可变性甚至可能是不可取的。Reinertsen在他的书中就断言：无论 Six Sigma 之类的工具怎么说，在产品研发中，你无法完全的消除可变性，甚至实际上你也并不会想要完全消除它。你可以通过一些技术手段来限制可变性带来的后果，比如说用一种可变性来替换另一个。在投入与回报不对等的情况下，你甚至可以使得可变性给你带来利益——当可变性带来当成功的价值远远高于失败的成本时。&lt;/p&gt;
&lt;p&gt;但是，即使你有能力而且同时也想要消除可变性，队列又会发生怎样的变化？&lt;/p&gt;
&lt;h3&gt;确定的到达过程&lt;/h3&gt;
&lt;p&gt;从下图可以看出，即使我们完全消除到达过程的不确定性，使得每个任务的到达时间是确定的，排队现象也依然会出现，除非服务过程有明显的产能过剩才不会产生排队。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4a68efff2417e47fce1cebcff4dbdf58.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;(原图为交互图，可在原文查看)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;确定的服务过程&lt;/h3&gt;
&lt;p&gt;如果我们双方互换，使得服务过程确定（这种情形在现实世界中很容易想象出来），如下图：&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5d2441929ee55eed45aa62cf0124f443.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;(原图为交互图，可在原文查看)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;看来只降低或消除某一个过程的不确定性并不能解决我们的问题。可能问题的严重性是降低了，但是相应的我们付出的代价是多少？&lt;/p&gt;
&lt;p&gt;实际上，可变性与队列大小之间的关系是线性的（然而产能利用率和队列大小是指数级的关系）。如果你只在单方面完全消除可变性，你所能期待的结果也仅仅是排队数减半而已。&lt;/p&gt;
&lt;h3&gt;完全确定的队列&lt;/h3&gt;
&lt;p&gt;只有我们将服务过程和到达过程的不确定性都完全消除，我们才能获取真正想要的成功——&lt;span style=&quot;font-family: Verdana;&quot;&gt;100%&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的产能利用率并且排队时间为&lt;/span&gt;&lt;span style=&quot;font-family: Verdana;&quot;&gt;0.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7ad27a1f4074d18db576287de7e48c49.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;(原图为交互图，可在原文查看)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然而，在现实世界中出现排队的情况下——当然是人参与的那种排队，这种完全确定的过程超出我们的能力范围。同时就像之前讨论的那样，在某些产品设计研发的活动中，我们也并不想要这种完全确定的过程。&lt;/p&gt;
&lt;h2&gt;限制在制品数量&lt;/h2&gt;
&lt;p&gt;若队列大小和产能利用率之间存在指数级的关系，那么如果我们选择限制队列大小，或者换句说话，我们对在制品数量做限制呢？排队时间和产能利用率又会发生怎样的变化？&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/31146bb9b8b0568d1063482927c19b10.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;(原图为交互图，可在原文查看)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这似乎是一个合理有效的策略。如果我们对频繁的到达过程做出比较严格的&lt;span style=&quot;font-family: Verdana;&quot;&gt;WIP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;限制，就能很有效的打破产能利用率和队列大小之间的指数关系。我们可以高负荷运转，同时任务的排队时间也比较短。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然，这样做的代价是得拒绝一些到达的请求。对在制品数目作出限制的情况下，我们只能选择丢弃一些到达的请求任务，不对这些请求做处理。对于这些HTTP&lt;span style=&quot;font-family: 宋体;&quot;&gt;请求只能返回一个网关超时的错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然，对在制品做限制的手段并不只有简单丢弃请求这一种方式。相反，这种WIP&lt;span style=&quot;font-family: 宋体;&quot;&gt;限制技术是其他更高级策略的重要构建块。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当队列大小达到上限时，你可以引入其他兼职资源从实质上支援服务过程（或者给同一队列增加额外的服务过程）。当队列大小降下来之后，你可以去掉这些额外资源。这种策略在超市中很常见，当开始出现排队的时候，就会增加收银员来收银。IT&lt;span style=&quot;font-family: 宋体;&quot;&gt;从业人员对这种情况也比较熟悉，当某项目落后于计划时，他们就会被“召唤”过去帮忙。&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;当你打算不再接新任务时可以给上游发送信号，上游过程可以停止任务或者将在制品加入成本较低的队列池中&lt;span style=&quot;color: #000000;&quot;&gt;。这种WIP&lt;span style=&quot;font-family: 宋体;&quot;&gt;信号机制是&lt;/span&gt;Eli Goldratt瓶颈理论(&lt;a href=&quot;http://en.wikipedia.org/wiki/Theory_of_constraints&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;Theory of Constraints&lt;/span&gt;&lt;/a&gt;)的基础，该理论中瓶颈的WIP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;约束用来限制整个系统的操作速度。&lt;/span&gt;它同样也是丰田制造系统（&lt;/span&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Toyota_Production_System&quot;&gt;Toyota Production System&lt;/a&gt;）中看板系统的基础，在这个系统中，过程间的在制品都在本地控制，一旦在制品数量达到上限就给上游发送信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;队列如此的普遍而又如此重要，&lt;span style=&quot;color: #000000;&quot;&gt;对它们做定量的推理以及给它们的概率系统建模就显得很有意义。&lt;/span&gt;希望在这篇文章中我给你们传达出了这种意思。&lt;/p&gt;
&lt;p&gt;鉴于这个话题的广度和深度，在文中我只做了一些简单的说明，并不完整。&lt;span style=&quot;color: #000000;&quot;&gt;可能最大的疏漏点在于忽略了排队带来的经济效益：&lt;/span&gt;听起来好像排队都是不好的并且需要将排队问题最小化。不过，这就跟简单的说“产能利用率应该最大化”一样。实际上，可以基于经济决策来对队列大小和产能利用率做出权衡。如果你能从相同的角度来量化这二者的成本，你就可以做出这样的决策。&lt;/p&gt;
&lt;p&gt;这一点，以及队列的其他方面，可变性，在制品等概念都在这本书《产品开发过程原理》（&lt;a href=&quot;http://www.amazon.com/The-Principles-Product-Development-Flow/dp/1935401009&quot;&gt;The Principles of Product Development Flow&lt;/a&gt;）中涵盖了，如果各位对这些话题感兴趣的话，我真心推荐你们阅读这本书。&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87158&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87158votetotal&quot;&gt;2&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87158&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt; 2 评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者：&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/fengzhixun&quot;&gt;巽离&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/fengzhixun&quot;&gt;
			&lt;img src=&quot;/images/jobbole.com/4d8ad0b6e65624d1c18aac0963063eaf.jpg&quot;&gt;
		&lt;/a&gt;
	&lt;/div&gt;

    &lt;div class=&quot;author-bio-info&quot;&gt;

        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            坐标北京， linux应用程序开发，家乡安徽巢湖。@饕餮巽离        &lt;/span&gt;
        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            &lt;a href=&quot;http://www.jobbole.com/members/fengzhixun&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 个人主页&lt;/a&gt; ·
            &lt;a href=&quot;http://blog.jobbole.com/author/fengzhixun/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;/i&gt; 我的文章&lt;/a&gt; ·
            &lt;a title=&quot;声望值&quot; target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/fengzhixun/reputation/&quot;&gt;&lt;i class=&quot;fa fa-graduation-cap&quot;&gt;&lt;/i&gt; 11&lt;/a&gt;        &lt;/span&gt;
    &lt;/div&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Fri, 29 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-29-87158-45c4542f0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-29-87158-45c4542f0.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>林仕鼎：系统架构领域的一些学习材料</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;系统架构是一个工程和研究相结合的领域，既注重实践又依赖理论指导，入门容易但精通很难，有时候还要讲点悟性，很具有“伪科学”的特征。要在此领域进阶，除了要不断设计并搭建实际系统，也要注意方法论和设计理念的学习和提炼。&lt;/p&gt;
&lt;p&gt;经常有同学询问如何学习，特贴一篇学习材料，供大家参考。09年时写的，在系统领域浩如烟海的文献中提取了一些我认为值得研究和学习的项目，没包括近几年出现的一些工作，也不够全面。不过，其实也足够了，看paper是一个从少到多再到少的过程。对问题本质、背景和发展历史有大致了解，再辅以hands-on的实践（长期的真正的实践），足以摸到本领域的门径。&lt;/p&gt;
&lt;p&gt;此文在网上转载不少，但多数没有说明出处。今天在这里重发，也顺便向315致敬。&lt;/p&gt;
&lt;p&gt;—&lt;/p&gt;
&lt;p&gt;对于工程师来说，到一定阶段后往往会遇到成长瓶颈。要突破此瓶颈，需要在所属技术领域更深入学习，了解本领域的问题本质、方法论与设计理念、发展历史等。以下提供一些架构相关领域的学习材料，附上简单点评，供有兴趣的工程师参考。希望大家能通过对这些领域的了解和学习，掌握更多system design principles，在自己的工作中得心应手，步入自由王国。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Operating Systems&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mach&lt;/strong&gt; [Intro: &lt;a href=&quot;http://www-2.cs.cmu.edu/afs/cs/project/mach/public/www/mach.html&quot;&gt;http://www-2.cs.cmu.edu/afs/cs/project/mach/public/www/mach.html&lt;/a&gt;,Paper: &lt;a href=&quot;http://www-2.cs.cmu.edu/afs/cs/project/mach/public/www/doc/publications.html&quot;&gt;http://www-2.cs.cmu.edu/afs/cs/project/mach/public/www/doc/publications.html&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;传统的kernel实现中，对中断的响应是在一个“大函数”里实现的。称为大函数的原因是从中断的入口到出口都是同一个控制流，当有中断重入发生的时候，实现逻辑将变得非常复杂。大多数的OS，如UNIX，都采用这种monolithic kernel architecture。&lt;/p&gt;
&lt;p&gt;1985年开始的Mach项目，提出了一种全新的microkernel结构，使得由于70年代UNIX的发展到了极致而觉得后续无枝可依的学术界顿时找到了兴奋点，也开始了沸沸扬扬的monokernel与microkernel的争论。&lt;/p&gt;
&lt;p&gt;插播一个花絮：Mach的主导者Richard Rashid，彼时是CMU的教授，受BillGates之托去游说JimGray加盟MS。结果把自己也被绕了进来，组建了Microsoft Research。他到中国来做过几次21Century Computing的keynotes。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exokernel&lt;/strong&gt;  [Intro:&lt;a href=&quot;http://pdos.csail.mit.edu/exo/&quot;&gt;http://pdos.csail.mit.edu/exo/&lt;/a&gt;，Paper:&lt;a href=&quot;http://pdos.csail.mit.edu/PDOS-papers.html#Exokernels&quot;&gt;http://pdos.csail.mit.edu/PDOS-papers.html#Exokernels&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;虽然microkernel的结构很好，但实际中并没有广泛应用，因为performance太差，而且大家逐渐发现OS的问题并不在于实现的复杂性，而更多在于如何提高application使用资源的灵活性。这也就是在kernel extension（例如loadable module in Linux）出现后，有关OS kernel architecture的争论就慢慢淡出人们视线的原因。&lt;/p&gt;
&lt;p&gt;Exokernel正是在这样的背景中出现的，它并不提供传统OS的abstraction（process,virtual memory等），而是专注于资源隔离与复用（resource isolation and multiplexing），由MIT提出。在exokernel之上，提供了一套库，著名的libOS，用于实现各种OS的interface。这样的结构为application提供了最大的灵活度，使不同的application可以或专注于调度公平性或响应实时性，或专注于提高资源使用效率以优化性能。以今天的眼光来看，exokernel更像是一个virtual machine monitor。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Singularity&lt;/strong&gt; [Intro:&lt;a href=&quot;http://research.microsoft.com/os/Singularity/&quot;&gt;http://research.microsoft.com/os/Singularity/&lt;/a&gt;,Paper: &lt;a href=&quot;http://www.research.microsoft.com/os/singularity/publications/HotOS2005_BroadNewResearch.pdf&quot;&gt;http://www.&lt;br&gt;
research.microsoft.com/os/singularity/publications/HotOS2005_BroadNewResearch.pdf&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;Singularity出现在virus，spyware取之不尽、杀之不绝的21世纪初期，由Microsoft Research提出。学术界和工业界都在讨论如何提供一个trust-worthy computing环境，如何使计算机系统更具有manage-ability。Singularity认为要解决这些问题，底层系统必须提供hardisolation，而以前人们都依赖的硬件virtual memory机制并无法提供高灵活性和良好性能。在.Net和Java等runtime出现之后，一个软件级的解决方案成为可能。&lt;/p&gt;
&lt;p&gt;Singularity在microkernel的基础上，通过.Net构建了一套type-safed assembly作为ABI，同时规定了数据交换的message passing机制，从根本上防止了修改隔离数据的可能。再加上对application的安全性检查，从而提供一个可控、可管理的操作系统。由于.NetCLR的持续优化以及硬件的发展，加了这些检查后的Singularity在性能上的损失相对于它提供的这些良好特性，仍是可以接受的。&lt;/p&gt;
&lt;p&gt;这种设计目前还处于实验室阶段，是否能最终胜出，还需要有当年UNIX的机遇。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Virtual Machines&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VMWare&lt;/strong&gt; [&quot;&lt;a href=&quot;http://www.usenix.org/events/osdi02/tech/waldspurger/waldspurger.pdf&quot;&gt;MemoryResource Management in VMware ESX Server&lt;/a&gt;&quot;，OSDI’02,Best paper award]&lt;br&gt;
耳熟能详的vmware，无需多说。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XEN&lt;/strong&gt;  [“&lt;a href=&quot;http://www.cl.cam.ac.uk/research/srg/netos/papers/2003-xensosp.pdf&quot;&gt;Xen and the Art of Virtualization&lt;/a&gt;”, OSDI’04]&lt;br&gt;
性能极好的VMM，来自Cambridge。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Denali&lt;/strong&gt;  [“&lt;a href=&quot;http://denali.cs.washington.edu/pubs/distpubs/papers/denali_osdi.pdf&quot;&gt;Scaleand Performance in the Denali Isolation Kernel&lt;/a&gt;”, OSDI’02, UW]&lt;br&gt;
为internetservices而设计的application level virtual machine，在普通机器上可运行数千个VMs。其VMM基于isolation kernel，提供隔离，但并不要求资源分配绝对公平，以此减少性能消耗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Entropia [“&lt;a href=&quot;http://www-csag.ucsd.edu/papers/Entropia-VM.pdf&quot;&gt;The Entropia VirtualMachine for Desktop Grids&lt;/a&gt;”, VEE’05]&lt;/strong&gt;&lt;br&gt;
要统一利用公司内桌面机器资源来进行计算，需要对计算任务进行良好的包装，以保证不影响机器正常使用并与用户数据隔离。Entropia就提供了这样的一个计算环境，基于windows实现了一个application level virtual machine。其基本做法就是对计算任务所调用的syscall进行重定向以保证隔离。类似的工作还有FVM：“&lt;a href=&quot;http://www.usenix.org/events/vee06/full_papers/p24-yu.pdf&quot;&gt;AFeather-weight Virtual Machine for Windows Applications&lt;/a&gt;”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Design Revisited&lt;/strong&gt;&lt;br&gt;
“&lt;a href=&quot;http://www.usenix.org/event/hotos05/final_papers/full_papers/hand/hand.pdf&quot;&gt;Are Virtual Machine Monitors Microkernels Done Right?&lt;/a&gt;”，HotOS’05&lt;/p&gt;
&lt;p&gt;这个题目乍听起来，十分费解，其意思是VMMs其实就是Microkernel的正确实现方法。里面详细讨论了VMM和Microkernel，是了解这两个概念的极好参考。&lt;/p&gt;
&lt;p&gt;“&lt;a href=&quot;http://www.usenix.org/events/hotos05/final_papers/full_papers/brewer/brewer.pdf&quot;&gt;Thirty Years Is Long Enough: Getting Beyond C&lt;/a&gt;”, HotOS’05&lt;/p&gt;
&lt;p&gt;C可能是这个世界上最成功的编程语言，但其缺点也十分明显。比如不支持thread，在今天高度并行的硬件结构中显得有点力不从心，而这方面则是functional programming language的长处，如何结合二者的优点，是一个很promising的领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. Programming Model&lt;/strong&gt;&lt;br&gt;
“&lt;a href=&quot;http://www.stanford.edu/class/cs240/readings/threads-bad-usenix96.pdf&quot;&gt;Why Threads Are a Bad Idea&lt;/a&gt;”&lt;/p&gt;
&lt;p&gt;单使用thread结构的server是很难真正做到高性能的，原因在于内存使用、切换开销、同步开销和保证锁正确性带来的编程复杂度等。&lt;/p&gt;
&lt;p&gt;“&lt;a href=&quot;http://www.eecs.harvard.edu/~mdw/papers/seda-sosp01.pdf&quot;&gt;SEDA: An Architecture for Well-Conditioned, Scalable Internet Services&lt;/a&gt;”，OSDI’01&lt;/p&gt;
&lt;p&gt;Thread不好，但event也没法解决所有问题，于是我们寻找一个结合的方法。SEDA将应用拆分为多个stage，不同stage通过queue相连接，同一个stage内可以启动多个thread来执行queue中的event，并且可通过反馈来自动调整thread数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Software Transactional Memory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果内存可以提供transaction语义，那么我们面对的世界将完全两样，language, compiler, OS, runtime都将发生根本变化。虽然intel现在正在做hardware transactional memory，但估计可预见的将来不会商用，所以人们转而寻求软件解决方案。可想而知，这个方案无法base在native assembly上，目前有C#,haskell等语言的实现版本。资料比较多，参见&lt;a href=&quot;http://en.wikipedia.org/wiki/Software_transactional_memory&quot;&gt;Wikipedia&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. Distributed Algorithms&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Logical clock&lt;/strong&gt;, [“&lt;a href=&quot;http://portal.acm.org/ft_gateway.cfm?id=359563&amp;amp;type=pdf&amp;amp;coll=GUIDE&amp;amp;dl=GUIDE&amp;amp;CFID=12744388&amp;amp;CFTOKEN=15273596&quot;&gt;Time,clocks, and the ordering of events in a distributed system&lt;/a&gt;”, Leslie Lamport, 1978]&lt;/p&gt;
&lt;p&gt;这是一篇关于Logic clock, time stamp, distributed synchronization的经典paper。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Byzantine&lt;/strong&gt;  [“&lt;a href=&quot;http://research.microsoft.com/users/lamport/pubs/byz.pdf&quot;&gt;The ByzantineGenerals Problem&lt;/a&gt;”, Leslie Lamport, 1982]&lt;/p&gt;
&lt;p&gt;分布式系统中的错误各种各样，有出错就能停机的，有出错了拖后腿的，更严重的是出错了会做出恶意行为的。最后的这种malicious behavior，就好像出征将军的叛变，将会对系统造成严重影响。对于这类问题，Lamport提出了Byzantine failure model，对于一个由3f+1个replica组成的statemachine，只要叛变的replica数量小于等于f，整个state machine还能正常工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Paxos [“&lt;a href=&quot;http://portal.acm.org/ft_gateway.cfm?id=279229&amp;amp;type=pdf&amp;amp;coll=GUIDE&amp;amp;dl=GUIDE&amp;amp;CFID=12744388&amp;amp;CFTOKEN=15273596&quot;&gt;The part-time parliament&lt;/a&gt;”, Leslie Lamport, 1998]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何在一个异步的分布式环境中达成consensus，这是分布式算法研究的最根本问题。Paxos是这类算法的顶峰。不过这篇paper太难了，据说全世界就3.5人能看懂，所以Lamport后来又写了一篇普及版paper：“&lt;a href=&quot;http://research.microsoft.com/users/lamport/pubs/paxos-simple.pdf&quot;&gt;Paxos Made Simple&lt;/a&gt;” ，不过还是很难懂。另外，也可参看Butler Lampson写的“&lt;a href=&quot;http://portal.acm.org/citation.cfm?id=383962.383969&amp;amp;coll=GUIDE&amp;amp;dl=GUIDE&amp;amp;CFID=12744978&amp;amp;CFTOKEN=60475496&quot;&gt;The ABCD’s of Paxos&lt;/a&gt;”（PODC’01），其中关于replicated state machine的描述会严重启发你对并行世界本质的认识，图灵奖的实力可不是盖的。&lt;/p&gt;
&lt;p&gt;这上面反复出现了一个名字：&lt;a href=&quot;http://research.microsoft.com/users/lamport/&quot;&gt;Leslie Lamport&lt;/a&gt;，他在distributed computing这个领域挖坑不辍，终成一代宗师。关于他，也有几则轶事。记得以前他在MSR的主页是这么写的，“当我在研究logicalclock的时候，BillGates还穿着开裆裤(in diaper)…”（大意如此，原文现在找不到了）。另外，他在写paper的时候，很喜欢把其他牛人的名字变换一下编排进去。这可能也是他还没拿到图灵奖的原因。[注1]&lt;/p&gt;
&lt;p&gt;关于Lamport的其他成就，还可以参见这篇向他60岁生日献礼的paper：“&lt;a href=&quot;http://portal.acm.org/ft_gateway.cfm?id=383967&amp;amp;type=pdf&amp;amp;coll=GUIDE&amp;amp;dl=GUIDE&amp;amp;CFID=12744388&amp;amp;CFTOKEN=15273596&quot;&gt;Lamport on mutual exclusion: 27 years of planting seeds&lt;/a&gt;”, PODC’01。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. Overlay Networking, and P2P DHT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RON&lt;/strong&gt;  [“&lt;a href=&quot;http://nms.lcs.mit.edu/papers/ron-sosp2001.html&quot;&gt;Resilient Overlay Networks&lt;/a&gt;”, SOSP’01]&lt;/p&gt;
&lt;p&gt;RON描述了如何在应用层搭建一个overlay，以提供秒级广域网网络层故障恢复速度，而现有的通过路由协议来恢复通信的时间至少在几十分钟。这种快速恢复特性和灵活性使得overlay networking现在被广泛应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Application Level Multicast&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“&lt;a href=&quot;http://www.cs.cmu.edu/~hzhang/papers/sigmetrics-2000.ps.gz&quot;&gt;End System Multicast&lt;/a&gt;”, SigMetrics’00&lt;/p&gt;
&lt;p&gt;“&lt;a href=&quot;http://pages.cs.wisc.edu/~suman/pubs/sigcomm02.pdf&quot;&gt;Scalable Application Layer Multicast&lt;/a&gt;”, SigComm’02&lt;/p&gt;
&lt;p&gt;关于ALM的paper很多，基本上都是描述如何搭建一个mesh network用以鲁棒的传输控制信息，另外再搭建一个multicast tree用以高效传输数据，然后再根据多媒体数据的特点做一些layered delivery。前几年出现的coolstream, pplive等系统都是这类系统的商业化产品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P2P&lt;/strong&gt;&lt;br&gt;
P2P的出现改变了网络。按照各种P2P网络的结构，可以分为三种。&lt;br&gt;
1. Napster式，集中式目录服务，数据传输Peer to peer。&lt;br&gt;
2. Gnutella式，通过在邻居间gossip来查询，也被称为unstructured P2P。&lt;br&gt;
3. DHT，与unstructured P2P不同的是，DHT进行的查询有保证，如果数据存在，可在一定的hop数内返回。这个hop数通常为logN，N为系统节点数。&lt;/p&gt;
&lt;p&gt;典型的DHT有&lt;a href=&quot;http://berkeley.intel-research.net/sylvia/cans.pdf&quot;&gt;CAN&lt;/a&gt;, &lt;a href=&quot;http://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf&quot;&gt;Chord&lt;/a&gt;,&lt;a href=&quot;http://research.microsoft.com/~antr/PAST/pastry.pdf&quot;&gt;Pastry&lt;/a&gt;, &lt;a href=&quot;http://oceanstore.cs.berkeley.edu/publications/papers/pdf/tapestry_sigcomm_tr.pdf&quot;&gt;Tapestry&lt;/a&gt;等四种。这些研究主要在算法层面，系统方面的工作主要是在其上建立广域网存储系统。还有一些人在机制层面进行研究，例如如何激励用户共享、防止作弊等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. Distributed Systems&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GFS/MapReduce/BigTable/Chubby/Sawzall&lt;/strong&gt;&lt;br&gt;
Google的系列paper，大家比较熟悉，不再多说。在此可查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Storage&lt;/strong&gt;&lt;br&gt;
Distributed storage system的paper太多了。下面列出几篇最相关的。&lt;/p&gt;
&lt;p&gt;“&lt;a href=&quot;http://www.cs.cornell.edu/fbs/publications/chainreplicosdi.pdf&quot;&gt;Chain Replication for Supporting High Throughput and Availability&lt;/a&gt;”, OSDI’04。&lt;/p&gt;
&lt;p&gt;“&lt;a href=&quot;http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf&quot;&gt;Dynamo: Amazon’s Highly Available Key-value Store&lt;/a&gt;”，SOSP’07。&lt;/p&gt;
&lt;p&gt;“&lt;a href=&quot;http://research.microsoft.com/asia/dload_files/group/system/2007/BitVault-SigOpsOSR0704.pdf&quot;&gt;BitVault: a Highly Reliable Distributed Data Retention Platform&lt;/a&gt;”, SIGOPS OSR’07。&lt;/p&gt;
&lt;p&gt;“&lt;a&gt;PacificA: Replication inLog-Based Distributed Storage Systems&lt;/a&gt;”, MSR-TR。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Distributed Simulation&lt;/strong&gt;&lt;br&gt;
“&lt;a href=&quot;http://research.microsoft.com/asia/dload_files/group/system/wids-mascots.pdf&quot;&gt;Simulating Large-Scale P2P Systems with the WiDS Toolkit&lt;/a&gt;”, MASCOTS’05。Distributed simulation有意思的地方是simulated protocol是distributed的，而这个simulation engine本身也是distributed的。Logical和physical的time和event交杂在系统中，需要仔细处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. Controversial Computing Models&lt;/strong&gt;&lt;br&gt;
现在的软件系统已经复杂到了人已经无法掌握的程度，很多系统在发布时都仍然带着许多确定性(deterministic)或非确定性(non-deterministic)的bugs，只能不断的patch。既然作为人类，不够精细的特性决定了我们无法把系统的bug fix干净，我们只能从其他角度入手研究一种让系统在这令人沮丧的环境中仍能工作的方法。这就像一个分布式系统，故障无法避免，我们选择让系统作为整体来提供高可靠性。&lt;/p&gt;
&lt;p&gt;以下3个便是典型代表。基本上，主要研究内容都集中于1) 如何正确保存状态；2)如何捕捉错误并恢复状态；3)在进行单元级恢复时，如何做到不影响整体。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://roc.cs.berkeley.edu/&quot;&gt;Recovery Oriented Computing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cag.lcs.mit.edu/~rinard/paper/osdi04.pdf&quot;&gt;Failure oblivious computing&lt;/a&gt;, OSDI’04&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://opera.cs.uiuc.edu/paper/Rx-SOSP05.pdf&quot;&gt;Treating Bugs as Allergies&lt;/a&gt;, SOSP’05&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9. Debugging&lt;/strong&gt;&lt;br&gt;
系统很复杂，人类无法从逻辑上直接分析，只能通过data mining的方法在宏观上进行观察。&lt;br&gt;
Black box debugging[“&lt;a href=&quot;http://pdos.csail.mit.edu/~athicha/papers/blackboxes:sosp03.pdf&quot;&gt;Performance debugging for distributed systems of black boxes&lt;/a&gt;”, SOSP’03]&lt;br&gt;
对大型系统的performance debugging非常困难，因为里面的问题很多都是非确定性的，而且无法重现。只能通过对log的挖掘，找出配对的调用/消息以定位问题。&lt;/p&gt;
&lt;p&gt;CP-miner [“A Tool for Finding Copy-paste and Related Bugs in Operating System Code”, OSDI’04]&lt;br&gt;
很多人在重用代码的时候，都使用copy-paste。但有时候简单的CP会带来严重的问题，例如局部变量的重名等。CP-miner通过分析代码，建立语法树结构，然后mine出这类错误。&lt;/p&gt;
&lt;p&gt;—&lt;/p&gt;
&lt;p&gt;注1：2014年3月19日，Lamport获得2013年度图灵奖，也是Microsoft Research的第5位图灵奖获得者。一代宗师，实至名归，功德圆满，可喜可贺。&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87194&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87194votetotal&quot;&gt;2&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87194&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 28 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-28-87194-29f8034d0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-28-87194-29f8034d0.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>SQL on Hadoop 的真相（2）</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;这是一组系列博客，目的是详尽介绍 SQL-on-Hadoop 。&lt;a href=&quot;http://blog.jobbole.com/86710/&quot; target=&quot;_blank&quot;&gt;该系列的第一篇会介绍一些存储引擎和在线事务处理（简称 OLTP ）相关话题&lt;/a&gt;，这一篇将介绍联机分析处理（简称 OLAP ），第三篇将介绍对 Hadoop 引擎改造以及在相关替代产品中如何选型等话题。&lt;/p&gt;
&lt;h3&gt;数据处理与联机分析处理 ( OLAP )&lt;/h3&gt;
&lt;p&gt;联机分析处理是那些为了支持商业智能，报表和数据挖掘与探索等业务而开展的工作。这类工作的例子有零售商按地区和季度两个维度计算门店销售额，银行按语言和月份两个维度计算手机银行装机量，设备制造商定位有哪些零部件的故障率比期望值高，以及医院研究有哪些事件会引起高危婴儿紧张等。&lt;/p&gt;
&lt;p&gt;如果原始数据来源于 OLTP 系统，典型的做法是将这些数据拷贝到 OLAP 数据库中，再进行这类“离线”分析任务的处理，这么做有很多原因，但考虑最多的还是性能因素。&lt;/p&gt;
&lt;p&gt;假设一下，如果一个实体店使用他们的事务处理系统来承担数据分析工作，这种情况下分析师提交的粗暴查询就可能会实实在在地影响并拉低门店对于那些已经记录在册等待结算的订单结算率。另外用于事务中的查询类型从根本上就不同于数据分析类查询。&lt;/p&gt;
&lt;p&gt;事务系统典型的查询是基于某个独立的实体，比如某一个客户或某一个用户。例如当一个在线零售网站创建一个交易订单状态页时，数据的查询是针对某一个客户已经提交的特定订单。然而在数据分析的用例中，分析师最感兴趣的却是那些根据时间维度划分查询本身已跨越了订单或用户数据的汇总信息。就如前面提到的那样，根据区域和季度两个维度统计的门店销售额会查询给定时间段内所有订单数据。&lt;/p&gt;
&lt;p&gt;行动之前还有最后一个注意要点，本篇中的数据库并不提供传统关系型数据库用户所期望的那类增删改操作。与事务系统不同的是，分析类型的查询主要是那些涉及到数百万甚至数亿行数据的 SELECT 查询。分析型数据库的优化也主要围绕着这类负载进行，而这些优化措施却会导致针对小批量数据的增删改操作执行起来代价昂贵。&lt;/p&gt;
&lt;p&gt;即便这类数据库在接口和语义方面都与关系型数据库不同，但他们也确实提供了增加行 （ INSERT ），更新行（ UPDATE ）和删除行（ DELETE ）操作的功能支持。有些读者或许正在问 Hive 系统里最近新增加的 “ ACID ” 相关的问题，容后详禀。&lt;/p&gt;
&lt;p&gt;在 Hive 系统的 “ACID” 功能之外，处理更新操作有两种方式可选，一种是使用数据所在的 HBase 系统本身提供的更新功能。尽管 HBase 经常主要用于 OLTP 业务，但有些 OLAP 系统会使用 HBase 来存储一些小表，典型的称为维度表，这类表需要周期性地更新。第二种处理更新操作的方式是执行一次合并操作。&lt;/p&gt;
&lt;p&gt;从一个 ETL 开发者角度出发，一个合并过程会引入额外工作量。因此有个问题一定会被问到，那就是既然 HBase 系统已经提供了更新功能，那这类合并工作就不是必须的，那为什么不直接都用 HBase 呢？原因是扫描查询的处理性能，如果要在基于尾部追加模式的 HDFS 文件系统提供随机更新的功能，HBase 就得在它读取每一行时都做少量的合并操作，这个架构决定了能提供较高的写和随机读性能，但与 HDFS 相比，只能提供较差的扫描查询和顺序读操作性能。这样一来 HBase 就只能用于存储那些需要频繁更新的小表场合；&lt;/p&gt;
&lt;p&gt;这个领域包含几个子目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apache Hive&lt;/li&gt;
&lt;li&gt;Dremel clones&lt;/li&gt;
&lt;li&gt;Spark SQL&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Apache Hive&lt;/h3&gt;
&lt;p&gt;本项目最初由脸谱公司创建，Hive 是第一个基于 Hadoop 之上的 SQL 引擎，且至今仍是最成熟的。Hive 原先是构建在MapReduce之上的，也曾经被改造过以便运行在 Apache Tez 上，现在正在进行的是为适应 Apache Spark 而进行的改造，基于 Spark 的Hive 改造被称为是最后的工作，但不能与 Spark 项目上的其他 SQL 支持项目相互混淆，关于 Spark 上的其他 SQL 支持项目我会再找个合适时机进行讨论。&lt;/p&gt;
&lt;p&gt;到目前为止，Hive 拥有最完整的 SQL 功能支持，并且也是拥有最多贡献者的项目，几乎所有的 Hadoop 用户都会部署Hive，同时几乎 Hadoop 上其他 SQL 引擎使用者也都会部署 Hive ，事实上大多数 SQL 引擎都以这种或那种方式依赖于Hive 。&lt;/p&gt;
&lt;p&gt;大多数 Hadoop 赞助商，包括 Cloudera 和 Hortonworks，都一致认同 Hive 是唯一有能力处理大批量任务和集成多种非标准数据格式的组件。Hortonworks 与 Cloudera 意见相左的地方在于对 Hive 的性能评价，Clourdera 觉得 Hive 的性能简直不能与 Dremel clones 相比，而 Hortonworks 则觉得 Hive 可以和 Dremel Clones 一较高下。&lt;/p&gt;
&lt;h3&gt;Dremel Clones&lt;/h3&gt;
&lt;p&gt;就像开源界一样，谷歌内部也创立了多个 SQL 引擎，他们有一个类似于 Hive 的 SQL 引擎叫 Tenzing，还有另外一个系统叫 Dremel。Hive 的创立者 Facebook 公司也创建了一个 Dremel 的克隆版本叫 Presto。&lt;/p&gt;
&lt;p&gt;Cloudera Impala 和 Apache Drill 是最杰出的两个 Dremel 克隆版本，Cloudera 将 Impala 市场定位为最成熟的开源 Dremel 分支，Impala 在2013年年中发布 GA 版本，MapR 是 Drill 背后的主要赞助商，他把 Drill 的市场角色定位为最灵活的 Dremel 分支， Impala 能满足在 Hive 系统中存储元数据表的需求，而 Drill 可以直接查询 JSON 和自定义格式文件，比如 Apache Parquet 和 Avro 文件格式等。&lt;/p&gt;
&lt;h3&gt;Spark SQL&lt;/h3&gt;
&lt;p&gt;尽管有 Hadoop 上有其他多个 SQL 引擎，但 Spark SQL 却有着对其感兴趣的最广泛受众。Spark SQL 是 Spark 引擎上的榜眼，而状元是 Shark， Shark 因为顾及 Spark SQL 和 Hive on Spark 项目，Shark 目前已经终止开发，与 Shark 项目曾近是加州伯克利大学的一个研究项目不同，Spark SQL 和 Hive on Spark 已经在 Spark 赞助商们的支持下建立了各自的开源项目；&lt;/p&gt;
&lt;p&gt;基于 Spark 的 Hive 可以简单地说成是前端是 Hive 后端是 Spark ，基于 MR 或 Tez 的 Hive 既有用户可以在原系统与 Hive on Spark 系统之间轻松切换，切换工作仅仅只需要简单地修改下配置参数。&lt;/p&gt;
&lt;p&gt;Spark SQL 是一个完整的新引擎，今天的 Spark SQL 对那些希望把 SQL 嵌入到他们的 Scala，Java 或者 Python 程序的Spark 开发者而言是最有用的，但 Spark SQL 的主要赞助商 Databricks 对 Spark SQL 还有着更大的雄心，并指望将 Spark SQL 的使用范围扩展到非 Spark 开发者中去；&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87159&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87159votetotal&quot;&gt;&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87159&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者：&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/sunny4715&quot;&gt;jerry&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/sunny4715&quot;&gt;
			&lt;img src=&quot;/images/jobbole.com/4d8ad0b6e65624d1c18aac0963063eaf.jpg&quot;&gt;
		&lt;/a&gt;
	&lt;/div&gt;

    &lt;div class=&quot;author-bio-info&quot;&gt;

        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            西电通信工程本硕；熟悉监控设备SDK和流媒体服务器；原MySQL/NTSE内核组开发人员，熟悉MySQL内核与架构以及运维调优；现杭州某公司...        &lt;/span&gt;
        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            &lt;a href=&quot;http://www.jobbole.com/members/sunny4715&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 个人主页&lt;/a&gt; ·
            &lt;a href=&quot;http://blog.jobbole.com/author/sunny4715/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;/i&gt; 我的文章&lt;/a&gt; ·
            &lt;a title=&quot;声望值&quot; target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/sunny4715/reputation/&quot;&gt;&lt;i class=&quot;fa fa-graduation-cap&quot;&gt;&lt;/i&gt; 10&lt;/a&gt;        &lt;/span&gt;
    &lt;/div&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 28 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-28-87159-b9487b125.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-28-87159-b9487b125.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我用 Go 语言做了一个红白机模拟器</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;译注：Family Computer（简称 FC）是任天堂（Nintendo）公司发行的家用游戏主机。日版 FC 机身以红色和白色为主，因此在华人圈中又有“红白机”的俗称；欧美版 FC 在欧美则称 Nintendo Entertainment System（简称 NES）。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/bae393881c2ab1e2a30102da727eb1b2.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;（游戏截图）&lt;/p&gt;
&lt;p&gt;最近我编写了一个 &lt;a title=&quot;FC 模拟器&quot; href=&quot;https://github.com/fogleman/nes&quot;&gt;FC 模拟器&lt;/a&gt;。制作这样一个模拟器主要是出于兴趣以及为了从中学习 FC 的工作原理。在这个过程中我学到了很多有趣的知识，于是写下这篇文章同诸位分享我所学到的内容。由于相关的文档已经有很多了，所以这里我只打算讲述一些有趣的特性。请注意，接下来都将是些技术方面的内容。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e37c04debfb4a37dfc1f83cca346f793.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;图1 我的模拟器可以将画面录制成 GIF。这是我正在玩《大金刚》（Donkey Kong）的画面。&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;CPU&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;FC 使用 MOS 6502（主频1.79MHz）作为其CPU。6502 是一枚诞生于 1975 年（距今已有 40 年之久了）的 8位微处理器。在当时这款芯片非常流行，不仅应用于 FC，还被广泛应用于雅达利 2600 &amp;amp; 800、Apple I &amp;amp; II、Commodore 64、VIC-20、BBC Micro等机器上。事实上，直到今天6502的修订版（&lt;a title=&quot;65C02&quot; href=&quot;http://en.wikipedia.org/wiki/WDC_65C02&quot;&gt;65C02&lt;/a&gt;）还依然在生产。&lt;/p&gt;
&lt;p&gt;6502 的寄存器相对较少，只有寄存器 A、 X 和 Y ，而且它们都是专用寄存器。尽管如此，其指令却有多种寻址模式。这其中包括一种称为“零页”（Zero Page）的寻址模式，使开发人员可以访问内存中最初的256个字（$0000～ $00FF）。6502 的操作码占用的程序内存较少，执行时花费的 CPU 周期也较短。这样理解，&lt;span style=&quot;color: #000000;&quot;&gt; 开发人员可以把零页上的 256 个存储单元看作是 256 个寄存器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6502 中没有乘法和除法指令，当然也没有浮点数运算指令。虽然有 BCD 码模式，但是在 FC 版的6502中，可能是由于专利问题该模式被禁用了。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;译注：Binary-Coded Decimal，简称BCD，中国大陆称BCD码或二-十进制编码，是一种十进制的数字编码形式。在这种编码下，每个十进制数字用一串单独的二进制比特来存储表示。通常 4 个二进制数表示 1 个十进制数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6502 还具有一块不带溢出检测的 256 字节的栈空间。&lt;/p&gt;
&lt;p&gt;6502 拥有 151 条指令（理论上有 256 条指令）。剩余的 105 条都是非法或没有文档的指令，多数会使导致处理器崩溃。但是其中也有一些可能会碰巧产生某种作用，于是大部分这样的指令也会有与其作用相应的名称。&lt;/p&gt;
&lt;p&gt;6502 至少有一个已知的硬件上的缺陷，例如间接跳转指令的缺陷在于，当 &lt;code style=&quot;font-style: inherit;&quot;&gt;JMP &amp;lt;addr&amp;gt;&lt;/code&gt; 指令的操作数为形如 $xxFF 的地址时就无法正常工作。因为当从这样的地址读出 2 字节的数据时，该指令无法将低字节 FF 加 1 后（FF -&amp;gt; 00）产生的进位加到高字节上。例如，当从 $10FF 读出2字节的数据时，读取的其实是 $10FF 和 $1000 中的数据，而不是 $10FF 和 $1100 中的数据。&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;内存映射&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;6502 拥有 16 位地址空间，寻址能力为 64 KB。但是 FC 实际只有 2 KB的 RAM（Internal RAM），对应的地址范围是 $0000～$0799。而剩余的地址空间则用于访问 PPU、 APU、游戏卡以及输入设备等。&lt;/p&gt;
&lt;p&gt;6502 上有些地址总线的引脚并没有布线，所以有很大的一块内存空间实际上都映射到了之前的空间。例如 RAM 中的 $1000～$17FF 就映射到了 $0000～$07FF，这意味着向 $1000 写数据等价于向 $0000 写数据。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4eb364704ef254c1a2b215517a69bebf.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;图2 “IT’S DANGEROUS TO GO ALONE! TAKE THIS.”（《塞尔达传说》中的游戏对白）&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;PPU（图形处理器）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;PPU 为 FC 生成视频输出。与 CPU 不同，PPU 芯片是为 FC 定制的，其运行频率是 CPU 的 3 倍。渲染时 PPU 在每个周期输出1个像素。&lt;/p&gt;
&lt;p&gt;PPU 能够渲染游戏中的背景层和最多 64 个子画面（Sprite）。子画面可以由 8 x 8 或 8 x 16 像素构成。而背景则既可以延水平（X轴）方向卷动，又可以延竖直（Y轴）方向卷动。并且 PPU 还支持一种称为微调（Fine）的卷动模式，即每次只卷动 1 像素。&lt;span style=&quot;color: #000000;&quot;&gt;这种卷动模式在当年可是非常了不起的技术。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;背景和子画面都是由 8 x 8 像素的图形块（Tile）构成的，而图形块是定义在游戏卡 ROM 中的 Pattern Table 里的。Pattern Table 中的图形块仅指定了其所用颜色中的最后 2 比特，剩余的 2 比特来自 Attribute Table。Nametable 则指定了图形块在背景上的位置。总之，这一切看起来都要比今天的标准复杂得多，所以我不得不和合作者解释说“这不是简单的位图”。&lt;/p&gt;
&lt;p&gt;背景的分辨率为 32 x 30 = 960 像素，由 8 x 8 像素的图形块构成。背景卷动的实现方法是再额外渲染多幅 32 x 30 像素的背景，且每幅背景都加上一个偏移量。如果同时沿 X 轴和 Y 轴卷动背景，那么最多可以有 4 幅背景处于可见状态。但是 FC 只支持 2 幅背景，因此游戏中经常使用不同的镜像模式（Mirroring Mode）来实现水平镜像或竖直镜像。&lt;/p&gt;
&lt;p&gt;PPU 包含 256 字节的 OAM（Object Attribute Memory）用于存储全部 64 个子画面的属性。属性包括子画面的 X 和 Y 坐标、对应的图形块编号以及一组标志位。在这组标志位中，有 2 比特用于指定子画面的颜色，还有用于指定子画面是显示在背景层之前还是之后，是否允许沿水平和/或竖直方向翻转子画面的标志位。FC 支持 DMA 复制，可以快速地将 256 字节从 CPU 可寻址的某段内存&lt;span style=&quot;color: #888888;&quot;&gt;（译注：通常是 $0200 – $02FF）&lt;/span&gt;填充到整个 OAM。像这样直接访问比手工逐字节拷贝大约快 3 倍左右。&lt;/p&gt;
&lt;p&gt;虽然 PPU 支持 64 个卡通图形，但是在一条扫描线（Scan Line）上只能显示 8 个子画面。当一条扫描线上有过多的子画面时，PPU 的溢出（Overflow）标志位将被置位，程序可以依此做出相应的处理。这也就是当画面中有很多的子画面时，这些子画面会发生闪烁的原因。另外，由于一个硬件上的缺陷，会导致溢出标志位有时不能正常工作。&lt;/p&gt;
&lt;p&gt;很多游戏会使用一种叫做 mid-frame 的技术，使 PPU 可以在屏幕的一部分做一件事而在另一部分做另一件事。这项技术经常用于分屏滚动画面或刷新分数条。这需要精确的时间掐算以及对每条指令所需 CPU 周期的详细了解。实现类似这样的功能将会加大编写模拟器的难度。&lt;/p&gt;
&lt;p&gt;PPU 具有一个原始形态的碰撞检测机制。如果第 1 个（编号为0的）子画面和背景相交，那么一个标志位将会被置位，表示“子画面0 发生了碰撞”。这种碰撞在每一帧只会发生一次。&lt;/p&gt;
&lt;p&gt;FC 具有一个内置的 54 色调色板，游戏只能使用这里面的颜色。这些颜色不是 RGB 颜色，基本上只会向电视输出特定的色度（Chroma）和亮度（Luminance）信号。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/185694862d0bd047747bf4423e0e6628.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;图3 FC的调色板。&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;APU（音频处理器）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;APU 支持 5 个声道，包括 2 个方波声道，1 个三角波声道，1 个噪声声道和 1 个增量调制声道（DMC）。&lt;/p&gt;
&lt;p&gt;游戏程序需要向指定的寄存器（已映射到内存）写入数据以驱动这些声道发出声音。&lt;/p&gt;
&lt;p&gt;方波声道支持对频率和时值的控制，以及频率扫描（Frequency Sweep）和音量包络（Volume Envelope）。&lt;/p&gt;
&lt;p&gt;噪声声道可以利用线性反馈移位（Linear Feedback Shift）寄存器生成伪随机的噪声。&lt;/p&gt;
&lt;p&gt;增量调制声道（DMC）可以播放内存中的声音样本。例如在《超级马里奥3》中金属鼓的敲击声以及《忍者神龟3》中的语音“cowabunga”使用的都是DMC。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/46307fc1af8e2d1dbba3bcbb445f1043.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;图4 打气球游戏&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;内存映射器&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;预留给游戏卡的地址空间是有限的，游戏卡的程序内存（Program Memory）被限制在 32 KB，角色内存（Character Memory）被限制在 8 KB。为了突破这种限制，人们发明了内存映射器（Mapper）。&lt;/p&gt;
&lt;p&gt;内存映射器是游戏卡中的一个硬件，具有存储体空间切换（Bank Switching）的功能，以将新的程序或角色内存引入到可寻址的内存空间。程序可以通过向指向内存映射器的特定的地址写入数据来控制存储体空间的切换。&lt;/p&gt;
&lt;p&gt;不同的游戏卡实现了不同的存储体空间切换方案，所以会有十几种不同的内存映射器。既然模拟器要模拟 FC 的硬件，也就必须能够模拟游戏卡的 内存映射器。尽管如此，实际上 90% 的 FC 游戏使用的都是六种最常见的内存映射器中的一种。&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;ROM文件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;一个扩展名为 .nes 的 ROM 文件包含游戏卡中的一个或多个程序内存 Bank 和角色内存 Bank。除此之外还有一个简单的头部用于说明游戏中使用了哪种 Mapper 和视频镜像模式，以及是否存在带蓄电池后备电源的 RAM。&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;结尾&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;学习 FC 很有意思，当时的人们能够用如此有限的硬件完成这样一款游戏机给我留下了深刻的印象。接下来我都想开始编写一个 8 比特风格的游戏了。&lt;/p&gt;
&lt;p&gt;我用 Go 语言编写了我的模拟器，用 OpenGL 和 GLFW 处理视频，PortAudio 处理音频。模拟器的代码都放到了 GitHub 上，欢迎诸位下载：&lt;a href=&quot;https://github.com/fogleman/nes&quot;&gt;https://github.com/fogleman/nes&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/deb084b22d8e8a0c9b86a566aecf68e2.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;图5 我的最爱：《超级马里奥3》&lt;/p&gt;
&lt;h3&gt;了解更多&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://nesdev.com/NESDoc.pdf&quot;&gt;NES Documentation (PDF)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.nesdev.com/w/index.php/NES_reference_guide&quot;&gt;NES Reference Guide (Wiki)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.obelisk.demon.co.uk/6502/&quot;&gt;6502 CPU Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87068&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87068votetotal&quot;&gt;4&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87068&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt; 1 收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt; 1 评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者：&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/jackalhu&quot;&gt;JackalHu&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/jackalhu&quot;&gt;
			&lt;img src=&quot;/images/jobbole.com/ca44b272678408d3e2650ac448de62da.jpg&quot;&gt;
		&lt;/a&gt;
	&lt;/div&gt;

    &lt;div class=&quot;author-bio-info&quot;&gt;

        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            热爱编程，关注设计模式，致力于提升软件开发的质量。新浪微博：@Jackal-Hu        &lt;/span&gt;
        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            &lt;a href=&quot;http://www.jobbole.com/members/jackalhu&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 个人主页&lt;/a&gt; ·
            &lt;a href=&quot;http://blog.jobbole.com/author/jackalhu/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;/i&gt; 我的文章&lt;/a&gt; ·
            &lt;a title=&quot;声望值&quot; target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/jackalhu/reputation/&quot;&gt;&lt;i class=&quot;fa fa-graduation-cap&quot;&gt;&lt;/i&gt; 11&lt;/a&gt;        &lt;/span&gt;
    &lt;/div&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 28 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-28-87068-d4c8911d3.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-28-87068-d4c8911d3.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>实时处理日均50亿会话，解析Twitter Answers的架构</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;去年我们&lt;a title=&quot;发布了Answers&quot; href=&quot;http://www.crashlytics.com/blog/launching-answers-by-crashlytics/&quot; target=&quot;_blank&quot;&gt;发布了Answers&lt;/a&gt;，至今移动社区产生了惊人的使用量，让我们感到兴奋不已。现在Answers每天处理50亿次会话，并且这个数量在持续增加。上亿设备每秒向Answers端点发送数以百万计的请求。在你已经阅读到此处的这段时间里，Answers后台收到并处理了一千万次分析事件。&lt;/p&gt;
&lt;p&gt;其中的挑战是如何利用这些信息向移动开发者提供可靠的、实时的、有实际价值的洞见（视角）去了解他们的移动应用。&lt;/p&gt;
&lt;p&gt;在高层，我们依靠 组件解耦、异步通信、在应对灾难性故障时优雅地服务降级等原则来帮助架构决策。我们使用Lambda架构将数据完整性和实时数据更新结合起来。&lt;/p&gt;
&lt;p&gt;在实践过程中，我们需要设计一个能够接收并保存事件、执行离线和实时计算且能将上述两种计算结果整合成相关信息的系统。这些行为全部都要以百万次每秒的规模执行。&lt;/p&gt;
&lt;p&gt;让我们从第一个挑战开始：接受并处理这些事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;事件接收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在设计设备-服务器通信的时候，我们的目标是：减少对电池和网络使用的影响；确保数据的可靠性；接近实时地获取数据。为了减少对设备的影响，我们批量地发送分析数据并且在发送前对数据进行压缩。为了保证这些宝贵的数据始终能够到达我们的服务器，在传输失败随机退避后以及达到设备存储达到上限时，设备会进行重传。为了确保数据能够尽快到达服务器，我们设置来多个触发器来使设备尝试发送：当程序运行于前台的时候，事件触发器每分钟触发一次；一个消息数量触发器和程序转入后台触发器。&lt;/p&gt;
&lt;p&gt;这样的通信协议导致设备每秒发送来数以万计压缩过的有效载荷。每一个载荷都包含数十条事件。为了能够可靠的、易于线性伸缩的方式去处理载荷，接收事件的服务必须极度简单。&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/0c1dc8a6fe083dcce2ac0a3f6ca51c24.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个服务使用GO语言编写，这个服务使用了亚马逊弹性负载均衡器（ELB），并将每一个消息负荷放入一个持久化的Kafka队列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kafka是一个持久存储器，因为它把收到的消息写入磁盘并且每个消息都有多份冗余。因此一旦我们知道信息到了&lt;a title=&quot;kafka&quot; href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot;&gt;Kafka&lt;/a&gt;队列，我们就可以通过延迟处理、再处理来容忍下游延迟和下游失败。然而，Kafka不是我们历史数据的永久真理之源——按照上文提到的速度，仅仅是几天的数据，我们也需要数以百计的box来存储。因此我们把Kafka集群配置为将消息只保留几个小时（这些时间足够我们处理不期而至的重大故障）并且将数据尽快地存入永久存储——亚马逊简易存储服务（Amazon S3）。&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/6556de24d546f0ebc4871ac2a50b3cc5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们广泛地使用&lt;a title=&quot;storm&quot; href=&quot;https://storm.apache.org/&quot; target=&quot;_blank&quot;&gt;Storm&lt;/a&gt;来进行实时数据处理，第一个相关的Topology就是从Kafka读取信息并存储到Amazon S3上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;批量计算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦这些数据存到了S3上，我们可以使用亚马逊弹性MapReduce（Amazon EMR）来计算我们的数据能够计算的任何东西。这既包括要展示在客户的仪表盘上的数据，也包括我们为了开发新功能而开发的实验性的任务。&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/c58e27a2c6b407329238fb4092b7456f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们使用&lt;a title=&quot;http://www.cascading.org/&quot; href=&quot;http://www.cascading.org/&quot; target=&quot;_blank&quot;&gt;Cascading&lt;/a&gt;框架编写、Amazon EMR执行MapReduce程序。 Amazon EMR将我们存储到S3上的数据作为输入，处理完毕后，再将结果存入S3。我们通过运行在Storm上的调度topology来探测程序执行完毕，并将结果灌入&lt;a title=&quot;http://cassandra.apache.org/&quot; href=&quot;http://cassandra.apache.org/&quot; target=&quot;_blank&quot;&gt;Cassandra&lt;/a&gt;集群，这样结果就能用于亚秒级查询API。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;实时计算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;迄今，我们描述的是一个能够执行分析计算的持久的容错的框架。然而，存在一个显眼的问题——这个框架不是实时的。一些计算每小时计算一次，有的计算需要一整天的数据作为输入。计算时间从几分钟到几小时不等，把S3上的输出导入到服务层也需要这么多时间。因此，在最好情况下，我们的数据也总是拖后几个小时，显然不能满足实时和可操作的目标。&lt;/p&gt;
&lt;p&gt;为了达成实时的目标，数据涌入后进行存档的同时，我们对数据进行流式计算。&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e3329ed0c7e27980256a5b1f9a0eafbc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;就像我们的存储Topology读取数据一样，一个独立的Storm Topology实时地从Kafka Topic中读取数据然后进行实时计算，计算的逻辑和MapReduce任务一样。这些实时计算的结果放在另一个独立的Cassandra集群里以供实时查询。&lt;/p&gt;
&lt;p&gt;为了弥补我们在时间以及在资源方面可能的不足，我们没有在批量处理层中而是在实时计算层中使用了一些概率算法，如布隆过滤器、HyperLogLog（也有一些自己开发的算法）。相对于那些蛮力替代品，这些算法在空间和时间复杂度上有数量级的优势，同时只有可忽略的精确度损失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;合并&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们拥有两个独立生产出的数据集（批处理和实时处理），我们怎么将二者合并才能得到一个一致的结果？&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/9fe3c8c8276c57184f29d985068c7aeb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们在API的逻辑中，根据特定的情况分别使用两个数据集然后合并它们。&lt;/p&gt;
&lt;p&gt;因为批量计算是可重现的，且相对于实时计算来说更容错，我们的API总是倾向于使用批量产生的数据。例如，API接到了一个三十天的时间序列的日活跃用户数量数据请求，它首先会到批量数据Cassandra集群里查询全范围的数据。如果这是一个历史数据检索，所有的数据都已经得到。然而，查询的请求更可能会包含当天，批量产生的数据填充了大部分结果，只有近一两天的数据会被实时数据填充。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;错误处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们来温习几个失效的场景，看一下这样的架构在处理错误的时候， 是如何避免宕机或者损失数据，取之以优雅地降级。&lt;/p&gt;
&lt;p&gt;我们在上文中已经讨论过设备上的回退重试策略。在设备端网络中断、服务器端短时无服务情况下，重试保证数据最终能够到达服务器。随机回退确保设备不会在某区域网络中断或者后端服务器短时间不可用之后，不会压垮（DDos攻击）服务器。&lt;/p&gt;
&lt;p&gt;当实时处理层失效时，会发生什么？我们待命的工程师会受到通知并去解决问题。因为实时处理层的输入是存储在持久化的Kafka集群里，所以没有数据会丢失；等实时处理恢复之后，它会赶上处理那些停机期间应该处理的数据。&lt;/p&gt;
&lt;p&gt;因为实时处理和批处理是完全解耦的，批处理层完全不会受到影响。因此唯一的影响就是实时处理层失效期间，对数据点实时更新的延迟。&lt;/p&gt;
&lt;p&gt;如果批处理层有问题或者严重延迟的话，会发生什么？我们的API会无缝地多获取实时处理的数据。一个时间序列数据的查询，可能先前只取一天的实时处理结果，现在就需要查询两到三天的实时处理结果。因为实时处理和批处理是完全解耦的，实时处理不受影响继续运行。同时，我们的待命工程师会得到消息并且解决批处理层的问题。一旦批处理层恢复正常，它会执行那些延迟的数据处理任务，API也会无缝切换到使用现在可以得到的批处理的结果。&lt;/p&gt;
&lt;p&gt;我们系统后端架构由四大组件构成：事件接收，事件存储，实时计算和批量计算。各个组件之间的持久化队列确保任意组件的失效不会扩散到其他组件，并且后续可以从中断中恢复。API可以在计算层延迟或者失效时无缝地优雅降级，在服务恢复后重新恢复；这些都是由API内部的检索逻辑来保证的。&lt;/p&gt;
&lt;p&gt;Answer的目标是创建一个仪表盘，这个仪表盘能够把了解你的用户群变得非常简单。因此你可以将时间花费在打造令人惊叹的用户体验上，而不是用来掘穿数据。从现在就开始，&lt;a title=&quot;了解Answers&quot; href=&quot;http://answers.io/?utm_source=twitter_eng_blog&amp;amp;utm_medium=twitter_blog&amp;amp;utm_campaign=answers_5B_sessions_2.17.2015&amp;amp;utm_content=inline_cta&quot; target=&quot;_blank&quot;&gt;点击此处更多了解Answers&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;非常感谢致力于将此架构实现（付诸现实）的Answers团队。还有&lt;a title=&quot;Big Data&quot; href=&quot;http://manning.com/marz/&quot; target=&quot;_blank&quot;&gt;《Big Data》&lt;/a&gt;这本书的作者Nathan Marz。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;贡献者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/ajorgensen&quot;&gt;Andrew Jorgensen&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/bswift&quot;&gt;Brian Swift&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/brianhatfield&quot;&gt;Brian Hatfield&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/mikefurtak&quot;&gt;Michael Furtak&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/marknic&quot;&gt;Mark Pirri&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/CoryDolphin&quot;&gt;Cory Dolphin&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/rothbutter&quot;&gt;Jamie Rothfeder&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/jeffseibert&quot;&gt;Jeff Seibert&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/sirstarry&quot;&gt;Justin Starry&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/krob&quot;&gt;Kevin Robinson&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/Kris10rht&quot;&gt;Kristen Johnson&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/marcrichards&quot;&gt;Marc Richards&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/patrickwmcgee&quot;&gt;Patrick McGee&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/richparet&quot;&gt;Rich Paret&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/wayne&quot;&gt;Wayne Chang&lt;/a&gt;.&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87067&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87067votetotal&quot;&gt;2&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87067&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者：&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/mingyuan&quot;&gt;刘志成&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/mingyuan&quot;&gt;
			&lt;img src=&quot;/images/jobbole.com/4d8ad0b6e65624d1c18aac0963063eaf.jpg&quot;&gt;
		&lt;/a&gt;
	&lt;/div&gt;

    &lt;div class=&quot;author-bio-info&quot;&gt;

        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            新浪微博：@柳鸣渊        &lt;/span&gt;
        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            &lt;a href=&quot;http://www.jobbole.com/members/mingyuan&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 个人主页&lt;/a&gt; ·
            &lt;a href=&quot;http://blog.jobbole.com/author/mingyuan/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;/i&gt; 我的文章&lt;/a&gt; ·
            &lt;a title=&quot;声望值&quot; target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/mingyuan/reputation/&quot;&gt;&lt;i class=&quot;fa fa-graduation-cap&quot;&gt;&lt;/i&gt; 11&lt;/a&gt;        &lt;/span&gt;
    &lt;/div&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Wed, 27 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-27-87067-3e26d261e.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-27-87067-3e26d261e.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Netflix工程总监眼中的分类算法：深度学习优先级最低</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;【编者按】针对Quora上的一个老问题：不同分类算法的优势是什么？Netflix公司工程总监Xavier Amatriain近日给出新的解答，他根据奥卡姆剃刀原理依次推荐了逻辑回归、SVM、决策树集成和深度学习，并谈了他的不同认识。他并不推荐深度学习为通用的方法，这也侧面呼应了我们之前讨论的问题：深度学习能否取代其他机器学习算法。&lt;/p&gt;
&lt;p&gt;不同分类算法的优势是什么？例如有大量的训练数据集，上万的实例，超过10万的特征，我们选择哪种分类算法最好？Netflix公司工程总监Xavier Amatriain认为，应当根据奥卡姆剃刀原理（Occam’s Razor）来选择算法，建议先考虑逻辑回归。&lt;/p&gt;
&lt;p&gt;选择一个合理的算法可以从很多方面来考察，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;训练实例的数量？&lt;/li&gt;
&lt;li&gt;特征空间的维度？&lt;/li&gt;
&lt;li&gt;是否希望该问题线性可分？&lt;/li&gt;
&lt;li&gt;特征是否是独立的？&lt;/li&gt;
&lt;li&gt;是否预期特征能够线性扩展？&lt;/li&gt;
&lt;li&gt;过度拟合是否会成为一个问题？&lt;/li&gt;
&lt;li&gt;系统在速度/性能/内存使用等方面的要求如何？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;逻辑回归&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为一般的经验法则，我建议先考虑逻辑回归（LR，Logistic Regression）。逻辑回归是一个漂亮乖巧的分类算法，可以训练你希望的特征大致线性和问题线性可分。你可以很容易地做一些特征引擎把大部分的非线性特征转换为线性。逻辑回归对噪声也相当强劲，能避免过度拟合，甚至使用L2或L1正则化做特征选择。逻辑回归也可以用在大数据场景，因为它是相当有效的，并且可以分布使用，例如ADMM。 逻辑回归的最后一个优点是，输出可以被解释为概率。这是一个好的附加作用，例如，你可以使用它排名而不是分类。&lt;/p&gt;
&lt;p&gt;即使在你不希望逻辑回归100%地工作，你也可以帮自己一个忙，在使用“票友”办法之前，运行一个简单的L2正则化逻辑回归作为基线。&lt;/p&gt;
&lt;p&gt;好了，现在你已经设置逻辑回归基线，下一步你应该做的，我基本上会推荐两个可能的方向：支持向量机（SVM）或者决策树集成。如果我不知道你的具体问题，我肯定会选择后者，但我将开始描述为什么SVM可能是一个值得考虑的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持向量机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;支持向量机使用一个与LR不同的损失函数（Hinge）。它们也有不同的解释（maximum-margin）。然而，在实践中，用线性核函数的SVM和逻辑回归是没有很大的不同的（如果你有兴趣，你可以观察Andrew Ng在他的Coursera机器学习课程如何从逻辑回归中驱动SVM）。用SVM代替逻辑回归的一个主要原因可能是因为你的问题线性不可分。在这种情况下，你将不得不使用有非线性内核的SVM（如RBF）。事实上，逻辑回归也可以伴随不同的内核使用，但出于实际原因你更可能选择SVM。另一个使用SVM的相关理由可能是高维空间。例如，SVM已经被报道在工作文本分类方面做得更出色。&lt;/p&gt;
&lt;p&gt;不幸的是，SVM的主要缺点是，它们的训练低效到痛苦。所以，对于有大量训练样本的任何问题，我都不会推荐SVM。更进一步地说，我不会为大多数“工业规模”的应用程序推荐SVM。任何超出玩具/实验室的问题可能会使用其他的算法来更好地解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;决策树集成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第三个算法家族：决策树集成（Tree Ensembles）。这基本上涵盖了两个不同的算法：随机森林（RF）和梯度提升决策树（GBDT）。它们之间的差异随后再谈，现在先把它们当做一个整体和逻辑回归比较。&lt;/p&gt;
&lt;p&gt;决策树集成有超过LR的不同优势。一个主要优势是，它们并不指望线性特征，甚至是交互线性特性。在LR里我没有提到的是，它几乎不能处理分类（二进制）特性。而决策树集成因为仅仅是一堆决策树的结合，可以非常好地处理这个问题。另一主要优点是，因为它们构造了（使用bagging或boosting）的算法，能很好地处理高维空间以及大量的训练实例。&lt;/p&gt;
&lt;p&gt;至于RF和GBDT之间的差别，可以简单理解为GBDT的性能通常会更好，但它们更难保证正确。更具体而言，GBDT有更多的超参数需要调整，并且也更容易出现过度拟合。RF几乎可以“开箱即用”，这是它们非常受欢迎的一个原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后但并非最不重要，没有深度学习的次要参考，这个答案将是不完整的。我绝对不会推荐这种方法作为通用的分类技术。但是，你可能会听说这些方法在某些情况下（如图像分类）表现如何。如果你已经通过了前面的步骤并且感觉你的解决方案还有优化的空间，你可能尝试使用深度学习方法。事实是，如果你使用一个开源工具（如Theano）实现，你会知道如何使这些方法在你的数据集中非常快地执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;综上所述，先用如逻辑回归一样简单的方法设定一个基准，如果你需要，再使问题变得更加复杂。这一点上，决策树集成可能正是要走的正确道路，特别是随机森林，它们很容易调整。如果你觉得还有改进的余地，尝试GBDT，或者更炫一些，选择深度学习。&lt;/p&gt;
&lt;p&gt;你还可以看看Kaggle比赛。如果你搜索关键字“分类”，选择那些已经完成的，你能找到一些类似的东西，这样你可能会知道选择一个什么样的方法来赢得比赛。在这一点上，你可能会意识到，使用集成方法总容易把事情做好。当然集成的唯一问题，是需要保持所有独立的方法并行地工作。这可能是你的最后一步，花哨的一步。&lt;/p&gt;
&lt;p&gt;编辑点评：Xavier Amatriain不推荐深度学习为通用算法的理由，并不能说是因为深度学习不好，而是因为深度学习会增加复杂性及成本，却无法保证在所有的场景表现出比逻辑回归、SVM及决策树集成更优的结果。事实上，Xavier Amatriain的Netflix团队早已开始研究人工神经网络和深度学习技术，希望借助AWS云服务和GPU加速的分布式神经网络，分析网民最爱看的电影电视剧，实现节目的个性化推荐。&lt;/p&gt;
&lt;p style=&quot;text-align: center&quot;&gt; &lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/8152c51793bfd7edcbb064a10c985d69.jpg&quot; width=&quot;581&quot; height=&quot;640&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center&quot;&gt;Netflix推荐系统架构（图片来自Xavier Amatrain参与撰写的Netflix官方博客）&lt;/p&gt;
&lt;p&gt;此后，Xavier Amatriain还分享了Netflix机器学习实践的十大经验教训，大致包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更多的数据需要与更好的模型之匹配&lt;/li&gt;
&lt;li&gt;你可能不需要所有的大数据&lt;/li&gt;
&lt;li&gt;更复杂的模型未必意味着更好的结果，可能是你的样本集太简单&lt;/li&gt;
&lt;li&gt;要充分考虑你的训练数据&lt;/li&gt;
&lt;li&gt;学会处理偏差&lt;/li&gt;
&lt;li&gt;UI是联系算法和最重要的用户之间唯一通道&lt;/li&gt;
&lt;li&gt;正确的演进方式比数据和模型更重要&lt;/li&gt;
&lt;li&gt;分布式算法重要，知道在哪个层级使用它更重要&lt;/li&gt;
&lt;li&gt;选择合适的度量自动超参数优化&lt;/li&gt;
&lt;li&gt;并非所有的事都能离线完成，近线处理也是一种选择&lt;/li&gt;
&lt;/ul&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87148&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87148votetotal&quot;&gt;&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87148&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Tue, 26 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-26-87148-0ee3711f9.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-26-87148-0ee3711f9.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>理解 MySQL（4）：并行数据库与分区(Partition)</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;h3&gt;&lt;strong&gt;1、并行数据库 &lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.1、并行数据库的体系结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;并行机的出现，催生了并行数据库的出现，不对，应该是关系运算本来就是高度可并行的。对数据库系统性能的度量主要有两种方式：(1)吞吐量(Throughput)，在给定的时间段里所能完成的任务数量；(2)响应时间(Response time)，单个任务从提交到完成所需要的时间。对于处理大量小事务的系统，通过并行地处理许多事务可以提高它的吞吐量。对于处理大事务的系统，通过并行的执行事务的子任务，可以缩短系统晌应时间。&lt;/p&gt;
&lt;p&gt;并行机有三种基本的体系结构，相应的，并行数据库的体系结构也可以大概分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享内存(share memeory)：所有处理器共享一个公共的存储器；&lt;/li&gt;
&lt;li&gt;共享磁盘(share disk)：所有处理器共享公共的磁盘；这种结构有时又叫做集群(cluster)；&lt;/li&gt;
&lt;li&gt;无共享(share nothing)：所有处理器既不共享内存，也不共享磁盘。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/edc230f4efffff66335ecd644f9c42f7.jpg&quot; width=&quot;690&quot; height=&quot;269&quot;&gt;&lt;/p&gt;
&lt;p&gt;1.1.1、 共享内存&lt;br&gt;
该结构包括多个处理器、一个全局共享的内存（主存储器）和多个磁盘存储，各个处理器通过高速通讯网络（Interconnection Network）与共享内存连接，并均可直接访问系统中的一个、多个或全部的磁盘存储，在系统中，所有的内存和磁盘存储均由多个处理器共享。&lt;br&gt;
这种结构的优点在于，处理器之间的通信效率极高，访问内存的速度要比消息通信机制要快很多。这种结构的缺点在于，处理器的规模不能超过32个或者64个，因为总线或互边网络是由所有的处理器共享，它会变成瓶颈。当处理器数量到达某一个点时，再增加处理器已经没有什么好处。&lt;/p&gt;
&lt;p&gt;共享内存结构通常在每个处理器上有很大的高速缓存，从而减少对内存的访问。但是，这些高速缓存必须保持一致，也就是缓存一致性(cache-coherency)的问题。&lt;/p&gt;
&lt;p&gt;1.1.2、 共享磁盘&lt;br&gt;
该结构由多个具有独立内存（主存储器）的处理器和多个磁盘存储构成，各个处理器相互之间没有任何直接的信息和数据的交换，多个处理器和磁盘存储由高速通信网络连接，每个处理器都可以读写全部的磁盘存储。&lt;/p&gt;
&lt;p&gt;共享磁盘与共享内存结构相比，有以下一些优点：(1)每个处理器都有自己的存储器，存储总线不再是瓶颈；(2)以一种较经济的方式提供了容错性(fault tolerence)，如果一个处器发生故障，其它处理器可以代替工作。&lt;/p&gt;
&lt;p&gt;该结构的主要问题不是在于可扩展性问题，虽然存储总线不是瓶颈，但是，与磁盘之间的连接又成了瓶颈。&lt;/p&gt;
&lt;p&gt;运行Rdb的DEC集群是共享磁盘的体系结构的早期商用化产品之一(DEC后来被Compaq公司收购，再后来，Oracle又从Compaq手中取得Rdb，发展成现在的Oracle RAC)。&lt;/p&gt;
&lt;p&gt;1.1.3、 无共享&lt;/p&gt;
&lt;p&gt;该结构由多个完全独立的处理节点构成，每个处理节点具有自己独立的处理器、独立的内存（主存储器）和独立的磁盘存储，多个处理节点在处理器级由高速通信网络连接，系统中的各个处理器使用自己的内存独立地处理自己的数据。&lt;/p&gt;
&lt;p&gt;这 种结构中，每一个处理节点就是一个小型的数据库系统，多个节点一起构成整个的分布式的并行数据库系统。由于每个处理器使用自己的资源处理自己的数据，不存 在内存和磁盘的争用，提高的整体性能。另外这种结构具有优良的可扩展性——只需增加额外的处理节点，就可以以接近线性的比例增加系统的处理能力。&lt;/p&gt;
&lt;p&gt;这种结构中，由于数据是各个处理器私有的，因此系统中数据的分布就需要特殊的处理，以尽量保证系统中各个节点的负载基本平衡，但在目前的数据库领域，这个数据分布问题已经有比较合理的解决方案。&lt;/p&gt;
&lt;p&gt;由于数据是分布在各个处理节点上的，因此，使用这种结构的并行数据库系统，在扩展时不可避免地会导致数据在整个系统范围内的重分布（Re-Distribution）问题。&lt;/p&gt;
&lt;p&gt;Shared-Nothing结构的典型代表是Teradata(并行数据库的先驱)，值得一提的是，MySQL NDB Cluster也使用了这种结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2、I/O并行(I/O Parallelism)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I/O并行的最简单形式是通过对关系划分，放置到多个磁盘上来缩减从磁盘读取关系的时间。并行数据库中数据划分最通用的形式是水平划分(horizontal portioning)，一个关系中的元组被划分到多个磁盘。&lt;/p&gt;
&lt;p&gt;1.2.1、常用划分技术&lt;/p&gt;
&lt;p&gt;假定将数据划分到n个磁盘D0，D1，…，Dn中。&lt;/p&gt;
&lt;p&gt;(1) 轮转法(round-bin)。对关系顺序扫描，将第i个元组存储到标号为Di%n的磁盘上；该方式保证了元组在多个磁盘上均匀分布。&lt;br&gt;
(2) 散列划分(hash partion)。选定一个值域为{0, 1, …,n-1}的散列函数，对关系中的元组基于划分属性进行散列。如果散列函数返回i，则将其存储到第i个磁盘。&lt;br&gt;
(3) 范围划分(range partion)。&lt;/p&gt;
&lt;p&gt;由于将关系存储到多个磁盘，读写时能同时进行，划分(partion)能大大提高系统的读写性能。数据的存取可以分为以下几类：&lt;/p&gt;
&lt;p&gt;(1) 扫描整个关系；&lt;br&gt;
(2) 点查询(point query)，如name = “hustcat”；&lt;br&gt;
(3) 范围查询(range query)，如 20 &amp;lt; age &amp;lt; 30。&lt;/p&gt;
&lt;p&gt;不同的划分技术，对这些存取类型的效率是不同的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轮转法适合顺序扫描关系，对点查询和范围查询的处理较复杂。&lt;/li&gt;
&lt;li&gt;散列划分特别适合点查询，速度最快。&lt;/li&gt;
&lt;li&gt;范围划分对点查询、范围查询以及顺序扫描都支持较好，所以适用性很广。但是，这种方式存在一个问题——执行偏斜(execution skew)，也就是说某些范围的元组较多，使得大量的I/O出现在某几个磁盘。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.3、查询间并行(interquery parallism)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询间并行指的是不同的查询或事务间并行的执行。这种形式的并行可以提高事务的吞吐量，然而，单个事务并不能执行得更快(即响应时间不能减少)。查询间的并行主要用于扩展事务处理系统，在单位时间内能够处理更多的事务。&lt;/p&gt;
&lt;p&gt;查询间并行是数据库系统最易实现的一种并行，在共享内存的并行系统(如SMP)中尤其这样。为单处理器设计的数据库系统可以不用修改，或者很少修改就能用到共享内存的体系结构。&lt;/p&gt;
&lt;p&gt;在共享磁盘和无共享的体系结构中，实现查询间并行要更复杂一些。各个处理需要协调来进行封锁、日志操作等等，这就需要处理器之间的传递消息。并行数据库系统必须保证两个处理器不会同时更新同一数据。而且，处理器访问数据时，系统必须保证处理器缓存的数据是最新的数据，即缓存一致性问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.4、查询内并行(intraquery parallism)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询内并行是指单个查询要在多个处理器和磁盘上同时进行。为了理解，来考虑一个对某关系进行排序的查询。假设关系已经基于某个属性进行了范围划分，存储于多个磁盘上，并且划分是基于划分属性的。则排序操作可以如下进行：对每个分区并行的排序，然后将各个已经有序的分区合并到一起。&lt;/p&gt;
&lt;p&gt;单个查询的执行可以有两种并行方式：&lt;br&gt;
(1) 操作内并行(Intraoperation parallism)：通过并行的执行每一个运算，如排序、选择、连接等，来加快一个查询的处理速度。&lt;br&gt;
(2) 操作间并行(Interoperation parallism)：通过并行的执行一个查询中的多个不同的运算，来加速度一个查询的处理速度。&lt;/p&gt;
&lt;p&gt;注意两者间的区别，前者可以认为多个处理器同时执行一个运算，而后者是多个处理器同时执行不同的运算。&lt;/p&gt;
&lt;p&gt;这两种形式之间的并行是互相补充的，并且可以同时存在于一个查询中。通常由于一个查询中的运算数目相对于元组数目是较小的，所以当并行度增加时，第一种方式取得的效果更显著。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2、MySQL的分区(partion)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1、MySQL分区概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在MySQL中，InnoDB存储引擎长期支持表空间的概念，并且MySQL服务器甚至在分区引入之前，就能配置为存储不同的数据库使用不同的物理路径。分区(partion)更进一步，它允许你通过设置各种规则将一个表的各个分区跨文件系统存储。实际上，不同位置的不同表分区是作为一个单独的表来存储的。用户所选择的、实现数据分割的规则被称为分区函数(partioning function)，这在MySQL中它可以是模数，或者是简单的匹配一个连续的数值区间或数值列表，或者是一个内部HASH函数，或一个线性HASH函数。&lt;/p&gt;
&lt;p&gt;最常见是的水平分区(horizontal partitioning)，也就是将表的不同的元组分配到不同的物理分区上。目前，MySQL 5.1还不支持垂直分区(vertical partitioning)，即将表的不同列分配到不同的物理分区。你可以使用MySQL支持的大多数存储引擎来创建表的分区，在MySQL 5.1中，同一个表的各个分区必须使用相同的存储引擎，比如，你不能对一个分区使用MyISAM，而对另一个分区使用InnoDB。但是，你可以对同一个数据库的不同的表使用不同的存储引擎。&lt;/p&gt;
&lt;p&gt;要为某个分区表配置一个专门的存储引擎，必须且只能使用[STORAGE] ENGINE 选项，这如同为非分区表配置存储引擎一样。但是，必须记住[STORAGE] ENGINE（和其他的表选项）必须列在用在CREATE TABLE语句中的其他任何分区选项之前。下面的例子给出了怎样创建一个通过HASH分成6个分区、使用InnoDB存储引擎的表：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/cfa3b328a0e403b028502a15ee87e303.jpg&quot; width=&quot;436&quot; height=&quot;108&quot;&gt;&lt;/p&gt;
&lt;p&gt;注：分区必须对一个表的所有数据和索引；不能只对数据分区而不对索引分区，反之亦然，同时也不能只对表的一部分进行分区。&lt;br&gt;
分区对数据库管理系统实现并行处理有着重要的影响，如果对数据进行分区，则很容易进行并行处理，但是，MySQL还没有充分利用分区的这种并行优势，而这也是它改进的方向 (这种分治思想深深的影响着并行计算，而且在并行计算方面具有天然优势)。MySQL的分区，会给系统带来以下一些优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与单个磁盘或文件系统分区相比，单个表可以存储更多的数据。&lt;/li&gt;
&lt;li&gt;对于那些已经失去保存意义的数据，通常可以通过删除与那些数据有关的分区，很容易地删除那些数据。相反地，在某些情况下，添加新数据的过程又可以通过为那些新数据专门增加一个新的分区，来很方便地实现。&lt;/li&gt;
&lt;li&gt;对于带Where的条件查询语句，可以得到更大的优化；只需要查询某些分区，而不用扫描全部分区。&lt;/li&gt;
&lt;li&gt;还有其它一些优点，不过MySQL 5.1还不支持：&lt;/li&gt;
&lt;li&gt;一些聚合函数，比如SUM() 和COUNT()，能够很容易的并行执行；&lt;/li&gt;
&lt;li&gt;通过并行I/O，可以大大提高查询的吞吐量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：实际上，分区不论是对I/O并行，还是查询内并行，都有着重要的影响。只不过MySQL在这方面做得还不够多(不过，正在改进)，而Oracle对于查询内并行，做了很多工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2、分区类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL 5.1中可用的分区类型包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RANGE分区(portioning)：根据列值所属的范围区间，将元组分配到各个分区。&lt;/li&gt;
&lt;li&gt;LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。&lt;/li&gt;
&lt;li&gt;HASH分区：根据用户定义的函数的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。&lt;/li&gt;
&lt;li&gt;KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL 服务器提供其自身的哈希函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.2.1、范围分区&lt;/p&gt;
&lt;p&gt;范围分区是通过计算表达式的值所属的范围区间，对元组进行分区。这些区间要求连续且不能相互重叠，使用VALUES LESS THAN操作符来进行定义。在下面的几个例子中，假定你创建了一个如下的一个表，该表保存有20家音像店的职员记录，这20家音像店的编号从1到20。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/99bc1c2295c9f7639c4e992838f420ed.jpg&quot; width=&quot;434&quot; height=&quot;234&quot;&gt;&lt;/p&gt;
&lt;p&gt;你可以根据需要对该表进行各种分区，比如，你可以通过store_id来进行分区：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e8fcdeb8a506ca908471878efa14fa62.jpg&quot; width=&quot;434&quot; height=&quot;386&quot;&gt;&lt;/p&gt;
&lt;p&gt;很容易确定数据(72, ‘Michael’, ‘Widenius’, ’1998-06-25′, NULL, 13)被插入分区p2；但是，如果一条数据的store_id = 21，会怎么样呢？由于没有规则处理大于20的情况，所以服务器会报错。你可以通过如下方式来处理这种情况：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/2e25b1df1ea95378b367af4e3a6c58b6.jpg&quot; width=&quot;433&quot; height=&quot;385&quot;&gt;&lt;/p&gt;
&lt;p&gt;MAXVALUE 表示最大的可能的整数值。现在，store_id 列值大于或等于16（定义了的最高值）的所有行都将保存在分区p3中。在将来的某个时候，当商店数已经增长到25, 30, 或更多 ，可以使用ALTER TABLE语句为商店21-25, 26-30,等等增加新的分区&lt;br&gt;
RANGE分区在如下场合特别有用：&lt;/p&gt;
&lt;p&gt;(1) 当需要删除“旧的”数据时。 在上面的例子中，你只需简单地使用 “ALTER TABLE employees DROP PARTITION p0；”来删除所有在1991年前就已经停止工作的雇员相对应的所有行。对于有大量行的表，这比运行一个如“DELETE FROM employees WHERE YEAR(separated) &amp;lt;= 1990；”这样的一个DELETE查询要有效得多。&lt;br&gt;
(2) 经常依赖于分区属性进行查询。例如，当执行一个如“SELECT COUNT(*) FROM employees WHERE YEAR(separated) = 2000 GROUP BY store_id；”这样的查询时，MySQL可以很迅速地确定只有分区p2需要扫描，这是因为余下的分区不可能包含有符合该WHERE子句的任何记录。注：这种优化还没有在MySQL 5.1源程序中启用，但是，有关工作正在进行中。&lt;br&gt;
范围分区的缺点就是容易出现执行偏斜，这会影响系统性能。&lt;/p&gt;
&lt;p&gt;2.2.2、HASH分区&lt;/p&gt;
&lt;p&gt;HASH分区主要用来确保数据在预先确定数目的分区中平均分布。在RANGE和LIST分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在HASH分区中，MySQL 自动完成这些工作，你所要做的只是基于将要被哈希的列值指定一个列值或表达式，以及指定被分区的表将要被分割成的分区数量。&lt;/p&gt;
&lt;p&gt;你可以通过要在CREATE TABLE 语句上添加一个“PARTITION BY HASH (expr)”子句，其中“expr”是一个返回一个整数的表达式。它可以仅仅是字段类型为MySQL 整型的一列的名字。此外，你很可能需要在后面再添加一个“PARTITIONS num”子句，其中num 是一个非负的整数，它表示表将要被分割成分区的数量。比如：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3dfcaf5a98f8c76a918ca5fd9e34e6af.jpg&quot; width=&quot;431&quot; height=&quot;283&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果没有PARTITIONS语句，默认分区数为1。但是，PARTITIONS后面没有数字，系统会报错。&lt;br&gt;
相对于范围分区，HASH分区更可能保证数据均衡分布。&lt;/p&gt;
&lt;p&gt;2.2.3、子分区(Subpartitioning)&lt;/p&gt;
&lt;p&gt;子分区，也叫做复合分区(composite partitioning)，是对分区表的每个分区的进一步分割。例如，&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/365e7c5244c2bd521028cbb0bc5e5122.jpg&quot; width=&quot;434&quot; height=&quot;208&quot;&gt;&lt;/p&gt;
&lt;p&gt;表ts 有3个RANGE分区。这3个分区中的每一个分区——p0, p1, 和 p2 ——又被进一步分成了2个子分区。实际上，整个表被分成了3 * 2 = 6个分区。但是，由于PARTITION BY RANGE子句的作用，这些分区的头2个只保存“purchased”列中值小于1990的那些记录。&lt;/p&gt;
&lt;p&gt;在MySQL 5.1中，对于已经通过RANGE或LIST分区了的表再进行分区。子分区既可以使用HASH希分区，也可以使用KEY分区。&lt;/p&gt;
&lt;p&gt;为了对个别的子分区指定选项，使用SUBPARTITION 子句来明确定义子分区也是可能的。例如，创建在前面例子中给出的同一个表的、一个更加详细的方式如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/ed18bc63b1142b74e15632f79d5603ac.jpg&quot; width=&quot;434&quot; height=&quot;412&quot;&gt;&lt;/p&gt;
&lt;p&gt;一些注意点：&lt;/p&gt;
&lt;p&gt;(1) 每个分区的子分区数必须相同；&lt;br&gt;
(2) 如果在一个分区表上的任何分区上使用SUBPARTITION 来明确定义任何子分区，那么就必须定义所有的子分区；&lt;br&gt;
(3) 每个SUBPARTITION子句必须包含一个子分区的名称；&lt;br&gt;
(4) MySQL 5.1.7及之前的版本，每个分区的子分区的名称必须唯一，但是在整个表中，没有必要唯一。从MySQL 5.1.8开始，子分区的名称在整个表中都必须唯一。&lt;/p&gt;
&lt;p&gt;子分区可以用于特别大的表，在多个磁盘间分配数据和索引。假设有6个磁盘，分别为/disk0， /disk1， /disk2等，对于如下例子：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/a87179d72a97265f41568e1a5314ac32.jpg&quot; width=&quot;432&quot; height=&quot;718&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3、体验分区&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;下面通过例子来体验分区：&lt;/p&gt;
&lt;p&gt;(1)创建如下分区表：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/514c4e42f078c78daf8667863c647838.jpg&quot; width=&quot;431&quot; height=&quot;417&quot;&gt;&lt;/p&gt;
&lt;p&gt;(2)创建一个不分区的表：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/2f2580f0ce3d37356ec290669a0c31b4.jpg&quot; width=&quot;433&quot; height=&quot;128&quot;&gt;&lt;/p&gt;
&lt;p&gt;(3)    创建一个生成8000000行数据的存储过程：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/b75a80d3e37c5aa58d45209bc6be4d5e.jpg&quot; width=&quot;434&quot; height=&quot;328&quot;&gt;&lt;/p&gt;
&lt;p&gt;(4)    调用存储过程，生成数据：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/2006399c4b1a90f70c9e268db0dc6d8f.jpg&quot; width=&quot;433&quot; height=&quot;78&quot;&gt;&lt;/p&gt;
&lt;p&gt;(5)&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/c429c9e28527e73d776fe61f92cc3549.jpg&quot; width=&quot;433&quot; height=&quot;81&quot;&gt;&lt;/p&gt;
&lt;p&gt;数据准备好了，下面开始测试：&lt;/p&gt;
&lt;p&gt;(6)&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/b856f8482d9be16244b0efb918b321b1.jpg&quot; width=&quot;435&quot; height=&quot;437&quot;&gt;&lt;/p&gt;
&lt;p&gt;速度差异很明显；下面看一下查询计划：&lt;/p&gt;
&lt;p&gt;(7)&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/75612b73e4437f3d08a7991d1b3f7ba0.jpg&quot; width=&quot;539&quot; height=&quot;669&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附SQL语句：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;代码Code highlighting produced by Actipro CodeHighlighter (freeware)http://www.CodeHighlighter.com/--&amp;gt; 1 CREATE TABLE part_tab
(  c1 int default NULL,
c2 varchar(30) default NULL,
c3 date default NULL
) engine=myisam
PARTITION BY RANGE (year(c3)) 
(
PARTITION p0 VALUES LESS THAN (1995),
PARTITION p1 VALUES LESS THAN (1996) , 
PARTITION p2 VALUES LESS THAN (1997) ,
PARTITION p3 VALUES LESS THAN (1998) ,
PARTITION p4 VALUES LESS THAN (1999),
PARTITION p5 VALUES LESS THAN (2000) , 
PARTITION p6 VALUES LESS THAN (2001) ,
PARTITION p7 VALUES LESS THAN (2002) , 
PARTITION p8 VALUES LESS THAN (2003) ,
PARTITION p9 VALUES LESS THAN (2004) , 
PARTITION p10 VALUES LESS THAN (2010),
PARTITION p11 VALUES LESS THAN MAXVALUE 
);

create table no_part_tab
(c1 int(11) default NULL,
c2 varchar(30) default NULL,
c3 date default NULL
) engine=myisam;

delimiter //
CREATE PROCEDURE load_part_tab()
begin
declare v int default 0;
          while v &amp;lt; 8000000
  do
  insert into part_tab(c1,c2,c3)
  values (v,&#39;testing partitions&#39;,adddate(&#39;1995-01-01&#39;,(rand(v)*36520) mod 3652));
  set v = v + 1;
  end while;
  end
//

delimiter ;
call load_part_tab();
explain select count(*) from no_part_tab where
c3 &amp;gt; date &#39;1995-01-01&#39; and c3 &amp;lt; date &#39;1995-12-31&#39;;

explain select count(*) from part_tab where
c3 &amp;gt; date &#39;1995-01-01&#39; and c3 &amp;lt; date &#39;1995-12-31&#39;;

CREATE TABLE part_tab2
(  
c1 int default NULL
) engine=myisam
PARTITION BY RANGE (c1) 
(
PARTITION p0 VALUES LESS THAN (5),
PARTITION p1 VALUES LESS THAN (10),
PARTITION p2 VALUES LESS THAN MAXVALUE
);

insert into part_tab2 values(2),(3);&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要参考：《MySQL Manual》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87137&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87137votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87137&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Mon, 25 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-25-87137-2c52da121.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-25-87137-2c52da121.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>理解 MySQL（3）：复制(Replication)</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;h3&gt;&lt;strong&gt;1、复制概述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.1、复制解决的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据复制技术有以下一些特点：&lt;br&gt;
(1) 数据分布&lt;br&gt;
(2) 负载平衡(load balancing)&lt;br&gt;
(3) 备份&lt;br&gt;
(4) 高可用性(high availability)和容错&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2、复制如何工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从高层来看，复制分成三步：&lt;br&gt;
(1) master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）；&lt;br&gt;
(2) slave将master的binary log events拷贝到它的中继日志(relay log)；&lt;br&gt;
(3) slave重做中继日志中的事件，将改变反映它自己的数据。&lt;/p&gt;
&lt;p&gt;下图描述了这一过程：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/b59126917043fecf5124a0b2e5e94712.jpg&quot; width=&quot;506&quot; height=&quot;339&quot;&gt;&lt;/p&gt;
&lt;p&gt;该过程的第一部分就是master记录二进制日志。在每个事务更新数据完成之前，master在二日志记录这些改变。MySQL将事务串行的写入二进制日志，即使事务中的语句都是交叉执行的。在事件写入二进制日志完成后，master通知存储引擎提交事务。&lt;/p&gt;
&lt;p&gt;下一步就是slave将master的binary log拷贝到它自己的中继日志。首先，slave开始一个工作线程——I/O线程。I/O线程在master上打开一个普通的连接，然后开始binlog dump process。Binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件。I/O线程将这些事件写入中继日志。&lt;/p&gt;
&lt;p&gt;SQL slave thread处理该过程的最后一步。SQL线程从中继日志读取事件，更新slave的数据，使其与master中的数据一致。只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小。&lt;/p&gt;
&lt;p&gt;此外，在master中也有一个工作线程：和其它MySQL的连接一样，slave在master中打开一个连接也会使得master开始一个线程。复制过程有一个很重要的限制——复制在slave上是串行化的，也就是说master上的并行更新操作不能在slave上并行操作。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2、体验MySQL复制&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;MySQL开始复制是很简单的过程，不过，根据特定的应用场景，都会在基本的步骤上有一些变化。最简单的场景就是一个新安装的master和slave，从高层来看，整个过程如下：&lt;/p&gt;
&lt;p&gt;(1)在每个服务器上创建一个复制帐号；&lt;br&gt;
(2)配置master和slave；&lt;br&gt;
(3)Slave连接master开始复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1、创建复制帐号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个slave使用标准的MySQL用户名和密码连接master。进行复制操作的用户会授予REPLICATION SLAVE权限。用户名的密码都会存储在文本文件master.info中。假如，你想创建repl用户，如下：&lt;br&gt;
mysql&amp;gt; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.*&lt;br&gt;
-&amp;gt; TO repl@’192.168.0.%’ IDENTIFIED BY ‘p4ssword’;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2、配置master&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来对master进行配置，包括打开二进制日志，指定唯一的servr ID。例如，在配置文件加入如下值：&lt;br&gt;
[mysqld]&lt;br&gt;
log-bin=mysql-bin&lt;br&gt;
server-id=10&lt;br&gt;
重启master，运行SHOW MASTER STATUS，输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/50f67fedd289e0393860356900bb6628.jpg&quot; width=&quot;519&quot; height=&quot;118&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3、配置slave&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Slave的配置与master类似，你同样需要重启slave的MySQL。如下：&lt;/p&gt;
&lt;p&gt;log_bin = mysql-bin&lt;br&gt;
server_id = 2&lt;br&gt;
relay_log = mysql-relay-bin&lt;br&gt;
log_slave_updates = 1&lt;br&gt;
read_only = 1&lt;/p&gt;
&lt;p&gt;server_id是必须的，而且唯一。slave没有必要开启二进制日志，但是在一些情况下，必须设置，例如，如果slave为其它slave的master，必须设置bin_log。在这里，我们开启了二进制日志，而且显示的命名(默认名称为hostname，但是，如果hostname改变则会出现问题)。&lt;br&gt;
relay_log配置中继日志，log_slave_updates表示slave将复制事件写进自己的二进制日志(后面会看到它的用处)。&lt;/p&gt;
&lt;p&gt;有些人开启了slave的二进制日志，却没有设置log_slave_updates，然后查看slave的数据是否改变，这是一种错误的配置。所以，尽量使用read_only，它防止改变数据(除了特殊的线程)。但是，read_only并是很实用，特别是那些需要在slave上创建表的应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.4、启动slave&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来就是让slave连接master，并开始重做master二进制日志中的事件。你不应该用配置文件进行该操作，而应该使用CHANGE MASTER TO语句，该语句可以完全取代对配置文件的修改，而且它可以为slave指定不同的master，而不需要停止服务器。如下：&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; CHANGE MASTER TO MASTER_HOST=’server1′,&lt;/p&gt;
&lt;p&gt;-&amp;gt; MASTER_USER=’repl’,&lt;/p&gt;
&lt;p&gt;-&amp;gt; MASTER_PASSWORD=’p4ssword’,&lt;/p&gt;
&lt;p&gt;-&amp;gt; MASTER_LOG_FILE=’mysql-bin.000001′,&lt;/p&gt;
&lt;p&gt;-&amp;gt; MASTER_LOG_POS=0;&lt;/p&gt;
&lt;p&gt;MASTER_LOG_POS的值为0，因为它是日志的开始位置。然后，你可以用SHOW SLAVE STATUS语句查看slave的设置是否正确：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/c6c064b597017836f7f41c2b12b960db.jpg&quot; width=&quot;546&quot; height=&quot;406&quot;&gt;&lt;/p&gt;
&lt;p&gt;Slave_IO_State, Slave_IO_Running, 和Slave_SQL_Running表明slave还没有开始复制过程。日志的位置为4而不是0，这是因为0只是日志文件的开始位置，并不是日志位置。实际上，MySQL知道的第一个事件的位置是4。&lt;/p&gt;
&lt;p&gt;为了开始复制，你可以运行：&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; START SLAVE;&lt;/p&gt;
&lt;p&gt;运行SHOW SLAVE STATUS查看输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/8ed6916d8f3f6357dfdb00579fffbf33.jpg&quot; width=&quot;552&quot; height=&quot;407&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意，slave的I/O和SQL线程都已经开始运行，而且Seconds_Behind_Master不再是NULL。日志的位置增加了，意味着一些事件被获取并执行了。如果你在master上进行修改，你可以在slave上看到各种日志文件的位置的变化，同样，你也可以看到数据库中数据的变化。&lt;/p&gt;
&lt;p&gt;你可查看master和slave上线程的状态。在master上，你可以看到slave的I/O线程创建的连接：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/33476b877b38f7902e0d90f4f4772754.jpg&quot; width=&quot;590&quot; height=&quot;515&quot;&gt;&lt;/p&gt;
&lt;p&gt;行2为处理slave的I/O线程的连接。&lt;br&gt;
在slave上运行该语句：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/a35142c7ab002dd1950fc5b0bf285bb0.jpg&quot; width=&quot;530&quot; height=&quot;744&quot;&gt;&lt;/p&gt;
&lt;p&gt;行1为I/O线程状态，行2为SQL线程状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.5、从另一个master初始化slave&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面讨论的假设你是新安装的master和slave，所以，slave与master有相同的数据。但是，大多数情况却不是这样的，例如，你的master可能已经运行很久了，而你想对新安装的slave进行数据同步，甚至它没有master的数据。&lt;/p&gt;
&lt;p&gt;此时，有几种方法可以使slave从另一个服务开始，例如，从master拷贝数据，从另一个slave克隆，从最近的备份开始一个slave。Slave与master同步时，需要三样东西：&lt;/p&gt;
&lt;p&gt;(1)master的某个时刻的数据快照；&lt;br&gt;
(2)master当前的日志文件、以及生成快照时的字节偏移。这两个值可以叫做日志文件坐标(log file coordinate)，因为它们确定了一个二进制日志的位置，你可以用SHOW MASTER STATUS命令找到日志文件的坐标；&lt;br&gt;
(3)master的二进制日志文件。&lt;/p&gt;
&lt;p&gt;可以通过以下几中方法来克隆一个slave：&lt;/p&gt;
&lt;p&gt;(1) 冷拷贝(cold copy)&lt;br&gt;
停止master，将master的文件拷贝到slave；然后重启master。缺点很明显。&lt;br&gt;
(2) 热拷贝(warm copy)&lt;br&gt;
如果你仅使用MyISAM表，你可以使用mysqlhotcopy拷贝，即使服务器正在运行。&lt;br&gt;
(3) 使用mysqldump&lt;/p&gt;
&lt;p&gt;使用mysqldump来得到一个数据快照可分为以下几步：&lt;/p&gt;
&lt;p&gt;&amp;lt;1&amp;gt;锁表：如果你还没有锁表，你应该对表加锁，防止其它连接修改数据库，否则，你得到的数据可以是不一致的。如下：&lt;br&gt;
mysql&amp;gt; FLUSH TABLES WITH READ LOCK;&lt;br&gt;
&amp;lt;2&amp;gt;在另一个连接用mysqldump创建一个你想进行复制的数据库的转储：&lt;br&gt;
shell&amp;gt; mysqldump –all-databases –lock-all-tables &amp;gt;dbdump.db&lt;br&gt;
&amp;lt;3&amp;gt;对表释放锁。&lt;br&gt;
mysql&amp;gt; UNLOCK TABLES;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3、深入复制&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;已经讨论了关于复制的一些基本东西，下面深入讨论一下复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1、基于语句的复制(Statement-Based Replication)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL 5.0及之前的版本仅支持基于语句的复制（也叫做逻辑复制，logical replication），这在数据库并不常见。master记录下改变数据的查询，然后，slave从中继日志中读取事件，并执行它，这些SQL语句与master执行的语句一样。&lt;br&gt;
这种方式的优点就是实现简单。此外，基于语句的复制的二进制日志可以很好的进行压缩，而且日志的数据量也较小，占用带宽少——例如，一个更新GB的数据的查询仅需要几十个字节的二进制日志。而mysqlbinlog对于基于语句的日志处理十分方便。&lt;/p&gt;
&lt;p&gt;但是，基于语句的复制并不是像它看起来那么简单，因为一些查询语句依赖于master的特定条件，例如，master与slave可能有不同的时间。所以，MySQL的二进制日志的格式不仅仅是查询语句，还包括一些元数据信息，例如，当前的时间戳。即使如此，还是有一些语句，比如，CURRENT USER函数，不能正确的进行复制。此外，存储过程和触发器也是一个问题。&lt;br&gt;
另外一个问题就是基于语句的复制必须是串行化的。这要求大量特殊的代码，配置，例如InnoDB的next-key锁等。并不是所有的存储引擎都支持基于语句的复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2、基于记录的复制(Row-Based Replication)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL增加基于记录的复制，在二进制日志中记录下实际数据的改变，这与其它一些DBMS的实现方式类似。这种方式有优点，也有缺点。优点就是可以对任何语句都能正确工作，一些语句的效率更高。主要的缺点就是二进制日志可能会很大，而且不直观，所以，你不能使用mysqlbinlog来查看二进制日志。&lt;/p&gt;
&lt;p&gt;对于一些语句，基于记录的复制能够更有效的工作，如：&lt;br&gt;
mysql&amp;gt; INSERT INTO summary_table(col1, col2, sum_col3)&lt;br&gt;
-&amp;gt; SELECT col1, col2, sum(col3)&lt;br&gt;
-&amp;gt; FROM enormous_table&lt;br&gt;
-&amp;gt; GROUP BY col1, col2;&lt;/p&gt;
&lt;p&gt;假设，只有三种唯一的col1和col2的组合，但是，该查询会扫描原表的许多行，却仅返回三条记录。此时，基于记录的复制效率更高。&lt;br&gt;
另一方面，下面的语句，基于语句的复制更有效：&lt;br&gt;
mysql&amp;gt; UPDATE enormous_table SET col1 = 0;&lt;/p&gt;
&lt;p&gt;此时使用基于记录的复制代价会非常高。由于两种方式不能对所有情况都能很好的处理，所以，MySQL 5.1支持在基于语句的复制和基于记录的复制之前动态交换。你可以通过设置session变量binlog_format来进行控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3、复制相关的文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了二进制日志和中继日志文件外，还有其它一些与复制相关的文件。如下：&lt;/p&gt;
&lt;p&gt;(1)mysql-bin.index&lt;br&gt;
服务器一旦开启二进制日志，会产生一个与二日志文件同名，但是以.index结尾的文件。它用于跟踪磁盘上存在哪些二进制日志文件。MySQL用它来定位二进制日志文件。它的内容如下(我的机器上)：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/4e2faecf5e04ab8482aa913761d2a92c.jpg&quot; width=&quot;231&quot; height=&quot;191&quot;&gt;&lt;/p&gt;
&lt;p&gt;(2)mysql-relay-bin.index&lt;/p&gt;
&lt;p&gt;该文件的功能与mysql-bin.index类似，但是它是针对中继日志，而不是二进制日志。内容如下：&lt;br&gt;
.\mysql-02-relay-bin.000017&lt;br&gt;
.\mysql-02-relay-bin.000018&lt;/p&gt;
&lt;p&gt;(3)master.info&lt;br&gt;
保存master的相关信息。不要删除它，否则，slave重启后不能连接master。内容如下(我的机器上)：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/5ab61c42385f2d61881e393db0310c75.jpg&quot; width=&quot;259&quot; height=&quot;391&quot;&gt;&lt;/p&gt;
&lt;p&gt;I/O线程更新master.info文件，内容如下(我的机器上)：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e0dadfd1e2bb0e5366ac05fdd6168288.jpg&quot; width=&quot;435&quot; height=&quot;159&quot;&gt;&lt;/p&gt;
&lt;p&gt;(4)relay-log.info&lt;br&gt;
包含slave中当前二进制日志和中继日志的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.4、发送复制事件到其它slave&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当设置log_slave_updates时，你可以让slave扮演其它slave的master。此时，slave把SQL线程执行的事件写进行自己的二进制日志(binary log)，然后，它的slave可以获取这些事件并执行它。如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/96f23471a18889f83a895ac624424fa9.jpg&quot; width=&quot;668&quot; height=&quot;319&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.5、复制过滤(Replication Filters)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;复制过滤可以让你只复制服务器中的一部分数据，有两种复制过滤：在master上过滤二进制日志中的事件；在slave上过滤中继日志中的事件。如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/6b7fb272bc32c33fd6accabf53df161f.jpg&quot; width=&quot;634&quot; height=&quot;319&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4、复制的常用拓扑结构&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;复制的体系结构有以下一些基本原则：&lt;/p&gt;
&lt;p&gt;(1) 每个slave只能有一个master；&lt;br&gt;
(2) 每个slave只能有一个唯一的服务器ID；&lt;br&gt;
(3) 每个master可以有很多slave；&lt;br&gt;
(4) 如果你设置log_slave_updates，slave可以是其它slave的master，从而扩散master的更新。&lt;/p&gt;
&lt;p&gt;MySQL不支持多主服务器复制(Multimaster Replication)——即一个slave可以有多个master。但是，通过一些简单的组合，我们却可以建立灵活而强大的复制体系结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1、单一master和多slave&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由一个master和一个slave组成复制系统是最简单的情况。Slave之间并不相互通信，只能与master进行通信。如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/4aa5875ddf7e5e45471ba940cf36d95a.jpg&quot; width=&quot;283&quot; height=&quot;225&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果写操作较少，而读操作很时，可以采取这种结构。你可以将读操作分布到其它的slave，从而减小master的压力。但是，当slave增加到一定数量时，slave对master的负载以及网络带宽都会成为一个严重的问题。&lt;/p&gt;
&lt;p&gt;这种结构虽然简单，但是，它却非常灵活，足够满足大多数应用需求。一些建议：&lt;br&gt;
(1) 不同的slave扮演不同的作用(例如使用不同的索引，或者不同的存储引擎)；&lt;br&gt;
(2) 用一个slave作为备用master，只进行复制；&lt;br&gt;
(3) 用一个远程的slave，用于灾难恢复；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2、主动模式的Master-Master(Master-Master in Active-Active Mode)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Master-Master复制的两台服务器，既是master，又是另一台服务器的slave。如图：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/00aaef97b0a0f6ad12016f6c91cfdc19.jpg&quot; width=&quot;212&quot; height=&quot;108&quot;&gt;&lt;/p&gt;
&lt;p&gt;主动的Master-Master复制有一些特殊的用处。例如，地理上分布的两个部分都需要自己的可写的数据副本。这种结构最大的问题就是更新冲突。假设一个表只有一行(一列)的数据，其值为1，如果两个服务器分别同时执行如下语句：&lt;/p&gt;
&lt;p&gt;在第一个服务器上执行：&lt;br&gt;
mysql&amp;gt; UPDATE tbl SET col=col + 1;&lt;br&gt;
在第二个服务器上执行：&lt;br&gt;
mysql&amp;gt; UPDATE tbl SET col=col * 2;&lt;br&gt;
那么结果是多少呢？一台服务器是4，另一个服务器是3，但是，这并不会产生错误。&lt;/p&gt;
&lt;p&gt;实际上，MySQL并不支持其它一些DBMS支持的多主服务器复制(Multimaster Replication)，这是MySQL的复制功能很大的一个限制(多主服务器的难点在于解决更新冲突)，但是，如果你实在有这种需求，你可以采用MySQL Cluster，以及将Cluster和Replication结合起来，可以建立强大的高性能的数据库平台。但是，可以通过其它一些方式来模拟这种多主服务器的复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.3、主动-被动模式的Master-Master(Master-Master in Active-Passive Mode)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是master-master结构变化而来的，它避免了M-M的缺点，实际上，这是一种具有容错和高可用性的系统。它的不同点在于其中一个服务只能进行只读操作。如图：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/809b13a2d4c39abf1cca1eb6c1676489.jpg&quot; width=&quot;213&quot; height=&quot;112&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.4、带从服务器的Master-Master结构(Master-Master with Slaves)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种结构的优点就是提供了冗余。在地理上分布的复制结构，它不存在单一节点故障问题，而且还可以将读密集型的请求放到slave上。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/1f183ba9f0564a1cab22b197442b2e38.jpg&quot; width=&quot;291&quot; height=&quot;218&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要参考：《High Performance MySQL》 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87133&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87133votetotal&quot;&gt;&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87133&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Mon, 25 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-25-87133-3dfab74e5.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-25-87133-3dfab74e5.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>理解 MySQL（2）：索引与优化</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;写在前面：索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。考虑如下情况，假设数据库中一个表有10^6条记录，DBMS的页面大小为4K，并存储100条记录。如果没有索引，查询将对整个表进行扫描，最坏的情况下，如果所有数据页都不在内存，需要读取10^4个页面，如果这10^4个页面在磁盘上随机分布，需要进行10^4次I/O，假设磁盘每次I/O时间为10ms(忽略数据传输时间)，则总共需要100s(但实际上要好很多很多)。如果对之建立B-Tree索引，则只需要进行log100(10^6)=3次页面读取，最坏情况下耗时30ms。这就是索引带来的效果，很多时候，当你的应用程序进行SQL查询速度很慢时，应该想想是否可以建索引。进入正题：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;第二章、索引与优化&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、选择索引的数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。通常来说，可以遵循以下一些指导原则：&lt;/p&gt;
&lt;p&gt;(1)越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。&lt;/p&gt;
&lt;p&gt;(2)简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。&lt;/p&gt;
&lt;p&gt;(3)尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。&lt;/p&gt;
&lt;p&gt;1.1、选择标识符&lt;/p&gt;
&lt;p&gt;选择合适的标识符是非常重要的。选择时不仅应该考虑存储类型，而且应该考虑MySQL是怎样进行运算和比较的。一旦选定数据类型，应该保证所有相关的表都使用相同的数据类型。&lt;br&gt;
(1) 整型：通常是作为标识符的最好选择，因为可以更快的处理，而且可以设置为AUTO_INCREMENT。&lt;br&gt;
(2) 字符串：尽量避免使用字符串作为标识符，它们消耗更好的空间，处理起来也较慢。而且，通常来说，字符串都是随机的，所以它们在索引中的位置也是随机的，这会导致页面分裂、随机访问磁盘，聚簇索引分裂（对于使用聚簇索引的存储引擎）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、索引入门&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于任何DBMS，索引都是进行优化的最主要的因素。对于少量的数据，没有合适的索引影响不是很大，但是，当随着数据量的增加，性能会急剧下降。&lt;br&gt;
如果对多列进行索引(组合索引)，列的顺序非常重要，MySQL仅能对索引最左边的前缀进行有效的查找。例如：&lt;br&gt;
假设存在组合索引it1c1c2(c1,c2)，查询语句select * from t1 where c1=1 and c2=2能够使用该索引。查询语句select * from t1 where c1=1也能够使用该索引。但是，查询语句select * from t1 where c2=2不能够使用该索引，因为没有组合索引的引导列，即，要想使用c2列进行查找，必需出现c1等于某值。&lt;/p&gt;
&lt;p&gt;2.1、索引的类型&lt;/p&gt;
&lt;p&gt;索引是在存储引擎中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型。&lt;/p&gt;
&lt;p&gt;2.1.1、B-Tree索引&lt;/p&gt;
&lt;p&gt;假设有如下一个表：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/5074bc5fdd1677ede660cf9d740693a0.jpg&quot; width=&quot;437&quot; height=&quot;159&quot;&gt;&lt;/p&gt;
&lt;p&gt;其索引包含表中每一行的last_name、first_name和dob列。其结构大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/7a5eb6c5e34ed1ad43fef584b35da9b0.jpg&quot; width=&quot;671&quot; height=&quot;454&quot;&gt;&lt;/p&gt;
&lt;p&gt;索引存储的值按索引列中的顺序排列。可以利用B-Tree索引进行全关键字、关键字范围和关键字前缀查询，当然，如果想使用索引，你必须保证按索引的最左边前缀(leftmost prefix of the index)来进行查询。&lt;/p&gt;
&lt;p&gt;(1)匹配全值(Match the full value)：对索引中的所有列都指定具体的值。例如，上图中索引可以帮助你查找出生于1960-01-01的Cuba Allen。&lt;br&gt;
(2)匹配最左前缀(Match a leftmost prefix)：你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。&lt;br&gt;
(3)匹配列前缀(Match a column prefix)：例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。&lt;br&gt;
(4)匹配值的范围查询(Match a range of values)：可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。&lt;br&gt;
(5)匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：可以利用索引查找last name为Allen，而first name以字母K开始的人。&lt;br&gt;
(6)仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。&lt;/p&gt;
&lt;p&gt;由于B-树中的节点都是顺序存储的，所以可以利用索引进行查找(找某些值)，也可以对查询结果进行ORDER BY。当然，使用B-tree索引有以下一些限制：&lt;/p&gt;
&lt;p&gt;(1) 查询必须从索引的最左边的列开始。关于这点已经提了很多遍了。例如你不能利用索引查找在某一天出生的人。&lt;br&gt;
(2) 不能跳过某一索引列。例如，你不能利用索引查找last name为Smith且出生于某一天的人。&lt;br&gt;
(3) 存储引擎不能使用索引中范围条件右边的列。例如，如果你的查询语句为WHERE last_name=”Smith” AND first_name LIKE ‘J%’ AND dob=’1976-12-23′，则该查询只会使用索引中的前两列，因为LIKE是范围查询。&lt;br&gt;
2.1.2、Hash索引&lt;/p&gt;
&lt;p&gt;MySQL中，只有Memory存储引擎显示支持hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B-Tree索引。Memory存储引擎支持非唯一hash索引，这在数据库领域是罕见的，如果多个值有相同的hash code，索引把它们的行指针用链表保存到同一个hash表项中。&lt;/p&gt;
&lt;p&gt;假设创建如下一个表：&lt;/p&gt;
&lt;p&gt;CREATE TABLE testhash (&lt;br&gt;
fname VARCHAR(50) NOT NULL,&lt;br&gt;
lname VARCHAR(50) NOT NULL,&lt;br&gt;
KEY USING HASH(fname)&lt;br&gt;
) ENGINE=MEMORY;&lt;/p&gt;
&lt;p&gt;包含的数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/45057441280555a0e0f5526307251b56.jpg&quot; width=&quot;236&quot; height=&quot;171&quot;&gt;&lt;/p&gt;
&lt;p&gt;假设索引使用hash函数f( )，如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/88369a7dc1356b4c63f767947ff91ea5.jpg&quot; width=&quot;436&quot; height=&quot;108&quot;&gt;&lt;/p&gt;
&lt;p&gt;此时，索引的结构大概如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/548b001039e5a596e76b39c3221bbb22.jpg&quot; width=&quot;500&quot; height=&quot;137&quot;&gt;&lt;/p&gt;
&lt;p&gt;Slots是有序的，但是记录不是有序的。当你执行&lt;br&gt;
mysql&amp;gt; SELECT lname FROM testhash WHERE fname=’Peter’;&lt;br&gt;
MySQL会计算’Peter’的hash值，然后通过它来查询索引的行指针。因为f(‘Peter’) = 8784，MySQL会在索引中查找8784，得到指向记录3的指针。&lt;br&gt;
因为索引自己仅仅存储很短的值，所以，索引非常紧凑。Hash值不取决于列的数据类型，一个TINYINT列的索引与一个长字符串列的索引一样大。&lt;/p&gt;
&lt;p&gt;Hash索引有以下一些限制：&lt;/p&gt;
&lt;p&gt;(1)由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录。但是访问内存中的记录是非常迅速的，不会对性造成太大的影响。&lt;br&gt;
(2)不能使用hash索引排序。&lt;br&gt;
(3)Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。&lt;br&gt;
(4)Hash索引只支持等值比较，例如使用=，IN( )和&amp;lt;=&amp;gt;。对于WHERE price&amp;gt;100并不能加速查询。&lt;/p&gt;
&lt;p&gt;2.1.3、空间(R-Tree)索引&lt;br&gt;
MyISAM支持空间索引，主要用于地理空间数据类型，例如GEOMETRY。&lt;/p&gt;
&lt;p&gt;2.1.4、全文(Full-text)索引&lt;br&gt;
全文索引是MyISAM的一个特殊索引类型，主要用于全文检索。&lt;br&gt;
&lt;strong&gt;3、高性能的索引策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.1、聚簇索引(Clustered Indexes)&lt;/p&gt;
&lt;p&gt;聚簇索引保证关键字的值相近的元组存储的物理位置也相同（所以字符串类型不宜建立聚簇索引，特别是随机字符串，会使得系统进行大量的移动操作），且一个表只能有一个聚簇索引。因为由存储引擎实现索引，所以，并不是所有的引擎都支持聚簇索引。目前，只有solidDB和InnoDB支持。&lt;/p&gt;
&lt;p&gt;聚簇索引的结构大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e0ac4b23c58d234870940bedfe77644a.jpg&quot; width=&quot;659&quot; height=&quot;490&quot;&gt;&lt;/p&gt;
&lt;p&gt;注：叶子页面包含完整的元组，而内节点页面仅包含索引的列(索引的列为整型)。一些DBMS允许用户指定聚簇索引，但是MySQL的存储引擎到目前为止都不支持。InnoDB对主键建立聚簇索引。如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。一般来说，DBMS都会以聚簇索引的形式来存储实际的数据，它是其它二级索引的基础。&lt;/p&gt;
&lt;p&gt;3.1.1、InnoDB和MyISAM的数据布局的比较&lt;/p&gt;
&lt;p&gt;为了更加理解聚簇索引和非聚簇索引，或者primary索引和second索引(MyISAM不支持聚簇索引)，来比较一下InnoDB和MyISAM的数据布局，对于如下表：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/5074bc5fdd1677ede660cf9d740693a0.jpg&quot; width=&quot;437&quot; height=&quot;159&quot;&gt;&lt;/p&gt;
&lt;p&gt;假设主键的值位于1—10,000之间，且按随机顺序插入，然后用OPTIMIZE TABLE进行优化。col2随机赋予1—100之间的值，所以会存在许多重复的值。&lt;/p&gt;
&lt;p&gt;(1) MyISAM的数据布局&lt;/p&gt;
&lt;p&gt;其布局十分简单，MyISAM按照插入的顺序在磁盘上存储数据，如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e141d3bca2f7de9417c1f2fe35120679.jpg&quot; width=&quot;180&quot; height=&quot;209&quot;&gt;&lt;/p&gt;
&lt;p&gt;注：左边为行号(row number)，从0开始。因为元组的大小固定，所以MyISAM可以很容易的从表的开始位置找到某一字节的位置。&lt;br&gt;
据些建立的primary key的索引结构大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/1d7c5f5632a21cf72e3934f366404f17.jpg&quot; width=&quot;583&quot; height=&quot;246&quot;&gt;&lt;/p&gt;
&lt;p&gt;注：MyISAM不支持聚簇索引，索引中每一个叶子节点仅仅包含行号(row number)，且叶子节点按照col1的顺序存储。&lt;br&gt;
来看看col2的索引结构：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/fe8835b69c5f0ccfbc3d0ef98d526352.jpg&quot; width=&quot;470&quot; height=&quot;247&quot;&gt;&lt;/p&gt;
&lt;p&gt;实际上，在MyISAM中，primary key和其它索引没有什么区别。Primary key仅仅只是一个叫做PRIMARY的唯一，非空的索引而已。&lt;/p&gt;
&lt;p&gt;(2) InnoDB的数据布局&lt;/p&gt;
&lt;p&gt;InnoDB按聚簇索引的形式存储数据，所以它的数据布局有着很大的不同。它存储表的结构大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/d5082d3305d2ee43ee479d6599a08077.jpg&quot; width=&quot;658&quot; height=&quot;304&quot;&gt;&lt;/p&gt;
&lt;p&gt;注：聚簇索引中的每个叶子节点包含primary key的值，事务ID和回滚指针(rollback pointer)——用于事务和MVCC，和余下的列(如col2)。&lt;/p&gt;
&lt;p&gt;相对于MyISAM，二级索引与聚簇索引有很大的不同。InnoDB的二级索引的叶子包含primary key的值，而不是行指针(row pointers)，这减小了移动数据或者数据页面分裂时维护二级索引的开销，因为InnoDB不需要更新索引的行指针。其结构大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/091f4c0f4e5a1c8c4d25eb8e1e36c94b.jpg&quot; width=&quot;657&quot; height=&quot;248&quot;&gt;&lt;/p&gt;
&lt;p&gt;聚簇索引和非聚簇索引表的对比：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/8f1ec9dcebb405ec50ecb7b7dfadcc8c.jpg&quot; width=&quot;665&quot; height=&quot;579&quot;&gt;&lt;/p&gt;
&lt;p&gt;3.1.2、按primary key的顺序插入行(InnoDB)&lt;/p&gt;
&lt;p&gt;如果你用InnoDB，而且不需要特殊的聚簇索引，一个好的做法就是使用代理主键(surrogate key)——独立于你的应用中的数据。最简单的做法就是使用一个AUTO_INCREMENT的列，这会保证记录按照顺序插入，而且能提高使用primary key进行连接的查询的性能。应该尽量避免随机的聚簇主键，例如，字符串主键就是一个不好的选择，它使得插入操作变得随机。&lt;/p&gt;
&lt;p&gt;3.2、覆盖索引(Covering Indexes)&lt;/p&gt;
&lt;p&gt;如果索引包含满足查询的所有数据，就称为覆盖索引。覆盖索引是一种非常强大的工具，能大大提高查询性能。只需要读取索引而不用读取数据有以下一些优点：&lt;/p&gt;
&lt;p&gt;(1)索引项通常比记录要小，所以MySQL访问更少的数据；&lt;br&gt;
(2)索引都按值的大小顺序存储，相对于随机访问记录，需要更少的I/O；&lt;br&gt;
(3)大多数据引擎能更好的缓存索引。比如MyISAM只缓存索引。&lt;br&gt;
(4)覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了。&lt;/p&gt;
&lt;p&gt;覆盖索引不能是任何索引，只有B-TREE索引存储相应的值。而且不同的存储引擎实现覆盖索引的方式都不同，并不是所有存储引擎都支持覆盖索引(Memory和Falcon就不支持)。&lt;/p&gt;
&lt;p&gt;对于索引覆盖查询(index-covered query)，使用EXPLAIN时，可以在Extra一列中看到“Using index”。例如，在sakila的inventory表中，有一个组合索引(store_id,film_id)，对于只需要访问这两列的查询，MySQL就可以使用索引，如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e2d455071994988edab8e464dbafb670.jpg&quot; width=&quot;437&quot; height=&quot;356&quot;&gt;&lt;/p&gt;
&lt;p&gt;在大多数引擎中，只有当查询语句所访问的列是索引的一部分时，索引才会覆盖。但是，InnoDB不限于此，InnoDB的二级索引在叶子节点中存储了primary key的值。因此，sakila.actor表使用InnoDB，而且对于是last_name上有索引，所以，索引能覆盖那些访问actor_id的查询，如：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/5a1764aaf27210f3a2f8a55285baf422.jpg&quot; width=&quot;437&quot; height=&quot;356&quot;&gt;&lt;/p&gt;
&lt;p&gt;3.3、利用索引进行排序&lt;/p&gt;
&lt;p&gt;MySQL中，有两种方式生成有序结果集：一是使用filesort，二是按索引顺序扫描。利用索引进行排序操作是非常快的，而且可以利用同一索引同时进行查找和排序操作。当索引的顺序与ORDER BY中的列顺序相同且所有的列是同一方向(全部升序或者全部降序)时，可以使用索引来排序。如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引。其它情况都会使用filesort。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/cabf2c49dfbf35505f73a6cf426759a4.jpg&quot; width=&quot;438&quot; height=&quot;289&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/2be64445f4b4a8c3afc46de2322054f3.jpg&quot; width=&quot;425&quot; height=&quot;347&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/54ae9cf43f28bd378390e1996bf0e563.jpg&quot; width=&quot;416&quot; height=&quot;353&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/9854470399c6bc12108cd680a2447505.jpg&quot; width=&quot;432&quot; height=&quot;351&quot;&gt;&lt;/p&gt;
&lt;p&gt;当MySQL不能使用索引进行排序时，就会利用自己的排序算法(快速排序算法)在内存(sort buffer)中对数据进行排序，如果内存装载不下，它会将磁盘上的数据进行分块，再对各个数据块进行排序，然后将各个块合并成有序的结果集（实际上就是外排序）。对于filesort，MySQL有两种排序算法。&lt;/p&gt;
&lt;p&gt;(1)两遍扫描算法(Two passes)&lt;/p&gt;
&lt;p&gt;实现方式是先将须要排序的字段和可以直接定位到相关行数据的指针信息取出，然后在设定的内存（通过参数sort_buffer_size设定）中进行排序，完成排序之后再次通过行指针信息取出所需的Columns。&lt;br&gt;
注：该算法是4.1之前采用的算法，它需要两次访问数据，尤其是第二次读取操作会导致大量的随机I/O操作。另一方面，内存开销较小。&lt;/p&gt;
&lt;p&gt;(2) 一次扫描算法(single pass)&lt;/p&gt;
&lt;p&gt;该算法一次性将所需的Columns全部取出，在内存中排序后直接将结果输出。&lt;br&gt;
注：从 MySQL 4.1 版本开始使用该算法。它减少了I/O的次数，效率较高，但是内存开销也较大。如果我们将并不需要的Columns也取出来，就会极大地浪费排序过程所需要的内存。在 MySQL 4.1 之后的版本中，可以通过设置 max_length_for_sort_data 参数来控制 MySQL 选择第一种排序算法还是第二种。当取出的所有大字段总大小大于 max_length_for_sort_data 的设置时，MySQL 就会选择使用第一种排序算法，反之，则会选择第二种。为了尽可能地提高排序性能，我们自然更希望使用第二种排序算法，所以在 Query 中仅仅取出需要的 Columns 是非常有必要的。&lt;/p&gt;
&lt;p&gt;当对连接操作进行排序时，如果ORDER BY仅仅引用第一个表的列，MySQL对该表进行filesort操作，然后进行连接处理，此时，EXPLAIN输出“Using filesort”；否则，MySQL必须将查询的结果集生成一个临时表，在连接完成之后进行filesort操作，此时，EXPLAIN输出“Using temporary;Using filesort”。&lt;/p&gt;
&lt;p&gt;3.4、索引与加锁&lt;br&gt;
索引对于InnoDB非常重要，因为它可以让查询锁更少的元组。这点十分重要，因为MySQL 5.0中，InnoDB直到事务提交时才会解锁。有两个方面的原因：首先，即使InnoDB行级锁的开销非常高效，内存开销也较小，但不管怎么样，还是存在开销。其次，对不需要的元组的加锁，会增加锁的开销，降低并发性。&lt;/p&gt;
&lt;p&gt;InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。但是，只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。一旦索引不允许InnoDB那样做（即达不到过滤的目的），MySQL服务器只能对InnoDB返回的数据进行WHERE操作，此时，已经无法避免对那些元组加锁了：InnoDB已经锁住那些元组，服务器无法解锁了。&lt;br&gt;
来看个例子：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/c673a56d4ed89ea5c72950b95c2cff45.jpg&quot; width=&quot;437&quot; height=&quot;402&quot;&gt;&lt;/p&gt;
&lt;p&gt;该查询仅仅返回2—3的数据，实际已经对1—3的数据加上排它锁了。InnoDB锁住元组1是因为MySQL的查询计划仅使用索引进行范围查询（而没有进行过滤操作，WHERE中第二个条件已经无法使用索引了）：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/f4ff8205864c1bf5c28a50a0a07e8a95.jpg&quot; width=&quot;438&quot; height=&quot;433&quot;&gt;&lt;/p&gt;
&lt;p&gt;表明存储引擎从索引的起始处开始，获取所有的行，直到actor_id&amp;lt;4为假，服务器无法告诉InnoDB去掉元组1。&lt;br&gt;
为了证明row 1已经被锁住，我们另外建一个连接，执行如下操作：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/1e9aaedcea8e8c83c3d3b683499bdbca.jpg&quot; width=&quot;436&quot; height=&quot;84&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87127&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87127votetotal&quot;&gt;&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87127&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Mon, 25 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-25-87127-2d5108505.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-25-87127-2d5108505.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>理解 MySQL（1）：架构和概念</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;写在前面：最早接触的MySQL是在2006年前，那时候MySQL还是4.x版本，很多功能都不支持，比如，存储过程，视图，触发器，更别说分布式事务等复杂特性了。但从5.0(2005年10月)开始，MySQL渐渐步入企业级数据库的行列了；复制、集群、分区、分布式事务，这些企业级的特性，使得现在的MySQL，完全可以应用于企业级应用环境(很多互联网公司都用其作为数据库服务器，尽管节约成本是一个因素，但是没有强大功能作后盾，则是不可想象的)。虽然，MySQL还有很多不足，比如，复制、分区的支持都十分有限、查询优化仍需要改进，但是MySQL已经是一个足够好的DBMS了，更何况它是opensource的。这段时间没有事，出于好奇，略微的研究了一下MySQL，积累了一些资料，欲总结出来。这些资料打算分为两部分，上部主要讨论MySQL的优化，其中主要参考了《MySQL Manual》和《High Performance MySQL》，如果有时间，以后在下部分析一下MySQL的源码。如果你是MySQL高手，希望你不吝赐教；如果你是新手，希望对你有用。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;第一章、MySQL架构与概念&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、MySQL的逻辑架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/aee367182eeb4901f457628d1e067150.jpg&quot; width=&quot;232&quot; height=&quot;325&quot;&gt;&lt;/p&gt;
&lt;p&gt;最上面不是MySQL特有的，所有基于网络的C/S的网络应用程序都应该包括连接处理、认证、安全管理等。&lt;br&gt;
中间层是MySQL的核心，包括查询解析、分析、优化和缓存等。同时它还提供跨存储引擎的功能，包括存储过程、触发器和视图等。&lt;br&gt;
最下面是存储引擎，它负责存取数据。服务器通过storage engine API可以和各种存储引擎进行交互。&lt;/p&gt;
&lt;p&gt;1.1、查询优化和执行(Optimization and Execution)&lt;/p&gt;
&lt;p&gt;MySQL将用户的查询语句进行解析，并创建一个内部的数据结构——分析树，然后进行各种优化，例如重写查询、选择读取表的顺序，以及使用哪个索引等。查询优化器不关心一个表所使用的存储引擎，但是存储引擎会影响服务器如何优化查询。优化器通过存储引擎获取一些参数、某个操作的执行代价、以及统计信息等。在解析查询之前，服务器会先访问查询缓存(query cache)——它存储SELECT语句以及相应的查询结果集。如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。&lt;/p&gt;
&lt;p&gt;1.2、并发控制&lt;/p&gt;
&lt;p&gt;MySQL提供两个级别的并发控制：服务器级(the server level)和存储引擎级(the storage engine level)。加锁是实现并发控制的基本方法，MySQL中锁的粒度：&lt;/p&gt;
&lt;p&gt;(1) 表级锁：MySQL独立于存储引擎提供表锁，例如，对于ALTER TABLE语句，服务器提供表锁(table-level lock)。&lt;br&gt;
(2) 行级锁：InnoDB和Falcon存储引擎提供行级锁，此外，BDB支持页级锁。InnoDB的并发控制机制，下节详细讨论。&lt;/p&gt;
&lt;p&gt;另外，值得一提的是，MySQL的一些存储引擎（如InnoDB、BDB）除了使用封锁机制外，还同时结合MVCC机制，即多版本两阶段封锁协议(Multiversion two-phrase locking protocal)，来实现事务的并发控制，从而使得只读事务不用等待锁，提高了事务的并发性。&lt;/p&gt;
&lt;p&gt;注：并发控制是DBMS的核心技术之一(实际上，对于OS也一样)，它对系统性能有着至关重要的影响，以后再详细讨论。&lt;br&gt;
1.3、事务处理&lt;/p&gt;
&lt;p&gt;MySQL中，InnoDB和BDB都支持事务处理。这里主要讨论InnoDB的事务处理(关于BDB的事务处理，也十分复杂，以前曾较为详细看过其源码，以后有机会再讨论)。&lt;/p&gt;
&lt;p&gt;1.3.1、事务的ACID特性&lt;/p&gt;
&lt;p&gt;事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性(Jim Gray在《事务处理：概念与技术》中对事务进行了详尽的讨论)。&lt;/p&gt;
&lt;p&gt;(1)原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。&lt;br&gt;
(2)一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。&lt;br&gt;
(3)隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。&lt;br&gt;
(4)持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。&lt;/p&gt;
&lt;p&gt;1.3.2、事务处理带来的相关问题&lt;/p&gt;
&lt;p&gt;由于事务的并发执行，带来以下一些著名的问题：&lt;/p&gt;
&lt;p&gt;(1)更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。&lt;br&gt;
(2)脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。&lt;br&gt;
(3)不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。&lt;br&gt;
(4)幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。&lt;/p&gt;
&lt;p&gt;1.3.3、事务的隔离性&lt;/p&gt;
&lt;p&gt;SQL2标准定义了四个隔离级别。定义语句如下：&lt;/p&gt;
&lt;p&gt;SET TRANSACTION ISOLATION LEVEL&lt;br&gt;
[READ UNCOMMITTED |&lt;br&gt;
READ COMMITTED |&lt;br&gt;
REPEATABLE READ |&lt;br&gt;
SERIALIZABLE ]&lt;/p&gt;
&lt;p&gt;这与Jim Gray所提出的隔离级别有点差异。其中READ UNCOMMITTED即Jim的10（浏览）；READ COMMITTED即20，游标稳定性；REPEATABLE READ为2.99990隔离(没有幻像保护)；SERIALIZABLE隔离级别为30，完全隔离。SQL2标准默认为完全隔离(30)。各个级别存在问题如下：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;&lt;strong&gt;隔离级&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;104&quot;&gt;&lt;strong&gt;脏读&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;120&quot;&gt;&lt;strong&gt;幻象读&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;读未提交(Read uncommitted)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;104&quot;&gt;可能&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;可能&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;120&quot;&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;读提交(Read committed)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;104&quot;&gt;不可能&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;可能&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;120&quot;&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;可重复读(Repeatable read)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;104&quot;&gt;不可能&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;不可能&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;120&quot;&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;可串行化(Serializable)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;104&quot;&gt;不可能&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;不可能&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;120&quot;&gt;不可能&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;各个具体数据库并不一定完全实现了上述4个隔离级别，例如，Oracle只提供READ COMMITTED和Serializable两个标准隔离级别，另外还提供自己定义的Read only隔离级别；SQL Server除支持上述ISO/ANSI SQL92定义的4个隔离级别外，还支持一个叫做“快照”的隔离级别，但严格来说它是一个用MVCC实现的Serializable隔离级别。MySQL 支持全部4个隔离级别，其默认级别为Repeatable read，但在具体实现时，有一些特点，比如在一些隔离级别下是采用MVCC一致性读。国产数据库DM也支持所有级别，其默认级别为READ COMMITTED。&lt;/p&gt;
&lt;p&gt;1.3.4、InnoDB的锁模型&lt;/p&gt;
&lt;p&gt;InnoDB的行级锁有两种类型：&lt;/p&gt;
&lt;p&gt;(1)共享锁(shared lock，S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。&lt;br&gt;
(2)排它锁(exclusive lock，X)：允许获得排它锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。&lt;/p&gt;
&lt;p&gt;此外，InnoDB支持多粒度加锁(multiple granularity locking)，从而允许对记录和表同时加锁。为此，InnoDB引入意向锁(intention locks)，意向锁是针对表的：&lt;/p&gt;
&lt;p&gt;(1)意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。&lt;br&gt;
(2)意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。&lt;/p&gt;
&lt;p&gt;例如，SELECT … LOCK IN SHARE MODE加IS锁，SELECT … FOR UPDATE加IX锁，意向锁的规则如下：&lt;/p&gt;
&lt;p&gt;(1)事务在对表T中的记录获取S锁前，先要获取表T的IS锁或者更强的锁；&lt;br&gt;
(2)事务在获取表T中记录的X锁前，先要获取表T的IX锁。&lt;/p&gt;
&lt;p&gt;InnoDB的锁相容性矩阵：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/a2f8aa76118113a48535d489c37d71cd.jpg&quot; width=&quot;690&quot; height=&quot;108&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。意向锁只会阻塞其它事务对表的请求，例如，LOCK TABLES …WRITE，意向锁的主要目的是表明该事务将要或者正在对表中的记录加锁。使用封锁机制来进行并发控制，一个比较重要的问题就是死锁。&lt;br&gt;
来看一个死锁的例子：&lt;/p&gt;
&lt;p&gt;例1-1&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Session 1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Session 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; CREATE TABLE t (i INT) ENGINE = InnoDB;Query OK, 0 rows affected (0.22 sec)mysql&amp;gt; INSERT INTO t (i) VALUES(1);Query OK, 1 row affected (0.08 sec)
&lt;p&gt;mysql&amp;gt; START TRANSACTION;&lt;/p&gt;
&lt;p&gt;Query OK, 0 rows affected (0.00 sec)&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; SELECT * FROM t WHERE i = 1 LOCK IN SHARE MODE;&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;| i    |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;|    1 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;1 row in set (0.01 sec)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; START TRANSACTION;Query OK, 0 rows affected (0.00 sec)mysql&amp;gt; DELETE FROM t WHERE i = 1;等待…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; DELETE FROM t WHERE i = 1;等待…&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Query OK, 1 row affected (0.00 sec)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;1.3.5、一致性非阻塞读&lt;br&gt;
一致性读是MySQL的重要特点之一，InnoDB通过MVCC机制表示数据库某一时刻的查询快照，查询可以看该时刻之前提交的事务所做的改变，但是不能看到该时刻之后或者未提交事务所做的改变。但是，查询可以看到同一事务中之前语句所做的改变，例如：&lt;/p&gt;
&lt;p&gt;例1-2&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Session 1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Session 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; select * from t;Empty set (0.00 sec)mysql&amp;gt; INSERT INTO t (i) VALUES(1);Query OK, 1 row affected (0.00 sec)
&lt;p&gt;mysql&amp;gt; select * from t;&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;| i    |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;|    1 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;1 row in set (0.00 sec)&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; set autocommit = 0;&lt;/p&gt;
&lt;p&gt;Query OK, 0 rows affected (0.01 sec)&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; update t set i=3;&lt;/p&gt;
&lt;p&gt;Query OK, 1 row affected (0.00 sec)&lt;/p&gt;
&lt;p&gt;Rows matched: 1 Changed: 1 Warnings: 0&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from t;&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;| i    |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;|    3 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; set autocommit = 0;Query OK, 0 rows affected (0.00 sec)mysql&amp;gt; select * from t;+——+
&lt;p&gt;| i    |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;|    1 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; commit;Query OK, 0 rows affected (0.06 sec)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; select * from t;+——+| i    |+——+
&lt;p&gt;|    1 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&amp;gt; select * from t;+——+
&lt;p&gt;| i    |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;|    3 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果事务的隔离级别为REPEATABLE READ（默认），同一个事务中的所有一致性读都是读的事务的第一次读操作创建的快照。你可以提交当前事务，然后在新的查询中即可看到最新的快照，如上所示。&lt;br&gt;
如果事务的隔离级别为READ COMMITTED，一致性读只是对事务内部的读操作和它自己的快照而言的，结果如下：&lt;/p&gt;
&lt;p&gt;例1-3&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Session 1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Session 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;Query OK, 0 rows affected (0.01 sec)mysql&amp;gt; set autocommit = 0;Query OK, 0 rows affected (0.00 sec)
&lt;p&gt;mysql&amp;gt; select * from t;&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;| i    |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;|    3 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;Query OK, 0 rows affected (0.01 sec)mysql&amp;gt; set autocommit = 0;Query OK, 0 rows affected (0.00 sec)
&lt;p&gt;mysql&amp;gt; select * from t;&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;| i    |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;|    3 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; update t set i=5;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; select * from t;+——+| i    |+——+
&lt;p&gt;|    3 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; commit;Query OK, 0 rows affected (0.06 sec)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; select * from t;+——+| i    |+——+
&lt;p&gt;|    5 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;1 row in set (0.00 sec)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注意，session 2发生了不可重复读。&lt;/p&gt;
&lt;p&gt;当InnoDB在READ COMMITTED 和REPEATABLE READ隔离级别下处理SELECT语句时，一致性读是默认的模式。一致性读不会对表加任何锁，所以，其它连接可以同时改变表。&lt;br&gt;
假设事务处于REPEATABLE READ级别，当你正在进行一致性读时，InnoDB根据查询看到的数据给你一个时间点。如果其它的事务在该时间点之后删除一行，且提交事务，你不会看到行已经被删除，插入和更新操作一样。但是，InnoDB与其它DBMS的不同是，在REPEATABLE READ隔离级别下并不会造成幻像。&lt;br&gt;
一致性读不与DROP TABLE 或者 ALTER TABLE一起工作。&lt;br&gt;
在nodb_locks_unsafe_for_binlog变量被设置或者事务的隔离级别不是SERIALIZABLE的情况下，InnoDB对于没有指定FOR UPDATE 或 LOCK IN SHARE MODE的INSERT INTO … SELECT, UPDATE … (SELECT), 和CREATE TABLE … SELECT语句使用一致性读，在这种情况下，查询语句不会对表中的元组加锁。否则，InnoDB将使用锁。&lt;br&gt;
1.3.6、SELECT … FOR UPDATE和SELECT … LOCK IN SHARE MODE的加锁读(locking read)&lt;/p&gt;
&lt;p&gt;在一些场合，一致性读并不是很方便，此时，可以用加锁读。InnoDB支持两种加锁读：&lt;/p&gt;
&lt;p&gt;(1) SELECT … LOCK IN SHARE MODE：对读取的元组加S锁。&lt;br&gt;
(2) SELECT … FOR UPDATE：在扫描索引记录的过程中，会阻塞其它连接的SELECT …LOCK IN SHARE MODE和一定事务隔离级别下的读操作。&lt;/p&gt;
&lt;p&gt;InnoDB使用两阶段封锁协议，事务直到提交或回滚时才会释放所有的锁，这都是系统自动执行的。此外，MySQL支持LOCK TABLES和UNLOCK TABLES，但这些都是在服务器层实现的，而不是在存储引擎。它们有用处，但是不能取代存储引擎完成事务处理，如果你需要事务功能，请使用事务型存储引擎。&lt;br&gt;
来考虑locking read的应用，假设你要在表child插入一个新的元组，并保证child中的记录在表parent有一条父记录。如果你用一致性读来读parent表，确实可以将要插入的child row的parent row，但是可以安全的插入吗？不，因为在你读parent表时，其它连接可能已经删除该记录。（一致性读是针对事务内而言的，对于数据库的状态，它应该叫做“不一致性读”）&lt;br&gt;
此时，就可以使用SELECT LOCK IN SHARE MODE，它会对读取的元组加S锁，从而防止其它连接删除或更新元组。另外，如果你想在查询的同时，进行更新操作，可以使用SELECT … FOR UPDATE，它读取最新的数据，然后对读到的元组加X锁。此时，使用SELECT … LOCK IN SHARE MODE不是一个好主意，因为此时如果有两个事务进行这样的操作，就会造成死锁。&lt;/p&gt;
&lt;p&gt;注：SELECT … FOR UPDATE仅在自动提交关闭(即手动提交)时才会对元组加锁，而在自动提交时，符合条件的元组不会被加锁。&lt;/p&gt;
&lt;p&gt;1.3.7、记录锁(record lok)、间隙锁(gap lock)和后码锁(next-key lock)&lt;/p&gt;
&lt;p&gt;InnoDB有以下几种行级锁：&lt;/p&gt;
&lt;p&gt;(1)记录锁：对索引记录(index records)加锁，InnoDB行级锁是通过给索引的索引项加锁来实现的，而不是对记录实例本身加锁。如果表没有定义索引，InnoDB创建一个隐藏的聚簇索引，然后用它来实现记录加锁（关于索引与加锁之间的关系的详细介绍请看下一章）。&lt;br&gt;
(2)间隙锁：对索引记录之间的区间，或者第一个索引记录之前的区间和最后一个索引之后的区间加锁。&lt;br&gt;
(3)后码锁：对索引记录加记录锁，且对索引记录之前的区间加锁。&lt;/p&gt;
&lt;p&gt;默认情况下，InnoDB的事务工作在REPEATABLE READ的隔离级别，而且系统变量innodb_locks_unsafe_for_binlog为关闭状态。此时，InnoDB使用next-key锁进行查找和索引扫描，从而达到防止“幻像”的目的。&lt;br&gt;
Next-key锁是记录锁和间隙的结合体。当InnoDB查找或扫描表的索引时，对它遇到的索引记录加S锁或者X锁，所以，行级锁(row-level lock)实际上就是索引记录锁(index-record lock)；此外，它还对索引记录之前的区间加锁。也就是说，next-key锁是索引记录锁，外加索引记录之前的区间的间隙锁。如果一个连接对索引中的记录R持有S或X锁，其它的连接不能按照索引的顺序在R之前的区间插入一个索引记录。&lt;br&gt;
假设索引包含以下值：10, 11,13和20，则索引的next-key锁会覆盖以下区间(“(”表示不包含，“[”表示包含)：&lt;br&gt;
(negative infinity, 10]&lt;br&gt;
(10, 11]&lt;br&gt;
(11, 13]&lt;br&gt;
(13, 20]&lt;br&gt;
(20, positive infinity)&lt;br&gt;
对于最后一个区间，next-key锁将锁住索引最大值以上的区间，上界虚记录(“supremum” pseudo-record)的值比索引中的任何值都大，其实，上界不是一个真实的索引记录，所以，next-lock将对索引的最大值之后的区间加锁。&lt;/p&gt;
&lt;p&gt;间隙锁对查询唯一索引中的唯一值是没有必要的，例如，id列有唯一索引，则下面的查询仅对id=100的元组加索引记录锁(index-record lock)，而不管其它连接是否在之前的区间插入元组。&lt;br&gt;
SELECT * FROM child WHERE id = 100;&lt;br&gt;
如果id没有索引，或者非唯一索引，则语句会锁住之前的空间。&lt;br&gt;
例1-4&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;pre&gt;Session 1&lt;/pre&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;pre&gt;Session 2&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;pre&gt;mysql&amp;gt; create unique index i_index on t(i);&lt;/pre&gt;
&lt;pre&gt;Query OK, 0 rows affected (0.19 sec)&lt;/pre&gt;
&lt;pre&gt;Records: 0 Duplicates: 0 Warnings: 0&lt;/pre&gt;
&lt;pre&gt;mysql&amp;gt; select * from t;&lt;/pre&gt;
&lt;pre&gt;+------+&lt;/pre&gt;
&lt;pre&gt;| i    |&lt;/pre&gt;
&lt;pre&gt;+------+&lt;/pre&gt;
&lt;pre&gt;|    4 |&lt;/pre&gt;
&lt;pre&gt;|   10 |&lt;/pre&gt;
&lt;pre&gt;+------+&lt;/pre&gt;
&lt;pre&gt;2 rows in set (0.00 sec)&lt;/pre&gt;
&lt;pre&gt;&lt;/pre&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;pre&gt;mysql&amp;gt; set autocommit=0;&lt;/pre&gt;
&lt;pre&gt;Query OK, 0 rows affected (0.00 sec)&lt;/pre&gt;
&lt;pre&gt;mysql&amp;gt; select i from t where i =10 lock in share mode;&lt;/pre&gt;
&lt;pre&gt;+------+&lt;/pre&gt;
&lt;pre&gt;| i    |&lt;/pre&gt;
&lt;pre&gt;+------+&lt;/pre&gt;
&lt;pre&gt;|   10 |&lt;/pre&gt;
&lt;pre&gt;+------+&lt;/pre&gt;
&lt;pre&gt;1 row in set (0.00 sec)&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;pre&gt;mysql&amp;gt; insert into t(i) values(9);&lt;/pre&gt;
&lt;pre&gt;Query OK, 1 row affected (0.03 sec)&lt;/pre&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;pre&gt;mysql&amp;gt; select * from t;&lt;/pre&gt;
&lt;pre&gt;+------+&lt;/pre&gt;
&lt;pre&gt;| i    |&lt;/pre&gt;
&lt;pre&gt;+------+&lt;/pre&gt;
&lt;pre&gt;|    4 |&lt;/pre&gt;
&lt;pre&gt;|    9 |&lt;/pre&gt;
&lt;pre&gt;|   10 |&lt;/pre&gt;
&lt;pre&gt;+------+&lt;/pre&gt;
&lt;pre&gt;3 rows in set (0.00 sec)&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上例中，产生了幻像问题。如果将唯一查询变成范围查询，结果如下(接上例的索引)：&lt;/p&gt;
&lt;p&gt;例1-5&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Session 1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Session 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; select * from t;+——+| i    |+——+
&lt;p&gt;|    4 |&lt;/p&gt;
&lt;p&gt;|    9 |&lt;/p&gt;
&lt;p&gt;|   10 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; set autocommit=0;Query OK, 0 rows affected (0.00 sec)mysql&amp;gt; select i from t where i&amp;gt;4 lock in share mode;+——+
&lt;p&gt;| i    |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;|    9 |&lt;/p&gt;
&lt;p&gt;|   10 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; insert into t(i) values(1);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&amp;gt; insert into t(i) values(8);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看到，session 2 的next-key使得在i=4之前的区间和之后的插入都被阻塞。&lt;br&gt;
另外，如果删除索引i_index，则结果如下：&lt;/p&gt;
&lt;p&gt;例1-6&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Session 1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Session 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; drop index i_index on t;Query OK, 3 rows affected (0.25 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&amp;gt; select * from t;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;| i    |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;|    4 |&lt;/p&gt;
&lt;p&gt;|   10 |&lt;/p&gt;
&lt;p&gt;|    9 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; set autocommit=0;Query OK, 0 rows affected (0.00 sec)mysql&amp;gt; select i from t lock in share mode;+——+
&lt;p&gt;| i    |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;|    4 |&lt;/p&gt;
&lt;p&gt;|   10 |&lt;/p&gt;
&lt;p&gt;|    9 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; insert into t(i) values(8);等待。。。&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;另外，针对插入(INSERT)操作，只要多个事务不会在同一索引区间的同一个位置插入记录，它们就不用互相等待，这种情况可以称为插入意向间隙锁(insertion intention gap lock)。例如，索引记录的值为4和7，两个独立的事务分别插入5和6，仅管它们都持有4—7之间的间隙锁，但是它们不会相互阻塞。这可以提高事务的并发性。&lt;/p&gt;
&lt;p&gt;例1-7&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Session 1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;Session 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; select * from t;+——+| i    |+——+
&lt;p&gt;|    4 |&lt;/p&gt;
&lt;p&gt;|   10 |&lt;/p&gt;
&lt;p&gt;|    9 |&lt;/p&gt;
&lt;p&gt;|    8 |&lt;/p&gt;
&lt;p&gt;+——+&lt;/p&gt;
&lt;p&gt;4 rows in set (0.00 sec)&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; create unique index i_index on t(i);&lt;/p&gt;
&lt;p&gt;Query OK, 4 rows affected (0.34 sec)&lt;/p&gt;
&lt;p&gt;Records: 4 Duplicates: 0 Warnings: 0&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; set autocommit=0;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; set autocommit=0;Query OK, 0 rows affected (0.00 sec)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; insert into t(i) values(5);Query OK, 1 row affected (0.00 sec)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;mysql&amp;gt; insert into t(i) values(5);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&amp;gt; insert into t(i) values(6);Query OK, 1 row affected (0.00 sec)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;间隙锁是可以显示关闭的，如果你将事务的隔离级别设为READ COMMITTED，或者打开innodb_locks_unsafe_for_binlog系统变量，间隙锁就会关闭。在这种情况下，查找或扫描索引仅会进行外键约束检查和重复键值检查。&lt;/p&gt;
&lt;p&gt;此外，READ COMMITTED隔离级别和关闭nodb_locks_unsafe_for_binlog还有另外一个负作用：MySQL会释放掉不匹配Where条件的记录锁。例如，对于UPDATE语句，InnoDB只能进行“半一致性(semi_consistent)读”，所以，它会返回最新提交事务所做改变，从而产生不可重复读和幻像问题。&lt;/p&gt;
&lt;p&gt;1.3.8、使用next-key lock防止幻像问题&lt;br&gt;
例1-4展示了一个幻像问题。使用next-key锁的select语句可以解决幻像问题，但例1-4的之所以会产生总是在于唯一索引，使得select语句没有使用gap lock，而只使用了index-record lock。&lt;br&gt;
1.4、存储引擎&lt;/p&gt;
&lt;p&gt;插件式存储引擎是MySQL最重要特性之一，也是最不同于其它DBMS的地方。MySQL支持很多存储引擎，以适用于不同的应用需求，常用的包括MyISAM、InnoDB、BDB、MEMORY、MERGE、NDB Cluster等。其中，BDB和NDB Cluster提供事务支持。&lt;br&gt;
MySQL默认的存储引擎为MyISAM，当然，创建表的时候可以指定其它的存储引擎，你可以在同一个数据库中对不同的表使用不同的存储引擎(这是非常强大而独特的特性)。可以通过SHOW TABLE STATUS命令查询表所使用的存储引擎，例如，查看mysql数据库的user表：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;568&quot;&gt;mysql&amp;gt; SHOW TABLE STATUS LIKE ‘user’ \G*************************** 1. row ***************************Name: userEngine: MyISAM
&lt;p&gt;Version: 10&lt;/p&gt;
&lt;p&gt;Row_format: Dynamic&lt;/p&gt;
&lt;p&gt;Rows: 4&lt;/p&gt;
&lt;p&gt;Avg_row_length: 61&lt;/p&gt;
&lt;p&gt;Data_length: 244&lt;/p&gt;
&lt;p&gt;Max_data_length: 281474976710655&lt;/p&gt;
&lt;p&gt;Index_length: 2048&lt;/p&gt;
&lt;p&gt;Data_free: 0&lt;/p&gt;
&lt;p&gt;Auto_increment: NULL&lt;/p&gt;
&lt;p&gt;Create_time: 2009-06-16 21:50:34&lt;/p&gt;
&lt;p&gt;Update_time: 2009-09-30 14:59:08&lt;/p&gt;
&lt;p&gt;Check_time: NULL&lt;/p&gt;
&lt;p&gt;Collation: utf8_bin&lt;/p&gt;
&lt;p&gt;Checksum: NULL&lt;/p&gt;
&lt;p&gt;Create_options:&lt;/p&gt;
&lt;p&gt;Comment: Users and global privileges&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;Name：表的名称；&lt;/li&gt;
&lt;li&gt;Engine：表使用的存储引擎；&lt;/li&gt;
&lt;li&gt;Row_format：记录的格式。MyISAM支持三种不同的存储格式：静态(固定长度)表(默认格式)、动态表及压缩表。静态表的字段都是固定长度的，例如CHAR和INTEGER；动态表的字段可以是变长的，例如，VARCHAR或者BLOB。&lt;/li&gt;
&lt;li&gt;Rows：表中记录的数量。&lt;/li&gt;
&lt;li&gt;Avg_row_length：记录的平均长度(字节数)；&lt;/li&gt;
&lt;li&gt;Data_length：表中数据的全部字节数；&lt;/li&gt;
&lt;li&gt;Max_data_length：表中数据最大的字节数；&lt;/li&gt;
&lt;li&gt;Index_length：索引消耗的磁盘空间；&lt;/li&gt;
&lt;li&gt;Data_free：对于MyISAM表，表示已经分配但还没有使用的空间；该空间包含以前删除的记录留下的空间，可以被INSERT操作重用。&lt;/li&gt;
&lt;li&gt;Auto_increment：下一个自增的值。&lt;/li&gt;
&lt;li&gt;Check_time：上次使用CHECK TABLE或myisamchk检查表的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.4.1、MyISAM&lt;/p&gt;
&lt;p&gt;1.4.1.1、存储&lt;/p&gt;
&lt;p&gt;MySQL的默认存储引擎，性能与功能的折中，包括全文索引(full-text index)、数据压缩，支持空间(GIS)数据，但是，不支持事务和行级锁。一般来说，MyISAM更适用于大量查询操作。如果你有大量的插入、删除操作，你应该选择InnoDB。&lt;br&gt;
每个表包含3个文件：&lt;/p&gt;
&lt;p&gt;(1).frm：表定义文件，对于其它存储引擎也一样。&lt;br&gt;
(2).MYD文件：数据文件。&lt;br&gt;
(3).MYI文件：索引文件。&lt;/p&gt;
&lt;p&gt;可以在创建表时通过DATA DIRECTORY和INDEX DIRECTORY为数据文件和索引文件指定路径，它们可以位于不同目录。另外，MyISAM的存储格式是跨平台的，你可以将数据文件和索引文件从Intel平台拷贝到PPC或者SPARC平台。&lt;/p&gt;
&lt;p&gt;5.0中，MyISAM的变长记录表默认处理256TB数据，使用6字节的指针来指向数据记录；而之前的版本使用默认的4字节指针，所以只能处理4GB数据。所有的版本都可以将指针增加到8字节指针，如果你想改变MyISAM表的指针的大小，可以通过设置MAX_ROWS和AVG_ROW_LENGTH来实现：&lt;/p&gt;
&lt;p&gt;CREATE TABLE mytable (&lt;br&gt;
a INTEGER NOT NULL PRIMARY KEY,&lt;br&gt;
b CHAR(18) NOT NULL&lt;br&gt;
) MAX_ROWS = 1000000000 AVG_ROW_LENGTH = 32;&lt;/p&gt;
&lt;p&gt;上面的例子中，MySQL将至少可以存储32GB的数据。可以查看一下表的信息：&lt;/p&gt;
&lt;p&gt;：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;568&quot;&gt;mysql&amp;gt; SHOW TABLE STATUS LIKE ‘mytable’ \G*************************** 1. row ***************************Name: mytableEngine: MyISAM
&lt;p&gt;Row_format: Fixed&lt;/p&gt;
&lt;p&gt;Rows: 0&lt;/p&gt;
&lt;p&gt;Avg_row_length: 0&lt;/p&gt;
&lt;p&gt;Data_length: 0&lt;/p&gt;
&lt;p&gt;Max_data_length: 98784247807&lt;/p&gt;
&lt;p&gt;Index_length: 1024&lt;/p&gt;
&lt;p&gt;Data_free: 0&lt;/p&gt;
&lt;p&gt;Auto_increment: NULL&lt;/p&gt;
&lt;p&gt;Create_time: 2002-02-24 17:36:57&lt;/p&gt;
&lt;p&gt;Update_time: 2002-02-24 17:36:57&lt;/p&gt;
&lt;p&gt;Check_time: NULL&lt;/p&gt;
&lt;p&gt;Create_options: max_rows=1000000000 avg_row_length=32&lt;/p&gt;
&lt;p&gt;Comment:&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看到，Create_options列出了创建时的选项，而且该表的最大的数据量为91GB。你可以用ALTER TABLE来改变指针的大小，但是那会导致表和索引的重建，这会花费很长的时间。&lt;/p&gt;
&lt;p&gt;1.4.1.2、MyISAM的特性&lt;/p&gt;
&lt;p&gt;(1)锁与并发性：MyISAM只有表级锁，不支持行级锁。所以不适合于大量的写操作，但是它支持并发插入(concurrent inserts)，这是一个非常重要且有用的特性。&lt;br&gt;
(2)自动修复：MySQL支持自动检查和修复MyISAM表。&lt;br&gt;
(3)手动修复：你可以使用CHECK TABLE检查表的状态，并用REPAIR TABLE修复表。&lt;br&gt;
(4)索引：你可以为BLOB和TEXT的前500个字符创建索引。而且，MyISAM还支持全文索引，但仅限于CHAR、VARCHAR、和TEXT列。&lt;br&gt;
(5)延迟键写(Delayed key writes)：如果创建MyISAM表时指定DELAY_KEY_WRITE，MySQL在查询结束时，不会将改变的索引数据写入磁盘，而将修改保存在key buffer中。只有要改变缓存或者关闭表时，才会把索引数据刷入磁盘。&lt;/p&gt;
&lt;p&gt;1.4.2、InnoDB&lt;/p&gt;
&lt;p&gt;InnoDB是一个高性能的事务存储引擎，此外，BDB也支持事务处理(关于BDB，以前曾较为详细的阅读过其源码，以后有时间再讨论)，它有以下一些特点：&lt;/p&gt;
&lt;p&gt;1.4.2.1、表空间&lt;br&gt;
InnoDB存储表和索引有两种方式：&lt;/p&gt;
&lt;p&gt;(1)共享表空间存储：这种方式下，表的定义位于.frm文件中，数据和索引保存在innodb_data_home_dir和innodb_data_file_path指定的表空间中。&lt;br&gt;
(2)多表空间存储：表的定义仍位于.frm文件，但是，每个InnoDB表和它的索引在它自己的文件(.idb)中，每个表有它自己的表空间。&lt;br&gt;
对那些想把特定表格移到分离物理磁盘的用户，或者那些希望快速恢复单个表的备份而无须打断其余InnoDB表的使用的用户，使用多表空间会是有益的。你可以往my.cnf的[mysqld]节添加下面行来允许多表空间：&lt;/p&gt;
&lt;p&gt;[mysqld]&lt;br&gt;
innodb_file_per_table&lt;/p&gt;
&lt;p&gt;重启服务器之后，InnoDB存储每个新创建的表到表格所属于的数据库目录下它自己的文件tbl_name.ibd里。这类似于MyISAM存储引擎所做的，但MyISAM 把表分成数据文件tbl_name.MYD和索引文件tbl_name.MYI。对于InnoDB，数据和所以被一起存到.ibd文件。tbl_name.frm文件照旧依然被创建。&lt;/p&gt;
&lt;p&gt;如果你从my.cnf文件删除innodb_file_per_table行，并重启服务器，InnoDB在共享的表空间文件里再次创建表。&lt;br&gt;
innodb_file_per_table只影响表的创建。如果你用这个选项启动服务器，新表被用.ibd文件来创建，但是你仍旧能访问在共享表空间里的表。如果你删掉这个选项，新表在共享表空间内创建，但你仍旧可以访问任何用多表空间创建的表。&lt;/p&gt;
&lt;p&gt;InnoDB总是需要共享表空间，.ibd文件对InnoDB不足以去运行，共享表空间包含熟悉的ibdata文件，InnoDB把内部数据词典和undo日志放在这个文件中。&lt;/p&gt;
&lt;p&gt;1.4.2.2、外键约束&lt;br&gt;
MySQL中，支持外键的存储引擎只有InnoDB，在创建外键时，要求被参照表必须有对应的索引，参照表在创建外键时也会自动创建对应的索引。&lt;/p&gt;
&lt;p&gt;1.4.2.3、MVCC与后码锁(next-key locking)&lt;br&gt;
InnoDB将MVCC机制与next-key lock结合起来，实现事务的各个隔离级别，这是非常用意思的。在nodb_locks_unsafe_for_binlog变量被设置或者事务的隔离级别不是SERIALIZABLE的情况下，InnoDB对于没有指定FOR UPDATE 或 LOCK IN SHARE MODE的INSERT INTO … SELECT, UPDATE … (SELECT), 和CREATE TABLE … SELECT语句使用一致性读(参照前面)，在这种情况下，查询语句不会对表中的元组加锁。否则，InnoDB将使用锁。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《MySQL Manual》&lt;/p&gt;
&lt;p&gt;《High Performance MySQL》&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87121&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87121votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87121&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Mon, 25 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-25-87121-32418e1ba.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-25-87121-32418e1ba.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>由浅入深探究 MySQL索引结构原理、性能分析与优化</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;&lt;strong&gt;第一部分：基础知识：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索引&lt;/p&gt;
&lt;p&gt;官方介绍索引是帮助MySQL高效获取数据的数据结构。笔者理解索引相当于一本书的目录，通过目录就知道要的资料在哪里，不用一页一页查阅找出需要的资料。关键字index&lt;/p&gt;
&lt;p&gt;————————————————————-&lt;/p&gt;
&lt;p&gt;唯一索引&lt;/p&gt;
&lt;p&gt;强调唯一，就是索引值必须唯一，关键字unique index&lt;/p&gt;
&lt;p&gt;创建索引：&lt;/p&gt;
&lt;p&gt;1、create unique index 索引名 on 表名(列名);&lt;/p&gt;
&lt;p&gt;2、alter table 表名 add unique index 索引名 (列名);&lt;/p&gt;
&lt;p&gt;删除索引：&lt;/p&gt;
&lt;p&gt;1、 drop index 索引名 on 表名;&lt;/p&gt;
&lt;p&gt;2、 alter table 表名 drop index 索引名;&lt;/p&gt;
&lt;p&gt;————————————————————-&lt;/p&gt;
&lt;p&gt;主键&lt;/p&gt;
&lt;p&gt;主键就是唯一索引的一种，主键要求建表时指定，一般用auto_increatment列，关键字是primary key&lt;/p&gt;
&lt;p&gt;主键创建：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;creat table test2 (id int not null primary key auto_increment);&lt;/pre&gt;
&lt;p&gt;————————————————————-&lt;/p&gt;
&lt;p&gt;全文索引&lt;/p&gt;
&lt;p&gt;InnoDB不支持，Myisam支持性能比较好，一般在 CHAR、VARCHAR 或 TEXT 列上创建。&lt;/p&gt;
&lt;p&gt;Create table 表名( id int not null primary anto_increment,title&lt;/p&gt;
&lt;p&gt;varchar(100),FULLTEXT(title))type=myisam&lt;/p&gt;
&lt;p&gt;——————————&lt;/p&gt;
&lt;p&gt;单列索引与多列索引&lt;/p&gt;
&lt;p&gt;索引可以是单列索引也可以是多列索引(也叫复合索引)。按照上面形式创建出来的索引是单列索引，现在先看看创建多列索引：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;create table test3 (id int not null primary key auto_increment,uname char
(8) not null default &#39;&#39;,password char(12) not null,INDEX(uname,password))type
=myisam;&lt;/pre&gt;
&lt;p&gt;注意：INDEX(a, b, c)可以当做a或(a, b)的索引来使用，但和b、c或(b,c)的索引来使用这是一个最左前缀的优化方法，在后面会有详细的介绍，你只要知道有这样两个概念&lt;/p&gt;
&lt;p&gt;————————————————————-&lt;/p&gt;
&lt;p&gt;聚集索引&lt;/p&gt;
&lt;p&gt;一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。聚集索引确定表中数据的物理顺序。Mysql中myisam表是没有聚集索引的，innodb有(主键就是聚集索引)，聚集索引在下面介绍innodb结构的时有详细介绍。&lt;/p&gt;
&lt;p&gt;————————————————————-&lt;/p&gt;
&lt;p&gt;查看表的索引&lt;/p&gt;
&lt;p&gt;通过命令：Show index from 表名&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; show index from test3;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+----+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part |
Packed | Null | Index_type | Comment |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+----+
| test3 | 0 | PRIMARY | 1 | id | A | 0 | NULL |
NULL | | BTREE | |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+&lt;/pre&gt;
&lt;p&gt;Table：表名&lt;/p&gt;
&lt;p&gt;Key_name：什么类型索引(这了是主键)&lt;/p&gt;
&lt;p&gt;Column_name：索引列的字段名&lt;/p&gt;
&lt;p&gt;Cardinality：索引基数，很关键的一个参数，平均数值组=索引基数/表总数据行，平均数值组越接近1就越有可能利用索引&lt;/p&gt;
&lt;p&gt;Index_type：如果索引是全文索引，则是fulltext,这里是b+tree索引，b+tre也是这篇文章研究的重点之一&lt;/p&gt;
&lt;p&gt;其他的就不详细介绍，更多：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二部分：MYISAM和INNODB索引结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、 简单介绍B-tree B+ tree树&lt;/p&gt;
&lt;p&gt;B-tree结构视图&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/166d622e9c2fb7e5de13647356cfa551.jpg&quot; width=&quot;549&quot; height=&quot;236&quot;&gt;&lt;/p&gt;
&lt;p&gt;一棵m阶的B-tree树，则有以下性质&lt;/p&gt;
&lt;p&gt;(1)Ki表示关键字值，上图中，k1&amp;lt;k2&amp;lt;…&amp;lt;ki&amp;lt;k0&amp;lt;Kn(可以看出，一个节点的左子节点关键字值&amp;lt;该关键字值&amp;lt;右子节点关键字值)&lt;/p&gt;
&lt;p&gt;(2)Pi表示指向子节点的指针，左指针指向左子节点，右指针指向右子节点。即是：p1[指向值]&amp;lt;k1&amp;lt;p2[指向值]&amp;lt;k2……&lt;/p&gt;
&lt;p&gt;(3)所有关键字必须唯一值(这也是创建myisam 和innodb表必须要主键的原因)，每个节点包含一个说明该节点多少个关键字，如上图第二行的i和n&lt;/p&gt;
&lt;p&gt;(4)节点：&lt;/p&gt;
&lt;p&gt;l 每个节点最可以有m个子节点。&lt;/p&gt;
&lt;p&gt;l 根节点若非叶子节点，至少2个子节点，最多m个子节点&lt;/p&gt;
&lt;p&gt;l 每个非根，非叶子节点至少[m/2]子节点或叫子树([]表示向上取整)，最多m个子节点&lt;/p&gt;
&lt;p&gt;(5)关键字：&lt;/p&gt;
&lt;p&gt;l 根节点的关键字个数1~m-1&lt;/p&gt;
&lt;p&gt;l 非根非叶子节点的关键字个数[m/2]-1~m-1,如m=3，则该类节点关键字个数：2-1~2&lt;/p&gt;
&lt;p&gt;(6)关键字数k和指向子节点个数指针p的关系：&lt;/p&gt;
&lt;p&gt;l k+1=p ，注意根据储存数据的具体需求，左右指针为空时要有标志位表示没有&lt;/p&gt;
&lt;p&gt;B+tree结构示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/f6f063dd532cdde50086697c234cc8f1.jpg&quot; width=&quot;549&quot; height=&quot;236&quot;&gt;&lt;/p&gt;
&lt;p&gt;B+树是B-树的变体，也是一种多路搜索树：&lt;/p&gt;
&lt;p&gt;l 非叶子结点的子树指针与关键字个数相同&lt;/p&gt;
&lt;p&gt;l 为所有叶子结点增加一个链指针(红点标志的箭头)&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;B+树是B-树的变体，也是一种多路搜索树：&lt;/p&gt;
&lt;p&gt;l 非叶子结点的子树指针与关键字个数相同&lt;/p&gt;
&lt;p&gt;l 为所有叶子结点增加一个链指针(红点标志的箭头)&lt;/p&gt;
&lt;p&gt;2、 MyisAM索引结构&lt;/p&gt;
&lt;p&gt;MyisAM索引用的B+tree来储存数据，MyisAM索引的指针指向的是键值的地址，地址存储的是数据，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3020dd0a64902dd137130d60070e6d1c.jpg&quot; width=&quot;538&quot; height=&quot;450&quot;&gt;&lt;/p&gt;
&lt;p&gt;(1)结构讲解：上图3阶树，主键是Col2，Col值就是改行数据保存的物理地址，其中红色部分是说明标注。&lt;/p&gt;
&lt;p&gt;l 1标注部分也许会迷惑，前面不是说关键字15右指针的指向键值要大于15，怎么下面还有15关键字？因为B+tree的所以叶子节点包含所有关键字且是按照升序排列(主键索引唯一，辅助索引可以不唯一)，所以等于关键字的数据值在右子树&lt;/p&gt;
&lt;p&gt;l 2标注是相应关键字存储对应数据的物理地址，注意这也是之后和InnoDB索引不同的地方之一&lt;/p&gt;
&lt;p&gt;l 2标注也是一个所说MyiAM表的索引和数据是分离的，索引保存在”表名.MYI”文件内，而数据保存在“表名.MYD”文件内，2标注的物理地址就是“表名.MYD”文件内相应数据的物理地址。(InnoDB表的索引文件和数据文件在一起)&lt;/p&gt;
&lt;p&gt;l 辅助索引和主键索引没什么大的区别，辅助索引的索引值是可以重复的(但InnoDB辅助索引和主键索引有很明显的区别，这里先提醒注意一下)&lt;/p&gt;
&lt;p&gt;3、 Annode索引结构&lt;/p&gt;
&lt;p&gt;(1)首先有一个表，内容和主键索引结构如下两图：&lt;/p&gt;
&lt;p&gt;Col1  Col2  Col3&lt;/p&gt;
&lt;p&gt;1  15  phpben&lt;/p&gt;
&lt;p&gt;2  20  mhycoe&lt;/p&gt;
&lt;p&gt;3  23  phpyu&lt;/p&gt;
&lt;p&gt;4  25  bearpa&lt;/p&gt;
&lt;p&gt;5  40  phpgoo&lt;/p&gt;
&lt;p&gt;6  45  phphao&lt;/p&gt;
&lt;p&gt;7  48  phpxue&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/b6a84fb9032a176a91ca80735f0c6a69.jpg&quot; width=&quot;576&quot; height=&quot;346&quot;&gt;&lt;/p&gt;
&lt;p&gt;结构上：由上图可以看出InnoDB的索引结构很MyisAM的有很明显的区别&lt;/p&gt;
&lt;p&gt;l MyisAM表的索引和数据是分开的，用指针指向数据的物理地址，而InnoDB表中索引和数据是储存在一起。看红框1可一看出一行数据都保存了。&lt;/p&gt;
&lt;p&gt;l 还有一个上图多了三行的隐藏数据列(虚线表)，这是因为MyisAM不支持事务，InnoDB处理事务在性能上并发控制上比较好，看图中的红框2中的DB_TRX_ID是事务ID，自动增长；db_roll_ptr是回滚指针，用于事务出错时数据回滚恢复；db_row_id是记录行号，这个值其实在主键索引中就是主键值，这里标出重复是为了容易介绍，还有的是若不是主键索引(辅助索引)，db_row_id会找表中unique的列作为值，若没有unique列则系统自动创建一个。关于InnoDB跟多事务MVCC点此：http://www.phpben.com/?post=72&lt;/p&gt;
&lt;p&gt;(2)加入上表中Col1是主键(下图标错)，而Col2是辅助索引，则相应的辅助索引结构图：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/f04c749384f56dddb89106aedd5e502d.jpg&quot; width=&quot;576&quot; height=&quot;265&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;可以看出InnoDB辅助索引并没有保存相应的所有列数据，而是保存了主键的键值(图中1、2、3….)这样做利弊也是很明显：&lt;/p&gt;
&lt;p&gt;l 在已有主键索引，避免数据冗余，同时在修改数据的时候只需修改辅助索引值。&lt;/p&gt;
&lt;p&gt;l 但辅助索引查找数据事要检索两次，先找到相应的主键索引值然后在去检索主键索引找到对应的数据。这也是网上很多mysql性能优化时提到的“主键尽可能简短”的原因，主键越长辅助索引也就越大，当然主键索引也越大。&lt;/p&gt;
&lt;p&gt;4、 MyisAM索引与InnoDB索引相比较&lt;/p&gt;
&lt;p&gt;l MyisAM支持全文索引(FULLTEXT)、压缩索引，InnoDB不支持&lt;/p&gt;
&lt;p&gt;l AnnoDB支持事务，MyisAM不支持&lt;/p&gt;
&lt;p&gt;l MyisAM顺序储存数据，索引叶子节点保存对应数据行地址，辅助索引很主键索引相差无几；AnnoDB主键节点同时保存数据行，其他辅助索引保存的是主键索引的值&lt;/p&gt;
&lt;p&gt;l MyisAM键值分离，索引载入内存(key_buffer_size),数据缓存依赖操作系统；InnoDB键值一起保存，索引与数据一起载入InnoDB缓冲池&lt;/p&gt;
&lt;p&gt;l MyisAM主键(唯一)索引按升序来存储存储，InnoDB则不一定&lt;/p&gt;
&lt;p&gt;l MyisAM索引的基数值(Cardinality，show index 命令可以看见)是精确的，InnoDB则是估计值。这里涉及到信息统计的知识，MyisAM统计信息是保存磁盘中，在alter表或Analyze table操作更新此信息，而InnoDB则是在表第一次打开的时候估计值保存在缓存区内&lt;/p&gt;
&lt;p&gt;l MyisAM处理字符串索引时用增量保存的方式，如第一个索引是‘preform’，第二个是‘preformence’，则第二个保存是‘7，ance‘，这个明显的好处是缩短索引，但是缺陷就是不支持倒序提取索引，必须顺序遍历获取索引&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三部分：MYSQL优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql优化是一个重大课题之一，这里会重点详细的介绍mysql优化，包括表数据类型选择，sql语句优化，系统配置与维护优化三类。&lt;/p&gt;
&lt;p&gt;1、 表数据类型选择&lt;/p&gt;
&lt;p&gt;(1)能小就用小。表数据类型第一个原则是：使用能正确的表示和存储数据的最短类型。这样可以减少对磁盘空间、内存、cpu缓存的使用。&lt;/p&gt;
&lt;p&gt;(2)避免用NULL，这个也是网上优化技术博文传的最多的一个。理由是额外增加字节，还有使索引，索引统计和值更复杂。很多还忽略一&lt;/p&gt;
&lt;p&gt;个count(列)的问题，count(列)是不会统计列值为null的行数。更多关于NULL可参考：http://www.phpben.com/?post=71&lt;/p&gt;
&lt;p&gt;(3)字符串如何选择char和varchar？一般phper能想到就是char是固定大小，varchar能动态储存数据。这里整理一下这两者的区别：&lt;/p&gt;
&lt;p&gt;属性  Char  Varchar&lt;/p&gt;
&lt;p&gt;值域大小  最长字符数是255(不是字节)，不管什么编码，超过此值则自动截取255个字符保存并没有报错。  65535个字节，开始两位存储长度，超过255个字符，用2位储存长度，否则1位，具体字符长度根据编码来确定，如utf8，&lt;span style=&quot;color: #333333;font-style: normal&quot;&gt;则字符最长是21845个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如何处理字符串末尾空格  去掉末尾空格，取值出来比较的时候自动加上进行比较  Version&amp;lt;=4.1，字符串末尾空格被删掉，version&amp;gt;5.0则保留&lt;/p&gt;
&lt;p&gt;储存空间  固定空间，比喻char(10)不管字符串是否有10个字符都分配10个字符的空间  Varchar内节约空间，但更新可能发生变化，若varchar(10),开始若储存5个字符，当update成7个时有myisam可能把行拆开，innodb可能分页，这样开销就增大&lt;/p&gt;
&lt;p&gt;适用场合    适用于存储很短或固定或长度相似字符，如MD5加密的密码char(33)、昵称char(8)等    当最大长度远大于平均长度并且发生更新的时候。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;注意当一些英文或数据的时候，最好用每个字符用字节少的类型，如latin1&lt;/p&gt;
&lt;p&gt;(4)整型、整形优先原则&lt;/p&gt;
&lt;p&gt;Tinyint、smallint、mediumint、int、bigint，分别需要8、16、24、32、64。&lt;/p&gt;
&lt;p&gt;值域范围：-2^(n-1)~ 2^(n-1)-1&lt;/p&gt;
&lt;p&gt;很多程序员在设计数据表的时候很习惯的用int，压根不考虑这个问题&lt;/p&gt;
&lt;p&gt;笔者建议：能用tinyint的绝不用smallint&lt;/p&gt;
&lt;p&gt;误区：int(1) 和int(11)是一样的，唯一区别是mysql客户端显示的时候显示多少位。&lt;/p&gt;
&lt;p&gt;整形优先原则：能用整形的不用其他类型替换，如ip可以转换成整形保存，如商品价格‘50.00元’则保存成50&lt;/p&gt;
&lt;p&gt;(5)精确度与空间的转换。在存储相同数值范围的数据时，浮点数类型通常都会比DECIMAL类型使用更少的空间。FLOAT字段使用4字节存储&lt;/p&gt;
&lt;p&gt;数据。DOUBLE类型需要8 个字节并拥有更高的精确度和更大的数值范围，DECIMAL类型的数据将会转换成DOUBLE类型。&lt;/p&gt;
&lt;p&gt;2、 sql语句优化&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; create table one (
id smallint(10) not null auto_increment primary key,
username char(8) not null,
password char(4) not null,
`level` tinyint (1) default 0,
last_login char(15) not null,
index(username,password,last_login))engine=innodb;&lt;/pre&gt;
&lt;p&gt;这是test表，其中id是主键，多列索引(username,password,last_login),里面有10000多条数据.&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null |
Index_type | Comment |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+
| one | 0 | PRIMARY | 1 | id | A |20242 | NULL | NULL | |
BTREE | |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+
| one | 1 | username | 1 | username | A |10121 | NULL | NULL | |
BTREE | |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+
| one | 1 | username | 2 | password | A |10121 | NULL | NULL | YES |
BTREE | |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+
| one | 1 | username | 3 | last_login | A |20242 | NULL | NULL | |
BTREE | |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+&lt;/pre&gt;
&lt;p&gt;(1) 最左前缀原则&lt;/p&gt;
&lt;p&gt;定义：最左前缀原则指的的是在sql where 字句中一些条件或表达式中出现的列的顺序要保持和多索引的一致或以多列索引顺序出现，只要出现非顺序出现、断层都无法利用到多列索引。&lt;/p&gt;
&lt;p&gt;举例说明：上面给出一个多列索引(username,password,last_login)，当三列在where中出现的顺序如(username,password,last_login)、(username,password)、(username)才能用到索引，如下面几个顺序(password,last_login)、(passwrod)、(last_login)—这三者不从username开始，(username,last_login)—断层，少了password，都无法利用到索引。&lt;/p&gt;
&lt;p&gt;因为B+tree多列索引保存的顺序是按照索引创建的顺序，检索索引时按照此顺序检索&lt;/p&gt;
&lt;p&gt;测试：以下测试不精确，这里只是说明如何才能正确按照最左前缀原则使用索引。还有的是以下的测试用的时间0.00sec看不出什么时间区别，因为数据量只有20003条，加上没有在实体机上运行，很多未可预知的影响因素都没考虑进去。当在大数据量，高并发的时候，最左前缀原则对与提高性能方面是不可否认的。&lt;/p&gt;
&lt;p&gt;Ps：最左前缀原则中where字句有or出现还是会遍历全表&lt;/p&gt;
&lt;p&gt;(1.1)能正确的利用索引&lt;/p&gt;
&lt;p&gt;l Where子句表达式顺序是(username)&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one where username=&#39;abgvwfnt&#39;;
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref |rows | Extra |
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------------+
| 1 | SIMPLE | one | ref | username | username | 24 | const |5 | Using where |
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;l Where子句表达式顺序是(username,password)&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one where username=&#39;abgvwfnt&#39; and password=&#39;123456&#39;;
+----+-------------+-------+------+---------------+----------+---------+-------------+------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+----+-------------+-------+------+---------------+----------+---------+-------------+------+-------------+
| 1 | SIMPLE | one | ref | username | username | 43 | const,const | 1 | Using where |
+----+-------------+-------+------+---------------+----------+---------+-------------+------+-------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;l Where子句表达式顺序是(username,password, last_login)&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one where username=&#39;abgvwfnt&#39; and password=&#39;123456&#39;and last_login=&#39;1338251170&#39;;
+----+-------------+-------+------+---------------+----------+---------+-------------------+------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref| rows | Extra |
+----+-------------+-------+------+---------------+----------+---------+-------------------+------+-------------+
| 1 | SIMPLE | one | ref | username | username | 83 | const,const,const | 1 | Using where |
+----+-------------+-------+------+---------------+----------+---------+-------------------+------+-------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;上面可以看出type=ref 是多列索引，key_len分别是24、43、83，这说明用到的索引分别是(username), (username,password), (username,password, last_login );row分别是5、1、1检索的数据行都很少，因为这三个查询都按照索引前缀原则，可以利用到索引。&lt;/p&gt;
&lt;p&gt;(1.2)不能正确的利用索引&lt;/p&gt;
&lt;p&gt;l Where子句表达式顺序是(password, last_login)&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one where password=&#39;123456&#39;and last_login=&#39;1338251170&#39;;
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows| Extra |
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
| 1 | SIMPLE | one | ALL | NULL | NULL | NULL | NULL | 20146 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;l Where 子句表达式顺序是(last_login)&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one where last_login=&#39;1338252525&#39;;
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows| Extra |
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
| 1 | SIMPLE | one | ALL | NULL | NULL | NULL | NULL | 20146 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;以上的两条语句都不是以username开始，这样是用不了索引，通过type=all(全表扫描)，key_len=null，rows都很大20146&lt;/p&gt;
&lt;p&gt;Ps：one表里只有20003条数据，为什么出现20146，这是优化器对表的一个估算值，不精确的。&lt;/p&gt;
&lt;p&gt;l Where 子句表达式虽然顺序是(username,password, last_login)或(username,password)但第一个是有范围’&amp;lt;’、’&amp;gt;’，’&amp;lt;=’，’&amp;gt;=’等出现&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one where username&amp;gt;&#39;abgvwfnt&#39; and password =&#39;123456&#39;and last_login=&#39;1338251170&#39;;
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows| Extra |
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
| 1 | SIMPLE | one | ALL | username | NULL | NULL | NULL | 20146 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;这个查询很明显是遍历所有表，一个索引都没用到，非第一列出现范围(password列或last_login列)，则能利用索引到首先出现范围的一列，也就是“where username=’abgvwfnt’ and password &amp;gt;’123456′and last_login=’1338251170′;”或则“where username=’abgvwfnt’ and password &amp;gt;’123456′and last_login&amp;lt;’1338251170′;”索引长度ref_len=43,索引检索到password列，所以考虑多列索引的时候把那些查询语句用的比较的列放在最后(或非第一位)。&lt;/p&gt;
&lt;p&gt;l 断层，即是where顺序(username, last_login)&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one where username=&#39;abgvwfnt&#39; and last_login=&#39;1338252525&#39;;
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------------+
| 1 | SIMPLE | one | ref | username | username | 24 | const |5 | Using where |
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;注意这里的key_len=24=8*3(8是username的长度，3是utf8编码)，rows=5，和下面一条sql语句搜索出来一样&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; select * from one where username=&#39;abgvwfnt&#39;;
+-------+----------+----------+-------+------------+
| id | username | password | level | last_login |
+-------+----------+----------+-------+------------+
| 3597 | abgvwfnt | 234567 | 0 | 1338251420 |
| 7693 | abgvwfnt | 456789 | 0 | 1338251717 |
| 11789 | abgvwfnt | 456789 | 0 | 1338251992 |
| 15885 | abgvwfnt | 456789 | 0 | 1338252258 |
| 19981 | abgvwfnt | 456789 | 0 | 1338252525 |
+-------+----------+----------+-------+------------+
5 rows in set (0.00 sec)

mysql&amp;gt; select * from one where username=&#39;abgvwfnt&#39; and last_login=&#39;1338252525&#39;;
+-------+----------+----------+-------+------------+
| id | username | password | level | last_login |
+-------+----------+----------+-------+------------+
| 19981 | abgvwfnt | 456789 | 0 | 1338252525 |
+-------+----------+----------+-------+------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;这个就是要的返回结果，所以可以知道断层(username,last_login)，这样只用到username索引，把用到索引的数据再重新检查last_login条件，这个相对全表查询来说还是有性能上优化，这也是很多sql优化文章中提到的where 范围查询要放在最后(这不绝对，但可以利用一部分索引)&lt;/p&gt;
&lt;p&gt;(1.3)如果一个查询where子句中确实不需要password列，那就用“补洞”。&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; select distinct(password) from one;
+----------+
| password |
+----------+
| 234567 |
| 345678 |
| 456789 |
| 123456 |
+----------+
4 rows in set (0.08 sec)&lt;/pre&gt;
&lt;p&gt;可以看出password列中只有这几个值，当然在现实中不可能密码有这么多一样的，再说数据也可能不断更新，这里只是举例说明补洞的方法&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one where username=&#39;abgvwfnt&#39; and password in(&#39;123456&#39;,&#39;234567&#39;,&#39;345678&#39;,&#39;456789&#39;)
and last_login=&#39;1338251170&#39;;
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
| 1 | SIMPLE | one | range | username | username| 83 | NULL |4 | Using where |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;可以看出ref=83 所有的索引都用到了，type=range是因为用了in子句。&lt;/p&gt;
&lt;p&gt;这个被“补洞”列中的值应该是有限的，可预知的，如性别，其值只有男和女(加多一个不男不女也无妨)。&lt;/p&gt;
&lt;p&gt;“补洞”方法也有瓶颈，当很多列，且需要补洞的相应列(可以多列)的值虽有限但很多(如中国城市)的时候，优化器在优化时组合起来的数量是很大，这样的话就要做好基准测试和性能分析，权衡得失，取得一个合理的优化方法。&lt;/p&gt;
&lt;p&gt;(1.4)like&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one where username like &#39;abgvwfnt%&#39;;
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref |
rows | Extra |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
| 1 | SIMPLE | one | range | username | username | 24 | NULL |
5 | Using where |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
1 row in set (0.00 sec)
mysql&amp;gt; explain select * from one where username like &#39;%abgvwfnt%&#39;;
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows| Extra |
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
| 1 | SIMPLE | one | ALL | NULL | NULL | NULL | NULL | 20259 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
1 row in set (0.01 sec)&lt;/pre&gt;
&lt;p&gt;对比就知道like操作abgvwfnt%能用到索引，%abgvwfnt%用不到&lt;/p&gt;
&lt;p&gt;———————————————————————————————&lt;/p&gt;
&lt;p&gt;(2) Order by 优化&lt;/p&gt;
&lt;p&gt;(2.1)filesort优化算法.&lt;/p&gt;
&lt;p&gt;在mysql version()&amp;lt;4.1之前，优化器采用的是filesort第一种优化算法，先提取键值和指针，排序后再去提取数据，前后要搜索数据两次，第一次若能使用索引则使用，第二次是随机读(当然不同引擎也不同)。mysql version()&amp;gt;=4.1,更新了一个新算法，就是在第一次读的时候也把selcet的列也读出来，然后在sort_buffer_size中排序(不够大则建临时表保存排序顺序)，这算法只需要一次读取数据。所以有这个广为人传的一个优化方法，那就是增大sort_buffer_size。Filesort第二种算法要用到更的空间，sort_buffer_size不够大反而会影响速度，所以mysql开发团队定了个变量max_length_for_sort_data，当算法中读出来的需要列的数据的大小超过该变量的值才使用，所以一般性能分析的时候会尝试把max_length_for_sort_data改小。&lt;/p&gt;
&lt;p&gt;(2.2)单独order by 用不了索引，索引考虑加where 或加limit&lt;/p&gt;
&lt;p&gt;先建一个索引(last_login),建的过程就不给出了&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one order by last_login desc;
+----+-------------+-------+------+---------------+------+---------+------+-------+----------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows
| Extra |
+----+-------------+-------+------+---------------+------+---------+------+-------+----------------+
| 1 | SIMPLE | one | ALL | NULL | NULL | NULL | NULL | 2046
3 | Using filesort |
+----+-------------+-------+------+---------------+------+---------+------+-------+----------------+
1 row in set (0.00 sec)

mysql&amp;gt; explain select * from one order by last_login desc limit 10;
+----+-------------+-------+-------+---------------+------------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key | key_len | ref
| rows | Extra |
+----+-------------+-------+-------+---------------+------------+---------+------+------+-------+
| 1 | SIMPLE | one | index | NULL | last_login | 4 | NULL
| 10 | |
+----+-------------+-------+-------+---------------+------------+---------+------+------+-------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;开始没limit查询是遍历表的，加了limit后，索引可以使用，看key_len 和key&lt;/p&gt;
&lt;p&gt;(2.3)where + orerby 类型，where满足最左前缀原则，且orderby的列和where子句用到的索引的列的子集。即是(a,b,c)索引，where满足最左前缀原则且order by中列a、b、c的任意组合&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one where username=&#39;abgvwfnt&#39; and password =&#39;123456
&#39; and last_login=&#39;1338251001&#39; order by password desc,last_login desc;

+----+-------------+-------+------+---------------+----------+---------+-------------------+------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref

| rows | Extra |
+----+-------------+-------+------+---------------+----------+---------+-------------------+------+-------------+
| 1 | SIMPLE | one | ref | username | username | 83 | const,c
onst,const | 1 | Using where |
+----+-------------+-------+------+---------------+----------+---------+-------------------+------+-------------+
1 row in set (0.00 sec)

mysql&amp;gt; explain select * from one where username=&#39;abgvwfnt&#39; and password =&#39;123456
&#39; and last_login=&#39;1338251001&#39; order by password desc,level desc;
+----+-------------+-------+------+---------------+----------+---------+-------------------+------+----------------------------+
| id | select_type | table | type | possible_keys | key | key_len | ref| rows | Extra |
+----+-------------+-------+------+---------------+----------+---------+-------------------+------+-----------------------------+
| 1 | SIMPLE | one | ref | username | username | 83 | const,c
onst,const | 1 | Using where; Using filesort |
+----+-------------+-------+------+---------------+----------+---------+-------------------+------+-----------------------------+

1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;上面两条语句明显的区别是多了一个非索引列level的排序，在extra这列对了Using filesort&lt;/p&gt;
&lt;p&gt;笔者测试结果：where满足最左前缀且order by中的列是该多列索引的子集时(也就是说orerby中没最左前缀原则限制)，不管是否有asc ,desc混合出现，都能用索引来满足order by。&lt;/p&gt;
&lt;p&gt;笔者测试过，因为篇幅比较大，这里就不一一列出。&lt;/p&gt;
&lt;p&gt;Ps:很优化博文都说order by中的列要where中出现的列(是索引)的顺序一致，笔者认为不够严谨。&lt;/p&gt;
&lt;p&gt;(2.3) where + orerby+limit&lt;/p&gt;
&lt;p&gt;这个其实也差不多，只要where最左前缀，orderby也正确，limit在此影响不大&lt;/p&gt;
&lt;p&gt;(2.4)如何考虑order by来建索引&lt;/p&gt;
&lt;p&gt;这个回归到创建索引的问题来，在比较常用的oder by的列和where中常用的列建立多列索引，这样优化起来的广度和扩张性都比较好，当然如果要考虑UNION、JOIN、COUNT、IN等进来就复杂很多了&lt;/p&gt;
&lt;p&gt;(3) 隔离列&lt;/p&gt;
&lt;p&gt;隔离列是只查询语句中把索引列隔离出来，也就是说不能在语句中把列包含进表达式中，如id+1=2、inet_aton(’210.38.196.138′)—ip转换成整数、convert(123,char(3))—数字转换成字符串、date函数等mysql内置的大多函数。&lt;/p&gt;
&lt;p&gt;非隔离列影响性能很大甚至是致命的，这也就是赶集网石展的《三十六军规》中的一条，虽然他没说明是隔离列。&lt;/p&gt;
&lt;p&gt;以下就测试一下：&lt;/p&gt;
&lt;p&gt;首先建立一个索引(last_login )，这里就不给出建立的代码了，且把last_login改成整型(这里只是为了方便测试，并不是影响条件)&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one where last_login = 8388605;
+----+-------------+-------+------+---------------+------------+---------+-------+-------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+----+-------------+-------+------+---------------+------------+---------+-------+-------+-------------+
| 1 | SIMPLE | one | ref | last_login | last_login | 3 | const
| 1 | Using where |
+----+-------------+-------+------+---------------+------------+---------+-------+-------+-------------+
1 row in set, 1 warning (0.00 sec)
容易看出建的索引已起效
mysql&amp;gt; explain select * from one where last_login +1= 8388606 ;
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows
| Extra |
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
| 1 | SIMPLE | one | ALL | NULL | NULL | NULL | NULL | 2049
7 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;last_login +1=8388608非隔离列的出现导致查找的列20197，说明是遍历整张表且索引不能使用。&lt;/p&gt;
&lt;p&gt;这是因为这条语句要找出所有last_login的数据，然后+1再和20197比较，优化器在这方面比较差，性能很差。&lt;/p&gt;
&lt;p&gt;所以要尽可能的把列隔离出来，如last_login +1=8388606改成login_login=8388607,或者把计算、转换等操作先用php函数处理过再传递给mysql服务器&lt;/p&gt;
&lt;p&gt;(4) OR、IN、UNION ALL，可以尝试用UNION ALL&lt;/p&gt;
&lt;p&gt;(4.1)or会遍历表就算有索引&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; explain select * from one where username = &#39;abgvwfnt&#39; or password=&#39;123456&#39;;
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows| Extra |
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
| 1 | SIMPLE | one | ALL | username | NULL | NULL | NULL | 20259 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+-------+-------------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;p&gt;(4.2)对于in，这个是有争议的，网上很多优化方案中都提到尽量少用in，这不全面，其实在in里面如果是常量的话，可一大胆的用in，这个也是赶集网石展、阿里hellodab的观点(笔者从微博中获知)。应用hellodab一句话“MySQL用IN效率不好，通常是指in中嵌套一个子查询，因为MySQL的查询重写可能会产生一个不好的执行计划，而如果in里面是常量的话，我认为性能没有任何问题，可以放心使用”———当然对于这个比较的话，没有实战数据的话很难辩解，就算有，影响性能的因素也很多，也许会每个dba都有不同的测试结果.这也签名最左前缀中“补洞”一个方法&lt;/p&gt;
&lt;p&gt;(4.3)UNION All 直接返回并集，可以避免去重的开销。之所说“尝试”用UNION All 替代 OR来优化sql语句，因为这不是一直能优化的了，这里只是作为一个方法去尝试。&lt;/p&gt;
&lt;p&gt;(5) 索引选择性&lt;/p&gt;
&lt;p&gt;索引选择性是不重复的索引值也叫基数(cardinality)表中数据行数的比值，索引选择性=基数/数据行，基数可以通过“show index from 表名”查看。&lt;/p&gt;
&lt;p&gt;高索引选择性的好处就是mysql查找匹配的时候可以过滤更多的行，唯一索引的选择性最佳，值为1。&lt;/p&gt;
&lt;p&gt;那么对于非唯一索引或者说要被创建索引的列的数据内容很长，那就要选择索引前缀。这里就简单说明一下：&lt;/p&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;mysql&amp;gt; select count(distinct(username))/count(*) from one;
+------------------------------------+
| count(distinct(username))/count(*) |
+------------------------------------+
| 0.2047 |
+------------------------------------+
1 row in set (0.09 sec)&lt;/pre&gt;
&lt;p&gt;count(distinct(username))/count(*)就是索引选择性的值，这里0.2太小了。&lt;/p&gt;
&lt;p&gt;假如username列数据很长，则可以通过&lt;/p&gt;
&lt;p&gt;select count(distinct(concat(first_name, left(last_name, N))/count(*) from one;测试出接近1的索引选择性，其中N是索引的长度，穷举法去找出N的值，然后再建索引。&lt;/p&gt;
&lt;p&gt;(6) 重复或多余索引&lt;/p&gt;
&lt;p&gt;很多phper开始都以为建索引相对多点性能就好点，压根没考虑到有些索引是重复的，比如建一个(username),(username,password), (username,password,last_login),很明显第一个索引是重复的，因为后两者都能满足其功能。&lt;/p&gt;
&lt;p&gt;要有个意识就是，在满足功能需求的情况下建最少索引。对于INNODB引擎的索引来说，每次修改数据都要把主键索引，辅助索引中相应索引值修改，这可能会出现大量数据迁移，分页，以及碎片的出现。&lt;/p&gt;
&lt;p&gt;3、系统配置与维护优化&lt;/p&gt;
&lt;p&gt;(1) 重要的一些变量&lt;/p&gt;
&lt;p&gt;l key_buffer_size索引块缓存区大小, 针对MyISAM存储引擎,该值越大,性能越好.但是超过操作系统能承受的最大值,反而会使mysql变得不稳定. —-这是很重要的参数&lt;/p&gt;
&lt;p&gt;l sort_buffer_size 这是索引在排序缓冲区大小，若排序数据大小超过该值，则创建临时文件，注意和myisam_sort_buffer_size的区别—-这是很重要的参数&lt;/p&gt;
&lt;p&gt;l read_rnd_buffer_size当排序后按排序后的顺序读取行时，则通过该缓冲区读取行，避免搜索硬盘。将该变量设置为较大的值可以大大改进ORDER BY的性能。但是，这是为每个客户端分配的缓冲区，因此你不应将全局变量设置为较大的值。相反，只为需要运行大查询的客户端更改会话变量&lt;/p&gt;
&lt;p&gt;l join_buffer_size用于表间关联(join)的缓存大小&lt;/p&gt;
&lt;p&gt;l tmp_table_size缓存表的大小&lt;/p&gt;
&lt;p&gt;l table_cache允许 MySQL 打开的表的最大个数，并且这些都cache在内存中&lt;/p&gt;
&lt;p&gt;l delay_key_write针对MyISAM存储引擎,延迟更新索引.意思是说,update记录时,先将数据up到磁盘,但不up索引,将索引存在内存里,当表关闭时,将内存索引,写到磁盘&lt;/p&gt;
&lt;p&gt;更多参数查看http://www.phpben.com/?post=70&lt;/p&gt;
&lt;p&gt;(2) optimize、Analyze、check、repair维护操作&lt;/p&gt;
&lt;p&gt;l optimize 数据在插入，更新，删除的时候难免一些数据迁移，分页，之后就出现一些碎片，久而久之碎片积累起来影响性能，这就需要DBA定期的优化数据库减少碎片，这就通过optimize命令。&lt;/p&gt;
&lt;p&gt;如对MyisAM表操作：optimize table 表名&lt;/p&gt;
&lt;p&gt;对于InnoDB表是不支持optimize操作，否则提示“Table does not support optimize, doing recreate + analyze instead”，当然也可以通过命令：alter table one type=innodb; 来替代。&lt;/p&gt;
&lt;p&gt;l Analyze 用来分析和存储表的关键字的分布，使得系统获得准确的统计信息，影响 SQL 的执行计划的生成。对于数据基本没有发生变化的表，是不需要经常进行表分析的。但是如果表的数据量变化很明显，用户感觉实际的执行计划和预期的执行计划不 同的时候，执行一次表分析可能有助于产生预期的执行计划。&lt;/p&gt;
&lt;p&gt;Analyze table 表名&lt;/p&gt;
&lt;p&gt;l Check检查表或者视图是否存在错误，对 MyISAM 和 InnoDB 存储引擎的表有作用。对于 MyISAM 存储引擎的表进行表检查，也会同时更新关键字统计数据&lt;/p&gt;
&lt;p&gt;l Repair optimize需要有足够的硬盘空间，否则可能会破坏表，导致不能操作，那就要用上repair，注意INNODB不支持repair操作&lt;/p&gt;
&lt;p&gt;以上的操作出现的都是如下这是check&lt;/p&gt;
&lt;p&gt;+———-+——-+————–+————-+&lt;/p&gt;
&lt;p&gt;| Table | Op | Msg_type| Msg_text |&lt;/p&gt;
&lt;p&gt;+———-+——-+————–+————-+&lt;/p&gt;
&lt;p&gt;| test.one | check | status | OK |&lt;/p&gt;
&lt;p&gt;+———-+——-+————–+————-+&lt;/p&gt;
&lt;p&gt;其中op是option 可以是repair check optimize，msg_type 表示信息类型，msg_text 表示信息类型，这里就说明表的状态正常。如在innodb表使用repair就出现note | The storage engine for the table doesn’t support repair&lt;/p&gt;
&lt;p&gt;注意：以上操作最好在数据库访问量最低的时候操作，因为涉及到很多表锁定，扫描，数据迁移等操作，否则可能导致一些功能无法正常使用甚至数据库崩溃。&lt;/p&gt;
&lt;p&gt;(3)表结构的更新与维护&lt;/p&gt;
&lt;p&gt;l 改表结构。当要在数据量千万级的数据表中使用alter更改表结构的时候，这是一个棘手问题。一种方法是在低并发低访问量的时候用平常的alter更改表。另外一种就是建另一个与要修改的表，这个表除了要修改的结构属性外其他的和原表一模一样，这样就能得到一个相应的.frm文件，然后用flush with read lock 锁定读，然后覆盖用新建的.frm文件覆盖原表的.frm，最后unlock table 释放表。&lt;/p&gt;
&lt;p&gt;l 建立新的索引。一般方法这里不说。&lt;/p&gt;
&lt;p&gt;1、 创建没索引的a表，导入数据形成.MYD文件。&lt;/p&gt;
&lt;p&gt;2、 创建包括索引b表，形成.FRM和.MYI文件&lt;/p&gt;
&lt;p&gt;3、 锁定读写&lt;/p&gt;
&lt;p&gt;4、 把b表的.FRM和.MYI文件改成a表名字&lt;/p&gt;
&lt;p&gt;5、 解锁&lt;/p&gt;
&lt;p&gt;6、 用repair创建索引。&lt;/p&gt;
&lt;p&gt;这个方法对于大表也是很有效的。这也是为什么很多dba坚持说“先导数据库在建索引，这样效率更快”&lt;/p&gt;
&lt;p&gt;l 定期检查mysql服务器&lt;/p&gt;
&lt;p&gt;定期使用show status、show processlist等命令检查数据库。这里就不细说，这说起来也篇幅是比较大的，笔者对这个也不是很了解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四部分：图说mysql查询执行流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/102f0110cceb6a5d704ee61175e039e5.jpg&quot; width=&quot;690&quot; height=&quot;616&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、 查询缓存，判断sql语句是否完全匹配，再判断是否有权限，两个判断为假则到解析器解析语句，为真则提取数据结果返回给用户。&lt;/p&gt;
&lt;p&gt;2、 解析器解析。解析器先词法分析，语法分析，检查错误比如引号有没闭合等，然后生成解析树。&lt;/p&gt;
&lt;p&gt;3、 预处理。预处理解决解析器无法决解的语义，如检查表和列是否存在，别名是否有错，生成新的解析树。&lt;/p&gt;
&lt;p&gt;4、 优化器做大量的优化操作。&lt;/p&gt;
&lt;p&gt;5、 生成执行计划。&lt;/p&gt;
&lt;p&gt;6、 查询执行引擎，负责调度引擎获取相应数据&lt;/p&gt;
&lt;p&gt;7、 返回结果。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html&quot; rel=&quot;nofollow&quot;&gt;http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html&quot; rel=&quot;nofollow&quot;&gt;http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zuiaituantuan/article/details/5909334&quot; rel=&quot;nofollow&quot;&gt;http://blog.csdn.net/zuiaituantuan/article/details/5909334&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.codinglabs.org/html/theory-of-mysql-index.html&quot; rel=&quot;nofollow&quot;&gt;http://www.codinglabs.org/html/theory-of-mysql-index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://isky000.com/database/mysql_order_by_implement&quot; rel=&quot;nofollow&quot;&gt;http://isky000.com/database/mysql_order_by_implement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/server-system-variables.html&quot; rel=&quot;nofollow&quot;&gt;http://dev.mysql.com/doc/refman/5.0/en/server-system-variables.html&lt;/a&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87107&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87107votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87107&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Mon, 25 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-25-87107-fe468f89c.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-25-87107-fe468f89c.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>如何安全地存储密码？</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;h3&gt;使用 bcrypt&lt;/h3&gt;
&lt;p&gt;用 &lt;a href=&quot;http://www.usenix.org/events/usenix99/provos.html&quot;&gt;bcrypt&lt;/a&gt;、用 &lt;a href=&quot;http://www.usenix.org/events/usenix99/provos.html&quot;&gt;bcrypt&lt;/a&gt;、用 &lt;a href=&quot;http://www.usenix.org/events/usenix99/provos.html&quot;&gt;bcrypt&lt;/a&gt;、用 &lt;a href=&quot;http://www.usenix.org/events/usenix99/provos.html&quot;&gt;bcrypt&lt;/a&gt;、用&lt;a href=&quot;http://www.usenix.org/events/usenix99/provos.html&quot;&gt; &lt;/a&gt;&lt;a href=&quot;http://www.usenix.org/events/usenix99/provos.html&quot;&gt;bcrypt&lt;/a&gt;、用 &lt;a href=&quot;http://www.usenix.org/events/usenix99/provos.html&quot;&gt;bcrypt&lt;/a&gt;、用 &lt;a href=&quot;http://www.usenix.org/events/usenix99/provos.html&quot;&gt;bcrypt&lt;/a&gt;、用 &lt;a href=&quot;http://www.usenix.org/events/usenix99/provos.html&quot;&gt;bcrypt&lt;/a&gt;、用 &lt;a href=&quot;http://www.usenix.org/events/usenix99/provos.html&quot;&gt;bcrypt&lt;/a&gt; （重要的话就是要多多地重复几次）……&lt;/p&gt;
&lt;h3&gt;为什么不用 {MD5、 SHA1、 SHA256、 SHA512、 SHA-3 等加密算法}?&lt;/h3&gt;
&lt;p&gt;这些都是&lt;em&gt;通用&lt;/em&gt;的hash函数，设计的初衷是为了尽可能快的计算大量数据的摘要。这意味着它们在保证数据完整性方面非常优秀但是对于存储密码则十分糟糕。&lt;/p&gt;
&lt;p&gt;现代的服务器计算 MD5 的哈希值速度大概是&lt;a href=&quot;http://www.cryptopp.com/benchmarks-amd64.html&quot;&gt;每秒330MB&lt;/a&gt;。如果你的用户密码满足小写、数字字母混合、6个字符长这几个条件，你就可以在&lt;strong&gt;40秒内&lt;/strong&gt;&lt;em&gt;穷举&lt;/em&gt;出该密码。&lt;/p&gt;
&lt;p&gt;完全不需要其他的投入。&lt;/p&gt;
&lt;p&gt;如果你愿意花费2000美元和一到两周的时间来挑选一块支持 &lt;a href=&quot;http://www.nvidia.com/object/cuda_home.html&quot;&gt;CUDA&lt;/a&gt; 的显卡，那你可以搭建一个小型的、&lt;a href=&quot;http://www.win.tue.nl/cccc/sha-1-challenge.html&quot;&gt;每秒计算700,000,000个密码&lt;/a&gt;的超级计算机集群。估计你可以以&lt;strong&gt;每秒10%&lt;/strong&gt;的速度来破解那些密码。&lt;/p&gt;
&lt;h3&gt;加盐也救不了你&lt;/h3&gt;
&lt;p&gt;注意了，非常重要的一点：&lt;strong&gt;hash加盐对于字典攻击和暴力破解无效。&lt;/strong&gt;你可以用粗盐，或许多的盐，甚至是人工开采，阴凉的，有机的喜马拉雅粉晶盐。但这都无法影响到攻击者破解你密码的速度。&lt;/p&gt;
&lt;p&gt;加盐与否，只要你用了为速度而设计的通用哈希函数，你就会受到影响。&lt;/p&gt;
&lt;h3&gt;bcrypt 解决了这些问题&lt;/h3&gt;
&lt;p&gt;怎么做呢？从根本上说，是因为它的（计算速度可以）慢到令人发指。它由 Blowfish 加密算法演变而来，并引入了&lt;em&gt;功系数（work factor)&lt;/em&gt;，以便让你能决定该哈希函数的计算强度。基于以上原因，bcrypt 可以紧随摩尔定律的脚步。计算机发展更快，你也可以增加功系数来让哈希更难计算。&lt;/p&gt;
&lt;p&gt;比起 MD5，bcrypt 的计算强度能达到多大呢？这就要看功系数了。把功系数设为12情况下，在我的电脑上用 bcrypt 哈希 yaaa 这个密码大概要0.3秒。另一方面，用MD5 来处理要少于1微秒。&lt;/p&gt;
&lt;p&gt;你的密码可能不需要那么高的安全级别，而需要更快的运算速度。幸好，bcrypt允许你在速度和安全之间进行平衡。&lt;/p&gt;
&lt;h3&gt;长话短说&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;用bcrypt.&lt;/strong&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87058&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87058votetotal&quot;&gt;1&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87058&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt; 1 评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者：&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/lxtalx&quot;&gt;zer0Black&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/lxtalx&quot;&gt;
			&lt;img src=&quot;/images/jobbole.com/acc7de4f3e21ddea3affb662f132911f.jpg&quot;&gt;
		&lt;/a&gt;
	&lt;/div&gt;

    &lt;div class=&quot;author-bio-info&quot;&gt;

        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            关注信息安全，网络安全，目前为移动开发工程师，android和IOS兼有涉猎。半路出道，基础薄弱，正努力补习计算机基础中。近日习得“遍历”学...        &lt;/span&gt;
        &lt;span class=&quot;author-bio-info-block&quot;&gt;
            &lt;a href=&quot;http://www.jobbole.com/members/lxtalx&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 个人主页&lt;/a&gt; ·
            &lt;a href=&quot;http://blog.jobbole.com/author/lxtalx/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;/i&gt; 我的文章&lt;/a&gt; ·
            &lt;a title=&quot;声望值&quot; target=&quot;_blank&quot; href=&quot;http://www.jobbole.com/members/lxtalx/reputation/&quot;&gt;&lt;i class=&quot;fa fa-graduation-cap&quot;&gt;&lt;/i&gt; 10&lt;/a&gt;        &lt;/span&gt;
    &lt;/div&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Mon, 25 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-25-87058-e4ffd9ea5.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-25-87058-e4ffd9ea5.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>探索C#之微型MapReduce</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;p&gt;MapReduce近几年比较热的分布式计算编程模型，以C#为例简单介绍下MapReduce分布式计算。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;阅读目录&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;Map实现&lt;/li&gt;
&lt;li&gt;Reduce实现&lt;/li&gt;
&lt;li&gt;支持分布式&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;某平行世界程序猿小张接到Boss一项任务，统计用户反馈内容中的单词出现次数，以便分析用户主要习惯。文本如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;const string hamlet = @&quot;Though yet of Hamlet our dear brother&#39;s death
The memory be green, and that it us befitted
To bear our hearts in grief and our whole kingdom
To be contracted in one brow of woe,
Yet so far hath discretion fought with nature
That we with wisest sorrow think on him,
Together with remembrance of ourselves.
Therefore our sometime sister, now our queen,
The imperial jointress to this warlike state,
Have we, as &#39;twere with a defeated joy,--
With an auspicious and a dropping eye,
With mirth in funeral and with dirge in marriage,
In equal scale weighing delight and dole,--
Taken to wife: nor have we herein barr&#39;d
Your better wisdoms, which have freely gone
With this affair along. For all, our thanks.
Now follows, that you know, young Fortinbras,
Holding a weak supposal of our worth,
Or thinking by our late dear brother&#39;s death
Our state to be disjoint and out of frame,
Colleagued with the dream of his advantage,
He hath not fail&#39;d to pester us with message,
Importing the surrender of those lands
Lost by his father, with all bonds of law,
To our most valiant brother. So much for him.
Now for ourself and for this time of meeting:
Thus much the business is: we have here writ
To Norway, uncle of young Fortinbras,--
Who, impotent and bed-rid, scarcely hears
Of this his nephew&#39;s purpose,--to suppress
His further gait herein; in that the levies,
The lists and full proportions, are all made
Out of his subject: and we here dispatch
You, good Cornelius, and you, Voltimand,
For bearers of this greeting to old Norway;
Giving to you no further personal power
To business with the king, more than the scope
Of these delated articles allow.
Farewell, and let your haste commend your duty.&quot;;&lt;/pre&gt;
&lt;p&gt;小张作为蓝翔高材生，很快就实现了：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;var content = hamlet.Split(new[] { &quot; &quot;, Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
            var wordcount=new Dictionary&amp;lt;string,int&amp;gt;();
            foreach (var item in content)
            {
                if (wordcount.ContainsKey(item))
                    wordcount[item] += 1;
                else
                    wordcount.Add(item, 1);
            }&lt;/pre&gt;
&lt;p&gt;作为有上进心的青年，小张决心对算法进行抽象封装，并支持多节点计算。小张把这个统计次数程序分成两个大步骤：分解和计算。&lt;br&gt;
第一步：先把文本以某维度分解映射成最小独立单元。 (段落、单词、字母维度)。&lt;br&gt;
第二部：把最小单元重复的做合并计算。&lt;br&gt;
小张参考MapReduce论文设计Map、Reduce如下：&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Map实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Mapping&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Mapping函数把文本分解映射key，value形式的最小单元，即&amp;lt;单词，出现次数(1)&amp;gt;、&amp;lt;word,1&amp;gt;。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IEnumerable&amp;lt;Tuple&amp;lt;T, int&amp;gt;&amp;gt; Mapping(IEnumerable&amp;lt;T&amp;gt; list)
        {
            foreach (T sourceVal in list)
                yield return Tuple.Create(sourceVal, 1);
        }&lt;/pre&gt;
&lt;p&gt;使用，输出为(brow, 1), (brow, 1), (sorrow, 1), (sorrow, 1):&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt; var spit = hamlet.Split(new[] { &quot; &quot;, Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
            var mp = new MicroMapReduce&amp;lt;string&amp;gt;(new Master&amp;lt;string&amp;gt;());
            var result= mp.Mapping(spit);&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Combine&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了减少数据通信开销，mapping出的键值对数据在进入真正的reduce前，进行重复键合并。也相对于提前进行预计算一部分，加快总体计算速度。 输出格式为(brow, 2), (sorrow, 2):&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public Dictionary&amp;lt;T, int&amp;gt; Combine(IEnumerable&amp;lt;Tuple&amp;lt;T, int&amp;gt;&amp;gt; list)
        {
            Dictionary&amp;lt;T, int&amp;gt; dt = new Dictionary&amp;lt;T, int&amp;gt;();
            foreach (var val in list)
            {
                if (dt.ContainsKey(val.Item1))
                    dt[val.Item1] += val.Item2;
                else
                    dt.Add(val.Item1, val.Item2);
            }
            return dt;
        }&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Partitioner&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Partitioner主要用来分组划分,把不同节点的统计数据按照key进行分组。&lt;br&gt;
其输出格式为： (brow, {(brow,2)},(brow,3)), (sorrow, {(sorrow,10)},(brow,11)):&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IEnumerable&amp;lt;Group&amp;lt;T, int&amp;gt;&amp;gt; Partitioner(Dictionary&amp;lt;T, int&amp;gt; list)
        {
            var dict = new Dictionary&amp;lt;T, Group&amp;lt;T, int&amp;gt;&amp;gt;();
            foreach (var val in list)
            {
                if (!dict.ContainsKey(val.Key))
                    dict[val.Key] = new Group&amp;lt;T, int&amp;gt;(val.Key);
                dict[val.Key].Values.Add(val.Value);
            }
            return dict.Values;
        }&lt;/pre&gt;
&lt;p&gt;Group定义:&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public class Group&amp;lt;TKey, TValue&amp;gt; : Tuple&amp;lt;TKey, List&amp;lt;TValue&amp;gt;&amp;gt;
    {
        public Group(TKey key)
            : base(key, new List&amp;lt;TValue&amp;gt;())
        {
        }

        public TKey Key
        {
            get
            {
                return base.Item1;
            }
        }

        public List&amp;lt;TValue&amp;gt; Values
        {
            get
            {
                return base.Item2;
            }
        }
    }&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Reduce实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Reducing函数接收，分组后的数据进行最后的统计计算。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public Dictionary&amp;lt;T, int&amp;gt; Reducing(IEnumerable&amp;lt;Group&amp;lt;T, int&amp;gt;&amp;gt; groups)
        {
            Dictionary&amp;lt;T, int&amp;gt; result=new Dictionary&amp;lt;T, int&amp;gt;();
            foreach (var sourceVal in groups)
            {
                result.Add(sourceVal.Key, sourceVal.Values.Sum());
            }
            return result;
        }&lt;/pre&gt;
&lt;p&gt;封装调用如下：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public IEnumerable&amp;lt;Group&amp;lt;T, int&amp;gt;&amp;gt; Map(IEnumerable&amp;lt;T&amp;gt; list)
        {
            var step1 = Mapping(list);
            var step2 = Combine(step1);
            var step3 = Partitioner(step2);
            return step3;
        }

  public Dictionary&amp;lt;T, int&amp;gt; Reduce(IEnumerable&amp;lt;Group&amp;lt;T, int&amp;gt;&amp;gt; groups)
        {
            var step1 = Reducing(groups);
            return step1;
        }&lt;/pre&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public  Dictionary&amp;lt;T, int&amp;gt; MapReduce(IEnumerable&amp;lt;T&amp;gt; list)
        {
            var map = Map(list);
            var reduce = Reduce(map);
            return reduce;
        }&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/5db7b9a192ea17c8b61f6aaa233f5604.jpg&quot; width=&quot;195&quot; height=&quot;505&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;支持分布式&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;小张抽象封装后，虽然复杂度上去了。但暴露给使用者是非常清晰的接口，满足MapReduce的数据格式要求，即可使用。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;var spit = hamlet.Split(new[] { &quot; &quot;, Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
            var mp = new MicroMapReduce&amp;lt;string&amp;gt;(new Master&amp;lt;string&amp;gt;());
            var result1= mp.MapReduce(spit);&lt;/pre&gt;
&lt;p&gt;小张完成后脑洞大开，考虑到以后文本数据量超大。 所以fork了个分支，准备支持分布式计算，以后可以在多个服务器节点跑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据分片&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据分片就是把大量数据拆成一块一块的，分散到各个节点上，方便我们的mapReduce程序去计算。 分片主流的有mod、consistent hashing、vitual Buckets、Range Partition等方式。 关于consistent hashing上篇有介绍(探索c#之一致性Hash详解)。在Hadoop中Hdfs和mapreduce是相互关联配合的，一个存储和一个计算。如果自行实现的话还需要个统一的存储。所以这里的数据源可以是数据库也可以是文件。小张只是满足boss需求，通用计算框架的话可以直接用现成的。&lt;/p&gt;
&lt;p&gt;模拟分片&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public List&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt; Partition(IEnumerable&amp;lt;T&amp;gt; list)
        {
            var temp =new List&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt;();
            temp.Add(list);
            temp.Add(list);
            return temp;
        }&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Worker节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小张定义了Master，worker角色。 master负责汇集输出，即我们的主程序。 每一个worker我们用一个线程来模拟，最后输出到master汇总，master最后可以写到数据库或其他。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public void WorkerNode(IEnumerable&amp;lt;T&amp;gt; list)
        {
            new Thread(() =&amp;gt;
            {
                var map = Map(list);
                var reduce = Reduce(map);
                master.Merge(reduce);
            }).Start();
        }&lt;/pre&gt;
&lt;pre class=&quot;brush: csharp; gutter: true&quot;&gt;public class Master&amp;lt;T&amp;gt;
    {
        public Dictionary&amp;lt;T, int&amp;gt; Result = new Dictionary&amp;lt;T, int&amp;gt;();
        public  void Merge(Dictionary&amp;lt;T, int&amp;gt; list)
        {
            foreach (var item in list)
            {
                lock (this)
                {
                    if (Result.ContainsKey(item.Key))
                        Result[item.Key] += item.Value;
                    else
                        Result.Add(item.Key, item.Value);
                }
            }
        }
    }&lt;/pre&gt;
&lt;p&gt;分布式计算步骤图：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/d6d4afb5f02ea24af4ce6304d06a32d1.jpg&quot; width=&quot;563&quot; height=&quot;512&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;MapReduce模型从性能速度来说并不是非常好的，它优势在于隐藏了分布式计算的细节、容灾错误、负载均衡及良好的编程API，包含HDFS、Hive等在内一整套大数据处理的生态框架体系。在数据量级不是很大的话，企业自行实现一套轻量级分布式计算会有很多优点，比如性能更好、可定制化、数据库也不需要导入导出。从成本上也节省不少，因为hadoop开发、运维、服务器都需要不少人力物力。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://files.cnblogs.com/files/mushroom/mapReduce.zip&quot; target=&quot;_blank&quot;&gt;文中例子代码&lt;/a&gt;&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87088&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87088votetotal&quot;&gt;&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87088&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sun, 24 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-24-87088-03076fa0f.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-24-87088-03076fa0f.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>SQL Server自动化运维系列：关于数据收集</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;《&lt;a title=&quot;SQL Server自动化运维系列：监控性能指标脚本&quot; href=&quot;http://blog.jobbole.com/85631/&quot; target=&quot;_blank&quot;&gt;SQL Server自动化运维系列：监控性能指标脚本&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a title=&quot;SQL Server自动化运维系列：监控磁盘剩余空间及SQL Server错误日志&quot; href=&quot;http://blog.jobbole.com/85637/&quot; target=&quot;_blank&quot;&gt;SQL Server自动化运维系列：监控磁盘剩余空间及SQL Server错误日志&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a title=&quot;SQL Server自动化运维系列：关于邮件通知那点事&quot; href=&quot;http://blog.jobbole.com/87077/&quot; target=&quot;_blank&quot;&gt;SQL Server自动化运维系列：关于邮件通知那点事&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a title=&quot;SQL Server自动化运维系列：监控跑批Job运行状态&quot; href=&quot;http://blog.jobbole.com/87080/&quot; target=&quot;_blank&quot;&gt;SQL Server自动化运维系列：监控跑批Job运行状态&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a title=&quot;SQL Server自动化运维系列：关于数据收集&quot; href=&quot;http://blog.jobbole.com/87084/&quot; target=&quot;_blank&quot;&gt;SQL Server自动化运维系列：关于数据收集&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;需求描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在生产环境中，很多情况下需要采集数据，用以定位问题或者形成基线。&lt;/p&gt;
&lt;p&gt;关于SQL Server中的数据采集有着很多种的解决思路，可以采用Trace、Profile、SQLdiag、扩展事件等诸多方案。&lt;/p&gt;
&lt;p&gt;几种方案各有利弊，其中从SQL Server2012版本开始，微软的开始各种整合这些采集方案，力推扩展事件。&lt;/p&gt;
&lt;p&gt;对于上述的数据采集只是一种实现手段，对于采集完数据的存储没有统一的规范，并且对于多服务器的数据采集及汇总没形成统一的规范。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、通过SQL Server自带的数据采集器实现多服务器的性能采集&lt;/p&gt;
&lt;p&gt;2、利用SQL Server数据采集数据仓库（DW）形成运维报表&lt;/p&gt;
&lt;p&gt;3、通过灵活性的配置方式，实现不同服务器不同采集点的数据收集&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;1&amp;gt;基础配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以前，有个同事说SQL Server的自动化运维太弱了，并且定位问题也比较麻烦，需要记住各种系统的DMV….各种日志查找….你看看人家MySQL强大的图形化界面提示，让你一眼就能发现当前数据库所存在的问题。&lt;/p&gt;
&lt;p&gt;的确，来看看MySQL所提供的图形化的运维界面&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/809ea5d80a232935554818654eeb66eb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;是他娘的帅气，把整体的平台给划分的很详细：网络、实例状态、存储状态。&lt;/p&gt;
&lt;p&gt;而且还有看上去很优雅的图形化展示界面。&lt;/p&gt;
&lt;p&gt;上述界面所反映的内容，对于问题的查找是相当便利的，在SQL SERVER中就找不到同样的模块。如果有经验的DBA会通过任务管理器、性能监视器、然后配合系统自带个一些个DMV…进行分析….看上去复杂并且很高深的样子。&lt;/p&gt;
&lt;p&gt;其实，在SQL SERVER中，也有类似的功能模块，并且更灵活的实现多台服务器共同采集，下面，我们来看一下详细的使用和配置流程。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5c298df2e694798633813f0d81c386c8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在数据收集上，右键选择“配置管理数据仓库”&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/400fdcc5ab996cb46aeb27d40537ce98.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;SQL SERVER为了能够支撑多台服务器的数据采集任务，鉴于数据量的庞大和用于数据分析的重要性，所以自己创建了一个用于数据分析的数据仓库（DW）&lt;/p&gt;
&lt;p&gt;这里选择好实例，创建好数据仓库就可以。&lt;/p&gt;
&lt;p&gt;提示：为了避免影响生产系统的性能，一般这里建议采用另外一台空闲的实例，专门用于数据采集和性能分析。&lt;/p&gt;
&lt;p&gt;我这里演示，就采用本地的实例进行配置，然后下一步：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a8c6571228c7c15c509b597569d77de9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;到这一步是管理数据仓库的用户权限，可以配置用户权限，三种权限级别：管理员、可读、可写；&lt;/p&gt;
&lt;p&gt;很简单，配置完成直接下一步，然后就完成了该数据采集的数据仓库的搭建。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;2&amp;gt;基础配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一步就是设置数据收集了，简单点讲就是要配置收集的数据项有哪些。&lt;/p&gt;
&lt;p&gt;同样是，数据采集上右键，然后选择“设置数据采集”&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b8a013d77bbe2c29d504f93f259fcb62.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后，下一步就是连接数据仓库，选择缓存目录&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8cf3a720933ac7c67ce73ab6e3243cc0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后，下一步就可以完成，这里SQL SERVER同样的内置了一套数据搜集的模板，会为你收集全部的基本信息，当然，也可以自定义，文章后面介绍。&lt;/p&gt;
&lt;p&gt;来看默认的数据采集的收集项&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/03f1ccf0221abb9b321d32cb8a472113.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;自带的默认模板中，分为了查询统计信息，其实这个就对应的实例状态、磁盘存储、服务器活动，除了这下还赠送了一个实用工具信息，这个是用来灵活配置其它几个收集项的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a8c9a21207ac11c080ae7c71adaba176.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以随时的根据个人喜好启动、停止数据收集动作，酌情采用。&lt;/p&gt;
&lt;p&gt;并且，也可以自己配置收集动作的时间间隔或者状态值。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/040a2ee68c5de05ac0ea0c572b287116.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;并且，SQL Server贴心的给内置了一下计划模板，基本涵盖了所有的应用场景。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5a569cf6c9693a6defdd063bd2f7d59c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后，你就放心的让它自己去采集就可以了。不爽的时候随时停止就可以。&lt;/p&gt;
&lt;p&gt;剩下来的事就是查看采集数据了，鉴于MYSQL提供了如此精美的图像化展现方式，SQL SERVER同样也有。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9a89fda630429478279a353090551eb7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;就是它了&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7b18a0c8340a109383f6af39cc77ae18.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;看上去是不是也有那么点意思了，包括：CPU、内存、磁盘IO、网络…&lt;/p&gt;
&lt;p&gt;并且顺带着SQL server等待、SQL语句执行情况等&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2de3321857fae631e91b3c2c2f032743.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后，针对性能调优的一些语句，也给出了排序包括CPU、运行时间、IO总数、物理读取、逻辑读取等&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/604bf2cdefa83f6d2c8e94255c2cabcb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，我本地的机器本身采集量就很少，并且运行的T-SQL语句就不多，所以图表工具显示的很空旷。&lt;/p&gt;
&lt;p&gt;来看看磁盘存储的&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/231bf79fe23271710338fedc7acf2eb4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上述内容大体就这些，自己用的时候再行挖掘吧，本篇提供思路。&lt;/p&gt;
&lt;p&gt;如果经验老道的DBA，我估计上述语句通过系统的DMV都可以查看的到，但是那仅限于有经验的，上述方案为小白降低了维护数据库的成本。&lt;/p&gt;
&lt;p&gt;并且可以在多台服务器中进行采集，集中处理问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在本篇介绍利用SQL Server自带的数据收集工具进行数据库运维。关于自定义的数据收集项设置，后一篇介绍吧。&lt;/p&gt;
&lt;p&gt;另外关于数据收集的DW有很多很有用的内容，如果对于大型的平台性能运维，可以借此扩展，形成自己的运维平台。&lt;/p&gt;
&lt;p&gt;关于SQL Server自动化运维和检测的内容很广泛，其中很多都是从日常的经验中出发，一步步的从手动到自动的过程。&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87084&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87084votetotal&quot;&gt;&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87084&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sun, 24 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-24-87084-2d393ddb0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-24-87084-2d393ddb0.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>SQL Server自动化运维系列：监控跑批Job运行状态</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;《&lt;a title=&quot;SQL Server自动化运维系列：监控性能指标脚本&quot; href=&quot;http://blog.jobbole.com/85631/&quot; target=&quot;_blank&quot;&gt;SQL Server自动化运维系列：监控性能指标脚本&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a title=&quot;SQL Server自动化运维系列：监控磁盘剩余空间及SQL Server错误日志&quot; href=&quot;http://blog.jobbole.com/85637/&quot; target=&quot;_blank&quot;&gt;SQL Server自动化运维系列：监控磁盘剩余空间及SQL Server错误日志&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a href=&quot;http://blog.jobbole.com/87077/&quot; target=&quot;_blank&quot;&gt;SQL Server自动化运维系列：关于邮件通知那点事&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;需求描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我们的生产环境中，大部分情况下需要有自己的运维体制，包括自己健康状态的检测等。如果发生异常，需要提前预警的，通知形式一般为发邮件告知。&lt;/p&gt;
&lt;p&gt;在上一篇文章中已经分析了SQL SERVER中关于邮件的基础配置，本篇将利用此功能对多台Server的跑批Job进行监控。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、每天检查服务器中的SQL Server跑批Job的运行状态，如果跑批失败，则发邮件告诉管理员失败的明细&lt;/p&gt;
&lt;p&gt;2、解决多台服务器同时检查&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监控脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们来解决第二个问题，关于多台服务器的问题：&lt;/p&gt;
&lt;p&gt;&amp;lt;1&amp;gt;一般监控我们需要监控很多台服务器的JOb，所以对于服务器的量控制我们需要生成一个配置文件。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: xml; gutter: true&quot;&gt;&amp;lt;computernames&amp;gt;
        &amp;lt;computername&amp;gt;
                wuxuelei-pc
        &amp;lt;/computername&amp;gt;
&amp;lt;/computernames&amp;gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;配置文件名字：computername.xml，这样就解决很多服务器的问题，只需要在配置文件中增加就可以，因为我在本地测试，所以就配置了我的本地电脑&lt;/p&gt;
&lt;p&gt;&amp;lt;2&amp;gt;利用Power Shell脚本，抓取出每台服务器的Job的状态，并且将Job的运行时间、运行状态、描述以及错误的步骤等信息整理，形成汇总邮件。&lt;/p&gt;
&lt;p&gt;脚本如下：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;$server = &quot;(local)&quot;
$uid = &quot;sa&quot;
$db=&quot;master&quot;
$pwd=&quot;password&quot;
$mailprfname = &quot;TestMail&quot;
$recipients = &quot;787449667@qq.com&quot;
$subject = &quot;老大，快去看看这些服务器的Job跑失败了！&quot;
$computernamexml = &quot;F:\PowerShell\发送邮件\computername.xml&quot;

function GetServerName($xmlpath)
{
    $xml = [xml] (Get-Content $xmlpath)
    $return = New-Object Collections.Generic.List[string]
    for($i = 0;$i -lt $xml.computernames.ChildNodes.Count;$i++)
    {
        if ( $xml.computernames.ChildNodes.Count -eq 1)
        {
            $cp = [string]$xml.computernames.computername
        }
        else
        {
            $cp = [string]$xml.computernames.computername[$i]
        }
        $return.Add($cp.Trim())
    }
    $return
}

function GetAlterCounter($xmlpath)
{
    $xml = [xml] (Get-Content $xmlpath)
    $return = New-Object Collections.Generic.List[string]
    $list = $xml.counters.Counter
}

function CreateAlter($message)
{
    $SqlConnection = New-Object System.Data.SqlClient.SqlConnection 
    $CnnString =&quot;Server = $server; Database = $db;User Id = $uid; Password = $pwd&quot; 
    $SqlConnection.ConnectionString = $CnnString 
    $CC = $SqlConnection.CreateCommand(); 
    if (-not ($SqlConnection.State -like &quot;Open&quot;)) { $SqlConnection.Open() } 

    $cc.CommandText=
            &quot; EXEC msdb..sp_send_dbmail 
             @profile_name  = &#39;$mailprfname&#39;
            ,@recipients = &#39;$recipients&#39;
            ,@body = &#39;$message&#39;
            ,@subject = &#39;$subject&#39;
            &quot;
    $cc.ExecuteNonQuery()|out-null 
    $SqlConnection.Close();
}

$report = &quot;&quot;
$item = New-Object Collections.Generic.List[string]
$names = GetServerName($computernamexml)
foreach($cp in $names)
{
$srv=New-Object &quot;Microsoft.SqlServer.Management.Smo.Server&quot; &quot;(local)&quot;
$item=$srv.jobserver.jobs | where-object {$_.lastrunoutcome -eq &quot;Failed&quot; -and $_.isenabled -eq $TRUE} |  select OriginatingServer,name,Description,lastrunoutcome,lastrundate,JobSteps  
#Write-Host $item.JobSteps.name 
$report += &quot; 服务器：&quot;+$item.OriginatingServer+&quot;  Job名称：&quot;+$item.name+&quot;  Job描述：&quot;+$item.Description +&quot;  Job最后运行状态：&quot;+$item.lastrunoutcome  +&quot;  Job最后运行时间：&quot;+$item.lastrundate +&quot;  Job失败的步骤名称：&quot;+$item.JobSteps.name  + &quot;`n&quot;
}
#生产警告
CreateAlter $report&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过上述脚本，生成跑批任务，就可以定时监控多台服务器的Job了。&lt;/p&gt;
&lt;p&gt;当然，建议放在所有Job的运行完成之后，进行检测。&lt;/p&gt;
&lt;p&gt;上述代码中，有两个技术点：&lt;/p&gt;
&lt;p&gt;1、需要自己配置SQL Server邮件代理，具体方法参照我上一篇：&lt;a href=&quot;http://blog.jobbole.com/87077/&quot; target=&quot;_blank&quot;&gt;点击此&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;2、需要自己配置跑批计划，方法自己网上搜，很简单。&lt;/p&gt;
&lt;p&gt;本篇所监控的Job状态，利用的是上一篇我们创建的Job，跑批肯定失败的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/db555429528e5cf3ec115f721ed1a2aa.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果图如下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7774a5b98b6664e616d557af7b6271c1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;点击来看一下邮件明细内容：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/67b43b8ef29818a6a852e722eb3b5761.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;给出的失败信息还是挺详细的。&lt;/p&gt;
&lt;p&gt;另外，因为我只建立了一个失败的Job，所以邮件中只是发送一个条。&lt;/p&gt;
&lt;p&gt;其实关于此监控，还有一些状态是可以监控的：&lt;/p&gt;
&lt;p&gt;1、比如：可以指定服务器上的部分Job进行监控&lt;/p&gt;
&lt;p&gt;2、监控Job的状态：失败或者正常等&lt;/p&gt;
&lt;p&gt;以上内容，可以自己根据需要灵活配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本篇就列举了一下利用PowerShell实现自动化运维和检测。算作抛砖引玉了吧，自己另有需求可以自己灵活实现。&lt;/p&gt;
&lt;p&gt;另外关于Job，一般除了SQL Server的Agent会存在，还有一部分是操作系统的计划任务也需要检测，我们后面的文章解决此问题。&lt;/p&gt;
&lt;p&gt;关于SQL Server自动化运维和检测的内容很广泛，其中很多都是从日常的经验中出发，一步步的从手动到自动的过程。&lt;/p&gt;
&lt;p&gt;后面的文章，我们将会更深入关于SQL Server的自动化优化运维进行分析。有兴趣的童鞋，可以提前关注。&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87080&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87080votetotal&quot;&gt;&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87080&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sun, 24 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-24-87080-278f33a82.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-24-87080-278f33a82.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>SQL Server自动化运维系列：关于邮件通知那点事</title>
        <description>


        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		&lt;ul&gt;
&lt;li&gt;《&lt;a title=&quot;SQL Server自动化运维系列：监控性能指标脚本&quot; href=&quot;http://blog.jobbole.com/85631/&quot; target=&quot;_blank&quot;&gt;SQL Server自动化运维系列：监控性能指标脚本&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a title=&quot;SQL Server自动化运维系列：监控磁盘剩余空间及SQL Server错误日志&quot; href=&quot;http://blog.jobbole.com/85637/&quot; target=&quot;_blank&quot;&gt;SQL Server自动化运维系列：监控磁盘剩余空间及SQL Server错误日志&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;需求描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我们的生产环境中，大部分情况下需要有自己的运维体制，包括自己健康状态的检测等。如果发生异常，需要提前预警的，通知形式一般为发邮件告知。&lt;/p&gt;
&lt;p&gt;邮件作为一种非常便利的预警实现方式，在及时性和易用性方面也有着不可替代的优点。&lt;/p&gt;
&lt;p&gt;所以，在本篇中将详细的分析下在SQL Server中的邮件通知功能及使用方式等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、通过SQL Server自带的邮件功能实现运维的预警及检测&lt;/p&gt;
&lt;p&gt;2、利用数据库邮件组件代替传统的C#发送邮件的弊端&lt;/p&gt;
&lt;p&gt;3、实现Job任务运行状态的检测&lt;/p&gt;
&lt;p&gt;4、利用PowerShell实现Job任务计划的检测&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;1&amp;gt;基础配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，我们来配置下SQL Server中的邮件组件的基础服务项。SQL Server自从05版本起，邮件功能就不需要开启外配配置管理器了，它有着自己的组件，实现邮件发送的功能。&lt;/p&gt;
&lt;p&gt;如果，没使用过，可以按照以下步骤进行配置，步骤很简单。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/efb28ca4c630f5a9b7fd5e16fcae84ba.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;右键，配置数据库邮件&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fef7dc0d55a7bab0c78dab11352c329b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后直接下一步就行，然后新建一个账户&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e047ab67d6078fe3f1ef645fc1402b39.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后，下一步完成就可以，步骤很简单，这里面有几个概念需要理清楚，对于SQL Server的邮件账户是由权限控制的，目的是实现不同的人使用不同的邮件账户，比如大型数据库的管理一般有好几个DBA负责运维，分职责之后的运行，发送预警邮件也就产生了区分，总不能模块中出现了任何问题都发送给一个人。&lt;/p&gt;
&lt;p&gt;跟你一毛钱关系都没有的异常，天天给你发邮件，是不是很不爽？？….这种管理方式是灰常暴力的！&lt;/p&gt;
&lt;p&gt;为了解决上述问题，SQL Server对邮件的账户进行了分类：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3156c3c64b9bbcee1a00f2924e87bfa7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;分为公共账户和专用账户。&lt;/p&gt;
&lt;p&gt;一般如果管理人员少，就配置一个公共账户就可以，有问题都发送到该邮箱就可以。&lt;/p&gt;
&lt;p&gt;至此，你已经完成了数据库邮件模块的配置，步骤很简单。这里可以发送一封测试邮件，来测试下邮件的连通性。&lt;/p&gt;
&lt;p&gt;提示：SQL Server邮件组件的运行需呀SQL Server Age运行执行，所以需要确保此服务正在运行。&lt;/p&gt;
&lt;p&gt;在“数据库邮件”上右键，发送测试电子邮件，输入目标邮箱的地址，然后单击发送就可以。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e37d033a310b5715c64ce8c01833a369.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ddcb5264c5049ac8e9b4c38b73066c41.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;至此，你的SQL Server已经完成邮件组件的基础配置，然后剩下的工作就是如何利用该组件进行部分工作的完成了。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;2&amp;gt;c#调用数据库邮件组件进行邮件的发送&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还记得当年刚毕业的时候，对于发送邮件这块功能当时是异常的痴迷，各种的研究和各种的调试。&lt;/p&gt;
&lt;p&gt;后来的终归在废了九牛二虎之力之后，终于在一个午夜梦回之时看到了我梦寐以求的测试邮件发送通知，想想一个字描述：草！&lt;/p&gt;
&lt;p&gt;大体我记得需要引用以下几个命名空间：&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f0cd6c7f9e7ae96feae062cb48f670f0.jpg&quot; align=&quot;top&quot;&gt;using System.Net;  using System.Net.Mail;&lt;/p&gt;
&lt;p&gt;然后利用C#提供的SmtpClient类进行组装成邮件实体，而后一个Send()方法，这其中的痛苦点在于各种编码规范等。&lt;/p&gt;
&lt;p&gt;我相信现在也有很多程序猿依然再采用着这种方式。&lt;/p&gt;
&lt;p&gt;今天提供另外一种灵活的实现方式，利用SQL Server数据库的邮件组件进行邮件的发送。&lt;/p&gt;
&lt;p&gt;关于上面第一个步骤提供的邮件组件的调用，其实在SQL Server中是提供系统自带的存储过程进行实现的。方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/907ac88b5ec4522b097af61216ccf6eb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;该存储过程提供了发送邮件的的各种参数，完全满足发送邮件的各种需求，比如：主题、内容、附件、CC、秘密CC….等等吧&lt;/p&gt;
&lt;p&gt;调用该存储过程的方法如下：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--存储过程调用发邮件
    EXEC msdb.dbo.sp_send_dbmail
    @profile_name = &#39;testMail&#39;,
    @recipients = &#39;787449667@qq.com&#39;,
    @body = &#39;这是测试邮件&#39;,
    @subject = &#39;我发的&#39;, 
    @file_attachments=&#39;C:\temp\3-26-2015-16-20-21.png&#39;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;上面一个简单的方法执行既可以实现，邮件的发送。&lt;br&gt;
&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/db111cae12f9d242003d16776fee5724.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后，你需要的就是c#调用该存储过程了。&lt;/p&gt;
&lt;p&gt;关于写C#代码通过Ado.net调用存储过程的过程这里就不赘述了，我相信这是入门级别的小白也能搞定的事情了。&lt;/p&gt;
&lt;p&gt;而后，这里捎带分析一下邮件组件的原理和性能问题。我相信这是很多人关心的，其实SQL Server的邮件发送时通过一个底层的JOB轮询执行的，所以根本不用担心其执行顺序和性能问题。&lt;/p&gt;
&lt;p&gt;并且SQL Server为此还提供了几个系统的视图来查看历史运行状态和当前邮件的队列状态：&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--邮件内容
SELECT * FROM msdb.dbo.sysmail_allitems&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/32ef60f68b10e88019a33b89835f4943.jpg&quot;&gt;&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: sql; gutter: true&quot;&gt;--邮件发送日志
SELECT * FROM msdb.dbo.sysmail_event_log&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/30ebed3a203c0aac3c36a208c569da8c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;并且SQL Server提供了邮件重新发送的功能以及其它默认参数，具体设置参照此画面：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f26c0c6b8fe1d02faf25b40fbe2e142f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;至此，已经完成了利用C#进行发送邮件的功能。&lt;/p&gt;
&lt;p&gt;我相信基本上用C#就会搭配微软自己的SQL Server数据库，而使用它之后就可以少量的代码实现邮件发送的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;3&amp;gt;实现Job任务运行状态的检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我们使用SQL Server的时候，很多情况下都需要自定义Job进行部分功能的实现，而大部分时间是采取凌晨或者非业务期进行工作。&lt;/p&gt;
&lt;p&gt;而此Job的运行结果的检测便形成了一个需要跟踪的问题，比如有时候N个Job的运行，只有几个出现问题，并且不确定的此Job发生在那个机器上，所以自动化运维的重要性就不言而喻了。&lt;/p&gt;
&lt;p&gt;对于上面问题的解决，SQL Server提供了很简单的配置就可以实现。&lt;/p&gt;
&lt;p&gt;（1）首先，需要定义几个操作员，说到底就是几个人值班运维此数据库的&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9cc80fad1fb8345fd926fdf2994a733a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面，我就定义了一个人，其实可以定义多个人，几个运维人员几个…&lt;/p&gt;
&lt;p&gt;（2）其次，需要定义警报，说到底就是将产生的预警发送给上面的几个运维人员。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/99b17f5b02021a5b6015ba12f94cb755.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里面的严重性选项其实是一个很重要的功能，一些简单的问题警告有时候是不需要及时关注的，或者说不需要暂时处理的。&lt;/p&gt;
&lt;p&gt;但是有些问题则需要里面去解决，比如服务器宕机….&lt;/p&gt;
&lt;p&gt;然后，我们来将此预警关联之操作员&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/450ba38deec902337ddd6c22bb0c9949.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;到此，我们已经完成了预警的检测配置，然后需要的就是关联下Job代理的任务属性值。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3fc844ed93e8f7770d5f56c631fdf1ab.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过上面的配置，任何我们自定义的Job工作状态都可以进行自动化检测了。&lt;/p&gt;
&lt;p&gt;比如：某个Job跑批成功了，某个Job跑批失败了。我们来新建一个自定义的Job来测试下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/575a73c8467d0a966224134efc8a2dd0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后设置警告&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/66fa1fafe2788492342943ec6d858429.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后，在运行此Job出现异常的时候，就可以自动的报告到相应的运维人员了。&lt;/p&gt;
&lt;p&gt;这里我们就设置了一个运维人员，所以这里只发送给一个人。&lt;/p&gt;
&lt;p&gt;我们来手动运行下，来测试一下效果&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fdcfdc725c5d8e0f07af9ae2f095ac65.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;嘿嘿，果然，发出了警报，看起来很贴心的样子&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f0099605873839f87cde76f4418c4a5f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1549c4e62005c38ce60d4ec55fd21163.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;至此，此功能已经配置完成，自己可以灵活的实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;4&amp;gt;利用PowerShell实现Job任务计划的检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于Job的明细日志，请参照如下文章：&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://blog.jobbole.com/87080/&quot; target=&quot;_blank&quot;&gt;SQL Server自动化运维系列——监控跑批Job运行状态（Power Shell）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本来打算将利用Power Shell脚本检测的功能实现方式也加上的，但文章已经稍有点篇幅了，后续再完成吧。此篇的关于SQL Server的邮件功能算作抛砖引玉了，自己另有需求可以自己灵活实现。&lt;/p&gt;
&lt;p&gt;其实，在本篇所介绍的Job任务的检测在几台服务器上存在还问题不大，但是如果多台服务器，如果每台服务器上都有几个Job异常的话，每天早上打开邮件多的估计会令你头皮发麻，并且在自带的异常报警中，没有给出详细的错误信息，其实这是一个很不爽弊端。&lt;/p&gt;
&lt;p&gt;所以，为了优雅的进行自动化运维的工作，我们将会每次将我们所有检测的服务器Job运行状态进行扫描，而后将其汇总至一封邮件，然后按照重要性发送至固定的运维人员。&lt;/p&gt;
&lt;p&gt;听起来是不是还有点小激动的样子，下一篇我们来实现此功能。有兴趣的童鞋，可以提前关注。&lt;/p&gt;
&lt;p&gt;关于SQL Server自动化运维和检测的内容很广泛，其中很多都是从日常的经验中出发，一步步的从手动到自动的过程。&lt;/p&gt;

        
        
    &lt;div class=&quot;post-adds&quot;&gt;
        &lt;span data-post-id=&quot;87077&quot; class=&quot;btn-bluet href-style vote-post-up   register-user-only &quot;&gt;&lt;i class=&quot;fa  fa-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;h10 id=&quot;87077votetotal&quot;&gt;&lt;/h10&gt; 赞&lt;/span&gt;
        &lt;span data-book-type=&quot;1&quot; data-site-id=&quot;2&quot; data-item-id=&quot;87077&quot; data-item-type=&quot;1&quot; class=&quot;btn-bluet href-style bookmark-btn  register-user-only &quot;&gt;&lt;i class=&quot;fa fa-bookmark-o  &quot;&gt;&lt;/i&gt;  收藏&lt;/span&gt;

                &lt;a href=&quot;#article-comment&quot;&gt;&lt;span class=&quot;btn-bluet href-style&quot;&gt;&lt;i class=&quot;fa fa-comments-o&quot;&gt;&lt;/i&gt;  评论&lt;/span&gt;&lt;/a&gt;
        
            &lt;/div&gt;


        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Sun, 24 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-24-87077-779823da9.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-24-87077-779823da9.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>八岁小孩的数学：少儿图论</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;今天早上，我有幸到女儿所在的三年级客串数学老师，和这一群好问的八九岁的小女孩有了一个愉快的互动。接着我去年的时候讲过的话题《&lt;a href=&quot;http://blog.jobbole.com/71701/&quot; target=&quot;_blank&quot;&gt;七岁儿童的数学：图形着色，色彩数，欧拉路径和欧拉环&lt;/a&gt;》，我想和她们一起探索图论里的一些基本概念。这些概念数学内涵丰富，难度对于孩子来说也适宜。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/193b545fa8aa0316ffde1c0b9b7cb3c9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这次我讲课的目标是让她们体会到独立发现连通平面图的欧拉示性数的惊喜。&lt;/p&gt;
&lt;p&gt;我们从一个简单的例子开始，分别数出图中顶点(V)、边(E)和区域(R)的数量。在数区域的数量的时候，我强调说“图外面”的区域也算一个区域。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/60560ecd676ffd59e51e2e5fb752ade9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;接着，为了给这堂课添加一些神秘色彩，我提到欧拉在计算V-E+R这个量时，发现它有个独特的性质。她们能够注意到欧拉的发现么？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/89cf438309650adbd928ef58d8fd1565.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个学生都有自己的小册子且计算了各种各样简单的图的欧拉示性数，我也在教室里走动帮助他们。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fbb8019a970dba71e777d3250ecc6e7a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后，这些小女孩发现了：她们总是得到同一个结果—2！我听到她们说，“为什么总是得到2呢？”。她们发现了欧拉的惊喜！&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4fb0d38ffd90b92ab500831f8f551868.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;老师们也对这个结果非常好奇，一个老师惊异地对我说，“我真的很想知道为什么总是2！”&lt;/p&gt;
&lt;p&gt;接着，我建议同学们试试其他的几个不太常见的图，来检验一下这个“始终等于2”的情况有多么稳定。但是在这些图中，我们得到的结果仍然是2。&lt;/p&gt;
&lt;p&gt;女孩们自己画出图形检验了这一假设。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/78bf6ab3c9b648419a45b228293df86d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;最终，我设法提出了非连通图和有交叉边的图的例子，来检验“始终等于2”的现象。（&lt;span style=&quot;color: #808080;&quot;&gt;注：V-E+R=2对这样的图不成立&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9bc3d955cae6af2b8219a0be0a6e3037.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e90351d43d137a88da0300abb4138b3a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;就这样，我们一起把V-E+R=2的假设改进到只适用于连通平面图的情况。&lt;/p&gt;
&lt;p&gt;现在，到了该证明的时候了。我一开始不确定我是否应该给出一个证明，毕竟他们才三年级，证明对他们来说有些太难。但是有些老师向我表达了他们想知道为什么的想法，他们鼓励我让我给出证明，说“即使有的同学不能够理解这个证明，光看到有人能给出这样的证明也会有很大的价值。多好的老师啊！&lt;/p&gt;
&lt;p&gt;证明的过程如下。当一个图只有一个顶点，没有边的时候，V-E+R=2是成立的。而且，当往图里添加一个顶点和一个边的情况下，顶点和边（的贡献）能够互相抵消，这个等式也是成立的。同时，当往图中添加一条边并把一个已有的区域切分成两个的情况下，因为多了一个区域，多了一条边，这两个相互抵消，等式也是成立的。因为任何一个连通平面图都可以用上面描述的两种添加边和顶点的方式构建出来，所以V-E+R=2这个论证对于任何连通平面图都是成立的。这种证明是对图的势（size）的数学归纳法证明。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ec68809030a9aa81df6d7ece925807e6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/97b9af63b703689c6fcac61c37b41112.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下一步，我们把研究对象转移到三维立方体和它们的表面上。对于各种各样的多面体，小女孩们依旧能够证实V-E+R=2的拓展例子。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1b5438ecfc1dc0645d6962a4f19d332d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a4c4256ad6c1bb361e3c6b20c2f883bf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;接着，小女孩们自己画出多面体来计算欧拉示性数，我教她们怎么画立方体和图中所示的立方体；当图形不仅仅是一个简单的立方体时，这对孩子而言是一个挑战，尽管如此，一些小朋友仍然画出了些有趣的立方体。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fa8a648600994aa05be3703a40fd7707.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3eccd08f74a93ffb90452528fb6517fd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/64217b72026723eaacfad1a235670446.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后，每个孩子都有一个可以带回家的精美的小册子。以上图片摘自班里一位同学的小册子。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f0b06e04b618460a912c79aca4bf02a8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;多棒的一天啊！&lt;/p&gt;
&lt;p&gt;你可以在这儿找到小册子—八岁小孩的数学：&lt;a title=&quot;少儿图论&quot; href=&quot;https://plus.google.com/u/0/+JoelDavidHamkins1/posts/46ZctASr5US&quot; target=&quot;_blank&quot;&gt;少儿图论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也可以查看我上一次讲课的报道：&lt;a title=&quot;七岁小孩的数学：图着色和欧拉路径&quot; href=&quot;http://jdh.hamkins.org/math-for-seven-year-olds-graph-coloring-chromatic-numbers-eulerian-paths/&quot; target=&quot;_blank&quot;&gt;七岁小孩的数学：图着色和欧拉路径。&lt;/a&gt;&lt;/p&gt;

        
        &lt;!-- BEGIN #author-bio --&gt;

&lt;div id=&quot;author-bio&quot;&gt;
	
	&lt;h3 class=&quot;widget-title&quot;&gt;
	关于作者： &lt;a href=&quot;http://blog.jobbole.com/author/mingyuan/&quot;&gt;刘志成&lt;/a&gt;
	&lt;/h3&gt;
	&lt;div class=&quot;alignleft&quot;&gt;
		&lt;a href=&quot;http://blog.jobbole.com/author/mingyuan/&quot;&gt;
					&lt;/a&gt;
	&lt;/div&gt;
	&lt;p&gt;新浪微博：&lt;a href=&quot;http://weibo.com/sdwf&quot;&gt;@柳鸣渊&lt;/a&gt;&lt;/p&gt;
	&lt;p&gt;
		&lt;a style=&quot;text-decoration: none;&quot; href=&quot;http://blog.jobbole.com/author/mingyuan/&quot;&gt;查看刘志成的更多文章 »&lt;/a&gt;
	&lt;/p&gt;
	&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
	
&lt;/div&gt;

&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Fri, 22 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-22-86960-8358d0dfa.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-22-86960-8358d0dfa.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Shell（二）：变量、数据重定向和管道</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;在上一篇博客&lt;a href=&quot;http://blog.jobbole.com/86820/&quot; target=&quot;_blank&quot;&gt;Shell（一）：功能、配置和插件&lt;/a&gt;中，介绍了为什么要使用shell，shell有哪些功能，如何使用oh my zsh来提高效率等，本篇重点介绍，shell中的变量的如何设置和读取数据，读取之后如何使用变量？每个程序一般都有输入和输出，让我们看看数据重定向如何处理输入和输出的？还有，Unix/Linux系统提供丰富的工具，我们如何将这些工具通过管道来组合成更加强大的宏工具呢？下面，由我来逐一详细介绍变量、数据重定向和管道。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/23fde73486c88b8ec60e205c3373da96.jpg&quot; width=&quot;690&quot; height=&quot;433&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;变量的作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变量与其他程序设计语言一样，都是存储数据，然后被程序引用。相比于不使用变量，而是直接使用数据，存在两个问题：&lt;/p&gt;
&lt;p&gt;当数据改变时，直接使用数据的时候却不能灵活地根据数据改变而随着改变，而使用变量却不同，它能够做到这点。&lt;br&gt;
当数据发生变化时，如果想保证数据一致性，必须查找所有引用该数据的所有地方，然后将它修改，当下一次再需要修改时，也是像这种情况一样，是多么繁琐的事，而变量却不用，只需要修改变量值即可。&lt;br&gt;
因此，变量具有可变性和易于修改的两个特点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量的分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在shell中，大概分为两种变量：环境变量和局部变量，主要区别在于它们的使用范围不同，环境变量可以在父进程与子进程之间共享，而自定义变量只在本进程使用。举一个简单的例子来说明：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/779131174bda78f098c81335331d9195.jpg&quot; width=&quot;690&quot; height=&quot;123&quot;&gt;&lt;/p&gt;
&lt;p&gt;我首先设置一个shell变量devname=sam，然后输入bash打开一个新的shell，而这个shell是子进程，然后echo $devname输出变量值，变量值为空，最后exit退出子进程。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/caa630db46ddeaf5b6c08bcacc241fda.jpg&quot; width=&quot;690&quot; height=&quot;83&quot;&gt;&lt;/p&gt;
&lt;p&gt;但使用export devname设置环境变量后，再次进入输入bash进入子进程之后，echo $devname输出变量值，这次变量值是sam&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看环境变量env和set&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果想查看系统中以及自定义有哪些环境变量，可以使用env命令：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/1fa42177ba90ab550862e9b1abacee2e.jpg&quot; width=&quot;690&quot; height=&quot;500&quot;&gt;&lt;/p&gt;
&lt;p&gt;而set命令不仅能查看环境变量，还可以查看与shell接口有关的变量，下面只截取一部分变量：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/b387f8ad5812896873a4269c59ae8e30.jpg&quot; width=&quot;690&quot; height=&quot;353&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量有哪些操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显示echo $variable&lt;/p&gt;
&lt;p&gt;如果你想显示某个变量的值，例如PATH，你只需要输入：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;echo $PATH&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3f2b3bd9138d4012de7e7a1ef8d16a99.jpg&quot; width=&quot;690&quot; height=&quot;146&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意上面一条命令，需要在变量名前加上一个符号$，这样才能访问变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置variable=value和取消unset&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你想设置某个变量的值，只需在变量名和变量值之间用符号=连接就行了，例如：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3a6455d45005433527fc1ddf9571cfe4.jpg&quot; width=&quot;690&quot; height=&quot;231&quot;&gt;&lt;/p&gt;
&lt;p&gt;由上面的输入命令echo $devname，显示结果为空。由此可知，一开始如果没有设置某个变量时，它的是为空。另外，设置变量的规则还需要几点注意：&lt;/p&gt;
&lt;p&gt;1. 在命名变量名时，变量名称只能是英文字母和数字，而且首字母不能是数字。下面演示一个错误的例子：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/25cdbc229733ce96b3833b5a5e62f09d.jpg&quot; width=&quot;690&quot; height=&quot;77&quot;&gt;&lt;/p&gt;
&lt;p&gt;2. 等号=两边不能有空格&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/0808b1c942675bd695b3886bf48631b6.jpg&quot; width=&quot;690&quot; height=&quot;259&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 如果变量值有空格，可用双引号” “或单引号’ ‘来包围变量值，但两者是有区别：&lt;br&gt;
双引号” “内的一些特殊字符，可以保持原有的特性，例如：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/8ffabfd9a22eecdff7caad20394703f8.jpg&quot; width=&quot;690&quot; height=&quot;190&quot;&gt;&lt;/p&gt;
&lt;p&gt;而单引号’ ‘内的一些特殊字符，仅为一般字符，即纯文本，例如：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/6571f2b0da4d402246fd52d748a3444c.jpg&quot; width=&quot;690&quot; height=&quot;155&quot;&gt;&lt;/p&gt;
&lt;p&gt;4. 如果想显示一些特殊字符（$、空格、!等），在字符前面加上用转义字符\&lt;/p&gt;
&lt;p&gt;5. 有些时候，变量的值可能来源于一些命令，这时你可以使用反单引号`命令`或$(命令)，例如：&lt;/p&gt;
&lt;p&gt;使用反单引号`命令`的方式&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/ccd324509bd446b0e87f2943166831c9.jpg&quot; width=&quot;690&quot; height=&quot;146&quot;&gt;‘&lt;/p&gt;
&lt;p&gt;使用$(命令)的方式&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/8100e6d64cf53da84349526eb9335815.jpg&quot; width=&quot;690&quot; height=&quot;164&quot;&gt;&lt;/p&gt;
&lt;p&gt;6. 如果变量想增加变量的值，可以使用$variable累加&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/930c7e298386a35cff2f2a81b7ea9e24.jpg&quot; width=&quot;690&quot; height=&quot;285&quot;&gt;&lt;/p&gt;
&lt;p&gt;7. 如果变量需要在其他子进程使用，用&lt;code&gt;export&lt;/code&gt;关键字来设置变量为环境变量&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;export VARIABLE&lt;/pre&gt;
&lt;p&gt;8. 系统环境变量一般都是字母全部大写，例如：PATH，HOME，SHELL等&lt;/p&gt;
&lt;p&gt;9. 如果想取消设置变量的值，使用unset variable命令。注意，变量之前是没有符号$&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/ee65dd7bd45f8405c75d605f2e17d2d2.jpg&quot; width=&quot;690&quot; height=&quot;214&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前那些设置的环境变量，一旦退出系统后，就不能再次使用，如果想再次使用，必须重新再设置才行。如果想就算退出系统，也能重新使用自定义的环境变量，那怎么办呢？&lt;/p&gt;
&lt;p&gt;不用怕，系统提供一些环境配置文件：/etc/profile和~/.bash_profile。/etc/profile是系统整体的设置，每个用户共享，最好不要修改；而~/.bash_profile属于单个用户的设置，每个用户设置后，互不影响和共享。但因为我使用oh my zsh，之前~/.bash_profile设置一些配置都不生效了，但它提供一个环境配置文件.zshrc，所以如果想设置环境变量TEST，只需将export TEST=test添加.zshrc即可。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/ea68fa7a4089f8b86f765403f6e0b76c.jpg&quot; width=&quot;690&quot; height=&quot;223&quot;&gt;&lt;/p&gt;
&lt;p&gt;但在.zshrc文件设置好环境变量TEST后，echo $TEST为空，原因是还没使用source命令来读取环境配置文件。使用source .zshrc命令之后，设置环境变量TEST生效了&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e00a2a0672aeade7d0bbb0e3d29b1a7f.jpg&quot; width=&quot;690&quot; height=&quot;142&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;数据重定向&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当输入命令行时，一般都有输入参数(standard input)，而命令行处理完之后，一般都有输出结果，结果有可能成功(standard output)，也有可能失败(standard error)，而这些结果一般都会输出到屏幕上，如果你想控制结果输出到文件或以文件作为输入的话，你需要了解数据重定向的分类和符号操作。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/b03e3b25d6d6cc9b9d5d1fdcf38be4bf.jpg&quot; width=&quot;690&quot; height=&quot;259&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据重定向主要分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stdin，表示标准输入，代码为0，使用&amp;lt;或&amp;lt;&amp;lt;操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;符号&amp;lt;表示以文件内容作为输入&lt;br&gt;
符号&amp;lt;&amp;lt;表示输入时的结束符号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stdout，表示标准输出，代码为1，使用&amp;gt;或&amp;gt;&amp;gt;操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;符号&amp;gt;表示以覆盖的方式将正确的数据输出到指定文件中&lt;br&gt;
符号&amp;gt;&amp;gt;表示以追加的方式将正确的数据输出到指定文件中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stderr，表示标准错误输出，代码为2，使用2&amp;gt;或2&amp;gt;&amp;gt;操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;符号2&amp;gt;表示以覆盖的方式将错误的数据输出到指定文件中&lt;br&gt;
符号2&amp;gt;&amp;gt;表示以追加的方式将错误的数据输出到指定文件中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;stdout&lt;br&gt;
当你输入ls命令，屏幕会显示当前目录有哪些文件和目录；而当你使用符号&amp;gt;时，输出结果将重定向到dir.txt文件，而不显示在屏幕上&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/2146aa56576d3dd6a5a0b45bced80de1.jpg&quot; width=&quot;690&quot; height=&quot;230&quot;&gt;&lt;/p&gt;
&lt;p&gt;而符号&amp;gt;与符号&amp;gt;&amp;gt;有什么区别呢？&amp;gt;表示当文件存在时，将文件内容清空，然后stdout结果存放到文件中。而&amp;gt;&amp;gt;表示当文件存在时，文件内容并没有清空，而是将stdout结果追加到文件尾部。&lt;/p&gt;
&lt;p&gt;当你再次输入命令ls &amp;gt; dir.txt时，文件内容并没有改变，因为之前文件内容被清空，然后stdout结果存放在dir.txt文件&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/0e8da5fd9460376825e200adf87ba101.jpg&quot; width=&quot;690&quot; height=&quot;194&quot;&gt;&lt;/p&gt;
&lt;p&gt;而你这次使用符号ls &amp;gt;&amp;gt; dir.txt的话，文件内容被追加到dir.txt文件&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/07182755db7287ea7f767acd25eb6488.jpg&quot; width=&quot;690&quot; height=&quot;236&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stderr&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这次我输入命令ls test显示一个不存在的文件，会显示错误信息。然后将错误信息输出到文件error.txt。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/01211958d45d90545ce6108a2c565ae1.jpg&quot; width=&quot;690&quot; height=&quot;138&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你想追加错误信息，可以使用2&amp;gt;&amp;gt;符号&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/d130de034e3874ccff04dd534edfe3dc.jpg&quot; width=&quot;690&quot; height=&quot;117&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stdout &amp;amp; stderr&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将stdout和stderr分离：&amp;gt;和2&amp;gt;符号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入ls README.md test，在屏幕显示既有正确信息，也有错误信息，如果想将正确信息和错误信息分离到不同文件，你可以同时使用&amp;gt;和2&amp;gt;符号&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/4938a3e37d9b7d53c45fbdcf664c19de.jpg&quot; width=&quot;690&quot; height=&quot;185&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将stdout和stderr合并：&amp;amp;&amp;gt;符号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你想将正确信息和错误信息合并，且输出到同一个文件，可以使用&amp;amp;&amp;gt;符号&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/d32578ed30f64d4a03e8a1296d8cafe6.jpg&quot; width=&quot;690&quot; height=&quot;171&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stdin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般输入一些简单的数据的方式都是通过键盘，但是如果要输入大量的数据，最好还是通过文件的方式。举一个简单例子：&lt;br&gt;
首先输入cat &amp;gt; test命令之后，你就可以输入内容，那些内容最终会存放在test文件&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/e22d933ed7692846b61a1822316fbfc7.jpg&quot; width=&quot;690&quot; height=&quot;152&quot;&gt;&lt;/p&gt;
&lt;p&gt;但如果有大量数据从一个文件导入到test文件时，此时需要用到&amp;lt;符号&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/2b8cb1033043b77918f9a8941dd9444d.jpg&quot; width=&quot;690&quot; height=&quot;350&quot;&gt;&lt;/p&gt;
&lt;p&gt;还一个符号&amp;lt;&amp;lt;需要解释，符号&amp;lt;&amp;lt;表示输入时的结束符号。输入cat &amp;gt; test &amp;lt;&amp;lt; “eof”命令之后，你就可以输入内容，那些内容最终会存放在test文件，输入完内容后可以输入eof来结束输入&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/10a52fb8bf0b2ecb32be793ba96367a9.jpg&quot; width=&quot;690&quot; height=&quot;166&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;管道&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在Unix设计哲学中，有一个重要设计原则–KISS(Keep it Simple, Stupid)，大概意思就是只关注如何做好一件事，并把它做到极致。每个程序都有各自的功能，那么有没有一样东西将不同功能的程序互相连通，自由组合成更为强大的宏工具呢？此时，管道出现了，它能够让程序实现了高内聚，低耦合。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/a9e464ef9cb6e5aeb9fad8eb8b544c22.jpg&quot; width=&quot;690&quot; height=&quot;160&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果我想查看文件是否存在某个关键字，此时我可以使用管道&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/62816c4c13f157c3686fa178d179747c.jpg&quot; width=&quot;690&quot; height=&quot;141&quot;&gt;&lt;/p&gt;
&lt;p&gt;命令cat README.md | grep ‘pod’的处理过程分为两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cat README.md查看文件内容&lt;/li&gt;
&lt;li&gt;然后将cat README.md输出的内容作为grep ‘pod’命令的输入，再进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面一个很关键的符号|，就是管道，它能够将前一个命令处理完的stdout作为下一条命令stdin。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;扩展阅读&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/4889838/&quot; target=&quot;_blank&quot;&gt;鸟哥的Linux私房菜-基础学习篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://coolshell.cn/articles/1351.html&quot; target=&quot;_blank&quot;&gt;Unix Pipes 管道原稿&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 21 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-21-87053-498a03022.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-21-87053-498a03022.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>算法题：删除 K 位数字</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;h3&gt;&lt;strong&gt;1.问题描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;现有一个 n 位数，你需要删除其中的 k 位，请问如何删除才能使得剩下的数最大？&lt;/p&gt;
&lt;p&gt;比如当数为 2319274， k=1 时，删去 2 变成 319274 后是可能的最大值。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.问题分析&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;[1]贪心解法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这题可以使用贪心策略，每次从高位向低位数，删除高位比低位数字小的那位上的数字，直到删除了k位之后，得到的数字肯定是最大值。&lt;/p&gt;
&lt;p&gt;(1)删数问题具有最优子结构：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/4eb1ec5a141234981f4e15990f4bd405.jpg&quot; width=&quot;690&quot; height=&quot;90&quot;&gt;&lt;/p&gt;
&lt;p&gt;(2)删数问题具有贪心选择性质：&lt;/p&gt;
&lt;p&gt;设问题T已按照上面的方法删除，假设 A=(y1,y2,···,yk) 是删数问题的一个最优解。易知，若问题有解，则1≤k≤n。 (1)当k=1时，由前得证，A=(y1,A′)是问题的最优解，其中A′是A中不删除了y1而删除其他位的最优解； (2)当k=q时，由反证法，可得A=(y1,y2···,yq)是最优解； 当k=q+1时，由前得证，A=(y1,y2···,yq+yq+1)是最优解。 所以，删数问题具有贪心选择性质。&lt;/p&gt;
&lt;p&gt;代码很容易实现，AC，1.484s，1.089MB&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;
int t,k,len;
string name;
void deletek(){
    int tlen=name.length();
    int tk=k;
    bool flag=true;
    while (k--&amp;gt; 0 &amp;amp;&amp;amp; flag) {
        flag=false;
        len = name.length();
        for (int i=0; i&amp;lt;len; i++) {
            if (i+1&amp;lt;len &amp;amp;&amp;amp; name[i]&amp;lt;name[i+1]) {
                name.erase(i,1);
                len--;
                flag=true;
                break;
            }
        }
    }
    cout &amp;lt;&amp;lt; name.substr(0,tlen-tk) &amp;lt;&amp;lt; endl;
}
int main(int argc, const char * argv[])
{
    cin &amp;gt;&amp;gt; t;
    while (t--&amp;gt;0) {
        cin &amp;gt;&amp;gt; name;
        cin &amp;gt;&amp;gt; k;
        deletek();
    }
    return 0;
}&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[2]动态规划解法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据上面的分析可以看出此题还可用动态规划来解决，思路如下：&lt;/p&gt;
&lt;p&gt;假设A(i,j)表示输入数字(字符串)的从第i位到第j位数字组成的字符串，S(i,j)表示前i位中删除j位得到的最优解，它实际上可以看做两个子问题：如果删除第j位，那么S(i,j)等于前i-1位删除j-1位的最优解加上第j位数字；如果不删除第j位，那么S(i,j)等于前i-1位删除j位的最优解。于是便有下面的递推式：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/25d9f951793b5aa11c3f98e18a85bcf2.jpg&quot; width=&quot;519&quot; height=&quot;67&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个递推式非常类似最长公共子序列问题的递推式，所以解法也类似，在空间方面可以只使用一个一维数组，加上一个额外的O(1)的空间，计算过程如下面制作的表格所示，除了第一列，其他中间元素都只依赖于上面一行对应位置S(i−1,j)和上面一行左边位置S(i−1,j−1)两个元素的大小，比较的是字符串，使用字典序进行比较，C++内置的字符串比较函数compare即可。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/1e83f13184510ff68937db00444881b9.jpg&quot; width=&quot;460&quot; height=&quot;331&quot;&gt;&lt;/p&gt;
&lt;p&gt;动态规划实现代码 [这份代码没有AC，只能得到60分就超时了，应该还可以改进]。&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;
#define MAX_K 1001
int t,k;
string name;string up;string last;string temp;
void deletek(){
    int len=name.length();
    if(k&amp;gt;=len){
        cout &amp;lt;&amp;lt; &quot;&quot; &amp;lt;&amp;lt; endl;
        return;
    }
    string cur[MAX_K]={&quot;&quot;};
    for (int i=1; i &amp;lt;= len; i++) {
        for (int j=0; j &amp;lt; i &amp;amp;&amp;amp; j &amp;lt;= k; j++) {//
            if (j==0) {//sub string
                last=cur[j];
                cur[j]=name.substr(0,i);
            }else{//0 &amp;lt; j &amp;lt;= i
                up=cur[j]+name[i-1];//
                if (up.compare(last)&amp;gt;=0) {//up &amp;gt; left
                    last=cur[j];
                    cur[j]=up;
                }else{//up &amp;lt; left
                    temp=cur[j];
                    cur[j]=last;
                    last=temp;
                }
            }
        }
    }
    cout &amp;lt;&amp;lt; cur[k] &amp;lt;&amp;lt; endl;
}
int main(int argc, const char * argv[])
{
    cin &amp;gt;&amp;gt; t;
    while (t--&amp;gt;0) {
        cin &amp;gt;&amp;gt; name;
        cin &amp;gt;&amp;gt; k;
        deletek();
    }
    return 0;
}&lt;/pre&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 21 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-21-87018-3225f88cf.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-21-87018-3225f88cf.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>算法题：最长公共子序列</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;最长公共子序列(LCS)是典型的动态规划问题，如果不理解动态规划请移步先看&lt;a href=&quot;http://python.jobbole.com/81465/&quot; target=&quot;_blank&quot;&gt;这篇动态规划的总结&lt;/a&gt;，否则本篇文章中的代码实现会不理解的哟！&lt;/p&gt;
&lt;p&gt;LCS问题的一个变种就是求最长单调递增子序列，它的一种简易求解方法就是先将原序列A进行排序得到序列B，然后求解序列A和序列B的最长公共子序列。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.问题描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3e466bd42e6eac26c6b37f9a8e1e7977.jpg&quot; width=&quot;636&quot; height=&quot;181&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.最优子结构和子问题重叠&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3658414382687496f599f1d277450d10.jpg&quot; width=&quot;629&quot; height=&quot;701&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.5种实现方式&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;根据LCS的递推公式&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/dd591d0c1eda24cd1ca024af328f729e.jpg&quot; width=&quot;452&quot; height=&quot;85&quot;&gt;&lt;/p&gt;
&lt;p&gt;(1)从中可以看出计算c[i][j]时只需要2行即可，前一行(i-1)和当前行(i)，每行的长度是min{m,n}，首先初始化前一行都为0，然后计算当前行的值，当要计算下一行之前将当前行的值复制到前一行中即可。&lt;/p&gt;
&lt;p&gt;(2)从递推公式中还可以看出计算当前行i的话，其实只需要一行再加上O(1)的额外空间就行了。因为计算c[i][j]只需要前一行中c[i-1][k] (k&amp;gt;=j-1)的数据，对于k&amp;lt;j-1的数据都是没有用的，而当前行c[i]l的数据都是有用的，要用来计算下一行的值，所以，可以在计算当前行的时候，将当前行的前面计算好的部分复制到前一行中对应位置上，但是c[i][j-1]除外，因为c[i-1][j-1]也是需要的，所以需要额外的O(1)的空间保存c[i][j-1]。&lt;/p&gt;
&lt;p&gt;LCS的五种实现：分别为0：直接递归；1：带备忘录的递归；2：使用二维数组保存结果的迭代；3：使用2个一维数组保存结果的迭代；4：使用1个一维数组和额外的O(1)空间保存结果的迭代。&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;def lcs0(i,j):
    #string starts at index 0, not 1
    if i&amp;lt;0 or j&amp;lt;0: return 0 #attention to this!!!
    if x[i]==y[j]:  return lcs0(i-1,j-1)+1
    return max(lcs0(i-1,j),lcs0(i,j-1))

x,y=&#39;abcde&#39;,&#39;oaob&#39;
lenx,leny=len(x),len(y)
print(lcs0(lenx-1,leny-1)) #2

from functools import wraps

def memo(func):
    cache={}
    @wraps(func)
    def wrap(*args):
        if args not in cache:
            cache[args]=func(*args)
        return cache[args]
    return wrap

@memo
def lcs1(i,j):
    #string starts at index 0, not 1
    if i&amp;lt;0 or j&amp;lt;0: return 0 #attention to this!!!
    if x[i]==y[j]:  return lcs1(i-1,j-1)+1
    return max(lcs1(i-1,j),lcs1(i,j-1))

x,y=&#39;abcde&#39;,&#39;oaob&#39;
lenx,leny=len(x),len(y)
print(lcs1(lenx-1,leny-1)) #2

def lcs2(x,y):
    lenx,leny=len(x),len(y)
    minlen,maxlen=0,0
    if lenx&amp;lt;leny: minlen,maxlen=lenx,leny; x,y=y,x
    else: minlen,maxlen=leny,lenx;
    #s is maxlen * minlen
    s=[[0 for j in range(minlen)] for i in range(maxlen)]
    for i in range(maxlen): #so, let x be the longer string!!!
        for j in range(minlen):
            if x[i]==y[j]: s[i][j]=s[i-1][j-1]+1
            else: s[i][j]=max(s[i-1][j],s[i][j-1])
    return s

x,y=&#39;abcde&#39;,&#39;oaob&#39;
s=lcs2(x,y)
print(s) #[[0, 1, 1, 1], [0, 1, 1, 2], [0, 1, 1, 2], [0, 1, 1, 2], [0, 1, 1, 2]]

def lcs3(x,y):
    lenx,leny=len(x),len(y)
    minlen,maxlen=0,0
    if lenx&amp;lt;leny: minlen,maxlen=lenx,leny; x,y=y,x
    else: minlen,maxlen=leny,lenx;
    #s is maxlen * minlen
    pre=[0 for j in range(minlen)]
    cur=[0 for j in range(minlen)]
    for i in range(maxlen): #so, let x be the longer string!!!
        for j in range(minlen):
            if x[i]==y[j]: cur[j]=pre[j-1]+1
            else: cur[j]=max(pre[j],cur[j-1])
        pre[:]=cur[:]
    return cur

x,y=&#39;abcde&#39;,&#39;oaob&#39;
s=lcs3(x,y)
print(s) #[2, 2, 2, 2]

def lcs4(x,y):
    lenx,leny=len(x),len(y)
    minlen,maxlen=0,0
    if lenx&amp;lt;leny: minlen,maxlen=lenx,leny; x,y=y,x
    else: minlen,maxlen=leny,lenx;
    #s is maxlen * minlen
    s=[0 for j in range(minlen)]
    t=0
    for i in range(maxlen): #so, let x be the longer string!!!
        for j in range(minlen):
            if x[i]==y[j]: s[j]=t+1
            else: s[j]=max(s[j],s[j-1])
            t=s[j]
    return s

x,y=&#39;abcde&#39;,&#39;oaobce&#39;
s=lcs4(x,y)
print(s) #[3, 3, 3, 3, 4]&lt;/pre&gt;

        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 21 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-21-87015-293678f7c.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-21-87015-293678f7c.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>算法题：矩阵链乘问题</title>
        <description>

        &lt;!-- div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;script language=javascript&gt;
                var randomNumLuobo = Math.round(Math.random()*1);
                var imageLuobo=new Array(2);
                imageLuobo[0]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                imageLuobo[1]=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/luobo-620x60.png&quot;;
                var imageUrlLuobo=imageLuobo[randomNumLuobo];
                var urlsLuobo=new Array(2);
                urlsLuobo[0]=&quot;http://www.luobo360.com&quot;;
                urlsLuobo[1]=&quot;http://www.luobo360.com&quot;;
                var urlLuobo = urlsLuobo[randomNumLuobo];
                var adHTML = &quot;&lt;a href=&#39;&quot;+urlLuobo+&quot;&#39; target=&#39;_blank&#39;&gt;&lt;img src=&#39;&quot;+imageUrlLuobo+&quot;&#39; border=&#39;0&#39;&gt;&lt;/a&gt;&quot;;
                document.write(adHTML);
            &lt;/script&gt;
        &lt;/div --&gt;

        &lt;span style=&quot;display:block;margin-bottom:10px;&quot;&gt;&lt;/span&gt;
		
&lt;p&gt;矩阵链乘问题是最典型的动态规划问题，要理解下面的内容请先阅读&lt;a href=&quot;http://python.jobbole.com/81465/&quot; target=&quot;_blank&quot;&gt;这篇动态规划的总结&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.问题描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;矩阵链乘问题的描述如下，就是说要确定一个完全加括号的形式使得矩阵链乘需要进行的标量计算数目最少，矩阵Ai的维数为pi−1×pi，如果穷举所有可能形式的话，时间复杂度是指数级的！因为该问题满足最优子结构，并且子问题存在重叠，所以我们可以借助动态规划来求解。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/a34199733c6e27f4004e5c5519653cea.jpg&quot; width=&quot;690&quot; height=&quot;581&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.问题分析&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们需要确定一个递归式来将我们要求解的问题表示出来，下面摘自算法导论，介绍地非常详细&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/cf3e4c85f502681ac9282a4d7eaf50f3.jpg&quot; width=&quot;690&quot; height=&quot;451&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;最后给出的递归式如下，就是说我们要如何确定从第i个矩阵到第j个矩阵组成的矩阵链的最优解。如果i和j相等，那么就是一个矩阵，不需要运算；如果i小于j，那么肯定要从它们中间的某个位置分开来，那从哪里分开来呢? 这个我们可以尝试下所有可能的选择，也就是尝试不同的位置k，k满足条件(i &amp;lt;= k &amp;lt; j)，在位置k将矩阵链进行分开，看看它需要的计算次数，然后我们从这些可能的k中选择使得计算次数最小的那个k进行分开，分开了之后我们的问题就变成了2个小问题，确定矩阵链从i到k 和另一个矩阵链从k+1到j的最优解。如果我们一开始设置i=1(第一个矩阵)，j=n(最后一个矩阵)，那么，经过上面的递归即可得到我们需要的解。这就是递归的思想！&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3bd99ed2af439196ed7915fa55deb3ef.jpg&quot; width=&quot;471&quot; height=&quot;66&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.代码实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;根据上面的思想我们很快就可以写出一个递归版本的矩阵链承法的实现代码，输出的结果也没有错，给出的加括号的方式是( ( A1 ( A2 A3 ) ) ( ( A4 A5 ) A6 ) )。[问题的数据是算法导论中的问题的数据，值是30,35,15,5,10,20,25]。&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;def matrixchain_rec(p,i,j):
    if i==j:
        return 0
    for k in range(i,j):
        q=matrixchain_rec(p,i,k)+matrixchain_rec(p,k+1,j)+p[i-1]*p[k]*p[j]
        if q&amp;lt;m[i][j]:
            m[i][j]=q
            s[i][j]=k
    return m[i][j]

def showmatrixchain(s,i,j):
    if i==j:
        print &#39;A%d&#39;%(i),
    else:
        print &#39;(&#39;,
        showmatrixchain(s,i,s[i][j])
        showmatrixchain(s,s[i][j]+1,j)
        print &#39;)&#39;,

n=6
p=[30,35,15,5,10,20,25]
m=[[sys.maxint for i in range(n+1)] for j in range(n+1)]
s=[[0 for i in range(n+1)] for j in range(n+1)]
# pprint.pprint(m)
result=matrixchain_rec(p,1,6)
print(result) #15125
showmatrixchain(s,1,6) #( ( A1 ( A2 A3 ) ) ( ( A4 A5 ) A6 ) )&lt;/pre&gt;
&lt;p&gt;上面的代码运行没有问题，但是，它不够完美！为什么呢? 很明显，矩阵链乘问题子问题存在重叠，下面这张图很形象地显示了哪些子问题被重复计算了，所以我们需要改进，改进的方法就是使用带备忘录的递归形式！&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/1519f3c35bc11109b92847db68909758.jpg&quot; width=&quot;690&quot; height=&quot;185&quot;&gt;&lt;/p&gt;
&lt;p&gt;要改成带备忘录的很简单，但是，这次我们不能直接使用原来的装饰器，因为Python中的dict不能对list对象进行hash，所以我们要简单地修改下我们key值的构建，也很简单，看下代码就明白了：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;from functools import wraps

def memo(func):
    cache={}
    @wraps(func)
    def wrap(*args):
        #build new key!!!
        key=str(args[1])+str(args[2])
        if key not in cache:
            cache[key]=func(*args)
        return cache[key]
    return wrap

@memo
def matrixchain_rec(p,i,j):
    if i==j:
        return 0
    for k in range(i,j):
        q=matrixchain_rec(p,i,k)+matrixchain_rec(p,k+1,j)+p[i-1]*p[k]*p[j]
        if q&amp;lt;m[i][j]:
            m[i][j]=q
            s[i][j]=k
    return m[i][j]

def showmatrixchain(s,i,j):
    if i==j:
        print &#39;A%d&#39;%(i),
    else:
        print &#39;(&#39;,
        showmatrixchain(s,i,s[i][j])
        showmatrixchain(s,s[i][j]+1,j)
        print &#39;)&#39;,

n=6
p=[30,35,15,5,10,20,25]
m=[[sys.maxint for i in range(n+1)] for j in range(n+1)]
s=[[0 for i in range(n+1)] for j in range(n+1)]
# pprint.pprint(m)
result=matrixchain_rec(p,1,6)
print(result) #15125
showmatrixchain(s,1,6) #( ( A1 ( A2 A3 ) ) ( ( A4 A5 ) A6 ) )&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;接下来的一个问题是，我们怎么实现迭代版本呢? 迭代版本关键在于顺序！&lt;/strong&gt;我们怎么保证我们在计算$A{i…j}的最优解时，所有可能的k的选择需要求解的子问题A{i…k}以及A_{(k+1)…j}$是已经求解出来了的呢? 一个简单但是有效的想法就是看矩阵链的长度，我们先计算矩阵链短的最优解，然后再计算矩阵链长的最优解，后者计算时所需要求解的子问题肯定已经求解完了，对不对? 于是就有了迭代版本的实现，需要注意的就是其中的i,j,k的取值范围。&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;import sys
def matrixchain_iter(p):
    n=len(p)-1 #total n matrices 6
    #to solve the problem below, so initialize to n+1!!!
    m=[[0 for i in range(n+1)] for j in range(n+1)]
    s=[[0 for i in range(n+1)] for j in range(n+1)]
    # for i in range(n): #for matrix with len=1
        # m[i][i]=0
    # pprint.pprint(m)
    for l in range(2,n+1): #iterate the length, max is n
        for i in range(1,n-l+2): #i max is n-l+1
            j=i+l-1 #j is always l away from i
            m[i][j]=sys.maxint #initial to infinity
            for k in range(i,j):
                #attention to python array when index &amp;lt; 0!!!
                #solution is using more space with useless values
                q=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]
                if q&amp;lt;m[i][j]:
                    m[i][j]=q
                    s[i][j]=k
        # print(&#39;when len is %d &#39; % (l))
        # pprint.pprint(m)
    return m,s

print(&#39;&#39;)
m,s=matrixchain_iter(p)
print(m[1][6]) #15125
showmatrixchain(s,1,6) #( ( A1 ( A2 A3 ) ) ( ( A4 A5 ) A6 ) )&lt;/pre&gt;
&lt;p&gt;实现的时候需要注意一点，在Python中取list中的值时，如果索引是负值的话会从后面往前数返回对应的元素，而以前我们用其他语言的时候肯定是提示越界了，所以代码中用来存储结果的数数组是(n+1)x(n+1)，而不是nxn的，这样的话就能够保证返回的是0，而不是从后往前数得到的结果。&lt;/p&gt;
&lt;p&gt;得到的数组m如下，m[1,6]就是我们需要的解。&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;[[0, 0, 0, 0, 0, 0, 0],
 [0, 0, 15750, 7875, 9375, 11875, 15125],
 [0, 0, 0, 2625, 4375, 7125, 10500],
 [0, 0, 0, 0, 750, 2500, 5375],
 [0, 0, 0, 0, 0, 1000, 3500],
 [0, 0, 0, 0, 0, 0, 5000],
 [0, 0, 0, 0, 0, 0, 0]]&lt;/pre&gt;
&lt;p&gt;数组s如下：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp; gutter: true&quot;&gt;[[0, 0, 0, 0, 0, 0, 0],
 [0, 0, 1, 1, 3, 3, 3],
 [0, 0, 0, 2, 3, 3, 3],
 [0, 0, 0, 0, 3, 3, 3],
 [0, 0, 0, 0, 0, 4, 5],
 [0, 0, 0, 0, 0, 0, 5],
 [0, 0, 0, 0, 0, 0, 0]]&lt;/pre&gt;
&lt;p&gt;将这个两个数组旋转下，并且只看上三角部分的数字，就可以得到算法导论中给出的那张三角图形了，非常类似杨辉三角&lt;/p&gt;


        
        &lt;!-- BEGIN #author-bio --&gt;


&lt;!-- END #author-bio --&gt;
	

</description>
        <pubDate>Thu, 21 May 2015 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2015/2015-05-21-87012-731b58095.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2015/2015-05-21-87012-731b58095.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
  </channel>
</rss>
