<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IT技术干货</title>
    <description>[IT技术干货iftti.com] @KernelHacks</description>
    <link>http://iftti.com/</link>
    <atom:link href="http://iftti.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 25 Nov 2014 09:59:06 +0800</pubDate>
    <lastBuildDate>Tue, 25 Nov 2014 09:59:06 +0800</lastBuildDate>
    <generator>Jekyll v2.2.0</generator>
    
      <item>
        <title>利用动态仪表板实现kibana单图表导出功能</title>
        <description>

  
  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;昨天和朋友聊天，说监控报表的话题，他们认为 kibana 的仪表板形式，还是偏重技术人员做监控的 screen 思路，对 erp 之类的报表不是很友好。要想跟其他系统结合，或者说嵌入到其他系统中，就必须得有单个图表的导出，或者 URL 引用方式。当时我直觉上的反应，就是这个没问题，可以通过 javascript 动态仪表板这个高级功能完成。回来试了一下，比我想的稍微复杂一点点，还是可以很轻松完成的。&lt;/p&gt;
&lt;p&gt;读过&lt;a href=&quot;http://kibana.logstash.es/content/dashboard-schema.html&quot;&gt;仪表板纲要&lt;/a&gt;一文，或者自己看过源代码中 &lt;code&gt;src/app/dashboards/logstash.json&lt;/code&gt; 文件的人，应该都知道 kibana 中有些在页面配置界面里看不到的隐藏配置选项。其中很符合我们这次需求的，就有 &lt;code&gt;editable&lt;/code&gt;, &lt;code&gt;collapsable&lt;/code&gt; 等。所以，首先第一步，我们可以在自己的 &lt;code&gt;panel.js&lt;/code&gt;(直接从 logstash.js 复制过来) 中，把这些关掉：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;dashboard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;editable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;//不显示每行的编辑按钮&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;collapsable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;//不显示每行的折叠按钮&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Events&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;400px&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;panels&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;editable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;//不显示面板的编辑按钮&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;events over time&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;histogram&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;time_field&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ARGS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;timefield&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;@timestamp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;auto_int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;span&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;dashboard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;editable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//不显示仪表板的编辑按钮&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;dashboard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;panel_hints&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//不显示面板的添加按钮&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后要解决面板上方的 query 框和 filtering 框。这个同样在纲要介绍里说了，这两个特殊的面板是放在垂幕(pulldows)里的。所以，直接关掉垂幕就好了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;dashboard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pulldowns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再往上是顶部栏。顶部栏里有时间选择器，这个跟垂幕一样是可以关掉的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;dashboard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;nav&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，javascript 里可以关掉的，都已经关了。&lt;/p&gt;
&lt;p&gt;但是运行起来，发现顶部栏里虽然是没有时间选择器和配置编辑按钮了，本身这个黑色条带和 logo 图什么的，却依然存在！这时候我想起来有时候 config.js 没写对，&lt;code&gt;/_nodes&lt;/code&gt; 获取失败的时候，打开的页面就是背景色外加这个顶条 —— 也就是说，这部分代码是写在 &lt;code&gt;index.html&lt;/code&gt; 里的，不受 &lt;code&gt;app/dashboards/panel.js&lt;/code&gt; 控制。&lt;/p&gt;
&lt;p&gt;所以这里就得去修改一下 &lt;code&gt;index.html&lt;/code&gt; 了。不过为了保持兼容性，我这里没有直接删除顶部栏的代码，而是用了 angularjs 中很常用的 &lt;code&gt;ng-show&lt;/code&gt; 指令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ng-cloak&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;navbar navbar-static-top&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ng-show=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dashboard.current.nav.length&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为之前关闭时间选择器的时候，已经把这个 nav 数组定义为空了，所以只要判断一下数组长度即可。&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/chenlinux.com/3747fb3af94787b878445fd191c7a181.jpg&quot; alt=&quot;single panel&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;dashboard.services&lt;/code&gt; 的定义没有做修改，所以这个其实照样支持你用鼠标拉动选择时间范围，支持你在 URL 后面加上 &lt;code&gt;?query=status:404&amp;amp;from=1h&lt;/code&gt; 这样的参数，效果都是对的。只不过不会再让你看到这些文字显示在页面上了。&lt;/p&gt;
&lt;p&gt;如果要求再高一点，其实完全可以在 &lt;code&gt;ARGS&lt;/code&gt; 里处理更复杂的参数，比如直接 &lt;code&gt;?type=terms&amp;amp;field=host&amp;amp;value_field=requesttime&lt;/code&gt; 就生成 &lt;code&gt;dashboard.rows[0].panels[0]&lt;/code&gt; 里的对应参数，达到自动控制图表类型和效果的目的。&lt;/p&gt;
    &lt;hr&gt;
    
    &lt;hr&gt;
  &lt;!-- JiaThis Button BEGIN --&gt;
&lt;div class=&quot;jiathis_style&quot;&gt;
&lt;span class=&quot;jiathis_txt&quot;&gt;分享到：&lt;/span&gt;
&lt;a class=&quot;jiathis_button_tsina&quot;&gt;新浪微博&lt;/a&gt;
&lt;a class=&quot;jiathis_button_weixin&quot;&gt;微信&lt;/a&gt;
&lt;a class=&quot;jiathis_button_renren&quot;&gt;人人网&lt;/a&gt;
&lt;a class=&quot;jiathis_button_ydnote&quot;&gt;有道云笔记&lt;/a&gt;
&lt;a class=&quot;jiathis_button_gmail&quot;&gt;Gmail邮箱&lt;/a&gt;
&lt;a class=&quot;jiathis_button_twitter&quot;&gt;Twitter&lt;/a&gt;
&lt;a class=&quot;jiathis_button_googleplus&quot;&gt;Google+&lt;/a&gt;
&lt;a class=&quot;jiathis_button_hi&quot;&gt;百度空间&lt;/a&gt;
&lt;a class=&quot;jiathis_button_fb&quot;&gt;Facebook&lt;/a&gt;
&lt;a class=&quot;jiathis_button_douban&quot;&gt;豆瓣&lt;/a&gt;
&lt;a href=&quot;http://www.jiathis.com/share?uid=1589850&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;更多&lt;/a&gt;
&lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var jiathis_config={
	data_track_clickback:true,
	summary:&quot;&quot;,
	ralateuid:{
		&quot;tsina&quot;:&quot;1035836154&quot;
	},
	shortUrl:false,
	hideMore:false
}
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://v3.jiathis.com/code/jia.js?uid=1589850&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;!-- JiaThis Button END --&gt;
&lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;
  &lt;/div&gt;

</description>
        <pubDate>Sun, 23 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-23-kibana-panel-only-dashboard-3474bf0cc.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-23-kibana-panel-only-dashboard-3474bf0cc.html</guid>
        
        
        <category>chenlinux</category>
        
      </item>
    
      <item>
        <title>Linux Performance Tools 2014</title>
        <description>

&lt;p&gt;Last month I gave an updated Linux Performance Tools talk for &lt;a href=&quot;http://events.linuxfoundation.org/events/archive/2014/linuxcon-europe&quot;&gt;LinuxCon Europe 2014&lt;/a&gt; in Düsseldorf. This included static performance tuning, as well as other updates. My performance observability tools diagram now includes rdmsr, after my post on &lt;a href=&quot;/blog/2014-09-15/the-msrs-of-ec2.html&quot;&gt;The MSRs of EC2&lt;/a&gt;, where I discovered that MSRs could be useful:&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;
&lt;center&gt;&lt;a href=&quot;/Perf/linux_observability_tools.png&quot;&gt;&lt;img src=&quot;/images/brendangregg.com/386f03345157c7fac26406e42798f874.jpg&quot; width=&quot;500&quot; height=&quot;350&quot;&gt;&lt;/a&gt;&lt;/center&gt;

&lt;p&gt;I keep this diagram updated on &lt;a href=&quot;/linuxperf.html&quot;&gt;linuxperf&lt;/a&gt;. The slides from my talk are on (&lt;a href=&quot;http://www.slideshare.net/brendangregg/linux-performance-tools-2014&quot;&gt;slideshare&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;
&lt;center&gt;&lt;iframe src=&quot;http://www.slideshare.net/slideshow/embed_code/40240208&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen&gt; &lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;As I didn&#39;t see an official video camera in the room, I had my friends at &lt;a href=&quot;http://www.efficios.com/&quot;&gt;EfficOS&lt;/a&gt; film it, who also filmed the &lt;a href=&quot;http://lwn.net/Articles/622033/rss&quot;&gt;Tracing Summit&lt;/a&gt;. This is on (&lt;a href=&quot;https://www.youtube.com/watch?v=SN7Z0eCn0VY&quot;&gt;youtube&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;
&lt;center&gt;&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://www.youtube.com/embed/SN7Z0eCn0VY&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;The main objective of my talk was to give you exposure to what exists in the field of Linux performance tools – to turn unknown unknowns into known unknowns. &lt;/p&gt;

&lt;div style=&quot;float:right;padding-left:10px;padding-bottom:5px&quot;&gt;
&lt;img src=&quot;/images/brendangregg.com/40960fcd9a650b461bf8cd7271ebe119.jpg&quot; width=&quot;250&quot; height=&quot;161&quot;&gt;&lt;br&gt;&lt;center&gt;&lt;font size=&quot;-1&quot;&gt;&lt;i&gt;Photo by &lt;a href=&quot;https://www.flickr.com/photos/linuxfoundation/15348354449/&quot;&gt;Linux Foundation&lt;/a&gt;&lt;/i&gt;&lt;/font&gt;&lt;/center&gt;
&lt;/div&gt;

&lt;p&gt;In my earlier &lt;a href=&quot;/blog/2014-08-23/linux-perf-tools-linuxcon-na-2014.html&quot;&gt;LinuxCon North America&lt;/a&gt; talk, I had three main collections of performance tools, with a diagram for each: for observability, benchmarking, and tuning tools. For this LinuxCon Europe talk, I introduced a fourth main category: static performance tuning tools.&lt;/p&gt;

&lt;p&gt;I learned about static performance tuning from a paper by Richard Elling in 2000: the idea is to check the static configured state of the system, &lt;em&gt;without load&lt;/em&gt;, to look for a class of issues not found by other tools. This includes things like checking how full the filesystems are, the routing table, and network interface auto-negotiation. I feel the addition of this group of tools makes this talk complete: I&#39;m summarizing all the main tools in one short talk.&lt;/p&gt;

&lt;p&gt;At LinuxCon Europe I also saw a great talk by Ben Maurer on &lt;a href=&quot;http://events.linuxfoundation.org/sites/events/files/slides/lpc.pdf&quot;&gt;Scaling Userspace @ Facebook&lt;/a&gt; (slides), where he discussed some serious systems performance analysis on Linux that they have been doing. It&#39;s impressive, interesting, and deep work. Sadly I didn&#39;t see a video camera to capture it.&lt;/p&gt;

&lt;p&gt;Steven Rostedt from Red Hat gave a stunning talk on &lt;a href=&quot;http://www.linuxplumbersconf.org/2014/ocw//system/presentations/1773/original/ftrace-kernel-hooks-2014.pdf&quot;&gt;Ftrace Kernel Hooks: More than just tracing&lt;/a&gt; (slides). This might be the most technical talk I&#39;ve ever seen! I found it particularly interesting as I&#39;ve been doing a lot with ftrace, an undiscovered gem of Linux, including using it for my &lt;a href=&quot;https://github.com/brendangregg/perf-tools&quot;&gt;perf-tools&lt;/a&gt; collection. I heard this talk was videoed, although I haven&#39;t seen the video yet.&lt;/p&gt;

&lt;p&gt;I also saw Rikki Endsley, also now at Red Hat, give a talk on &lt;a href=&quot;http://lccoelce14.sched.org/event/e883537a4136e09a421beb97440ee59b?iframe=no&amp;amp;w=&amp;amp;sidebar=yes&amp;amp;bg=no#.VHD-NmTF9o8&quot;&gt;Confessions of a Reluctant Tweeter: Social Media for Open Source Communities&lt;/a&gt;. Rikki has contributed much to our industry, and it&#39;s interesting to hear her expertise on open source marketing in general. I had spoken about marketing earlier in the week at the Tracing Summit, where Linux technologies like ftrace could really benefit from more exposure.&lt;/p&gt;

&lt;p&gt;Thanks to those who attended my talk, and the Linux Foundation for organizing another great event!&lt;/p&gt;


</description>
        <pubDate>Sat, 22 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-22-linux-perf-tools-2014.html-100c15b15.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-22-linux-perf-tools-2014.html-100c15b15.html</guid>
        
        
        <category>brendangregg</category>
        
      </item>
    
      <item>
        <title>用 phantomjs 截图</title>
        <description>

  
  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;昨儿给 kibana 加上了 table 面板数据导出成 CSV 的功能。朋友们就问了，那其他面板的图表怎么导出保存呢？其实直接截图就好了嘛……&lt;/p&gt;
&lt;p&gt;FireFox 有插件用来截全网页图。不过如果作为定期的工作，这么搞还是比较麻烦的，需要脚本化下来。这时候就可以用上 phantomjs 软件了。phantomjs 是一个基于 webkit 引擎做的 js 脚本库。可以通过 js 程序操作 webkit 浏览器引擎，实现各种浏览器功能。&lt;/p&gt;
&lt;p&gt;因为用了 webkit ，所以软件编译起来挺麻烦的，建议是直接从官方下载二进制包用得了。&lt;/p&gt;
&lt;p&gt;想要给 kibana 页面截图，几行代码就够了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;webpage&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;http://kibana.dip.sina.com.cn/#/dashboard/elasticsearch/h5_view&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;kibana.png&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;viewportSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1366&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;600&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;success&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Unable to load the address!&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;phantom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;phantom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里两个要点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;要设置 &lt;code&gt;viewportSize&lt;/code&gt; 里的宽度，否则效果会变成单个 panel 依次往下排列。&lt;/li&gt;
  &lt;li&gt;要设置 &lt;code&gt;setTimeout&lt;/code&gt;，否则在获取完 index.html 后就直接返回了，只能看到一个大白板。用 phantomjs 截取 angularjs 这类单页 MVC 框架应用时一定要设置这个。&lt;/li&gt;
&lt;/ol&gt;
    &lt;hr&gt;
    
    &lt;hr&gt;
  &lt;!-- JiaThis Button BEGIN --&gt;
&lt;div class=&quot;jiathis_style&quot;&gt;
&lt;span class=&quot;jiathis_txt&quot;&gt;分享到：&lt;/span&gt;
&lt;a class=&quot;jiathis_button_tsina&quot;&gt;新浪微博&lt;/a&gt;
&lt;a class=&quot;jiathis_button_weixin&quot;&gt;微信&lt;/a&gt;
&lt;a class=&quot;jiathis_button_renren&quot;&gt;人人网&lt;/a&gt;
&lt;a class=&quot;jiathis_button_ydnote&quot;&gt;有道云笔记&lt;/a&gt;
&lt;a class=&quot;jiathis_button_gmail&quot;&gt;Gmail邮箱&lt;/a&gt;
&lt;a class=&quot;jiathis_button_twitter&quot;&gt;Twitter&lt;/a&gt;
&lt;a class=&quot;jiathis_button_googleplus&quot;&gt;Google+&lt;/a&gt;
&lt;a class=&quot;jiathis_button_hi&quot;&gt;百度空间&lt;/a&gt;
&lt;a class=&quot;jiathis_button_fb&quot;&gt;Facebook&lt;/a&gt;
&lt;a class=&quot;jiathis_button_douban&quot;&gt;豆瓣&lt;/a&gt;
&lt;a href=&quot;http://www.jiathis.com/share?uid=1589850&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;更多&lt;/a&gt;
&lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var jiathis_config={
	data_track_clickback:true,
	summary:&quot;&quot;,
	ralateuid:{
		&quot;tsina&quot;:&quot;1035836154&quot;
	},
	shortUrl:false,
	hideMore:false
}
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://v3.jiathis.com/code/jia.js?uid=1589850&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;!-- JiaThis Button END --&gt;
&lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;
  &lt;/div&gt;

</description>
        <pubDate>Thu, 20 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-20-phantomjs-snapshot-63b00217f.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-20-phantomjs-snapshot-63b00217f.html</guid>
        
        
        <category>chenlinux</category>
        
      </item>
    
      <item>
        <title>计算机算法：数据压缩之相对编码（4）</title>
        <description>
&lt;p&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 28px; font-style: normal; font-weight: bold; line-height: 42px;&quot;&gt;概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;相对编码是另一种数据压缩算法。&lt;a href=&quot;http://blog.jobbole.com/79758/&quot; target=&quot;_blank&quot;&gt;游程编码&lt;/a&gt;、&lt;a href=&quot;http://blog.jobbole.com/79760/&quot; target=&quot;_blank&quot;&gt;位图编码&lt;/a&gt;以及&lt;a href=&quot;http://blog.jobbole.com/79952/&quot; target=&quot;_blank&quot;&gt;图编码和模式替换&lt;/a&gt;都基于减少重复数据实现，而相对编码目标略有不同。的确，游程编码要查找连续重复出现的元素，模式替换和位图编码要“映射”重复出现的位置。&lt;/p&gt;
&lt;p&gt;这些算法的唯一问题在于输入数据并非总是由重复元素组成。很明显，如果输入数据流包含许多重复元素，必定能减少。然而，这并不意味着没有重复元素的数据就不能压缩。这取决于数据。假设我们要压缩的数据如下。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;1, 2, 3, 4, 5, 6, 7&lt;/pre&gt;
&lt;p&gt;难以想象这个数据流能被压缩。压缩字母时可能存在同样的问题。的确，字母是构成单词的基础，是构成单词的最小单元而且很难再压缩。&lt;/p&gt;
&lt;p&gt;幸运的是，事实并非如此。相对编码可以处理非重复数据。让我们看看下面的输入流——一段给定的年份（90年的）。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;1991,1991,1999,1998,1991,1993,1992,1992&lt;/pre&gt;
&lt;p&gt;这里有39个字符，我们能够压缩它们。我们通常使用的方法是去掉前面的“19”。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;91,91,99,98,91,93,92,92&lt;/pre&gt;
&lt;p&gt;现在我们得到一个更短的字符串，但在保留第一个年份的基础上可以更进一步的压缩。其余的年份均相对于该年份。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;91,0,8,7,0,2,1,1&lt;/pre&gt;
&lt;p&gt;此时传输的数据量减少了很多（从39降至16——超过50%）。然而，我们首先需要考虑一些问题，因为数据流的格式不会总是如此巧合。下面字符流会怎样？&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;91,94,95,95,98,100,101,102,105,110&lt;/pre&gt;
&lt;p&gt;我们看到数值100在区间的中间，使用该值作为相对编码的基准很方便。那么上面的数据流就变成如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;-9,-6,-5,-5,-2,100,1,2,5,10&lt;/pre&gt;
&lt;p&gt;问题在于决定哪一个数值作为基准值并不容易。如果数据以不同方式排列会怎样。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;96,97,98,99,100,101,102,103,999,1000,1001,1002&lt;/pre&gt;
&lt;p&gt;此时，数值“100”不能作为基准值，因为以该值为基准将得到如下结果：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;-4,-3,-2,-1,100,1,2,3,899,900,901,902&lt;/pre&gt;
&lt;p&gt;对某基准值附近的相对值分组将会更加方便。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;(-4,-3,-2,-1,100,1,2,3)(-1,1000,1,2)&lt;/pre&gt;
&lt;p&gt;然而，找出基准值并不那么容易。编码格式也并不那么重要。但是下面提到的这种情况，这种编码却很有用。&lt;/p&gt;
&lt;h1&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 28px; font-style: normal; font-weight: bold; line-height: 42px;&quot;&gt;实现&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;该算法的实现取决于特定的任务和数据流格式。假设我们要使用JSON从web服务器传输年份数据流到浏览器，下面是一段简单的PHP片段。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;// JSON: [1991,1991,1999,1998,1999,1998,1995,1997,1994,1993]
$years = array(1991,1991,1999,1998,1999,1998,1995,1997,1994,1993);

function relative_encoding($input)
{
       $output = array();
       $inputLength = count($input);

       $base = $input[0];

       $output[] = $base;

       for ($i = 1; $i &amp;lt; $inputLength; $i++) {
               $output[] = $input[$i] - $base;
       }

       return $output;
}

// JSON: [1991,0,8,7,8,7,4,6,3,2]
echo json_encode(relative_encoding($years));&lt;/pre&gt;
&lt;h1&gt;应用&lt;/h1&gt;
&lt;p&gt;该算法在很多情况都很有效，以下是其中一例。网络上有很多地图应用。例如&lt;a href=&quot;http://maps.google.com/&quot;&gt;谷歌地图&lt;/a&gt;，&lt;a href=&quot;http://maps.yahoo.com/&quot;&gt;雅虎地图&lt;/a&gt;，&lt;a href=&quot;http://www.bing.com/maps/&quot;&gt;必应地图&lt;/a&gt;就是非常有名的应用，同时也有非常有用的开源项目&lt;a href=&quot;http://www.openstreetmap.org/&quot;&gt;OpenStreetMap&lt;/a&gt;。成千上万的网站使用这些应用。&lt;/p&gt;
&lt;p&gt;典型的使用案例是使用JSON从服务器传输大量地理坐标到浏览器。的确，地球上任何地理坐标点都相对于非洲西海岸附近的（0,0）点而言，在一定范围内，当有大量标记时，我们可以使用相对编码来传输信息。&lt;/p&gt;
&lt;p&gt;例如，下图为标识了一些点的旧金山地图。它们的坐标都是相对于地球的（0,0）点而言。&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/3fad8a15b90e48d724e1bb8036fefbda.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;地图标记相对于地球的（0,0）点而言，有时没什么效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;更加有效方式是相对市中心对那些标记进行编码，这样可以节省空间。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/c19fa5a1a690d2a4f79e6929703d618a.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;在一定范围内对地图标记使用相对编码非常有效！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然而，这种压缩类型可能会非常棘手，比如拖动地图和更新坐标数组时。此外，如果需要加载多个城市，我们必须对坐标进行分组。所以，在实现时必须谨慎。但另一方面，这也会很有用——例如在初始化加载地图时可以减少数据量，缩短加载时间。&lt;/p&gt;
&lt;p&gt;使用相对编码，我们只要保存相对基准值（数据）的偏移量——就像版本控制系统一样，这样可以降低传输和加载的数据。这里有一个图形的例子。第一种情况下，我们看到以下图标中的每一项都是单独保存。它与相邻元素无关，可以独立与其他元素存在。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/92bd70c5fdd5339a160b1c40eb0a84ee.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们能只保存第一个元素，其余元素都相对与该元素，如下图标所示。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0911a3a6c537f407a0dd5814589baa3b.jpg&quot;&gt;&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Thu, 20 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-20-79761-28f044a97.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-20-79761-28f044a97.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>计算机算法：数据压缩之前缀编码（5）</title>
        <description>

        &lt;div style=&quot;margin-bottom: 10px;&quot;&gt;
            
        &lt;/div&gt;

		
&lt;p&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 28px; font-style: normal; font-weight: bold; line-height: 42px;&quot;&gt;概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前缀编码，有时也被称为前向编码，是另一个通过移除冗余数据来降低数据量的算法。思想非常简单，但算法实现比较困难。要了解原因，首先我们来看一看它的原理。&lt;/p&gt;
&lt;p&gt;请看下面的字典。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;use
used
useful
usefully
usefulness
useless
uselessly
uselessness&lt;/pre&gt;
&lt;p&gt;为了不使用纯文本保存这些单词或者在网络上传输，我们可以用前缀编码进行压缩（编码）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9130b42244a4abbf7fda5aad945efbe9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;很明显，每一个单词都以表中的第一个单词“use”为前缀。所以我们很容易将它们压缩成下面的数组。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$data = array(
0 =&amp;gt; &#39;use&#39;,
1 =&amp;gt; &#39;0d&#39;,
2 =&amp;gt; &#39;0ful&#39;,
3 =&amp;gt; &#39;0fully&#39;,
4 =&amp;gt; &#39;0less&#39;,
5 =&amp;gt; &#39;0lessly&#39;,
6 =&amp;gt; &#39;0lessness&#39;,
);&lt;/pre&gt;
&lt;p&gt;显然这并不是最佳的压缩结果，在不仅仅使用第一个词作为前缀的情况下，我们可以更进一步压缩。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$data = array(
0 =&amp;gt; &#39;use&#39;,
1 =&amp;gt; &#39;0d&#39;,
2 =&amp;gt; &#39;0ful&#39;,
3 =&amp;gt; &#39;2ly&#39;,
4 =&amp;gt; &#39;0less&#39;,
5 =&amp;gt; &#39;4ly&#39;,
6 =&amp;gt; &#39;4ness&#39;,
);&lt;/pre&gt;
&lt;p&gt;此时的压缩更好，好消息是解码是一个相对简单的过程。但棘手的部分在于压缩本身。问题是选择合适的前缀非常困难。第一个例程的前缀选择很简单，但事实上，大多时候数据很混乱。的确，对于随机产生的数据压缩过程将非常困难，算法过程不仅很慢，而且难以实现。&lt;/p&gt;
&lt;p&gt;好的方面是，如果我们事先知道数据的格式，该算法可以用于多种情况。那么，让我们看看下面三个例子，该算法可能会很方便。&lt;/p&gt;
&lt;h1&gt;应用&lt;/h1&gt;
&lt;p&gt;以下是三个前缀编码的例子。前面我说随机数据的压缩过程会很难，如果你事先知道输入数据的格式，这将会是一个很好的练习。&lt;/p&gt;
&lt;h2&gt;日期和时间前缀&lt;/h2&gt;
&lt;p&gt;我们通常会忽略年份的前两个数字，例如我们通常不会写1995或1996，而是使用更短的——‘95’和‘96’。这样年份就被编码成更短的字符串。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;input: (1991, 1992, 1993, 1994, 1995, 1996)
output: (91, 92, 93, 94, 95, 96)&lt;/pre&gt;
&lt;p&gt;问题在于输入流发生很小的变动，解码就会出错。如果我们加上21世纪的年份，我们将失去数据的唯一性。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;input: (1998, 1992, 1999, 2011, 2012)
output: (98, 92, 99, 11, 12)&lt;/pre&gt;
&lt;p&gt;此时，解码器肯会将最后两个数值解码成(1911, 1912)，因为“19”被认为是前缀。所以，我们事先必须知道前缀与每一个数值绝对平等。如果没有编码格式，必须不同。例如我们可以使用一些特殊标识和前缀一起编码。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;input: (1998, 1992, 1932, 1924, 2001, 2012)
output: (#19, 98, 92, 32, 24, #20, 01, 12)&lt;/pre&gt;
&lt;p&gt;一旦解码器读到#字符，它就知道下面的数为前缀。&lt;/p&gt;
&lt;p&gt;事实上，这种方法可用于日期和时间格式的编码。假设我们有一些日期时间值，而且我们知道所有数据都是在同一天。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;2012-01-31 15:33:45
2012-01-31 16:12:11
2012-01-31 17:32:35
2012-01-31 18:54:34&lt;/pre&gt;
&lt;p&gt;显然，我们可以忽略这些字符串的时间部分，仅发送（保存）时间。当然，我们必须确定所有的这些数值都是在同一天。如果不是，我们可以使用上例中的方法。&lt;/p&gt;
&lt;h2&gt;电话号码&lt;/h2&gt;
&lt;p&gt;电话号码是前缀编码的典型应用。不仅仅是国际代码，移动网络运营商的电话号码也使用前缀编码。如果我们要传输电话号码，假设是英国的，我们可以用一些更短的东西替换开头的“+44”。&lt;/p&gt;
&lt;p&gt;如果你要给移动设备编写电话簿，你可以通过前缀编码压缩数据，节省部分空间，这样用户将拥有更多空间，也可以在手机上存储更多电话号码。&lt;/p&gt;
&lt;p&gt;电话号码前缀也适用于数据库标准化。这样你可以将它们存储在单独的数据库表中，不用电话簿中唯一的号码。&lt;/p&gt;
&lt;h2&gt;地理坐标&lt;/h2&gt;
&lt;p&gt;对于我之前帖子中使用的例子，可以在一定范围内去掉通用前缀来发送地理坐标。的确，在必须传送大量坐标到地图应用时，你可以预期这些标记在一定范围内彼此间相当靠近。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/cedae08dc44c077d2df50b7782b0b954.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;在一定范围内，可以预期这些标记都有相同的前缀。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;那些点的坐标有共同的前缀，就像下面地铁站的例子一样。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;LatLon(40.762959,-73.985989)
LatLon(40.761886,-73.983629)
LatLon(40.762861,-73.981612)
LatLon(40.764616,-73.98056)&lt;/pre&gt;
&lt;p&gt;我们可以发现所有的地理坐标点有相同的前缀(40.76x, -73.98x)，所以我们只需要发送一次前缀。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;Prefix: (40.76, -73.98)
Data: 
LatLon(2959,5989)
LatLon(1886,3629)
LatLon(2861,1612)
LatLon(4616,056)&lt;/pre&gt;
&lt;p&gt;以上是前缀编码的三个例子，该算法在传输均匀数据是非常有用。&lt;/p&gt;
&lt;h1&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 28px; font-style: normal; font-weight: bold; line-height: 42px;&quot;&gt;后缀编码&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;后缀编码和前缀编码几乎相同，区别在于编码重复后缀。如下例，后缀编码替换最后重复的后缀，这非常有用。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;Johnson
Clarkson
Jackson&lt;/pre&gt;
&lt;p&gt;或者公司名称。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;Apple Inc.
Google Inc.
Yahoo! Inc.&lt;/pre&gt;
&lt;p&gt;这里我们可以使用一些其他更短的东西来替换“Inc”。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Thu, 20 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-20-79757-c5acf18ef.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-20-79757-c5acf18ef.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>在 kibana 里实现去重计数</title>
        <description>

  
  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;如何在 elk 里统计或者展示去重计数，是一个持续很久的需求了。几乎每个月都会有新手提问题说：“我怎么在 kibana 里统计网站 UV 啊？”可惜这个问题的回答总是：做不到……&lt;/p&gt;
&lt;p&gt;其实 Elasticsearch 从 1.1.0 版本开始已经可以做到&lt;a href=&quot;http://www.elasticsearch.org/blog/count-elasticsearch/&quot;&gt;去重统计&lt;/a&gt;了。但是 kibana3 本身是在 0.90 版本基础上实现的，所以也就没办法了。&lt;/p&gt;
&lt;p&gt;今天抽出时间，把 histogram 面板的代码重写了一遍，用 aggregations 接口替换了 facets 接口。改造完成后，再加上去重就很容易了。&lt;/p&gt;
&lt;p&gt;aggregations 接口最大的特点是层级关系。不过也不是可以完全随便嵌套的，原先 date_histogram facets 里的 global 参数，被拆分成了 global aggregation，但是这个 global aggregation 就强制要求必须用在顶层。所以最后 request 相关代码就变成了这个样子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;aggr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ejs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;DateHistogramAggregation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;panel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;count&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;aggr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;aggr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;panel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;time_field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;panel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;uniq&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;aggr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;aggr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;panel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;time_field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;agg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ejs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;CardinalityAggregation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;panel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value_field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;aggr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;aggr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;panel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;time_field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;agg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ejs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;StatsAggregation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;panel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value_field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;agg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ejs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;GlobalAggregation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;agg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ejs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FilterAggregation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ejs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;QueryFilter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;agg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;aggr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;panel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;panel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的代码已经提交到 github，见 &lt;a href=&quot;https://github.com/chenryn/kibana-authorization/commit/6cb4d28a6c610d28680fffdb81c9f6c83cfaf488&quot;&gt;https://github.com/chenryn/kibana-authorization/commit/6cb4d28a6c610d28680fffdb81c9f6c83cfaf488&lt;/a&gt;&lt;/p&gt;
    &lt;hr&gt;
    
    &lt;hr&gt;
  &lt;!-- JiaThis Button BEGIN --&gt;
&lt;div class=&quot;jiathis_style&quot;&gt;
&lt;span class=&quot;jiathis_txt&quot;&gt;分享到：&lt;/span&gt;
&lt;a class=&quot;jiathis_button_tsina&quot;&gt;新浪微博&lt;/a&gt;
&lt;a class=&quot;jiathis_button_weixin&quot;&gt;微信&lt;/a&gt;
&lt;a class=&quot;jiathis_button_renren&quot;&gt;人人网&lt;/a&gt;
&lt;a class=&quot;jiathis_button_ydnote&quot;&gt;有道云笔记&lt;/a&gt;
&lt;a class=&quot;jiathis_button_gmail&quot;&gt;Gmail邮箱&lt;/a&gt;
&lt;a class=&quot;jiathis_button_twitter&quot;&gt;Twitter&lt;/a&gt;
&lt;a class=&quot;jiathis_button_googleplus&quot;&gt;Google+&lt;/a&gt;
&lt;a class=&quot;jiathis_button_hi&quot;&gt;百度空间&lt;/a&gt;
&lt;a class=&quot;jiathis_button_fb&quot;&gt;Facebook&lt;/a&gt;
&lt;a class=&quot;jiathis_button_douban&quot;&gt;豆瓣&lt;/a&gt;
&lt;a href=&quot;http://www.jiathis.com/share?uid=1589850&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;更多&lt;/a&gt;
&lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var jiathis_config={
	data_track_clickback:true,
	summary:&quot;&quot;,
	ralateuid:{
		&quot;tsina&quot;:&quot;1035836154&quot;
	},
	shortUrl:false,
	hideMore:false
}
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://v3.jiathis.com/code/jia.js?uid=1589850&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;!-- JiaThis Button END --&gt;
&lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;
  &lt;/div&gt;

</description>
        <pubDate>Wed, 19 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-19-uniq-count-kibana-fb4d0c203.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-19-uniq-count-kibana-fb4d0c203.html</guid>
        
        
        <category>chenlinux</category>
        
      </item>
    
      <item>
        <title>计算机算法：数据压缩之图编码和模式替换（3）</title>
        <description>

&lt;p&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;概述&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;http://blog.jobbole.com/79758/&quot; target=&quot;_blank&quot;&gt;游程编码有两种变形&lt;/a&gt;，分别是“图编码”和“模式替换算法”。图编码是一种非常简单的算法，它不像游程编码那样必须要求输入字符串中必须含有很多重复的元素，比如&lt;em&gt;“aaaaaa”&lt;/em&gt;。这些情况在自然语言中很少出现，但是被称之为“图”的字符串几乎会出现在所有自然语言中。日常英语中就有些图，例如&lt;em&gt;“the”&lt;/em&gt;，&lt;em&gt;“and”&lt;/em&gt;，&lt;em&gt;“ing”&lt;/em&gt;（例如在&lt;em&gt;“waiting”&lt;/em&gt;中），&lt;em&gt;“aa”&lt;/em&gt;，&lt;em&gt;“tt”&lt;/em&gt;，&lt;em&gt;“ee”&lt;/em&gt;这些双字母。事实上我们可以通过添加字符串两边的空格来扩展这些图。这样我们可以不编码&lt;em&gt;“the”，&lt;/em&gt;而编码&lt;em&gt;“ the ”&lt;/em&gt;，就可以编码5个字符了（3个字符，2个空格），从而获得更好的压缩率。另一方面，在日常英语中有很多包含双字母的字符串，而这些情况在游程编码中并不能有效地被压缩，这样导致压缩效率非常低。有时候会有更加糟糕的情况出现，压缩后的长度比原来的长度还要长。我们看一些例子：&lt;/p&gt;
&lt;p&gt;我们谈一谈怎么编码这个包含了四对双字母的字符串“successfully accomplished”。很不幸，如果用游程编码的话，压缩这四对双字母至少需要八个字符，这意味着对压缩数据来说没有任何帮助。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;// 八个字母还是被八个字母替换了!?
压缩编码前：&quot;successfully accomplished&quot;
压缩编码后：&quot;su2ce2sfu2ly a2complished&quot;&lt;/pre&gt;
&lt;p&gt;这里有个问题，如果原本的输入字符串中含有数字的话，比如&lt;em&gt;“2”&lt;/em&gt;，那么我们必须指定一个字符（比如&lt;em&gt;“@”&lt;/em&gt;）用来描述我们编码替换开始的位置。那么如果输入的字符串为&lt;em&gt;“2 successfully accomplished tasks”&lt;/em&gt;，压缩之后就变为“&lt;em&gt;2 su@2ce@2sfu@2ly a@2complished tasks”&lt;/em&gt;，这时候输出的字符串比输入的字符串还要长！&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;// 压缩后的信息比压缩之前的还要长！！！
压缩编码前：&quot;2 successfully accomplished&quot;
压缩编码后：&quot;2 su@2ce@2sfu@2ly a@2complished tasks&quot;&lt;/pre&gt;
&lt;p&gt;如果输入的字符串中包含转义字符，我们必须找到另一个，然后问题就来了：若不进行全局查找，我们就很难找到另外一个出现在输入字符串中的转义字符。&lt;/p&gt;
&lt;p&gt;游程编码在压缩纯文本的时候并不是一个好的解决方案，因为长的重复情况（&lt;em&gt;“aaaaa”&lt;/em&gt;）出现频率太小了。当然，在失真压缩的时候是一个特例。很明显，当你要求解压出来的文本需要是完全一致的时候，失真压缩文本并没有很大用处。但是有时候失真压缩可能有用，比如在我们要去除空格的情况中。字符串&lt;em&gt;“&lt;strong&gt;successfully&lt;/strong&gt;           &lt;strong&gt;accomplished&lt;/strong&gt;”&lt;/em&gt;表达的意思和&lt;em&gt;“&lt;strong&gt;successfully accomplished&lt;/strong&gt;”&lt;/em&gt;确实完全相同。在这种情况下，我们能够很简单地去除那些空格。我们可以像这样用一个标记去代替一长串的空格：&lt;em&gt;“&lt;strong&gt;successfully@6 accomplished&lt;/strong&gt;”&lt;/em&gt;，这样可以使输入字符串完全没有损失，但是我们也有另一种选择，可以直接把那些空格直接扔掉。这个选择取决于我们的目的是什么，只有当我们很确定删除换行标记符和制表标记符能够完全保证表达出相同的意思时，才能下决定扔掉那些空格。但是话又说回来，现实中出现这种问题的情况也是少数，所以对纯文本压缩选择图压缩方法比游程编码更好。&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;在理解了图编码的基本规则之后，让我们看一些例子。在上面的例子中，最好的替代双字母的方法是，用“#”符号替代“cc”，用“@”替代“ss”，用“%”替代“ll”。这样的话输入字符串就可以表示为“su#e@fu%y a#omplished”，这样就可以比输入字符串短了。但是如果输入字符串中包含“# @ %”这些符号怎么办呢？而且我们也不能确定的说在输入字符串中有足够多的双字母让我们有理由去替换它们。一个更好的方式是模式替换。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/191cb637eefd2d38c88b5de67b8ddd80.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;游程编码对普通文本压缩并不是一个好的方法，因为长重复很少在自然语言中出现。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;模式替换&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;模式替换算法是图编码的一种变形。我在上面说过，在日常英语中&lt;em&gt;“ the ”&lt;/em&gt;这种单词会经常出现。我们现在可以把它替换为类似于&lt;em&gt;“$%”&lt;/em&gt;这样的字符。如果输入字符串是&lt;em&gt;“&lt;strong&gt;I send the message&lt;/strong&gt;”&lt;/em&gt;，那么压缩之后变成了&lt;em&gt;“&lt;strong&gt;I send$%message&lt;/strong&gt;”&lt;/em&gt;。但是这种方法也有一些缺陷。&lt;/p&gt;
&lt;p&gt;第一个问题是我们需要知道了解将要被压缩的这门语言，而且我们要定义出来哪些模式是经常被使用的。如果一条信息用我们完全不懂的语言写的。比如下面的拉丁文：&lt;/p&gt;
&lt;p style=&quot;padding-left: 30px;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras venenatis, sapien eget suscipit placerat, justo quam blandit mauris, quis tempor ante sapien sodales augue. Praesent ut mauris quam. Phasellus scelerisque, ante quis consequat tristique, metus turpis consectetur leo, vitae facilisis sapien mi eu sapien. Praesent vitae ligula elit, et faucibus augue. Sed rhoncus sodales dolor ut gravida. In quis augue ac nulla auctor mattis sed sed libero. Donec eget purus eget enim tempor porta vitae eget diam. Mauris aliquet malesuada ipsum, non pulvinar urna vestibulum ac. Donec feugiat velit vitae nunc cursus imperdiet. Donec accumsan faucibus dictum. Phasellus sed mauris sapien. Maecenas mi metus, tincidunt sed rhoncus nec, sodales non sapien.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很明显，如果我们不懂拉丁文，那么定义出来一个常用模式会十分困难。所以如果我们事先知道一些单词或者字母的话，会让我们更方便运用模式替换。&lt;/p&gt;
&lt;p&gt;第二个问题是关于解压缩。我们需要构造一个用来解压缩的字典。如果我们能够找到比三个字母长的模式会非常好。但是如果找不到，那么压缩率会比较低。而不幸的是，这种长的（3个字符以及3个以上的）模式在自然语言中很少出现。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e6fb413aabd037fd44f90ce2d812e2dc.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #888888;&quot;&gt;在压缩纯文本的情况下，图编码和模式替换都要优于游程编码。而且，模式替换在压缩编程语言的情况下十分高效。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;应用&lt;/h2&gt;
&lt;p&gt;一个很有趣的问题是，怎么使用图编码和模式替换算法压缩纯文本，特别是当我们不太了解被压缩文本使用的语言时。答案其实就在问题中，我们可以不压缩自然语言，转而压缩编程语言。因为编程语言限制了一个有限的小单词和符号集合。它几乎对任何编程语言都适用。比如PHP，&lt;em&gt;“function”&lt;/em&gt;，&lt;em&gt;“while”&lt;/em&gt;，&lt;em&gt;“for”&lt;/em&gt;，&lt;em&gt;“break”&lt;/em&gt;，&lt;em&gt;“switch”&lt;/em&gt;，&lt;em&gt;“foreach”&lt;/em&gt;都是经常用的，或者在&lt;em&gt;HTML&lt;/em&gt;中，有很多常用的标签。也许最好的例子是&lt;em&gt;CSS&lt;/em&gt;，在&lt;em&gt;CSS&lt;/em&gt;中只有属性值能够变化。&lt;em&gt;CSS&lt;/em&gt;文件中也经常有很多为了提高可读性的换行符，制表符以及空格。&lt;/p&gt;
&lt;p&gt;这里就有一个问题，很明显压缩之后的文件对程序员和计算机来说都完全不能发挥作用了，那么为什么我们要压缩这些文件呢。确实是这样，但是如果我们要把不同版本的文件存入数据库作为备份呢。想象一下你正在为一个网站托管公司工作，每天要存储大量托管网站的备份文件。即使只是一个小的网站托管网站上面只有少量的托管网站，那备份文件也是一个惊人的数量。用一个简易压缩工具压缩那些文件显然不是一个好主意。我们每天都必须要备份整个网站，但是我们知道每天网站的版本更新的地方非常少。版本控制系统是一个解决方案，但是你必须去存储那些纯文本文件。&lt;/p&gt;
&lt;p&gt;也许一个好方法是运用相对编码：用模式替换去压缩这些文本，而且只记录变化更新的部分——类似于版本控制。&lt;/p&gt;
&lt;p&gt;运用上面的方法我们能够节省很多磁盘空间，而且我们能够很方便进行压缩和解压缩。另外一个好处是你可以类似于版本控制把所有的更改保存到原始的文件中，而这个文件也可以被压缩。&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 24px; font-style: normal; font-weight: bold; line-height: 36px;&quot;&gt;实现&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这个算法的实现也是基于&lt;em&gt;PHP&lt;/em&gt;，希望能够描述这个压缩算法的主要思想，在这个例子中我试图利用上面的压缩方法压缩一个&lt;em&gt;CSS&lt;/em&gt;文件。虽然这个例子非常简单，但是我们仍然能看到很多有趣的地方。首先你只需要一个压缩和解压缩的字典。在实际中这个压缩过程和解压缩过程是相同的，所以你不需要去写两个不同的函数。在这里用了一个原生的PHP函数&lt;em&gt;“str_replace”&lt;/em&gt;&lt;a title=&quot;&quot; href=&quot;/%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6/%E4%BC%AF%E4%B9%90%E5%9C%A8%E7%BA%BF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%92%8C%E6%A8%A1%E5%BC%8F%E6%9B%BF%E6%8D%A2.docx#_ftn1&quot;&gt;[1]&lt;/a&gt;，因为这个算法的目的不是介绍实现模式替换的技术细节，而是描述模式替换的思想。所以我们假定编程语言有操作字符串的特定函数。&lt;/p&gt;
&lt;div&gt;
&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;&gt;
&lt;div&gt;
&lt;p&gt;&lt;a title=&quot;&quot; href=&quot;/%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6/%E4%BC%AF%E4%B9%90%E5%9C%A8%E7%BA%BF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%92%8C%E6%A8%A1%E5%BC%8F%E6%9B%BF%E6%8D%A2.docx#_ftnref1&quot;&gt;[1]&lt;/a&gt; 函数原型：m&lt;em&gt;ixed str_replace(mixed $search, mixed $replace, mixed $subject [, int $count])&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;功能：所有在&lt;em&gt;subject&lt;/em&gt;中出现的&lt;em&gt;search&lt;/em&gt;字符串替换成&lt;em&gt;replace&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: php; gutter: true&quot;&gt;$str = file_get_contents(&#39;large_style_file.css&#39;);

$encoding_dict = array(
	&quot;n&quot; 		=&amp;gt; &#39;$0&#39;,
	&#39;text&#39; 		=&amp;gt; &#39;$1&#39;,
	&#39;color&#39; 	=&amp;gt; &#39;$2&#39;,
	&#39;display&#39; 	=&amp;gt; &#39;$3&#39;,
	&#39;font&#39; 		=&amp;gt; &#39;$4&#39;,
	&#39;width&#39; 	=&amp;gt; &#39;$5&#39;,
	&#39;height&#39;	=&amp;gt; &#39;$6&#39;,	
	&#39; &#39;		=&amp;gt; &#39;&#39;,
);

function replace_patterns($input, $dict) 
{
	foreach ($dict as $pattern =&amp;gt; $replace) {
		$input = str_replace($pattern, $replace, $input);
	}

	return $input;
}

$result = replace_patterns($str, $encoding_dict);&lt;/pre&gt;
&lt;p&gt;我仅仅替换了少数几个&lt;em&gt;CSS&lt;/em&gt;的属性，但是我就已经得到了40%的压缩率（见下图）！初始文件大小为202KB，但是压缩之后只有131KB（当然它主要是依赖了&lt;em&gt;CSS&lt;/em&gt;文件的特性）。如果我把所有属性都替换成短字符呢。那样的压缩率将会更高。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Wed, 19 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-19-79952-fafd494bc.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-19-79952-fafd494bc.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>UDP有多不可靠？</title>
        <description>

&lt;p style=&quot;text-align: left;&quot; align=&quot;center&quot;&gt;最近我意识到了一件事：我实际上对UDP一无所知。好吧，我知道它是无连接的，没有三次握手过程，所以它对传输的质量不作任何保证。但是，在实际工程应用时，UDP的这些特征意味什么呢？&lt;/p&gt;
&lt;p&gt;我启用了5个VPS（虚拟专用服务器，译者注），在7个小时相互发送UDP包，不过网络负载并不大（不过可以尝试下加大负载的情况）。每台服务器，每9-11秒就会随机地接收一个包并且发送5-10个包，包的大小从16到1016字节不等。&lt;/p&gt;
&lt;p&gt;其中两个服务器位于新泽西州（NJ）的同一个数据中心，其余三台分别位于洛杉矶（LA）、阿姆斯特丹（NLD）和东京（JPN）。&lt;/p&gt;
&lt;h2&gt;可靠性分析&lt;b&gt;&lt;/b&gt;
&lt;/h2&gt;
&lt;p&gt;我想知道的第一件事是UDP到底有多不可靠。看到下表，我很好奇，我们是在讨论25%，50%，75%的传送率吗？&lt;/p&gt;
&lt;p&gt;包的接收数目&lt;/p&gt;
&lt;table width=&quot;687&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt; &lt;/td&gt;
&lt;td colspan=&quot;5&quot; width=&quot;473&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt; &lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2981/2981&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2888/2889&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2964/2964&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3053/3054&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3016/3016&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3100/3101&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2734/2735&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3054/3054&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2901/2941&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2932/2975&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2938/2942&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2712/2712&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3038/3038&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2771/2772&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2724/2724&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2791/2791&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2551/2552&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2886/2886&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2836/2838&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2887/2887&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;包的接收率&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt; &lt;/td&gt;
&lt;td colspan=&quot;5&quot; width=&quot;473&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt; &lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;99.97&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;99.97&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;99.97&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;99.97&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;98.64&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;98.55&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;99.86&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;99.97&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;99.96&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些数据远超过我的预期。我原以为从NLD—JPN一线会有明显超出均值的丢包，但是事实并不是这样的。反而是从LA发出、传送到NJ的数据有些异常。原因何在？&lt;/p&gt;
&lt;p&gt;首先，我将原因锁定在包的大小。我会使包尽量小（16字节的头，0-1000字节的有效数据）：&lt;/p&gt;
&lt;p&gt;每种大小的包的丢失个数&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;114&quot;&gt;0-115&lt;/td&gt;
&lt;td width=&quot;114&quot;&gt;116-215&lt;/td&gt;
&lt;td width=&quot;114&quot;&gt;216-315&lt;/td&gt;
&lt;td width=&quot;114&quot;&gt;316-515&lt;/td&gt;
&lt;td width=&quot;114&quot;&gt;516-715&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;114&quot;&gt;13&lt;/td&gt;
&lt;td width=&quot;114&quot;&gt;11&lt;/td&gt;
&lt;td width=&quot;114&quot;&gt;12&lt;/td&gt;
&lt;td width=&quot;114&quot;&gt;13&lt;/td&gt;
&lt;td width=&quot;114&quot;&gt;23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;没有什么异常。那么，这些包丢失的时间如何分布呢？&lt;/p&gt;
&lt;p&gt;不幸的是，我没有保存时间戳啊（Why？！），但是我统计了每一对服务器间丢包时间分布。从LA到NJ2的丢失的所有的43个包中，其中29个包在第1-2分钟内丢失。NJ1的包也大部分在刚开始很短的时间内丢失。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;排队&lt;b&gt;&lt;/b&gt;
&lt;/h2&gt;
&lt;p&gt;我关注的另一个点是排队。&lt;/p&gt;
&lt;p&gt;为了探讨这个问题，我们首先要讨论下数组的逆序数。逆序数就是数组中位置顺序与大小顺序相反的一对数。假设现有一个数组10,8,3,7,4，那么你必须要调换8次才能达到正确的顺序，这8次分别是：（（10,8），（10,3），（10,7），（10,4），（8,3），（8,7），（8,4），（7,4））。&lt;/p&gt;
&lt;p&gt;逆序数&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt; &lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;0&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2994&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2581&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;4658&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;0&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3147&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2459&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;4645&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3980&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3861&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3237&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;4010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3125&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1826&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3133&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;4189&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3920&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;4417&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;4147&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;4425&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;不知道你觉得怎样，我不确定这组数据是否有价值。这确实看上去很高，当然，使用UDP的一个很重要的原因是你可以丢弃掉某些包。如果你发送了10000个包，最后一个包先来，之前的9999个包之后才依次到来，那么你就不需要做9999次调换了，直接把那第1个包丢掉即可。&lt;/p&gt;
&lt;p&gt;如果我们把比已经处理过的包的号码小的包丢弃会怎样？比如，现在有5个包来了，1,5,4,3，6,7，由于我们已经处理过了5，所以把3和4给丢弃了。那么还剩下几个“good”的包呢？&lt;/p&gt;
&lt;p&gt;正常顺序的包的数目&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt; &lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;52.40&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;55.94&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;36.77&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;52.47&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;54.22&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;38.02&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;41.72&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;42.32&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;50.48&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;39.34&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;46.32&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;59.34&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;44.79&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;39.27&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;980&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1083&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1141&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1087&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;正常顺序的包的比率&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt; &lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;52.40&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;55.94&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;36.77&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;52.47&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;54.22&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;38.02&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;41.72&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;42.32&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;50.48&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;39.34&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;46.32&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;59.34&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;44.79&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;39.27&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;38.40&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;37.53&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;40.20&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;37.65&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;做一个小小的调整，如果我们将5个包整合到一起，再次使用上面的丢弃算法：&lt;/p&gt;
&lt;p&gt;正常顺序的包的数目（包整合之后）：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt; &lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2981&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2061&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2235&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1807&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;3016&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2214&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2041&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1889&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1868&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1873&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2066&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1720&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2200&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;2273&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1920&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1712&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;60.38&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;62.51&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;61.13&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;59.99&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;正常顺序的包的比率（包整合之后）：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt; &lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;71.34&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;75.40&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;59.17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;100&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;71.40&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;74.63&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;61.85&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;63.52&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;62.96&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;70.22&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;63.42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;72.42&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;82.00&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;70.48&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;61.34&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;95&quot;&gt;

&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1541&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1804&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1735&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;1732&lt;/td&gt;
&lt;td width=&quot;95&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;结论：&lt;/h2&gt;
&lt;p&gt;没有长时间的、大量的数据做支撑，很难得到任何结论。然而，上面的数据表明UDP的可靠性还是相当不错的。但是距离越远，遇到的跳变就越多，这也意味着发生不可预知错误的概率就越大，但是如果一切都还OK，距离也不成问题了。&lt;/p&gt;
&lt;p&gt;排队机制是个问题。通过整合包，我们发现性能有了很大的提升。在许多场合，排队都不会产生质的影响，除非你在疯狂发包，否则通过一个简单的时间戳和接收端的重排机制，UDP的性能依旧可观。&lt;/p&gt;
&lt;p&gt;我会做更多的测试、更长的时间、更多的数据、更多的地点。同时，我还会把UDP和TCP的相关性能做个对比。但是无论如何，我认为，可靠性超出我预期的UDP会成为我工具箱中的一员了。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Wed, 19 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-19-79528-a529a4bc7.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-19-79528-a529a4bc7.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>【翻译】Kibana 4 beta 2 发布</title>
        <description>

  
  &lt;div style=&quot;background-color: #FFF;&quot;&gt;
    &lt;p&gt;原文地址见：&lt;a href=&quot;http://www.elasticsearch.org/blog/kibana-4-beta-2-get-now/&quot;&gt;http://www.elasticsearch.org/blog/kibana-4-beta-2-get-now/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;哈哈哈哈哈哈哈哈哈！来啦！Kibana 4 Beta 2 现在正式雪地 360° 裸跪求调戏，包括你家喵星人都行，只要你给反馈。(译者注：ES 的发版日志越来越活泼，我也翻译的更中文化点好了)&lt;/p&gt;
&lt;p&gt;如果你已经等不及要开动，从&lt;a href=&quot;http://www.elasticsearch.org/overview/kibana/installation/&quot;&gt;这里&lt;/a&gt;下载 Kibana 4 Beta 2，否则继续阅读下面的亮点。&lt;/p&gt;
&lt;p&gt;除了很多小的修复和改进，这个版本里还有一些非常值得一看的新东西：&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;地图支持&lt;/h2&gt;
&lt;p&gt;地图回来啦，而且比过去更强大了！新的瓦片式地图可视化用上了 Elasticsearch 强大的 &lt;code&gt;geohash_grid&lt;/code&gt; 来显示地理数据，比如可视化展示相对响应时间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/chenlinux.com/735898972c6873398cbe7c9f670edfaf.jpg&quot; alt=&quot;map&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;可视化选项&lt;/h2&gt;
&lt;p&gt;在 Beta 1 里，柱状图是固定成堆叠式的。在 Kibana 4 Beta 2 里，我们添加了选项让你修改可视化展示数据的方式。比如，分组柱状图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/chenlinux.com/d51858af44b66ddeba0b45d60a7b07aa.jpg&quot; alt=&quot;grouped bars&quot;&gt;&lt;/p&gt;
&lt;p&gt;或者百分比式柱状图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/chenlinux.com/f2ac8d60664f2863768fe3934d17034b.jpg&quot; alt=&quot;Percent bars&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-2&quot;&gt;区域图&lt;/h2&gt;
&lt;p&gt;Beta 2 里区域图也回来了，包括堆叠式和非堆叠式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/chenlinux.com/25c7c7e8782364026614eeff107e6c5a.jpg&quot; alt=&quot;area&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-3&quot;&gt;高级参数&lt;/h2&gt;
&lt;p&gt;我们目标是支持尽可能多的 Elasticsearch 特性，不过有时候我们确实还没覆盖到某个聚合选项，而你偏偏现在就要用它。这种情况下，我们引入了 JSON 输入，让你可以定义附加的聚合参数到发送的请求里。比如，你可能想在一个 &lt;code&gt;terms&lt;/code&gt; 聚合里传递一个 &lt;code&gt;shard_size&lt;/code&gt;，或者在一个基数聚合里调大 &lt;code&gt;precision_threshold&lt;/code&gt;。在下面示例中，我们传了一个小脚本作为高级参数，计算 &lt;code&gt;bytes&lt;/code&gt; 字段的 &lt;code&gt;_value&lt;/code&gt; 的对数值，然后用它作为 X 轴：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/chenlinux.com/e87db7c97ebe497098dca2994c2a4515.jpg&quot; alt=&quot;scripts&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-4&quot;&gt;数据表格&lt;/h2&gt;
&lt;p&gt;有时候你想要个动态图，有时候可能只想要数值就够了。数据表格可视化达成你这个愿望：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/chenlinux.com/eb88433da50ae1293ce6c04b96fac072.jpg&quot; alt=&quot;data table&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-5&quot;&gt;喂！我的仪表盘哪去了？&lt;/h2&gt;
&lt;p&gt;Kibana 内部使用的索引从 &lt;code&gt;kibana-int&lt;/code&gt; 改名叫 &lt;code&gt;.kibana&lt;/code&gt; 了。我们建议你从老索引里把文档(比如：仪表盘，设置，可视化等)都挪到新索引来。不过，你还是可以在 kibana.yml 里直接定义 &lt;code&gt;kibanaIndex: &quot;kibana-int&quot;&lt;/code&gt; 的。&lt;/p&gt;
&lt;h2 id=&quot;section-6&quot;&gt;我们现在在做什么？&lt;/h2&gt;
&lt;p&gt;可以从 &lt;a href=&quot;https://github.com/elasticsearch/kibana/labels/roadmap&quot;&gt;roadmap&lt;/a&gt; 上看到我们离 Kibana 4 正式版还有多远。另外，我们永远欢迎你在 &lt;a href=&quot;https://github.com/elasticsearch/kibana/issues&quot;&gt;GitHub&lt;/a&gt; 的反馈、bug 报告、补丁等等。&lt;/p&gt;
    &lt;hr&gt;
    
    &lt;hr&gt;
  &lt;!-- JiaThis Button BEGIN --&gt;
&lt;div class=&quot;jiathis_style&quot;&gt;
&lt;span class=&quot;jiathis_txt&quot;&gt;分享到：&lt;/span&gt;
&lt;a class=&quot;jiathis_button_tsina&quot;&gt;新浪微博&lt;/a&gt;
&lt;a class=&quot;jiathis_button_weixin&quot;&gt;微信&lt;/a&gt;
&lt;a class=&quot;jiathis_button_renren&quot;&gt;人人网&lt;/a&gt;
&lt;a class=&quot;jiathis_button_ydnote&quot;&gt;有道云笔记&lt;/a&gt;
&lt;a class=&quot;jiathis_button_gmail&quot;&gt;Gmail邮箱&lt;/a&gt;
&lt;a class=&quot;jiathis_button_twitter&quot;&gt;Twitter&lt;/a&gt;
&lt;a class=&quot;jiathis_button_googleplus&quot;&gt;Google+&lt;/a&gt;
&lt;a class=&quot;jiathis_button_hi&quot;&gt;百度空间&lt;/a&gt;
&lt;a class=&quot;jiathis_button_fb&quot;&gt;Facebook&lt;/a&gt;
&lt;a class=&quot;jiathis_button_douban&quot;&gt;豆瓣&lt;/a&gt;
&lt;a href=&quot;http://www.jiathis.com/share?uid=1589850&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;更多&lt;/a&gt;
&lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var jiathis_config={
	data_track_clickback:true,
	summary:&quot;&quot;,
	ralateuid:{
		&quot;tsina&quot;:&quot;1035836154&quot;
	},
	shortUrl:false,
	hideMore:false
}
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://v3.jiathis.com/code/jia.js?uid=1589850&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;!-- JiaThis Button END --&gt;
&lt;!-- UY BEGIN --&gt;


&lt;!-- UY END --&gt;
  &lt;/div&gt;

</description>
        <pubDate>Tue, 18 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-18-kibana4-beta-2-get-now-2e4418715.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-18-kibana4-beta-2-get-now-2e4418715.html</guid>
        
        
        <category>chenlinux</category>
        
      </item>
    
      <item>
        <title>计算机算法：数据压缩之位图（2）</title>
        <description>

        &lt;div style=&quot;margin-bottom: 10px;&quot;&gt;
            &lt;a href=&quot;http://www.luobo360.com&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/jobbole.com/12610ea111a41bca1d747d2b055954c2.jpg&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;

		
&lt;p&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 28px; font-style: normal; font-weight: bold; line-height: 42px;&quot;&gt;概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/79758/&quot; target=&quot;_blank&quot;&gt;在之前的文章中&lt;/a&gt;，我们知道了如何压缩一段重复元素组成的数据。这种压缩称为“游程编码”，该算法在无损数据压缩传输时非常方便。但问题是数据必须遵循特定格式。比如，字符串&lt;strong&gt;“aaaaaaaabbbbbbbb”&lt;/strong&gt;可以被压缩成&lt;strong&gt;“a8b8”&lt;/strong&gt;。此时，16个字符的字符串被压缩成4个字符，没有丢失任何信息，而长度却只有原始长度的25%。但当字符（元素）以不同方式分散时，问题就会出现。如果字符不变，但是没有连续出现，会是什么情况？如果字符串是&lt;strong&gt;“abababababababab”&lt;/strong&gt;会如何？长度一样，字符一样，但是我们不能使用游程编码！确实，使用游程算法在最优情况下只能得到相同的字符串。&lt;/p&gt;
&lt;p&gt;然而在这种情况下，我们看到另一个事实。该字符串有太多重复元素组成，尽管不是一个接着另一个。我可以使用位图压缩该字符串。也就是说我们可以使用序列中的位来保存给定元素出现的位置，这个序列可以简单地转换成一个十进制值。上例中的字符串&lt;strong&gt;“abababababababab”&lt;/strong&gt;可以压缩成&lt;strong&gt;“1010101010101010”&lt;/strong&gt;，即十进制数&lt;strong&gt;43690&lt;/strong&gt;，甚至表示成十六进制的&lt;strong&gt;AAAA&lt;/strong&gt;更好。由此这个长字符串就被压缩了。当解压（解码）消息时，我们再从十进制/十六进制转化成二进制，匹配字符的出现次数。当然，上面这个例程非常简单，假设只有一个重复字符，其余组成字符不同，像这样：&lt;strong&gt;“abacadaeafagahai”&lt;/strong&gt;。那么，我们可以使用对字符“a”使用位图-&lt;strong&gt;“1010101010101010”&lt;/strong&gt;，压缩后为&lt;strong&gt;“AAAA bcdefghi”&lt;/strong&gt;。正如你所看到的，所有例子字符串只有16字符，这是一个限制。对变长数据使用位图有些棘手，它的解码不太容易。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5738889a968ad2369a053756711d5075.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;从根本上来说，位图压缩保存了消息中频繁出现元素的位置！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;此外，位图压缩不仅适用于字符串。也能压缩数组，对象以及任何数据。我之前帖子中的例程就很合适。我们需要使用JSON从服务器传输一个很大的数组到客户机（浏览器）。该数据非常适合于“游程编码”。假设数据不一样——不同年份的集合，这些时间以不同方式分散。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$data = array(
        0 =&amp;gt; 1991,
        1 =&amp;gt; 1992,
        2 =&amp;gt; 1993,
        3 =&amp;gt; 1994,
        4 =&amp;gt; 1991,
        5 =&amp;gt; 1992,
        6 =&amp;gt; 1993,
        7 =&amp;gt; 1992,
        8 =&amp;gt; 1991,
        9 =&amp;gt; 1991,
        10 =&amp;gt; 1991,
        11 =&amp;gt; 1992,
        12 =&amp;gt; 1992,
        13 =&amp;gt; 1991,
        14 =&amp;gt; 1991,
        15 =&amp;gt; 1992, 
        ...
);&lt;/pre&gt;
&lt;p&gt;JSON将会对消息进行编码，编码后的消息如下（一个简单但很大的javascript数组）。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;[1991,1992,1993,1994,1991,1992,1993,1992,1991,1991,1991,1992,1992,1991,1991,1992, ...]&lt;/pre&gt;
&lt;p&gt;然而，如果使用位图压缩，我们将得到一个更短的数组。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$data = array(
        0 =&amp;gt; array(1991, &#39;1000100011100110&#39;),
        1 =&amp;gt; array(1992, &#39;0100010100011001&#39;),
        2 =&amp;gt; array(1993, &#39;0010001000000000&#39;),
        3 =&amp;gt; array(1994, &#39;0001000000000000&#39;),
);&lt;/pre&gt;
&lt;p&gt;此时的JSON如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;[[1991,&quot;1000100011100110&quot;],[1992,&quot;0100010100011001&quot;],[1993,&quot;0010001000000000&quot;],[1994,&quot;0001000000000000&quot;]]&lt;/pre&gt;
&lt;p&gt;很明显，随着待压缩数据增加，压缩率会变得越来越好。事实上，大部分人都是从图像了解了位图压缩，因为该算法主要用于图像压缩。可想而知，在压缩黑白图像时效果会多么好（因为黑色和白色可以视为0和1）。实际上，它也被用于超过两种颜色（例如256色），压缩的程度就非常高。&lt;/p&gt;
&lt;h1&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 28px; font-style: normal; font-weight: bold; line-height: 42px;&quot;&gt;实现&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;下面基于PHP的实现仅仅是为了阐明位图压缩算法。这个算法适用于任何数据结构。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;// too many repeating &quot;a&quot; characters
$msg = &#39;aazahalavaatalawacamaahakafaaaqaaaiauaacaaxaauaxaaaaaapaayatagaaoafaawayazavaaaazaaabararaaaaakakaaqaarazacajaazavanazaaaeanaaoajauaaaaaxalaraaapabataaavaaab&#39;;

function bitmap($message) 
{
       $i = 0;
       $bits = $rest = &#39;&#39;;

       while ($v = $message[$i]) {
              if ($v == &#39;a&#39;) {
                      $bits .= &#39;1&#39;;
              } else {
                      $bits .= &#39;0&#39;;
                      $rest .= $v;
              }
              $i++;
       }

       return number_format(bindec($bits), 0, &#39;.&#39;, &#39;&#39;) . $rest;;
}

echo bitmap($msg);

// uncompressed: 
acaaaaadaaaabalaaeaaaaganaaxakaavawamaasavajawaaaayaauaaadalanagaeaeamaarafalaazaaaiasaanaahaaazaraxaalaahaaawaaajasamahaajaakarapanaakaoakaanawalaacamauaamaal
// compressed:
152299251941730035874325065523548237677352452096zhlvtlwcmhkfqiucxuxpytgofwyzvzbrrkkqrzcjzvnzenojuxlrpbtvb&lt;/pre&gt;
&lt;h1&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 28px; font-style: normal; font-weight: bold; line-height: 42px;&quot;&gt;应用&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;当数据中有元素频繁出现时，该算法效果很好，所以你需要研究待压缩数据的本质。实际上因为这个原因，该算法通常用于PNG8或GIF图像的压缩。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Tue, 18 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-18-79760-5efa36910.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-18-79760-5efa36910.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>计算机算法：数据压缩之游程编码</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 28px; font-style: normal; font-weight: bold; line-height: 42px;&quot;&gt;简介&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;无论现在计算机和网络的速度有多快，用户始终要求更快速的体验。为了降低传输数据的容量，我们通常会对数据进行压缩。这就是计算机科学领域一直是研究和发展的焦点的原因。&lt;/p&gt;
&lt;p&gt;数据压缩算法有很多，有些是无损的，有些是有损的，但是它们的主要目标都是降低存储空间和传输量。对于两个远距离节点之间的数据传输，这些压缩算法非常有用。也许最直观的例子就是web服务器和浏览器之间的数据传输。&lt;/p&gt;
&lt;p&gt;在过去的几年里做了很多关于文件压缩的研究，这些研究基于客户端实现的。这样的文件有javascript、css、html和图像。实际上，服务器和客户端都具备一些数据压缩技术，例如&lt;a href=&quot;http://www.gzip.org/&quot; target=&quot;_blank&quot;&gt;GZIP&lt;/a&gt;的使用极大地降低了数据传输量。此外，还有很多的工具和技巧能够降低数据大小。&lt;/p&gt;
&lt;p&gt;事实上，当文件在客户的虚拟机上执行时，程序员不必理会文件的具体格式如何。如此一来空格、水平制表符和换行符对于文件上下文的理解没有任何意义。这就是&lt;a href=&quot;http://hao.jobbole.com/yui-compressor/&quot; target=&quot;_blank&quot;&gt;YUI Compressor&lt;/a&gt;、&lt;a href=&quot;http://code.google.com/closure/compiler/&quot; target=&quot;_blank&quot;&gt;Google Closure Compiler&lt;/a&gt;等压缩工具移除那些符号的原因。当然，为了提高压缩率文件还能被进一步压缩。本篇文章暂不讨论这一点，但这表明了数据压缩算法的重要性。&lt;/p&gt;
&lt;p&gt;如果我们使用一些数据压缩工具，效果会更好。不幸的是，事实并非如此，压缩率通常取决于数据本身。很明显，数据压缩算法的选择主要取决于数据，我们必须首先对数据进行研究。&lt;/p&gt;
&lt;p&gt;这里我将讨论“游程编码”，它是一种十分简单的无损数据压缩算法，在某些情况下非常有用。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/fc6f6ce544645167f23cefe380c943b9.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 28px; font-style: normal; font-weight: bold; line-height: 42px;&quot;&gt;概述&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;该算法的实现是用当前数据元素以及该元素连续出现的次数来取代字符串中连续出现的数据部分。具体实现我们通过一个字符串实例来说明。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;aaaaaaaaaabbbaxxxxyyyzyx&lt;/pre&gt;
&lt;p&gt;字符串长度为24，我们可以看到字符串中有很多的重复部分。使用游程算法，我们用较短的字符串后加一个计数值来替换游程对象。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;a10b3a1x4y3z1y1x1&lt;/pre&gt;
&lt;p&gt;此时字符串长度为17，大约是初始字符串长度的70%。很明显，这并不是压缩给定字符串的最佳方式。例如当字符仅出现一次时，我们并不需要其后添加“1”。在某些情况下，这种方式会增加初始字符串的长度，而这违反了我们的初衷。这样我们得到的字符串如下。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;a10b3ax4y3zyx&lt;/pre&gt;
&lt;p&gt;此时字符串长度为13，是初始长度的54%！上面例子的一个变种是不对字符保持计数，而是对位置进行计数。这样原始字符串可以被压缩成下面这样。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;a0b10a13x14y18z21y22x23&lt;/pre&gt;
&lt;p&gt;使用这两种方式中的哪一个取决于我们的目标。第二种情况下，我们能够实现二分查找的优化。&lt;/p&gt;
&lt;p&gt;显然，这个算法不仅适用于字符串。对数组也能取得很好的结果。一个典型的例子是服务器和客户机之间字符对象(&lt;a href=&quot;http://www.json.org/&quot; target=&quot;_blank&quot;&gt;JSON&lt;/a&gt;)的传输。特别是如果有大量重复数据序列的存在，我们能获取很好的压缩结果。&lt;/p&gt;
&lt;h1&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 28px; font-style: normal; font-weight: bold; line-height: 42px;&quot;&gt;实现&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;下面的实现是假设我们要使用PHP编写程序对字符串进行压缩。但是这个算法本质上并没有限制我们只能压缩字符串。正如我前面所说，只要略微修改，我们就能将其用于其他数据结构。理解游程算法适用于大量重复元素序列非常重要，不管是字符元素还是数组元素。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$message = &#39;aaaaaaaaaabbbaxxxxyyyzyx&#39;;

function run_length_encode($msg)
{
       $i = $j = 0;
       $prev = &#39;&#39;;
       $output = &#39;&#39;;

       while ($msg[$i]) {
              if ($msg[$i] != $prev) {

                     if ($i) 
                            $output .= $j;

                     $output .= $msg[$i];

                     $prev = $msg[$i];

                     $j = 0;
               }
               $j++;
               $i++;
        }

        $output .= $j;

        return $output;
}

// a10b3a1x4y3z1y1x1
echo run_length_encode($message);&lt;/pre&gt;
&lt;p&gt;略微优化。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$message = &#39;aaaaaaaaaabbbaxxxxyyyzyx&#39;;

function run_length_encode($msg)
{
        $i = $j = 0;
        $prev = &#39;&#39;;
        $output = &#39;&#39;;

        while ($msg[$i]) {
               if ($msg[$i] != $prev) {

                      if ($i &amp;amp;&amp;amp; $j &amp;gt; 1) 
                             $output .= $j;

                      $output .= $msg[$i];

                      $prev = $msg[$i];

                      $j = 0;
                }
                $j++;
                $i++;
         }

         if ($j &amp;gt; 1)
                $output .= $j;

         return $output;
}

// a10b3ax4y3zyx
echo run_length_encode($message);&lt;/pre&gt;
&lt;p&gt;最后一个小变化——现在我们存储字符位置。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$message = &#39;aaaaaaaaaabbbaxxxxyyyzyx&#39;;

function run_length_encode($msg)
{
        $i = 0;
        $prev = &#39;&#39;;
        $output = &#39;&#39;;

        while ($msg[$i]) {
                if ($msg[$i] != $prev) {

                       $output .= $msg[$i] . $i;

                       $prev = $msg[$i];

                 }

                 $i++;
         }

         return $output;
}

// a0b10a13x14y18z21y22x23
echo run_length_encode($message);&lt;/pre&gt;
&lt;h1&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 28px; font-style: normal; font-weight: bold; line-height: 42px;&quot;&gt;复杂性和数据压缩&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;我们习惯使用时间复杂度来衡量时间，通常希望能找到最快的实现方式，比如查找算法。在这里快速压缩数据并不特别重要，重要的是尽可能的无损压缩，使得输出尽可能的小。游程编码的优点在于该算法容易实现。&lt;/p&gt;
&lt;h1&gt;&lt;span style=&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 28px; font-style: normal; font-weight: bold; line-height: 42px;&quot;&gt;应用程序&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;在很多情况下，我们可以使用游程编码。它常用于图像压缩，特别是用于黑白图片处理时是效果非常好。这里，我将介绍上面提及的另一种应用情况。假设我们要使用JSON将大量数组数据传给我们的Ajax程序。假设这些传输数据是一些年份，例如电影首映的年份。一年内有很多电影首映，虽然数据已被排序，但实际上我们没有得到任何好处。更要命的是有大量的数据序列。这里我们可以使用游程编码。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$data = array(
        0 =&amp;gt; 1991,
        1 =&amp;gt; 1991,
        ...
        2223 =&amp;gt; 1991,
        2224 =&amp;gt; 1992,
        ...
        19298 =&amp;gt; 1995,
        19299 =&amp;gt; 1996,
        ...
);&lt;/pre&gt;
&lt;p&gt;正如你看到的，传输整个数组将会是一个噩梦，特别是如果网络的速度很慢。最好对数据进行压缩(例如使用PHP的json_encode)。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;// {&quot;0&quot;:1991,&quot;1&quot;:1991, ..., &quot;2223&quot;:1991,&quot;2224&quot;:1992, ..., &quot;19298&quot;:1995,&quot;19299&quot;:1996, ...}
echo json_encode($data);&lt;/pre&gt;
&lt;p&gt;运行游程编码之后，我们得到结果像以下数组一样（注意这些只是样本数据，最佳存储数据格式取决于你）。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$data = array(
        0 =&amp;gt; array(1991, 2224),
        1 =&amp;gt; array(1992, 3948),
        2 =&amp;gt; array(1995, 2398),
        3 =&amp;gt; array(1996, 3489),
);&lt;/pre&gt;
&lt;p&gt;JSON输出&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;// [[1991,2224],[1992,3948],[1995,2398],[1996,3489]]
echo json_encode($data);&lt;/pre&gt;
&lt;p&gt;注意如果是已排序数据，我们能够获得更好的压缩结果！！！这种方式能够用于图像，图形或者地图坐标的压缩。&lt;/p&gt;
&lt;p&gt;这是数据压缩在日常工作中有用的唯一例子。尽管服务器和客户机之间的通信可以优化和压缩，我们能够改善它。换句话说我们不能够保证对方是否支持压缩。&lt;/p&gt;
&lt;p&gt;那么，相应的客户端必须对数据进行解压，这个过程很缓慢。在第一种情况下，我们只有时间去传输，如下面的流程图所示。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/9f63867602f2b075fda18ce3a40ab2ad.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;未压缩数据传输时间！&lt;/p&gt;
&lt;p&gt;第二种情况，我们应该累加压缩，传输和解压的时间。&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/13a99966ec661ca3630da71ba0f4f869.jpg&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;压缩数据传输时间！&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;所有这些都很重要，但总的来说数据压缩在我们日常生活中的多数情况下都很方便。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Sun, 16 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-16-79758-4988ff13b.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-16-79758-4988ff13b.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>你所不知道的SQL Server数据库启动过程，以及启动不起来的各种问题的分析及解决技巧</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;目前SQL Server数据库作为微软一款优秀的RDBMS，其本身启动的时候是很少出问题的，我们在平时用的时候，很少关注起启动过程，或者很少了解其底层运行过程，大部分的过程只关注其内部的表、存储过程、视图、函数等一系列应用方式，而当有一天它运行的正常的时候突然启动不起来了，这时候就束手无策了，能做的或许只能是重装、配置、还原等，但这一个过程其实是一个非常耗时的过程，尤其当我们面对是庞大的生产库的时候，可能在这火烧眉毛的时刻，是不允许你再重搭建一套环境的。&lt;/p&gt;
&lt;p&gt;所以作为一个合格的数据库使用者，我们要了解其启动、运行过程的事情，一旦发生问题，我们也能及时定位，迅速解决。&lt;/p&gt;
&lt;p&gt;闲言少叙，我们进入本篇的正题。&lt;/p&gt;
&lt;p&gt;SQL Server本身就是一个Windows服务，每一个实例对应的就是一个sqlserver.exe进程。这是一个可执行的文件，默认就放在SQL Server的安装目录下，当我们启动的时候，就是直接调用这个文件，然后启动这个服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一部分、SQL Server实例启动的方法和启动所发生的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL Server实例分为下面几种启动方法：&lt;/p&gt;
&lt;p&gt;（1）在Windows服务控制台里手动启动，或者自动启动（默认），这个也是最常用的方式&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2a913c82754e496d4d60108db6615b24.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（2）第二种方式是SQL Server本身自己提供的启动方式，我们这里可以手动启动&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/66c1f8c879d4a1b8381ae83f919147cb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（3）在SQL Server的SSMS里面手动启动它，这个方式一般大部分利用这种方式进行手动重启&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/706615873a74953fd6c73620a498326c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（4）通过Windows命令窗口，用’net start’命令手动启动，这种方法也可以用&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4815091d96a7fa90deaa87c42d59ab50.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上这几种方式都可以启动SQL Sever,并且都会在SQL 日志信息中有所记录。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二部分、SQL Server实例启动的详细过程以及所发生的问题项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步、检查注册表项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个sqlserver.exe文件开始启动的时候，首先要干的第一件事就是先检查它的配置信息存放于注册表的值项&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/47026dafb41f2c2ce8a55fa32857f6e5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;比较重要的几个键值有下面几个：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/47026dafb41f2c2ce8a55fa32857f6e5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里的&lt;/p&gt;
&lt;p&gt;AuditLevel:其实就是SQL 如何记录用户登录记录；&lt;/p&gt;
&lt;p&gt;LoginMode:是SQL Server服务器身份验证方式等；&lt;/p&gt;
&lt;p&gt;BackupDirectory:默认的备份路径等信息；&lt;/p&gt;
&lt;p&gt;关于注册表信息简要了解即可，不建议做任何修改，当然这些值的信息默认在SQL Server中都能设置：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5e395a4160c16b7a5c76185cddd7dc0c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在不修改注册表的情况下，一般这一步的启动顺序一般不会出现问题，当然出现问题了也通常没有办法解决，大部分的解决方式只有重装了。&lt;/p&gt;
&lt;p&gt;但这一步骤，通常出现以下两个个问题通常是可以解决的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;1&amp;gt;启动账号权限问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们启动SQL Server的进程使用的账号连读注册表的权限都没有，那这个服务是怎么也启动不了的，通常这时候连SQL 的错误日志都没有能力生成出来。&lt;/p&gt;
&lt;p&gt;这时候我们该如何发现呢，虽然这时候它没有能力创建SQL 的错误日志，但是它在Windows层面留下了痕迹，我们来看：&lt;/p&gt;
&lt;p&gt;我将服务启动账号设置成gust来宾账号，来启动该服务&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a8373e1e88833f20a802c0d5af11ce8e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这时候会产生以下错误信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bb18f9c8613a2c1ca5733966723ee04e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Windows的日志信息里也会产生一条错误日志记录：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8c73ebaeaa00f44f4fe6b0e194f3a306.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里的拒绝访问指的就是拒绝访问注册表信息了。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;此问题的解决方式就很简单了，只需要将当然的用户提权到SQL Server服务的启动账号就行了，提权的方式也很简单，只需要添加到SQL的本地用户的启动服务组就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b41e77876b9e8f922b11cf8e38e40a12.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，也可以直接换一个更高级别的用户登录。一般默认都用的超级管理员账户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;2&amp;gt;访问日志和文件夹出现问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认在SQL Server启动的时候会创建一个启动日志文件，记录所有正确的日志信息，当然也包括错误的日志信息，如果这时候找不到这个日志信息的路径，或者已经存在一个日志，但是日志被锁定了（某些NB的杀毒软件擅长干这个），这时候这个服务也是启动不了的，同样也创建不出SQL Server的日志文件，这时候我们还得借助于Windows平台本身，来解决。&lt;/p&gt;
&lt;p&gt;SQL Server启动的创建的日志文件路径，同样存在于注册表项里，我们来看这个参数：&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a4c7557c3827ec14cf83541e66601c8d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里我们故意改成一个错误的路径，来启动下看看：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/958b20c38b06c00084c76fcdf49c850e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;会产生以下错误&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/47a19d9c4c0290d0b0a1702c5e90ae72.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;系统的错误日志信息&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/10d1c4120c0f763aab797cae69f67aac.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;错误说明的很清楚。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;这个问题解决起来也很简单，只需要检查好该路径，确保路径下的文件正确就可以。&lt;/p&gt;
&lt;p&gt;不过有一点需要注意，当SQL Server还没启动起来的时候，有部分错误信息日志需要检查Windows平台下的系统日志。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步、检查系统配置环境，包括硬盘、内存与CPU等&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们进行完第一步的时候，SQL Server已经读取完注册表信息，完成了它的errorlog文件的创建，然后开始进行第二步的进行，这一步骤所有的信息就会按照顺序依次记录到errorlog文件中，我们可以通过查看该文件来详细跟踪这一步骤的进行，根据上一步的注册表信息，我们先来手动清空下这个日志，然后重启一下SQL Server服务，查看下这个日志记录&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/31207d287167c9bc39f9a02b677abd1b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们简单大致分了以下几大步骤：&lt;/p&gt;
&lt;p&gt;一、首先检查系统的软件环境，包括OS版本、电脑信号、内存、硬盘、注册表基础配置项是否正确等&lt;/p&gt;
&lt;p&gt;二、启动系统数据库master&lt;/p&gt;
&lt;p&gt;三、开始利用服务用户登录系统、启动系统资源数据库、检查数据库版本信息等&lt;/p&gt;
&lt;p&gt;四、启动系统数据库model&lt;/p&gt;
&lt;p&gt;五、开始网络配置进行连接，对外提供服务，使用的默认的1433端口&lt;/p&gt;
&lt;p&gt;我们接着分析下面的日志：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bc3f1e9eaa4b23059059da0cae17ff5d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;六、其实完成上面的第五步之后，也就开始启动msdb系统数据库&lt;/p&gt;
&lt;p&gt;七、这时候开始真正的启动用户数据库，并且完整各个库的完整性校验，并且在启动用户数据库之前，先将系统库的tempdb进行清空&lt;/p&gt;
&lt;p&gt;八、在搭建完成之后，才开始启系统的另外一个数据库tempdb&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;上面的整个SQL  Server系统启动的过程产生了详细的日志记录，我们下面会依次按照该步骤进行详细的进行逐步分析。&lt;/p&gt;
&lt;p&gt;在检查系统软硬件环境的过程中，基本不会发生什么致命错误。比较常见的问题就是内存配置问题，其实在上面的日志记录中有一句特别重要，它反映的就是SQL Server利用内存的情况，我们来看：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/97928b0549a477473728be10791f8ceb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这句话的意思是将所有的数据页锁定到内存中，作为大部分数据库而言，内存就是生命线，SQL Server同样也是，如果系统（64bit中）没有内存压力的情况下，才能将数据页正常的锁定到内存中，如果内存压力过大，系统内存是不允许将数据页也加入到内存中，而这样导致的问题就是SQL  Server严重的性能问题。&lt;/p&gt;
&lt;p&gt;很多用户希望限制SQL Server内存使用，并且有些客户机将它限制到服务都不能启动的情况，这时候在SQL Server的日志中是这样展现的，我们来看：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/db4aea2cb5327f13068ba68e948deb55.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f51d4a3cfd296f9ddebe6b29cfd1f72d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，该错误的原因还是挺清楚的，修复该错误的解决方法也很简单，将内存配置调大就可以。&lt;/p&gt;
&lt;p&gt;跟内存有关的还有一种特殊的情况，就是SQL Server的启动账号在服务器上没有Lock page in memory的权限，如果没有这个权限，在明细日志中查看不到上面的日志记录，该问题的解决方法也很简单，只需要将需要权限加上就可，加权限的方式如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/353feb244f338a0287ffe7e0ac552fe0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过上面的步骤基本，完成数据的软硬件检测过程。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步、启动系统数据库master&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;master数据库是SQL Server系统启动过程中的第一个系统库，是非常关键的数据库。如果这个库不能被正常打开，则SQL Server就不能正常启动。&lt;/p&gt;
&lt;p&gt;和其它数据库一样，master数据库也分为数据文件和日志文件，启动的过程是依次打开，然后做恢复动作，如果这个过程没问题的话，在Errorlog日志文件中，我们会看到如下的这句话：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/33f1567229d2b31ae94742249a0d6653.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果这个过程出现了任何问题，SQL Server的启动过程都会被中断，启动过程失败。&lt;/p&gt;
&lt;p&gt;而这个过程发生的错误，无非就集中以下几种情况，我们来分析一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;1&amp;gt;在指定的路径找不到master数据的数据文件或日志文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于这个SQL Server的最主要的系统数据库的路径，它是以注册表形式存在的，在一下注册表项，可以看到&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dceb010409fb998a256e14b41c9cdbbf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果在该路径下找不到这个系统数据库的话，服务是启动不了的，并且会产生相应的错误日志信息，我们来模拟下，关掉服务，将这两个文件移除走，然后启动看一下：&lt;/p&gt;
&lt;p&gt;首先，该服务是启动失败的&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4b24e6d47b95ba2c122587da8d4201d2.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们来看一下系统日志&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/479dd53e645351c4dd6307e5f3e443a5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;看Errorlog的日志信息&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/eae780fc1e0193875674ac83b0a9f715.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，该问题提示错误信息还是挺详细的。我们来看第二种情况&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;2&amp;gt;文件找到了，但是没有权限访问，或者不能以排他的方式打开该文件（默认的是独占锁进行文件打开的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此种情况也是有可能产生的，比如某些NB的杀毒软件就可以干这个事，让你的系统库无法访问，这样同样也是启动不了的，我们这样来看，提示的错误的信息有哪些：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4fbff887b497ec1843fc7124b793e2b9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;来看Errorlog的错误记录：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fbb5fb347d971a9b98b0a1939c0861bc.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;3&amp;gt;文件找到了，访问权限也有，但是文件有问题，就是说是数据库损坏了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个问题也经常出现，比如磁盘坏掉了，恢复后发现文件有问题，不能正常打开，这种问题我们来看错误信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/555097275517ed6ebe211b2d998a57a6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;日志中的信息&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/61fc6d366c9c0c4754fcfdcbd28af2c7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于master系统库的启动过程，基本就是上面的三种错误，关于这三种问题，我们该如何解决呢？&lt;/p&gt;
&lt;p&gt;解决方法：首先如果根据错误日志定位出问题的性质，如果是前两种问题其实是挺好解决的，比如文件没找到、权限项不对等，这些问题相应的去解决就可以，最棘手的就是第三种情况，出现这种情况最理想的情况是master数据库进行了备份，通过备份文件进行恢复就可以，一切就可以正常，当然通过暴力的停掉服务，拷贝文件进去也可以解决。&lt;/p&gt;
&lt;p&gt;最揪心的就是这个库就没备份，那该如何解决呢？这种方式的解决就得借助SQL Server的安装程序，进行重建master数据了，但是这种方式重建的master数据库会导致以前的SQL Server的设定全部清空掉。&lt;/p&gt;
&lt;p&gt;清空的信息包括：所有的账户信息（意味着需要重建）、msdb中的所有job信息等（也需要重建）、用户数据库信息（必须全部重新附加attch上）&lt;/p&gt;
&lt;p&gt;而这一系列过程如果是一个生产库，可能会是一个非常大的工作量！&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步、启动系统资源数据库，并检查数据版本信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;资源数据库是SQL Server2005中引入的逻辑数据库，在实例下是看不到的，但是有它的物理文件，主数据库默认名称为：mssqlsystemresource.mdf、日志名称为：mssqlsystemresource.ldf&lt;/p&gt;
&lt;p&gt;如果该数据库启动的过程中也出现了问题，那SQL Server也不能正常启动。&lt;/p&gt;
&lt;p&gt;这个系统数据库比较特别，它是一个只读数据库，完全由SQL Server自己维护，用户是不能更改的，所以我们只要保证它的是数据库文件和日志完好就可以，不需要对它进行任何的跟踪和维护。&lt;/p&gt;
&lt;p&gt;当然如果非要看这个数据库，可以通过单用户的DAC方式进行连接。&lt;/p&gt;
&lt;p&gt;所以这个数据库在一般情况下不会发生意外，基本上是能正常启动，不过特殊情况下，不能启动的情况就以下两种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;1&amp;gt;数据库文件不存在，无法访问，或者文件坏掉了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实它的报的错误信息，类似于上面的master数据库，我来截个图，看一下：&lt;/p&gt;
&lt;p&gt;这个是errorlog记录的错误信息&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a24ab8238466f37448ec40f3dea558c8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在windows层面也有它自己的错误日志信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/685e88d963c58b0dc0f93c24f41e55cf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;2&amp;gt;资源数据库的版本和SQL Server的版本不一致&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个有可能是人为的更改了这个资源数据库，导致现有的资源数据库文件和数据库版本不一致，这样的话也会导致错误的形成&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3a86b86849d143bcd0e902930388437e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;windwos平台也记录下了该错误的信息，看下面的图片：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c27f7c5041523639cacef687537f74b1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;关于资源库的这两个问题解决方法，非常的简单。只要找到和这台服务器上的SQL Server的版本一致的数据库，拷贝过来就行。&lt;/p&gt;
&lt;p&gt;当然最好的预防措施是：每当安装完SQL Server或者打完补丁之后，就及时的备份这个两个文件，放在安全的地方，用的时候拷贝过来就行，备份是数据库管理员的天职&lt;/p&gt;
&lt;p&gt;当然有时候在紧急的情况下，找不到相同版本的数据库，理论上这个库是只读的，所以不会发生任何改变，我们随便找一台机器，安装一下同版本数据库，然后拷贝过来就行，当然一定注意的是这里面是相同版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五步、启动系统数据库model&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;model系统数据库同样也是SQL Server启动过程中用到的一个非常关键的数据库，如果这个库损坏，SQL Server启动也会失败，关于model数据不能启动的原因基本和master的类似，同样也是两种：1、数据库文件早不到或者不能访问；2、数据库文件能访问但是是损坏的文件。&lt;/p&gt;
&lt;p&gt;诊断此种问题的方式也和上面的两种方式一样，查看启动过程产生的errorlog文件或者windows系统日志，这里我们就不重现该问题了。&lt;/p&gt;
&lt;p&gt;我们只给出此种问题的解决方法：&lt;/p&gt;
&lt;p&gt;1、如果该库我们已经做过备份，那最直接也是最有效的解决方式就是直接还原，这里的还原方式可能和普通库的还原方式不一样，因为SQL  Server实例还没有启动，我们恢复过程采取以下过程：&lt;/p&gt;
&lt;p&gt;a.用参数启动SQL Server，在命令提示行中执行以下命令，这样的话SQL Server启动就会跳过model数据库恢复这一步&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;net start MSSQLSERVER /f /m /T3608&lt;/pre&gt;
&lt;p&gt;b.现在恢复model数据库，打开SSMS，直接输入&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;RESTORE DATABASE model FROM DISK =&#39;G:\data\model.bak&#39;
WITH 
MOVE &#39;modeldev&#39; TO &#39;E:\dataDefaultFileManger\MSSQL10.MSSQLSERVER\MSSQL\DATA\model.mdf&#39;
MOVE &#39;modellog&#39; TO &#39;E:\dataDefaultFileManger\MSSQL10.MSSQLSERVER\MSSQL\DATA\model.ldf&#39;
,replace&lt;/pre&gt;
&lt;p&gt;c.恢复成功后，直接重启SQL Server既可以。&lt;/p&gt;
&lt;p&gt;2、将SQL Server关闭，然后直接采取暴力的方式将model数据文件拷贝回来就可以，这种方式简单有效，但是非常规操作&lt;/p&gt;
&lt;p&gt;3、还有一种方式是利用setup安装文件，重建该数据库，过程缓慢，稍显复杂，很不推荐。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第六步、开始网络配置进行连接，对外提供服务，使用的默认的1433端口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当上面的几个重要的系统库都已经启动完成之后，下一步就是开始检查网络环境，进行网络服务的配置，对外进行提供服务了，一般来讲，在SQL Server中利用的网络启动协议有三种：Shared Memory、Named Pope和TCP/IP，其实在日常我们最常用的就是TCP/IP这种方式了，并且默认开启的是1433端口。&lt;/p&gt;
&lt;p&gt;我们来看一下正常启动过程中，该部分的详细日志：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/22f4f88d3f2983e012d34478d2256401.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里面的Shared Memory是专供本地连接通过LPC(Local Procedure Call)技术向SQL Server做的连接。它不走网络层，所以他是速度最快的连接方式。正常启动后会显示上面的正常日志。&lt;/p&gt;
&lt;p&gt;Named Pipe方式正常启动，也会显示出上面的日志。可以看到。&lt;/p&gt;
&lt;p&gt;这其中我们最常用的TCP/IP这种方式，也正常的启动了，并且指定了两种访问方式，ipv4/ipv6，然后后面加上了1433端口号。&lt;/p&gt;
&lt;p&gt;在这个过程中最常出现的问题就是，1433端口被其它程序占用，这样就导致TCP/IP协议无法正常启动，这样我们会看到如下日志信息&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f5032d5079231cfbf56ef333d3240b42.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;并且在windows 系统日志中也会有记录&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/13a6bbbb7d036d55211f3598b79e49d5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;其实这里出现的问题还是挺好解决的，只需要找到占用这个端口的应用程序，采取措施让它把这个端口给让出来就可以。&lt;/p&gt;
&lt;p&gt;当然出现这些问题就意味着客户端已经无法通过TCP/IP这种远程连接的方式进行连接访问了。&lt;/p&gt;
&lt;p&gt;这时候一般管理员可以采用SQL Server给其提供的“专用管理员连接”（DAC）进行连接，这种方式我们以后再介绍。&lt;/p&gt;
&lt;p&gt;当然，在SQL Server启动的过程中，一般出现这种网络问题，或者协议不能成功加载，SQL Server会报出错误信息，但是一般情况下是不会影响SQL Server的正常启动的。受影响的可能只是出问题的那种协议功能。&lt;/p&gt;
&lt;p&gt;我们只需要根据日志，定位问题，然后解决掉，重新启动就可以了。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第七步、开始启动msdb系统数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于msdb这个系统数据库，它是被安排在系统库中接近最后一个了，除了用户数据库和临时库tempdb之外，当启动过程中已经进行到这一步的时候，其实我们的实例就已经启动起来了，并且能够连接。&lt;/p&gt;
&lt;p&gt;我们知道msdb这个库中主要的存储的信息是应用各个库的备份信息，各种job的历史跑批信息等，其实诸多的都是来自于用户数据库所产生的一些客观数据。&lt;/p&gt;
&lt;p&gt;我们来看一下这个库出现了问题会产生什么现象：&lt;/p&gt;
&lt;p&gt;我将这个库文件移除走，然后重新启动服务，启动过程中没有报任何错误，并且能够顺利启动，我们用SSMS直接连接过去，也可以正常连接&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/51ac8877c9b57e33c15e65db26c0969c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是当我们点击开数据的时候，其实是看不到任何用户数据库的，并且会产生一个错误提示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c22fd1e14d9897ec00965fd7f95bef58.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;看来是不能使用的，我们来查看一下错误日志：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3f06ae27ab116f0706d7af2ec6433a21.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;虽然这个库的重要性比起master之类的库重要性要稍显差一些，但是缺少了它我们的SQL Server虽然能启动，但是依然不能使用。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;要解决这个问题其实方式就很多种了，因为到此我们的SQL Server实例已经能够正常启动了，我们可以采取：&lt;/p&gt;
&lt;p&gt;1、利用备份还原该库，参考文章前面的方式（推荐）&lt;/p&gt;
&lt;p&gt;2、关掉服务，利用暴力的拷贝文件的方式进行恢复，简单有效，非常规操作&lt;/p&gt;
&lt;p&gt;3、找台相同的环境，找到相同的文件，直接拷贝过来使用&lt;/p&gt;
&lt;p&gt;4、利用安装文件进行恢复（不推荐）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第八步、启动用户数据库，并且完整各个库的完整性校验，并且在启动用户数据库之前，先将系统库的tempdb进行清空&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本步骤所遇到的问题层出不穷，各种样式，我打算再重新组织一篇文章，专门列举，此篇就不介绍了。&lt;/p&gt;
&lt;p&gt;但有一点需要记住：在这一步之前SQL Server会将tempdb这个系统库清空掉，也就是说，每次的重启操作，系统都会将tempdb清空，然后重建，这一步一般不会发生异常，成功之后会出现以下日志信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/93caedbde47e21908c22cc1ac614eb22.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第九步、开始重建系统的另外一个数据库tempdb&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tempdb这个库比较特殊，每次重启的时候都是重新创建的，SQL Server会根据master数据库里的记录的信息以model数据库为版本进行创建。所以只要我们保证model数据库没有问题，然后硬盘没有问题，tempdb的数据库文件就应该没有问题。&lt;/p&gt;
&lt;p&gt;关于temdb这个库的所有配置信息是存储于master的数据库中的，里面的内容信息是存储于model系统库中的&lt;/p&gt;
&lt;p&gt;这样就带来了一个问题，有时候我们的master的库是从别的机器下面备份下来的，所以它里面会记录这个tempdb这个库在原来机器上的路径，这样在启动创建的时候就会报错。&lt;/p&gt;
&lt;p&gt;所以我们需要执行以下命令更改这个库路径&lt;/p&gt;
&lt;p&gt;a、用参数启动SQL Server&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;net start MSSQLSERVER /f  /m  /T3608&lt;/pre&gt;
&lt;p&gt;b.修改数据文件和日志文件路径&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;ALTER DATABASE tempdb MODIFY FILE(NAME=tempdev,FILENAME=&#39;C:\right path....\temdb.mdf&#39;);
go
ALTER DATABASE tempdb MODIFY FILE(NAME=tempdev,FILENAME=&#39;C:\right path....\temdblog.ldf&#39;);
go&lt;/pre&gt;
&lt;p&gt;c.正常启动数据库既可以&lt;/p&gt;
&lt;p&gt;还有一种情况，就是创建该文件的时候，提供的硬盘空间不足，或者权限不够，我们也是根据上面的方式，修改到一个正确的路径，并且确保权限正确。&lt;/p&gt;
&lt;p&gt;也可以更改temp文件的大小，默认是4M，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;ALTER DATABASE tempdb MODIFY FILE(NAME=tempdev,SIZE=100MB);
go
ALTER DATABASE tempdb MODIFY FILE(NAME=tempdev,SIZE=100MB);
go&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;至此，如果上面的整个过程都没出问题的话，一个正常的SQL Server就可以启动成功的。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本篇文章到此结束了…..此篇耗时三天…..为了尽可能的呈现出所有的问题现象，我对本地的SQL Server进行了多种无情的蹂躏、各种的摧残，力求能够重显各种不同的应用场景问题现象，然后尽可能的找到合适的解决方案，当然还有很多的情况没有展现出来，后续遇到，会一一补充进来，当然有遇到不能解决的，也可以留言，我们一起分析解决。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Wed, 12 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-12-79624-3d48ea0c5.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-12-79624-3d48ea0c5.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>你不知道的 字符集和编码（编码字符集与字符集编码）</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;我的上篇文章，有朋友提出字符集和编码的区别，我在此立文和大家讨论下&lt;/p&gt;
&lt;p&gt;常说的字符集和编码区别，其实就是编码字符集和字符集编码的区别，其实，单单如果只是说字符集，没有任何编码的概念的话，那么字符集其实仅仅是一个简单的字符的集合，或者说是一个抽象的字符的集合，包括文字，符号等等，不参与任何存储形式，只是存在这么各种各样标准的字符的集合&lt;/p&gt;
&lt;p&gt;如果仅仅是抽象的字符集，我们是无需拿出讨论的，因为没有任何异议，通俗易懂，而常说的字符集指的编码字符集，比如常见的 unicode、ascii、gb2312、gbk等，这些我们常称做为字符集（其实是编码字符集），这些字符集，比如unicode其实本质上是已经“编码”过的字符集，即每个字符都有唯一的整数编号，每个字符都有自己特有的编号，同一个字符在不同编码字符集中编号也会不同，当然很多编码字符集都是ascll的超集，所以ascll字符集的编号与很多编码字符集中编号都一样，比如英文字母“A”，在ASCII及Unicode及GB2312中，均是第0×41个字符，说到这里朋友一定注意到了我上面再描述“ unicode其实本质上是已经“编码”过的字符集”中的“编码”二字加了双引号，我要强调的是这里的“编码”并不是真的我下面要说的编码，这里只是为每个字符编了一个对应的编号，但是我们还是习惯专业的称呼为“编码字符集”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们经常说“文章采用的是utf-8编码方式”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我对于这个编码方式的意义，个人理解是 &lt;strong&gt;将一个字符的整数编号用一个什么二进制的整数值来对应并在计算机存储。&lt;/strong&gt;这和上面说的编码字符集中的“编码”千差万别，这里我们称之为“字符集编码”，即我们常说的编码&lt;/p&gt;
&lt;p&gt;说到这里，很多人会觉得那么unicode和utf-8的区别在哪里？既然上文说到unicode是编码字符集，那么utf-8又是什么？就是常说的编码？&lt;/p&gt;
&lt;p&gt;“文章采用的是utf-8编码方式”，个人觉得准确的说法是“文章采用的是基于unicode编码字符集的utf-8的编码方案”，即&lt;/p&gt;
&lt;p&gt;即unicode本身作为编码字符集没有任何存储形式，只是一个编号和字符对应的表而已，如何在计算机存储？你可能想到了干脆直接把编号当作二进制数值来直接存储，那么为什么不这么做呢？这也算是一种字符集编码方案，就是基于unicode编码字符集的utf-32编码方案，那么有没有更加智能一点的编码方案呢？为什么会没有呢？那就是utf-8、utf-16等等，    等等，在我解释为何要用utf-8编码方案的时候，我必须说明一件事情：如下&lt;/p&gt;
&lt;p&gt;我在上一篇文章《&lt;a id=&quot;cb_post_title_url&quot; title=&quot;你不知道的 页面编码，浏览器选择编码，get，post各种乱码由来 &quot; href=&quot;http://blog.jobbole.com/79424/&quot; target=&quot;_blank&quot;&gt;你不知道的 页面编码，浏览器选择编码，get，post各种乱码由来&lt;/a&gt;》中说过：“如何查看中文字符的十六进制字符串？方法：BitConverter.ToString(System.Text.Encoding.UTF8.GetBytes(“阿道夫”));” 请注意我可以改为“System.Text.Encoding.Unicode.GetBytes” 如下图是vs2013 Encoding键入“.”后的智能提示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/07b7c02479df4ca8264431ae92fbabf21.png&quot; rel=&quot;lightbox[79610]&quot; title=&quot;你不知道的 字符集和编码（编码字符集与字符集编码）&quot;&gt;&lt;img class=&quot;size-full wp-image-79612 aligncenter&quot; alt=&quot;112227067411272&quot; src=&quot;/images/jobbole.com/41e0858c1d1915886f851f7e412df9d1.jpg&quot;&gt;&lt;/a&gt;&lt;img class=&quot;aligncenter size-full wp-image-79613&quot; alt=&quot;112226562562235&quot; src=&quot;/images/jobbole.com/b38326e5eb16637324f3425657aa90c3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;（列表过长，用两幅图分别截图）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上图有两个疑问：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、如果说unicode是编码字符集，为何会出现在和utf-8这种编码方案并列的列表中？&lt;/p&gt;
&lt;p&gt;2、ASCII或者gb2312都是编码字符集为何也会出现在和utf-8这种编码方案并列的列表中？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们假设有两个猜测：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、此处的unicode并不是真正的unicode编码字符集，可能只是一种和unicode编码字符集关系非常紧密的一种编码方案&lt;/p&gt;
&lt;p&gt;2、ASCII或者gb2312（其实就是图中的Default,即操作系统当前的编码，国内一般为gb2312）是编码字符集没有错，但是对于ASCII或者gb2312都只有唯一一种编码，那么我称呼它们为ASCII编码或者GB2312编码也没有问题，既然这样，那我把ascii和gb2312加入和utf-8这种编码方案并列的列表中也理所当然？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的两个假设，很快得到论证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、在Encoding 的元数据看到：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;//
        // 摘要:
        //     获取使用 Little-Endian 字节顺序的 UTF-16 格式的编码。
        //
        // 返回结果:
        //     使用 Little-Endian 字节顺序的 UTF-16 格式的编码。
        public static Encoding Unicode { get; }&lt;/pre&gt;
&lt;p&gt;这里解释在这里的unicode其实本质上“获取使用 Little-Endian 字节顺序的 UTF-16 格式的编码”，即使基于unicode编码字符集的utf-16编码方案，类似的有BigEndianUnicode（获取使用 Big Endian 字节顺序的 UTF-16 格式的编码）&lt;br&gt;
2、一般的ASCII或者gb2312，我们可以称呼为ASCII字符集也可以称呼为ASCII编码，只是意义不同而已，因为对于ASCII编码字符集或者gb2312编码字符集都只有唯一一种编码，就是ASCII编码和GB2312编码，那么列表中显示的ASCII和GB2312指的不是编码字符集而是ASCII和GB2312的编码方案，我想正是这种原因，才在很多时候，不管是字符集赋值还是编码方案赋值都可以直接用gb2312或者ascii，比如：&lt;br&gt;
Encoding gb2312 = Encoding.GetEncoding(“gb2312″);&lt;br&gt;
Response.ContentEncoding = gb2312;//编码&lt;br&gt;
Response.Charset=”gb2312″;//字符集&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结下的说：&lt;/strong&gt;&lt;br&gt;
就是unicode是字符集，不是编码！但是ascii（gb2312）是字符集，这个说法肯定正确，但是我表达为“ascii编码”也不能说大错特错，但是这种说法让人误解，如果一定要说那么就说“ascii编码字符集的编码”&lt;/p&gt;
&lt;p&gt;如果理解上面两个假设的论证道理，那么我们继续讨论之前暂停的话题，即“解释为何要用utf-8等编码方案（其他utf编码方案类似）”&lt;br&gt;
utf-8将很大一部分基于unicode编码字符集的字符的整数编号作了变换后存储在计算机中。（引用）以“汉”字为例，“汉”的Unicode值为0x6C49，但其编码为UTF-8格式后的值为0xE6B189（注意到变成了三个字节）。对于UTF-16编码方案，则是对unicode编码字符集中的前65536个字符编号都不做变换，直接作为计算机存储时使用的值（对65536以后的字符，仍然要做变换），例如“汉”字的Unicode编号为0x6C49，那么经过UTF-16编码后存储在计算机上时，它的表示仍为0x6C49，对于UTF-32编码方案，他对所有的Unicode字符均不做变换，直接使用编号存储，只是这种编码方案太浪费存储空间（就连1个字节就可以搞定的英文字符，它都必须使用4个字节）&lt;/p&gt;
&lt;p&gt;既然unicode编码字符集有如此多的编码方案，那么&lt;br&gt;
utf-8，字母数字符号等占1字节，汉字占三字节&lt;br&gt;
utf-16,对unicode编码字符集中的前65536个字符都占两个字节&lt;br&gt;
utf-32，全部占四字节&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果还有人问：&lt;/strong&gt;&lt;br&gt;
“unicode编码每个字符占几个字节”，我们可以理直气壮的说，第一unicode不是编码！第二每个字符具体占多少字节是要看编码方案！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很多面试题会问：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;string param = &quot;abc阿道夫&quot;;
int length1 = System.Text.Encoding.Unicode.GetBytes(param).Length;//别忘了这里的unicode本质是utf-16编码方案
int length2 = param.Length;&lt;/pre&gt;
&lt;p&gt;那么答案就是12和6了&lt;/p&gt;
&lt;p&gt;最后，对于gb2312或者ascii编码字符集的字符的编号就是直接存储在计算机中的二进制数，也就是说gb2312和ascii编码字符集都只有一种编码方案，因为在gb2312编码字符集中的ascii字符集部分的编号并没有变化（即和ascii编码字符集中的编码一致），所以gb2312的ascii部分字符存入计算机的二进制数还是占用1个字节，而中文字符存入计算机的二进制数也是该中文字符在gb2312编码字符集中的编号，该编号一般转换成二进制数都占两个字节，这个过程也就变成了所谓的gb2312编码&lt;br&gt;
如果上面的改为System.Text.Encoding.Default.GetBytes(param).Length，则值就是9和6了&lt;/p&gt;
&lt;p&gt;如果需要了解更加深入的编码内部原理请参考：&lt;br&gt;
&lt;a href=&quot;http://blog.csdn.net/nodeathphoenix/article/details/7057760&quot;&gt;http://blog.csdn.net/nodeathphoenix/article/details/7057760&lt;/a&gt;&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Wed, 12 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-12-79610-812efd89d.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-12-79610-812efd89d.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>Introduction to the Swift REPL</title>
        <description>

						
						

						&lt;p&gt;Xcode 6.1 introduces yet another way to experiment with Swift in the form of an interactive Read Eval Print Loop, or REPL. Developers familiar with interpreted languages will feel comfortable in this command-line environment, and even experienced developers will find a few unique features. To get started, launch Terminal.app (found in /Applications/Utilities) and type “swift” at the prompt in OS X Yosemite, or “xcrun swift” in OS X Mavericks. You’ll then be in the Swift REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Welcome to Swift version 1.1 (swift-600.0.20.0). Type :help for assistance.
  &lt;span class=&quot;console&quot;&gt;1&amp;gt;&lt;/span&gt;  &lt;span class=&quot;cursor&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All you need to do is type Swift statements and the REPL will immediately execute your code.  Expression results are automatically formatted and displayed along with their type, as are the results of both variable and constant declarations.  Console output flows naturally within the interactive session:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;span class=&quot;console&quot;&gt;1&amp;gt;&lt;/span&gt; &quot;100&quot;.toInt()
&lt;span class=&quot;output&quot;&gt;$R0: Int? = 100&lt;/span&gt;
  &lt;span class=&quot;console&quot;&gt;2&amp;gt;&lt;/span&gt; let name = &quot;Katherine&quot;
&lt;span class=&quot;output&quot;&gt;name: String = &quot;Katherine&quot;&lt;/span&gt;
  &lt;span class=&quot;console&quot;&gt;3&amp;gt;&lt;/span&gt; println(&quot;Hello, \(name)&quot;)
&lt;span class=&quot;output&quot;&gt;Hello, Katherine&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the result from line one has been given a name by the REPL even though the result of the expression wasn’t explicitly assigned to anything.  You can reference these results to reuse their values in subsequent statements:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;span class=&quot;console&quot;&gt;4&amp;gt;&lt;/span&gt; $R0! + 200
&lt;span class=&quot;output&quot;&gt;$R1: Int = 300&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Swift compiler recognizes incomplete code, and will prompt for additional input when needed.  Your code will even be indented automatically as it would in Xcode. For instance, starting a function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;console&quot;&gt;5&amp;gt;&lt;/span&gt; func timesTwo() {
&lt;span class=&quot;console&quot;&gt;6.		&lt;/span&gt;&lt;span class=&quot;cursor&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The prompt for continuation lines is a line number followed by a period instead of the angle bracket that indicates a new statement, so you can tell at a glance when you’re being asked to complete a code fragment.  At this point you can keep typing remaining lines in the method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;console&quot;&gt;5&amp;gt;&lt;/span&gt; func timesTwo() {
&lt;span class=&quot;console&quot;&gt;6.&lt;/span&gt;		return value * 2
&lt;span class=&quot;console&quot;&gt;7.&lt;/span&gt; }&lt;span class=&quot;cursor&quot;&gt; &lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are three noteworthy points to make here:  The first is that line six was originally indented, but the REPL automatically unindented when we typed the closing brace.  The second is that the function references a parameter we forgot to declare and needs a return type, so you’ll need to add both to the declaration.  The last is that even if you did press return after the last line, it’s not too late to fix it.&lt;/p&gt;
&lt;h3&gt;Multi-Line History&lt;/h3&gt;
&lt;p&gt;When code is submitted to the compiler it’s also recorded in the REPL history, which makes correcting mistakes trivial.  If you pressed return at the end of the incomplete function declaration above, you’d be presented with the following message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;string&quot;&gt;error:&lt;/span&gt; use of unresolved identifier &#39;value&#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Like most history implementations, you can call up your last entry by pressing up arrow from the prompt.  The REPL brings back all three lines in our example, and places the cursor at the end.  You can now proceed with editing the code to correct your mistake as described in the next section.&lt;/p&gt;
&lt;p&gt;Your history is preserved between sessions and will record hundreds of code fragments.  Each time you move up from the top line you’ll move to an earlier history entry.  Each time you move down from an empty line at the bottom of an entry you’ll move to a more recent history entry.  The empty line that opens up before moving to the next entry comes in handy for reasons discussed below.&lt;/p&gt;
&lt;h3&gt;Multi-Line Editing&lt;/h3&gt;
&lt;p&gt;Even though the REPL behaves like a traditional line editor, it also provides convenient features for dealing with multi-line input like most class or function declarations.  In the example above, before pressing return on the final line you can press up arrow to move the cursor up to the declaration line, then use the left arrow to move the cursor just after the opening parenthesis for the parameter list:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;console&quot;&gt;5&amp;gt;&lt;/span&gt; func timesTwo(&lt;span class=&quot;cursor&quot;&gt;)&lt;/span&gt; {
&lt;span class=&quot;console&quot;&gt;6.&lt;/span&gt;		return value * 2
&lt;span class=&quot;console&quot;&gt;7.&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Type the parameter declaration, press the right arrow to move past the closing parenthesis and add the return type as well:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;console&quot;&gt;5&amp;gt;&lt;/span&gt; func timesTwo(value: Int) -&amp;gt; Int&lt;span class=&quot;cursor&quot;&gt; &lt;/span&gt;{
&lt;span class=&quot;console&quot;&gt;6.&lt;/span&gt;		return value * 2
&lt;span class=&quot;console&quot;&gt;7.&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can’t press return to complete the declaration at this point because you’re in the middle of a block of text.  Pressing return here would insert a line break, which can be useful if you’re trying to insert additional lines in a function or method body, but what you want here is to move to the end of the declaration.  You can press down arrow twice to get there, or use the Emacs sequence &lt;span class=&quot;keyword&quot;&gt;ESC &amp;gt;&lt;/span&gt; (the escape key followed by a closing angle bracket).  Pressing return at the end of the last line will compile the newly declared function so it’s ready for use:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;span class=&quot;console&quot;&gt;8&amp;gt; &lt;/span&gt; timesTwo(21)
&lt;span class=&quot;output&quot;&gt;$R2: (Int) = 42&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Automatic detection of statement completion means that you can just type code and the REPL will do the right thing the vast majority of the time.  There are occasions, however, where it’s necessary to submit more than one declaration at the same time because they have mutual dependencies. Consider the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func foo() {
	bar()
}
func bar() {
	foo()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Typing everything above line by line will result in trying to compile the first function once the third line is complete, and of course this produces an error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;string&quot;&gt;error:&lt;/span&gt; use of unresolved identifier &#39;bar&#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You could declare both functions on a single line to get around automatic completion detection that takes place when you press return, but there’s a better solution.  After typing the third line above you can press the down arrow to move to create a fourth line manually, and type the remainder normally.  The two declarations are compiled together, achieving the desired goal of mutual recursion.&lt;/p&gt;
&lt;h3&gt;Quick Reference&lt;/h3&gt;
&lt;p&gt;To help you get started, here’s a handy chart with some of the most commonly used editing and navigation keys:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Arrow Keys		Move cursor left/right/up/down
Control+F		Move cursor right one character, same as right arrow
Control+B		Move cursor left one character, same as left arrow
Control+N		Move cursor to end of next line, same as down arrow
Control+P		Move cursor to end of prior line, same as up arrow
Control+D		Delete the character under the cursor
Option+Left		Move cursor to start of prior word
Option+Right	Move cursor to start of next word
Control+A		Move cursor to start of current line
Control+E		Move cursor to end of current line
Delete			Delete the character to the left of the cursor
Esc &amp;lt;			Move cursor to start of first line
Esc &amp;gt;			Move cursor to end of last line&lt;/code&gt;&lt;/pre&gt;

						
						

												
											

</description>
        <pubDate>Tue, 11 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-11--id=18-dde9d26de.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-11--id=18-dde9d26de.html</guid>
        
        
        <category>apple_swift</category>
        
      </item>
    
      <item>
        <title>Differential Flame Graphs</title>
        <description>

&lt;p&gt;How quickly can you debug a CPU performance regression? If your environment is complex and changing quickly, this becomes challenging with existing tools. If it takes a week to root cause a regression, the code may have changed multiple times, and now you have new regressions to debug.&lt;/p&gt;

&lt;p&gt;Debugging CPU usage is easy in most cases, thanks to &lt;a href=&quot;/FlameGraphs/cpuflamegraphs.html&quot;&gt;CPU flame graphs&lt;/a&gt;. To debug regressions, I would load before and after flame graphs in separate browser tabs, and then blink between them like searching for &lt;a href=&quot;http://en.wikipedia.org/wiki/Planets_beyond_Neptune#Discovery_of_Pluto&quot;&gt;Pluto&lt;/a&gt;. It got the job done, but I wondered about a better way.&lt;/p&gt;

&lt;p&gt;Introducing &lt;strong&gt;red/blue differential flame graphs&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;object data=&quot;/images/brendangregg.com/2aa60bc452509468303f37e584575032.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;720&quot; height=&quot;296&quot;&gt;
&lt;img src=&quot;/images/brendangregg.com/2aa60bc452509468303f37e584575032.jpg&quot; width=&quot;720&quot;&gt;
&lt;/object&gt;&lt;/p&gt;

&lt;p&gt;This is an interactive SVG (direct &lt;a href=&quot;/blog/images/2014/zfs-flamegraph-diff.svg&quot;&gt;link&lt;/a&gt;). The color shows &lt;strong&gt;red for growth&lt;/strong&gt;, and &lt;strong&gt;blue for reductions&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The size and shape of the flame graph is the same as a CPU flame graph for the second profile (y-axis is stack depth, x-axis is population, and the width of each frame is proportional to its presence in the profile; the top edge is what&#39;s actually running on CPU, and everything beneath it is ancestry.)&lt;/p&gt;

&lt;p&gt;In this example, a workload saw a CPU increase after a system update. Here&#39;s the CPU flame graph (&lt;a href=&quot;/blog/images/2014/zfs-flamegraph-after.svg&quot;&gt;SVG&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;object data=&quot;/images/brendangregg.com/49970762d02ea8e1b80cbd5bc5eb1a97.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;720&quot; height=&quot;296&quot;&gt;
&lt;img src=&quot;/images/brendangregg.com/49970762d02ea8e1b80cbd5bc5eb1a97.jpg&quot; width=&quot;720&quot;&gt;
&lt;/object&gt;&lt;/p&gt;

&lt;p&gt;Normally, the colors are picked at random to differentiate frames and towers. Red/blue differential flame graphs use color to show the difference between two profiles.&lt;/p&gt;

&lt;p&gt;The deflate_slow() code and children were running more in the second profile, highlighted earlier as red frames. The cause was that ZFS compression was enabled in the system update, which it wasn&#39;t previously.&lt;/p&gt;

&lt;p&gt;While this makes for a clear example, I didn&#39;t really need a differential flame graph for this one. Imagine tracking down subtle regressions, of less than 5%, and where the code is also more complex.&lt;/p&gt;

&lt;h2&gt;Red/Blue Differential Flame Graphs&lt;/h2&gt;

&lt;p&gt;I&#39;ve had many discussions about this for years, and finally wrote an implementation that I hope makes sense. It works like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Take stack profile 1.&lt;/li&gt;
&lt;li&gt;Take stack profile 2.&lt;/li&gt;
&lt;li&gt;Generate a flame graph using 2. (This sets the width of all frames using profile 2.)&lt;/li&gt;
&lt;li&gt;Colorize the flame graph using the &quot;2 - 1&quot; delta. If a frame appeared more times in 2, it is red, less times, it is blue. The saturation is relative to the delta.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The intent is for use with before &amp;amp; after profiles, such as for &lt;strong&gt;non-regression testing&lt;/strong&gt; or benchmarking code changes. The flame graph is drawn using the &quot;after&quot; profile (such that the frame widths show the current CPU consumption), and then colorized by the delta to show how we got there.&lt;/p&gt;

&lt;p&gt;The colors show the difference that function directly contributed (eg, being on-CPU), not its children.&lt;/p&gt;

&lt;h2&gt;Generation&lt;/h2&gt;

&lt;p&gt;I&#39;ve pushed a simple implementation to github (see &lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;FlameGraph&lt;/a&gt;), which includes a new program, difffolded.pl. To show how it works, here are the steps using Linux &lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;perf_events&lt;/a&gt; (you can use other profilers).&lt;/p&gt;

&lt;p&gt;Collect profile 1:&lt;/p&gt;

&lt;pre&gt;
# &lt;b&gt;perf record -F 99 -a -g -- sleep 30&lt;/b&gt;
# &lt;b&gt;perf script &amp;gt; out.stacks1&lt;/b&gt;
&lt;/pre&gt;

&lt;p&gt;Some time later (or after a code change), collect profile 2:&lt;/p&gt;

&lt;pre&gt;
# &lt;b&gt;perf record -F 99 -a -g -- sleep 30&lt;/b&gt;
# &lt;b&gt;perf script &amp;gt; out.stacks2&lt;/b&gt;
&lt;/pre&gt;

&lt;p&gt;Now fold these profile files, and generate a differential flame graph:&lt;/p&gt;

&lt;pre&gt;
$ &lt;b&gt;git clone --depth 1 http://github.com/brendangregg/FlameGraph&lt;/b&gt;
$ &lt;b&gt;cd FlameGraph&lt;/b&gt;
$ &lt;b&gt;./stackcollapse-perf.pl ../out.stacks1 &amp;gt; out.folded1&lt;/b&gt;
$ &lt;b&gt;./stackcollapse-perf.pl ../out.stacks2 &amp;gt; out.folded2&lt;/b&gt;
$ &lt;b&gt;./difffolded.pl out.folded1 out.folded2 | ./flamegraph.pl &amp;gt; diff2.svg&lt;/b&gt;
&lt;/pre&gt;

&lt;p&gt;difffolded.pl operates on the &quot;folded&quot; style of stack profiles, which are generated by the stackcollapse collection of tools (see the files in &lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;FlameGraph&lt;/a&gt;). It emits a three column output, with the folded stack trace and two value columns, one for each profile. Eg:&lt;/p&gt;

&lt;pre&gt;
func_a;func_b;func_c 31 33
[...]
&lt;/pre&gt;

&lt;p&gt;This would mean the stack composed of &quot;func_a()-&amp;gt;func_b()-&amp;gt;func_c()&quot; was seen 31 times in profile 1, and in 33 times in profile 2. If flamegraph.pl is handed this three column input, it will automatically generate a red/blue differential flame graph.&lt;/p&gt;

&lt;h2&gt;Options&lt;/h2&gt;

&lt;p&gt;Some options you&#39;ll want to know about:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;difffolded.pl -n&lt;/strong&gt;: This normalizes the first profile count to match the second. If you don&#39;t do this, and take profiles at different times of day, then all the stack counts will naturally differ due to varied load. Everything will look red if the load increased, or blue if load decreased. The -n option balances the first profile, so you get the full red/blue spectrum.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;difffolded.pl -x&lt;/strong&gt;: This strips hex addresses. Sometimes profilers can&#39;t translate addresses into symbols, and include raw hex addresses. If these addresses differ between profiles, then they&#39;ll be shown as differences, when in fact the executed function was the same. Fix with -x.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;flamegraph.pl --negate&lt;/strong&gt;: Inverts the red/blue scale. See the next section.&lt;/p&gt;

&lt;h2&gt;Negation&lt;/h2&gt;

&lt;p&gt;While my red/blue differential flame graphs are useful, there is a problem: if code paths vanish completely in the second profile, then there&#39;s nothing to color blue. You&#39;ll be looking at the current CPU usage, but missing information on how we got there.&lt;/p&gt;

&lt;p&gt;One solution is to reverse the order of the profiles and draw a negated flame graph differential. Eg:&lt;/p&gt;

&lt;p&gt;&lt;object data=&quot;/images/brendangregg.com/81122e6264570b8aefad9516038fef3a.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;720&quot; height=&quot;296&quot;&gt;
&lt;img src=&quot;/images/brendangregg.com/81122e6264570b8aefad9516038fef3a.jpg&quot; width=&quot;720&quot;&gt;
&lt;/object&gt;&lt;/p&gt;

&lt;p&gt;Now the widths show the first profile, and the colors show what &lt;em&gt;will&lt;/em&gt; happen. The blue highlighting on the right shows we&#39;re about to spend a lot less time in the CPU idle path. (Note that I usually filter out cpu_idle from the folded files, by including a grep -v cpu_idle.)&lt;/p&gt;

&lt;p&gt;This also highlights the vanishing code problem (or rather, &lt;em&gt;doesn&#39;t&lt;/em&gt; highlight), as since compression wasn&#39;t enabled in the &quot;before&quot; profile, there is nothing to color red.&lt;/p&gt;

&lt;p&gt;This was generated using:&lt;/p&gt;

&lt;pre&gt;
$ &lt;b&gt;./difffolded.pl out.folded2 out.folded1 | ./flamegraph.pl --negate &amp;gt; diff1.svg&lt;/b&gt;
&lt;/pre&gt;

&lt;p&gt;Which, along with the earlier diff2.svg, gives us:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;diff1.svg&lt;/strong&gt;: widths show the before profile, colored by what WILL happen&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;diff2.svg&lt;/strong&gt;: widths show the after profile, colored by what DID happen&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If I were to automate this for non-regression testing, I&#39;d generate and show both side by side.&lt;/p&gt;

&lt;h2&gt;CPI Flame Graphs&lt;/h2&gt;

&lt;p&gt;I first used this code for my &lt;a href=&quot;/blog/2014-10-31/cpi-flame-graphs.html&quot;&gt;CPI flame graphs&lt;/a&gt;, where instead of doing a difference between two profiles, I showed the difference between CPU cycles and stall cycles, which highlights what the CPUs were doing.&lt;/p&gt;

&lt;h2&gt;Other Differential Flame Graphs&lt;/h2&gt;

&lt;div style=&quot;float:right;padding-left:10px;padding-bottom:1px&quot;&gt;&lt;a href=&quot;http://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs/167&quot;&gt;&lt;img src=&quot;/images/brendangregg.com/6c97a332cb2bc9ee6379a7a58928be8d.jpg&quot; width=&quot;250&quot; border=&quot;0&quot;&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;There&#39;s other ways flame graph differentials can be done. &lt;a href=&quot;http://dtrace.org/blogs/rm&quot;&gt;Robert Mustacchi&lt;/a&gt; experimented with &lt;a href=&quot;http://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs/167&quot;&gt;differentials&lt;/a&gt; a while ago, and used an approach similar to a colored code review: only the difference is shown, colored red for added (increased) code paths, and blue for removed (decreased) code paths. The key difference is that the frame widths are now relative to the size of the difference only. An example is on the right. It&#39;s a good idea, but in practice I found it a bit weird, and hard to follow without the bigger picture context: a standard flame graph showing the full profile.&lt;/p&gt;

&lt;div style=&quot;float:right;padding-left:10px;padding-bottom:1px&quot;&gt;&lt;a href=&quot;https://github.com/corpaul/flamegraphdiff&quot;&gt;&lt;img src=&quot;/images/brendangregg.com/a8b78e5863c9d43ebbf6a4c588ea1548.jpg&quot; width=&quot;250&quot; border=&quot;0&quot;&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Cor-Paul Bezemer has created &lt;a href=&quot;http://corpaul.github.io/flamegraphdiff/&quot;&gt;flamegraphdiff&lt;/a&gt;, which shows the profile difference using three flame graphs at the same time: the standard before and after flame graphs, and then a differential flame graph where the widths show the difference. See the &lt;a href=&quot;http://corpaul.github.io/flamegraphdiff/demos/dispersy/dispersy_diff.html&quot;&gt;example&lt;/a&gt;. You can mouse-over frames in the differential, which highlights frames in all profiles. This solves the context problem, since you can see the standard flame graph profiles.&lt;/p&gt;

&lt;p&gt;My red/blue flame graphs, Robert&#39;s hue differential, and Cor-Paul&#39;s triple-view, all have their strengths. These could be combined: the top two flame graphs in Cor-Paul&#39;s view could be my diff1.svg and diff2.svg. Then the bottom flame graph colored using Robert&#39;s approach. For consistency, the bottom flame graph could use the same palette range as mine: blue-&amp;gt;white-&amp;gt;red.&lt;/p&gt;

&lt;p&gt;Flame graphs are spreading, and are now used by many companies. I wouldn&#39;t be surprised if there were already other implementations of flame graph differentials I didn&#39;t know about. (Leave a comment!)&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you have problems with performance regressions, red/blue differential flame graphs may be the quickest way to find the root cause. These take a normal flame graph and then use colors to show the difference between two profiles: red for greater samples, and blue for fewer. The size and shape of the flame graph shows the current (&quot;after&quot;) profile, so that you can easily see where the samples are based on the widths, and then the colors show how we got there: the profile difference.&lt;/p&gt;

&lt;p&gt;These differential flame graphs could also be generated by a nightly non-regression test suite, so that performance regressions can be quickly debugged after the fact.&lt;/p&gt;


</description>
        <pubDate>Sun, 09 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-09-differential-flame-graphs.html-eb140f444.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-09-differential-flame-graphs.html-eb140f444.html</guid>
        
        
        <category>brendangregg</category>
        
      </item>
    
      <item>
        <title>5 分钟上手 Tmux</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;如果你在做的项目需要你打开多个终端，那 Tmux（还有它的好基友 Tmuxinator）将会大大提高你的效率！Tmux 允许你在一个终端运行多个会话，Tmuxinator 则可以让你保存 tmux 的配置。&lt;/p&gt;
&lt;p&gt;例如你是一个Rails的开发者， 你可以很轻松的打开不同的会话，同时处理几件事，比如运行Rails服务器，一个Rails终端，一个tailing 日志。&lt;/p&gt;
&lt;p&gt;如果你是在一个&lt;a href=&quot;http://www.flyingmachinestudios.com/programming/building-a-forum-with-clojure-datomic-angular/&quot;&gt;Clojure-based forum&lt;/a&gt; 工作时， 我也可以打开几个会话， 一个shell，一个grunt服务器构建前端， 一个处理datomic数据库，一个用来部署，像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;pic&quot; alt=&quot;&quot; src=&quot;/images/jobbole.com/10e1a81be5ad75c584117ac852e8dbe9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我可以敲入一个命令 mux ath，就可以全都启动好。 这比需要记住每个服务，然后手动单个启动要方便的多。&lt;/p&gt;
&lt;p&gt;下面是一些上手 tmux 和tmuxinator的一些步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 首先，使用安装tmux 参考 &lt;a href=&quot;https://gist.github.com/simme/1297707&quot;&gt;in this gist&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;然后，使用 gem install  tmuxinator 安装 tmuxinator&lt;code&gt;&lt;br&gt;
&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;然后在~/.tmuxinator/sample.yml 创建你的 第一个 tmuxinator配置文件，配置文件类似于下面这样，&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;name: sample
root: ~/path/to/your/project
pre: git pull
windows:
  - shell: 
  - server: bundle exec rails s&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在打开窗口前，在root的目录中运行pre选项中的命令， 你可以使用这个配置文件打开tmux的会话， 你可以使用C-b n 切换到下个窗口，&lt;code&gt;C-b p&lt;/code&gt; 切换到前一个窗口， C-b p 意味着你按下了控制键，然后按下了‘b’键， 想要离开一个tmux会话，可以使用  C-b d， 如果你离开了这个会话，它仍然在运行，任何你在一个窗口中启动的进程都依然在运行，我很少使用其他的命令，如果你需要，可以参考这里  &lt;a href=&quot;http://cheat.errtheblog.com/s/tmux&quot;&gt;tmux cheatsheet&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;如果你要完全停掉一个会话，你需要杀死它， 使用tmux kill-session -t sample， sample是你的tmuxinator配置文件中name的选项名字，我创建了一个别名 alias “tmk”=”tmux kill-session -t”，然后就只要 tmk sample 就可以了&lt;/p&gt;
&lt;p&gt;我希望这个工具对你有所帮助， 更多信息，参考  &lt;a href=&quot;https://github.com/tmuxinator/tmuxinator&quot;&gt;tmuxinator’s github repo&lt;/a&gt;， 你可以干一些很炫的事，比如把屏幕切成多个，  这里还有一个参考书 &lt;a href=&quot;http://www.amazon.com/gp/product/1934356964/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=1934356964&amp;amp;linkCode=as2&amp;amp;tag=aflyingmachin-20&amp;amp;linkId=KX7OZEGOV4WX5K7W&quot;&gt;a handy book&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;我希望这些小建议对你有所帮助。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-08-79494-3c1703041.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-08-79494-3c1703041.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>你不知道的页面编码，浏览器选择编码，get，post各种乱码由来</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;strong&gt;asp.net页面编码和浏览器的选择编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个asp.net的朋友都知道，在新版本的visual studio，在没有任何设置的情况下，新建页面时的默认编码为utf-8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以从两个地方可以看出：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一：&lt;/strong&gt;打开aspx页面，“文件”-&amp;gt;“高级保存选项”，如下图，可以看出编码为：Unicode（UTF-8带签名）&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b62ea9762abc232aaa7bd7271782ef0b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二：&lt;/strong&gt;找到aspx存放路径，用系统自带的文本编辑器打开，然后“文件”-&amp;gt;”另存为”，如下图，可以看出编码为UTF-8&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c1a2e8fbcae174f37f383f78e5b06964.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;很多时候我们有些疑问，我们经常在aspx页面的&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;强制把carset改为gb2312&lt;/p&gt;
&lt;p&gt;然后我们在“文件”-&amp;gt;“高级保存选项”，可以看出编码为：GB2312（如果你前面把carset改为gb2312，vs会自动在高级保存选项中进行绑定改变）,然后编译运行后，右击html“查看源”发现&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;没有变化，这时候一切正常&lt;/p&gt;
&lt;p&gt;下面以IE为例：我们以为此时 “右击浏览器”-&amp;gt;“编码” 看到的是 浏览器会选中简体中文（GB2312）,但是事实上，你看到的还是选中的Unicode（UTF-8）  (再勾选了‘自动选择’前提下)&lt;/p&gt;
&lt;p&gt;现象已经很明显，但是需要验证浏览器为何会这样，F12调试浏览器（如下图），我们发现content-type竟然是“text/html；charset=utf-8”！&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/42453fac14aef0a0e43e15f8fe23f6da.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个现象至少说了两个问题点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;1、&lt;/strong&gt;&lt;/em&gt;asp.net机制至少在某个地方改变了response的ContentEncoding，导致虽然html页面代码上看到的设置&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;并没有生效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2、&lt;/em&gt;&lt;/strong&gt;浏览器再自动选择编码方式的时候不会优先根据html源码中的所展示的&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;代码来决定选择什么编码方式，很明显，以上的现象证明浏览器是优先根据“响应标头-response header”中的键为“Content-Type”的值来自动选择判断，导致html中的所看到的&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;形同虚设。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上两个问题点很快得到论证：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;问题1、&lt;/strong&gt;&lt;/em&gt;在任意新建一个测试页面，在第一个“}”处设置断点,然后命中断点后再“即时窗口”中写入“Response.ContentEncoding.EncodingName”，按enter执行，输出什么？没错：”Unicode (UTF-8)”&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;protected void Page_Load(object sender, EventArgs e)
{

}&lt;/pre&gt;
&lt;p&gt;如果了解asp.net生命机制的朋友知道，在执行到Page_Load之前已经执行了很多潜在的初始化事件，类似：Page_Init，LoadViewState， LoadPostData等等，可以想象一定是在某个地方系统为响应页面指定修改了ContentEncoding的值，也就是“响应标头-response header”中的键为“Content-Type”的值为“UTF-8”&lt;/p&gt;
&lt;p&gt;我们不妨做一个测试，上面说过，我把&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;的carset改为gb2312,是没有效果的，那么我如果在Page_Load事件中如下写上代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;protected void Page_Load(object sender, EventArgs e)
{
            Encoding gb2312 = Encoding.GetEncoding(&quot;gb2312&quot;);
            Response.ContentEncoding = gb2312;
 }&lt;/pre&gt;
&lt;p&gt;即我在load事件中再次强制性把响应标头中的“Content-Type”改为gb2312，那么浏览器表现如何呢？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6aa9fc339817cd2db675de39d4718ecf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ff598546ac6d0660237a6228dc5c3bd5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这正是我们想看到的，我相信很多朋友有过中文乱码的情况，我先不说具体乱码的解决方案，但是至少搜索发现很多解决方案是在web.config下添加如下节点，即把网站内所有网页的请求编码和响应编码都改为utf-8&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;&amp;lt;system.web&amp;gt;
&amp;lt;globalization requestEncoding=&quot;utf-8&quot; responseEncoding=&quot;utf-8&quot; /&amp;gt;
&amp;lt;/system.web&amp;gt;&lt;/pre&gt;
&lt;p&gt;其实，上面案例其实只是单个页面的修改response Encoding为gb2312，我们也可以在web.config中添加&amp;lt;globalization requestEncoding=”gb2312″ responseEncoding=”gb2312″ /&amp;gt;，即整个网站有效&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;问题2、&lt;/strong&gt;&lt;/em&gt;浏览器编码方式是根据“响应标头-response header”中的键为“Content-Type”的值来自动选择判断，而不会简单的根据你在html中看到的标签值&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&amp;gt;来判定，虽然这个标签一般情况下会写入header，但是有时候会被暗中修改掉，导致html中看到的和调试捕捉到的Content-Type不一致的情况&lt;/p&gt;
&lt;p&gt;当然在老版本的ie中，有时候出现的页面全部为空白，右击ie浏览器编码发现没有勾选“自动选择”的情况下会出现这种白屏现象，那不是本文讨论的范围，但是简单的说下原因（拷贝）：老版本的ie浏览器解析网页编码时以HTML内的标签优先，而后才是HTTP header内的讯息，而mozilla系列的浏览器则刚刚相反，由于UTF-8为3个字节表示一个汉字，而普通的GB2312或BIG5是两个。页面输出时，由于上述原因，使浏览器解析、输 出&amp;lt;title$amp;&amp;gt;amp;$lt;/title&amp;gt;的内容时，如果在&amp;lt;/title&amp;gt;前有奇数个全角字符时，IE把UTF-8当作两 个字节解析时出现半个汉字的情况，这时该半个汉字会和&amp;lt;/title&amp;gt;的&amp;lt;结合成一个乱码字，导致IE无法读 完&amp;lt;title&amp;gt;部分，使整个页面为空百输出。而这个时候如果察看源文件的话，会发现实际上整个叶面全部已经输出了&lt;/p&gt;
&lt;p&gt;解决方法：将&amp;lt;meta http-equiv=”Content-Type” content=”text/html; charset=utf-8″ /&amp;gt;放在&amp;lt;title&amp;gt;测试标题&amp;lt;/title&amp;gt;之前（好像现在新建网页默认都在title之前）&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;asp.net URL参数编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几乎所有的朋友都会遇到中文情况下乱码的问题，其原因到底是为何？&lt;/p&gt;
&lt;p&gt;我先不说乱码问题，先说get和post的区别，几乎没有人不知道&lt;/p&gt;
&lt;p&gt;我们在新建asp.net页面时，是很少去对form进行修改的，即保持默认的&amp;lt;form id=”form1″ runat=”server”&amp;gt;，可是编译运行后查看代码发现变成&amp;lt;form method=”post” action=”Default2.aspx” id=”form1″&amp;gt;&lt;/p&gt;
&lt;p&gt;很显然，asp.net默认会为form的method写上post，但是需要注意的是如果仅仅是单纯的html页面，form默认的method是get&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我这边可以举一个例子诠释一些无关紧要但是又比较重要的东西：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况1（post）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器选择编码 ：  &lt;/strong&gt;utf-8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译前的aspx  ：&lt;/strong&gt;  &amp;lt;form id=”form1″  runat=”server”&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行后的html  ：&lt;/strong&gt;  &amp;lt;form id=”form1″ action=”Default2.aspx” method=”post”&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击服务器按钮(按钮文本：阿道夫)：&lt;/strong&gt;F12在请求正文中有如下图内容&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/eefcc91951ecbb323eea06f4e7bf5ca6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况2（get）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器选择编码 ：  &lt;/strong&gt;utf-8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译前的aspx  ：&lt;/strong&gt;  &amp;lt;form id=”form1″  runat=”server” method=”get”&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行后的html  ：&lt;/strong&gt;  &amp;lt;form id=”form1″ action=”Default2.aspx” method=”get”&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击服务器按钮(按钮文本：阿道夫)：&lt;/strong&gt;F12在请求正文中有如下图内容&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/cf2b99ca759574904318487eddbe29c0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;其实，情况1和情况2的对比，并不是我今天想说的意图，但是我还是要稍微顺带说下：&lt;/p&gt;
&lt;p&gt;1、我们可以看到get方式的提交，参数仅仅是拼接在url后面，然后直接向web服务器请求，所以我们图中“请求标头-request header”中就可以看到参数的值，而post可以从图中看到，在“请求标头”中并看不到值，而在“请求正文”中看到值，说明post提交时值是包装在请求的body中，发送给服务器，然后向服务器请求数据&lt;/p&gt;
&lt;p&gt;2、在asp.net中，图中可以看到不管是get还是post，提交形式不一样，内容确是一样的，本文仅为测试，所以内容相对较少，但是看起来也非常的长了，如果用get提交方式，这就带来隐患，浏览器到底支持多长的uri，web服务器到底支持多长的uri，反正是有限制的（具体长度见：&lt;a href=&quot;http://www.cnblogs.com/henryhappier/archive/2010/10/09/1846554.html&quot;&gt;http://www.cnblogs.com/henryhappier/archive/2010/10/09/1846554.html&lt;/a&gt;），不仅仅是长度，数据量也是有限制，get数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，web服务器载体例如iis应该会有限制，比如IIS5的post最大传输量为100kb等&lt;/p&gt;
&lt;p&gt;3、安全性，get更加容易暴露参数，而且会被保存在浏览器的历史记录中，但是对于稍微专业点的人来说，post请求传送的数据也是可以被捕捉到的&lt;/p&gt;
&lt;p&gt;4、缓存和seo优化等就不提了&lt;/p&gt;
&lt;p&gt;5、&lt;strong&gt;编码问题！！！（这边上面说这么多，就是为了最后一个“编码问题”）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我将着重讲解编码问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Form元素的语法中，EncType表明提交数据的格式&lt;br&gt;
用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型。&lt;br&gt;
一般是下面几种类型：&lt;br&gt;
application/x-www-form-urlencoded： 窗体数据被编码为名称/值对。这是标准的编码格式。&lt;br&gt;
multipart/form-data： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。&lt;br&gt;
text/plain： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设此时使用get提交form方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器则会用x-www-form-urlencoded的数据格式，虽然在F12浏览器调试或者cs代码中的Request.ContentType都看不出来。注意如下是我的get提交的url：&lt;/p&gt;
&lt;p&gt;GET /Default2.aspx?__VIEWSTATE=MGASeC9kBMq4iDCI2YLRzkZYqkKYhDhWH2jlP5mpv7idP8gAoNcy0T0y6g6wRvccP%2BFz%2FVx4HdMGwLLW%2BYPbJsMEOTMi5PjS7Ea66DmHQJc%3D&amp;amp;__VIEWSTATEGENERATOR=9BD98A7D&amp;amp;__EVENTVALIDATION=BFMAr0Q6mSwngMhaCLeScGaXywIIRlFClDYAnVhHprxOeifBIGWKNbsunWO9yVOAV6jWHW%2FJ4g2laHQpTvJe%2Fc7X8vralK3hyO5Y0nuiJkT%2FdfxEj9NnCb8S5BfNvZKXVJA%2FOy8yH4Bf9K5DN%2FRI9aDR3EFR86Zm6fN4iEkvJfc%3D&amp;amp;Button2=%E9%98%BF%E9%81%93%E5%A4%AB&lt;/p&gt;
&lt;p&gt;我只看最后部分“Button2=%E9%98%BF%E9%81%93%E5%A4%AB”，这是我的服务器按钮“阿道夫”，这一串“%E9%98%BF%E9%81%93%E5%A4%AB”是“阿道夫”三个汉字编码后的，究竟这个编码方式到底是什么？又是如何经常引起乱码问题的呢？&lt;/p&gt;
&lt;p&gt;首先：get只能向服务器发送ASCII字符，这是W3C组织规定的，所以任何参数最后都要以ASCII码的形式传递，例如“Button2=%E9%98%BF%E9%81%93%E5%A4%AB”都是ASCII码中的英文字符和符号等字符，没有任何中文字符，其次编码方式是根据当前网页采用选择的编码来编码，例如asp.net网页使用的是utf-8码，那么“阿道夫”用utf-8的编码后的十六进制字符串就是“E9-98-BF-E9-81-93-E5-A4-AB”，和上面提到的“%E9%98%BF%E9%81%93%E5%A4%AB”是不是非常的类似，只是多了百分号&lt;/p&gt;
&lt;p&gt;如何查看中文字符的十六进制字符串？方法：BitConverter.ToString(System.Text.Encoding.&lt;strong&gt;UTF8&lt;/strong&gt;.GetBytes(“阿道夫”));&lt;/p&gt;
&lt;p&gt;如果用本文一开始介绍的方法，在Page_Load中加上&lt;/p&gt;
&lt;p&gt;Encoding gb2312 = Encoding.GetEncoding(“gb2312″);&lt;br&gt;
Response.ContentEncoding = gb2312;&lt;/p&gt;
&lt;p&gt;强制把当前页面编码改为gb2312，然后点击按钮，那么我们猜测在F12浏览器调试时，get提交的url的最后部分一定不再是“%E9%98%BF%E9%81%93%E5%A4%AB”，&lt;/p&gt;
&lt;p&gt;调试后发现是：“%B0%A2%B5%C0%B7%F2”&lt;/p&gt;
&lt;p&gt;那么用BitConverter.ToString(System.Text.Encoding.&lt;strong&gt;Default&lt;/strong&gt;.GetBytes(“阿道夫”))生成的值呢？答案是：B0-A2-B5-C0-B7-F2&lt;/p&gt;
&lt;p&gt;这一切证明了url参数编码方式是根据当前网页采用选择的编码来编码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后我将在服务端接受参数，这边有两种情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况1、&lt;/strong&gt;ok，我再次以get方式提交form，并是以utf-8编码（默认），此时，我在服务端通过Request.QueryString[&quot;Button2&quot;]，我将得到“阿道夫”，一切正常&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况2、&lt;/strong&gt;ok，我继续以get方式提交form，并是以gb2312编码（如何设置上文讲过），此时，我在服务端通过Request.QueryString[&quot;Button2&quot;]，我将得到“������”，正如我愿&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为何一开始正常，后面会出现乱码，我这边做几个假设：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设1、&lt;/strong&gt;对于情况1 的Request.QueryString[&quot;Button2&quot;]没有出现乱码，我是否可以猜测微软Request.QueryString内部自带有解码的操作？并且在这种情况下该操作是utf-8的解码方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设2、&lt;/strong&gt;对于情况2 的Request.QueryString[&quot;Button2&quot;]出现乱码,我是否可以猜测是因为微软Request.QueryString内部自带有解码的操作，并按照utf-8解码方式 解码我用gb2312编码的字符，这种不对称的解码肯定是错误的&lt;/p&gt;
&lt;p&gt;如何验证我的结论？&lt;a href=&quot;http://www.cnblogs.com/cyq1162/archive/2010/11/29/1891124.html&quot; target=&quot;_blank&quot;&gt;路过秋天&lt;/a&gt;  的这篇文章写的很详细，我总结下大概就是：&lt;/p&gt;
&lt;p&gt;反编译Request.QueryString属性，你会发现有这么如下代码：最后深入到代码关键点：this._queryString.FillFromEncodedBytes(queryStringBytes, this.QueryStringEncoding);从FillFromEncodedBytes方法中可以看出调用HttpUtility.UrlDecode(bytes, num2, num3 - num2, encoding)的解码方法，我们现在知道Request.QueryString内部实现是调用了HttpUtility.UrlDecode解码的方法，那么关键点就在HttpUtility.UrlDecode方法的第三个参数encoding到底是哪种解码方式&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public NameValueCollection QueryString
{
    get
    {
        this.EnsureQueryString();
        if (this._flags[1])
        {
            this._flags.Clear(1);
            this.ValidateHttpValueCollection(this._queryString, RequestValidationSource.QueryString);
        }
        return this._queryString;
    }
}

QueryString&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;internal HttpValueCollection EnsureQueryString()
{
    if (this._queryString == null)
    {
        this._queryString = new HttpValueCollection();
        if (this._wr != null)
        {
            this.FillInQueryStringCollection();
        }
        this._queryString.MakeReadOnly();
    }
    return this._queryString;
}

EnsureQueryString&lt;/pre&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private void FillInQueryStringCollection()
{
    byte[] queryStringBytes = this.QueryStringBytes;
    if (queryStringBytes != null)
    {
        if (queryStringBytes.Length != 0)
        {
            this._queryString.FillFromEncodedBytes(queryStringBytes, this.QueryStringEncoding);
            return;
        }
    }
    else
    {
        if (!string.IsNullOrEmpty(this.QueryStringText))
        {
            this._queryString.FillFromString(this.QueryStringText, true, this.QueryStringEncoding);
        }
    }
}&lt;/pre&gt;
&lt;p&gt;下面是FillFromEncodedBytes方法实现：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;internal void FillFromEncodedBytes(byte[] bytes, Encoding encoding)
{
    int num = (bytes != null) ? bytes.Length : 0;
    for (int i = 0; i &amp;lt; num; i++)
    {
        this.ThrowIfMaxHttpCollectionKeysExceeded();
        int num2 = i;
        int num3 = -1;
        while (i &amp;lt; num)
        {
            byte b = bytes[i];
            if (b == 61)
            {
                if (num3 &amp;lt; 0)
                {
                    num3 = i;
                }
            }
            else
            {
                if (b == 38)
                {
                    break;
                }
            }
            i++;
        }
        string name;
        string value;
        if (num3 &amp;gt;= 0)
        {
            name = HttpUtility.UrlDecode(bytes, num2, num3 - num2, encoding);
            value = HttpUtility.UrlDecode(bytes, num3 + 1, i - num3 - 1, encoding);
        }
        else
        {
            name = null;
            value = HttpUtility.UrlDecode(bytes, num2, i - num2, encoding);
        }
        base.Add(name, value);
        if (i == num - 1 &amp;amp;&amp;amp; bytes[i] == 38)
        {
            base.Add(null, string.Empty);
        }
    }
}&lt;/pre&gt;
&lt;p&gt;this.QueryStringEncoding是HttpUtility.UrlDecode解码的关键，我们发现系统默认会先取globalization配置节点的编码方式，如果取不到，则默认为UTF-8编码方式&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;internal Encoding QueryStringEncoding
{
    get
    {
        Encoding contentEncoding = this.ContentEncoding;
        if (!contentEncoding.Equals(Encoding.Unicode))
        {
            return contentEncoding;
        }
        return Encoding.UTF8;
    }
}&lt;/pre&gt;
&lt;div&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public Encoding ContentEncoding
{
    get
    {
        if (this._flags[32] &amp;amp;&amp;amp; this._encoding != null)
        {
            return this._encoding;
        }
        this._encoding = this.GetEncodingFromHeaders();
        if (this._encoding is UTF7Encoding &amp;amp;&amp;amp; !AppSettings.AllowUtf7RequestContentEncoding)
        {
            this._encoding = null;
        }
        if (this._encoding == null)
        {
            GlobalizationSection globalization = RuntimeConfig.GetLKGConfig(this._context).Globalization;
            this._encoding = globalization.RequestEncoding;
        }
        this._flags.Set(32);
        return this._encoding;
    }
    set
    {
        this._encoding = value;
        this._flags.Set(32);
    }
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;得出结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在method为get的提交方式中，如果在web.config中不配置任何globalization相关节点，那么Request.QueryString属性获取uri参数时会自动用utf-8解码，如果此时你的页面是采用gb2312编码，那么cs端获取必定会是乱码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法（form提交method为get）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法1、&lt;/strong&gt;配置globalization节点，例如&amp;lt;globalization requestEncoding=”gb2312″ responseEncoding=”gb2312″ fileEncoding=”gb2312″ culture=”zh-CN”/&amp;gt;&lt;br&gt;
那么get提交的uri附加的参数会采用gb2312编码，cs服务端Request.QueryString就会根据globalization配置的requestEncoding值gb2312进行内部的HttpUtility.UrlDecode&lt;br&gt;
&lt;strong&gt;方法2、&lt;/strong&gt;不配置globalization任何节点，在html端对将要拼接到uri后面的中文参数进行encodeURIComponent或者encodeURI编码处理，因为encodeURIComponent或者encodeURI就是utf-8的编码方法（永远不会变），然后再cs服务端Request.QueryString接收后，再用 HttpUtility.UrlDecode(“”, Encoding.Default)进行解码（或者用Server.UrlDecode（）解码，效果一样，Server.UrlDecode为使用当前操作系统的编码解码方式），如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;假设form method=get，当前环境ContentEncoding为gb2312&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;未做任何处理操作时要请求服务器的uri的一部分：&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
Default2.aspx?Button2=%B0%A2%B5%C0%B7%F2&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;在脚本端用encodeURIComponent对”阿道夫“进行编码后的将要请求服务器的uri的一部分：&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
Default2.aspx?Button2=%E9%98%BF%E9%81%93%E5%A4%AB&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;cs服务端:&lt;br&gt;
&lt;/em&gt;&lt;/strong&gt;string param1 = Request.QueryString[&quot;Button2&quot;];//param1的值为：%E9%98%BF%E9%81%93%E5%A4%AB，虽然Request.QueryString内部有utf-8解码操作，但是对于全是英文和符号等属于assic码的字符不会做任何解码操作（utf-8包含assic）&lt;br&gt;
string param2 = HttpUtility.UrlDecode(param1, Encoding.UTF8);//再针对性的用Encoding.UTF8对在脚本端用encodeURIComponent（编码方式为：utf-8）编码的param1进行对应解码，一切都安静了。值为“阿道夫”&lt;/p&gt;
&lt;p&gt;如果理解了编码解码的机制，那么如果仅仅是在cs服务端编码传递带有中文参数的url到另一个页面，也需要注意对应的编码解码问题，比如A页面的按钮点击后跳转到B页面，我举四种情况，大家判断哪种情况下在B页面接收时会有乱码出现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;备注： &lt;/em&gt;&lt;/strong&gt; HttpUtility.UrlDecode(param1)在没有第二个参数的情况下默认和HttpUtility.UrlDecode(param1, Encoding.UTF8)等效，除非你强制指定第二个参数比如：HttpUtility.UrlDecode(param1, Encoding.Default)&lt;br&gt;
第一种：没有配置任何globalization节点（&lt;strong&gt;正确&lt;/strong&gt;）&lt;br&gt;
A页面的按钮代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;protected void Button1_Click(object sender, EventArgs e)
         {
             string param = &quot;阿道夫&quot;;
             Response.Redirect(&quot;~/Default.aspx?param=&quot; + param);
         }&lt;/pre&gt;
&lt;p&gt;B页面的接收代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;string param1 = Request.QueryString[&quot;param&quot;];&lt;/pre&gt;
&lt;p&gt;第二种：配置了globalization节点&amp;lt;globalization requestEncoding=”gb2312″ responseEncoding=”gb2312″ fileEncoding=”gb2312″ culture=”zh-CN”/&amp;gt;（&lt;strong&gt;正确&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;A页面的按钮代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;protected void Button1_Click(object sender, EventArgs e)
         {
             string param = &quot;阿道夫&quot;;
             Response.Redirect(&quot;~/Default.aspx?param=&quot; + param);
         }&lt;/pre&gt;
&lt;p&gt;B页面的接收代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;string param1 = Request.QueryString[&quot;param&quot;];&lt;/pre&gt;
&lt;p&gt;第三种：没有配置任何globalization节点（&lt;strong&gt;正确&lt;/strong&gt;）&lt;br&gt;
A页面的按钮代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;protected void Button1_Click(object sender, EventArgs e)
         {
             string param = &quot;阿道夫&quot;;
             Response.Redirect(&quot;~/Default.aspx?param=&quot; + HttpUtility.UrlEncode(param));
         }&lt;/pre&gt;
&lt;p&gt;B页面的接收代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;string param1 = Request.QueryString[&quot;param&quot;];&lt;/pre&gt;
&lt;p&gt;第四种：配置了globalization节点&amp;lt;globalization requestEncoding=”gb2312″ responseEncoding=”gb2312″ fileEncoding=”gb2312″ culture=”zh-CN”/&amp;gt;（&lt;strong&gt;乱码&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;A页面的按钮代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;protected void Button1_Click(object sender, EventArgs e)
         {
             string param = &quot;阿道夫&quot;;
             Response.Redirect(&quot;~/Default.aspx?param=&quot; + HttpUtility.UrlEncode(param));
         }&lt;/pre&gt;
&lt;p&gt;B页面的接收代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;string param1 = Request.QueryString[&quot;param&quot;];&lt;/pre&gt;
&lt;p&gt;参考上面的解释，应该能理解为何第四种是乱码，这里不再做太多解释&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外在jquery被大行其道的现在，&lt;/strong&gt;$.ajax{}、$.post()、$.get()等函数使用时更是应该注意编码解码的问题，大致注意如下：&lt;br&gt;
如果你的页面使用的是gb2312编码，不要用jquery的$.get()或$.post()做ajax提交，因为这两个方法默认为utf-8，而且是无法指定修改contentType的，默认为：contentType:”pplication/x-www-form-urlencoded; charset=UTF-8″，为什么无法修改？因为$.post 和$.get()本身就只是 $.ajax 的 post 或者get方式的一种简写形式，既然是简写为了方便使用当然会固定死很多属性&lt;br&gt;
可以用$.ajax()并在其中加入：contentType:”application/x-www-form-urlencoded; charset=GB2312″;&lt;br&gt;
写成以下形式，可以在大多数情况避免乱码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;$.ajax({ 
  type: &quot;POST&quot;,
 contentType:&quot;pplication/x-www-form-urlencoded; charset=GB2312&quot;, 
  url: &quot;XXX“, 
  data: {},
  success: function(msg){ alert( msg ); }
});&lt;/pre&gt;
&lt;p&gt;*****以上使用get提交form方式的介绍真的可以告一段落，我想我写的很臃肿，表达上会有很多冗余的地方******&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面介绍post提交form的方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在asp.net页面的form不做任何处理的时候，默认编译生成html时会自动加上method=”post” ，F12调试，发现Content-Type的值是：application/x-www-form-urlencoded，这也是我上面提到过的Form元素的EncType属性：表明提交数据的格式&lt;br&gt;
一般Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型。&lt;br&gt;
application/x-www-form-urlencoded： 窗体数据被编码为名称/值对。这是标准的编码格式。&lt;br&gt;
multipart/form-data： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。&lt;br&gt;
text/plain： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符&lt;/p&gt;
&lt;p&gt;那也就是说，假如我使用post方式提交，Enctype为application/x-www-form-urlencoded，那么那些需要提交服务器的值依然会被编码，只不过这次不是拼接在uri后面，而是存放在body里面，那么这样依然在不小心的情况下会带来上面描述的乱码问题，当然如果你是post提交，（或者你在asp.net页面不操作form任何属性，保持默认）那么在cs服务端请不要再用Request.QueryString获取值了，这是获取不到的，应该用Request.Form[&quot;&quot;]，请尽量少用Request[&quot;&quot;]或者Request.Params[&quot;&quot;]，这两个将加大你的遍历搜索你需要参数值的范围，Request可以访问的有QueryString、Form、Cookies 或 ServerVariables这4个集合的数据，get请求用Request.QueryString，post用Request.Form，而Request[&quot;&quot;]是依次访问这4个集合，找到就返回结果，而Request.Params[&quot;&quot;]是在访问时，先将4个集合的数据合并到一个新集合(集合不存在时创建)再去查找，效率可想而知&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;我现在手动将form改为：&amp;lt;form id=”form1″ enctype=”multipart/form-data” method=”post” runat=”server”&amp;gt; 注意multipart/form-data只能用于post&lt;/p&gt;
&lt;p&gt;浏览器会把整个表单以控件为单位分割，并为每个部分加上Content-Disposition(form-data或者file),Content-Type(默认为text/plain),name(控件name)等信息，并加上分割符&lt;br&gt;
&lt;strong&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/aa207300263aceddce82a73190123285.jpg&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/14392398024ed2438b738da2f602714f.jpg&quot;&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“boundary”是分隔符的意思，一般multipart/form-data用于文件上传，普通的传参或者提交form元素列表值还是使用默认的application/x-www-form-urlencoded吧&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Thu, 06 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-06-79424-c859d07eb.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-06-79424-c859d07eb.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>我的Git笔记</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;转眼间加入git的阵营已经快两年了，结识git，缘起github，2年前在寻找代码托管网站，当时还是用svn，起初使用google code，可是google的服务虽好，在天朝你懂得，后来发现了github，多亏了蒋鑫老师的《GotGitHub》将我带入github的大门，如果你是个github新手，那我强烈建议你阅读这篇文章，里面讲了很多东西。&lt;/p&gt;
&lt;p&gt;起初的时候我是用github for windows这个客户端，在切换到多分支的时候被，自动转换换行符坑的不浅，后来越来阅读了《&lt;a href=&quot;http://www.open-open.com/lib/view/open1328069609436.html&quot; target=&quot;_blank&quot;&gt;git详解&lt;/a&gt;》系列文章，对git的了解深入了一步，并开始转到命令行上来，如今我在github上开源了60几个库，借助git，可自由在这些项目之间穿梭，同时还维护了github家园的微博和Q群(193091696)，如果你想获取关于git和github的最新消息可以关注微博，如果你有什么疑问或者问题，欢迎加群一起讨论。&lt;/p&gt;
&lt;p&gt;这篇文章记录个人常用的一些命令，和记不住的一些命令。&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;在 Windows 上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;http://msysgit.github.io/&lt;/pre&gt;
&lt;p&gt;完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;首先是配置帐号信息&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git config --global user.name yanhaijing
git config --global user.email yanhaijing@yeah.net

git config --list#查看配置的信息

git help config#获取帮助信息&lt;/pre&gt;
&lt;p&gt;配置自动换行（自动转换坑太大）&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git config --global core.autocrlf input #提交到git是自动将换行符转换为lf&lt;/pre&gt;
&lt;p&gt;配置密钥&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;ssh-keygen -t rsa -C yanhaijing@yeah.net #生成密钥

ssh -T git@github.com #测试是否成功&lt;/pre&gt;
&lt;h2 id=&quot;section-2&quot;&gt;新建仓库&lt;/h2&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git init#初始化
git status#获取状态
git add file#.或*代表全部添加
git commit -m &quot;message&quot;#此处注意乱码
git remote add origin git@github.com:yanhaijing/test.git#添加源
git push -u origin master#push同事设置默认跟踪分支&lt;/pre&gt;
&lt;h2 id=&quot;section-3&quot;&gt;从现有仓库克隆&lt;/h2&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git clone git://github.com/yanhaijing/data.js.git	
git clone git://github.com/schacon/grit.git mypro#克隆到自定义文件夹&lt;/pre&gt;
&lt;h2 id=&quot;section-4&quot;&gt;本地&lt;/h2&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git add *#跟踪新文件

rm *&amp;amp;git rm *#移除文件
git rm -f *#移除文件
git rm --cached *#取消跟踪
git mv file_from file_to#重命名跟踪文件

git log#查看提交记录

git commit#提交更新
git commit -m &#39;message&#39;
git commit -a#跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交
git commit --amend#修改最后一次提交

git reset HEAD *#取消已经暂存的文件

git checkout -- file#取消对文件的修改（从暂存区去除file）
git checkout branch|tag|commit -- file_name#从仓库取出file覆盖当前分支
git checkout -- .#从暂存区去除文件覆盖工作区&lt;/pre&gt;
&lt;h2 id=&quot;section-5&quot;&gt;分支&lt;/h2&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git branch#列出本地分支
git branch -r#列出远端分支
git branch -a#列出所有分支
git branch -v#查看各个分支最后一个提交对象的信息
git branch --merge#查看已经合并到当前分支的分支
git branch --no-merge#查看为合并到当前分支的分支

git branch test#新建test分支
git checkout test#切换到test分支
git checkout -b test#新建+切换到test分支
git checkout -b test dev#基于dev新建test分支，并切换

git branch -d test#删除test分支
git branch -D test#强制删除test分支

git merge test#将test分支合并到当前分支
git rebase master#将master分之上超前的提交，变基到当前分支&lt;/pre&gt;
&lt;h2 id=&quot;section-6&quot;&gt;远端&lt;/h2&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git fetch originname branchname#拉去远端上指定分支
git merge originname branchname#合并远端上指定分支
git push originname branchname#推送到远端上指定分支
git push originname localbranch:serverbranch#推送到远端上指定分支

git checkout -b test origin/dev#基于远端dev新建test分支

git push origin :server#删除远端分支&lt;/pre&gt;
&lt;h2 id=&quot;section-7&quot;&gt;源&lt;/h2&gt;
&lt;p&gt;git是一个分布式代码管理工具，所以可以支持多个仓库，在git里，服务器上的仓库在本地称之为remote。&lt;/p&gt;
&lt;p&gt;个人开发时，多源用的可能不多，但多源其实非常有用。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git remote add origin1 git@github.com:yanhaijing/data.js.git

git remote#显示全部源
git remote -v#显示全部源+详细信息

git remote rename origin1 origin2#重命名

git remote rm origin1#删除

git remote show origin1#查看指定源的全部信息&lt;/pre&gt;
&lt;h2 id=&quot;section-8&quot;&gt;标签&lt;/h2&gt;
&lt;p&gt;当开发到一定阶段时，给程序打标签是非常棒的功能。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git tag#列出现有标签	

git tag v0.1#新建标签
git tag -a v0.1 -m &#39;my version 1.4&#39;#新建带注释标签

git checkout tagname#切换到标签

git push origin v1.5#推送分支到源上
git push origin --tags#一次性推送所有分支

git tag -d v0.1#删除标签
git push origin :refs/tags/v0.1#删除远程标签&lt;/pre&gt;
&lt;h2 id=&quot;section-9&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;啊哈！终于总结完了，以后不会的时候，再也不用到处去找了。&lt;/p&gt;
&lt;p&gt;其实还有两个最有用的命令还未提到。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;git help *#获取命令的帮助信息
git status#获取当前的状态，非常有用，因为git会提示接下来的能做的事情&lt;/pre&gt;
&lt;h2 id=&quot;section-10&quot;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://gitref.org/zh/index.html&quot;&gt;Git参考手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mceiba.com/tool/git-cheat-sheet.html&quot;&gt;Git简明手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/&quot;&gt;Git Magic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gitbook.liuhui998.com/index.html&quot;&gt;Git Community Book 中文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git-scm.com/book/en/v2&quot;&gt;Pro Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://marklodato.github.io/visual-git-guide/index-zh-cn.html&quot;&gt;图解Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://rogerdudler.github.io/git-guide/index.zh.html&quot;&gt;git-简明指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pcottle.github.io/learnGitBranching/&quot;&gt;learnGitBranching&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Thu, 06 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-06-79417-b73b5e65d.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-06-79417-b73b5e65d.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>如何简单解释 MapReduce 算法</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在Hackbright做导师期间，我被要求向技术背景有限的学生解释&lt;a href=&quot;https://en.wikipedia.org/wiki/MapReduce&quot;&gt;MapReduce算法&lt;/a&gt;，于是我想出了一个有趣的例子，用以阐释它是如何工作的。&lt;/p&gt;
&lt;h2&gt;例子&lt;/h2&gt;
&lt;p&gt;你想数出一摞牌中有多少张黑桃。直观方式是一张一张检查并且数出有多少张是黑桃。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c97c630b70a357d86c6b14106640b8f5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;MapReduce方法则是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给在座的所有玩家中分配这摞牌&lt;/li&gt;
&lt;li&gt;让每个玩家数自己手中的牌有几张是黑桃，然后把这个数目汇报给你&lt;/li&gt;
&lt;li&gt;你把所有玩家告诉你的数字加起来，得到最后的结论&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;谷歌在2004年发表了可以分析大量数据的&lt;a href=&quot;http://research.google.com/archive/mapreduce.html&quot;&gt;MapReduce&lt;/a&gt;算法。每当你听到“大数据”这个词时，它指的是因为太大而让仅仅一台机器难以有效存储或分析的问题。MapReduce通过把计算量分配给不同的计算机群，能够解决大部分和大数据有关的分析问题。&lt;a href=&quot;https://en.wikipedia.org/wiki/Apache_Hadoop&quot;&gt;Hadoop&lt;/a&gt;提供了最受欢迎的利用MapReduce算法来管理大数据的开源方式。现今MapReduce是主流。&lt;/p&gt;
&lt;p&gt;所以通常来说，每当你听到“大数据”，那也许意味着Hadoop被用来存储数据，也通常意味着数据的抽取和检索是用的MapReduce。&lt;/p&gt;
&lt;h2&gt;拆分&lt;/h2&gt;
&lt;p&gt;MapReduce合并了两种经典函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;映射（Mapping）&lt;/strong&gt;对集合里的每个目标应用同一个操作。即，如果你想把表单里每个单元格乘以二，那么把这个函数单独地应用在每个单元格上的操作就属于mapping。&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;化简（Reducing ）&lt;/strong&gt;遍历集合中的元素来返回一个综合的结果。即，输出表单里一列数字的和这个任务属于reducing。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;重新审视上面的例子&lt;/h2&gt;
&lt;p&gt;重新审视我们原来那个分散纸牌的例子，我们有MapReduce数据分析的基本方法。友情提示：这不是个严谨的例子。在这个例子里，人代表计算机，因为他们同时工作，所以他们是个&lt;strong&gt;集群&lt;/strong&gt;。在大多数实际应用中，我们假设数据已经在每台计算机上了 – 也就是说把牌分发出去并不是MapReduce的一步。（事实上，在计算机集群中如何存储文件是Hadoop的真正核心。）&lt;/p&gt;
&lt;p&gt;通过把牌分给多个玩家并且让他们各自数数，你就在&lt;strong&gt;并行&lt;/strong&gt;执行运算，因为每个玩家都在同时计数。这同时把这项工作变成了&lt;strong&gt;分布式的&lt;/strong&gt;，因为多个不同的人在解决同一个问题的过程中并不需要知道他们的邻居在干什么。&lt;/p&gt;
&lt;p&gt;通过告诉每个人去数数，你对一项检查每张牌的任务进行了映射。 你不会让他们把黑桃牌递给你，而是让他们把你想要的东西化简为一个数字。&lt;/p&gt;
&lt;p&gt;另外一个有意思的情况是牌分配得有多均匀。MapReduce假设数据是&lt;strong&gt;洗过的&lt;/strong&gt;（&lt;strong&gt;shuffled&lt;/strong&gt;）- 如果所有黑桃都分到了一个人手上，那他数牌的过程可能比其他人要慢很多。&lt;/p&gt;
&lt;p&gt;如果有足够的人的话，问一些更有趣的问题就相当简单了 - 比如“一摞牌的平均值（二十一点算法）是什么”。你可以通过合并“所有牌的值的和是什么”及“我们有多少张牌”这两个问题来得到答案。用这个和除以牌的张数就得到了平均值。&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;MapReduce算法的机制要远比这复杂得多，但是主体思想是一致的 – 通过分散计算来分析大量数据。无论是Facebook、NASA，还是小创业公司，MapReduce都是目前分析互联网级别数据的主流方法。有趣的是，MapReduce在多于10PB数据时趋向于变慢，所以谷歌在他们今年的IO大会上报告称MapReduce已经不够他们用了，请参见这篇资讯《&lt;strong&gt;&lt;a href=&quot;../72145/&quot; target=&quot;_blank&quot;&gt;谷歌弃用 MapReduce, 推出替代品 Cloud Dataflow&lt;/a&gt;&lt;/strong&gt;》。&lt;/p&gt;
&lt;h3&gt;推荐阅读：《&lt;a href=&quot;../1321/&quot; target=&quot;_blank&quot;&gt;我是如何向老婆解释MapReduce的？&lt;/a&gt;》&lt;/h3&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Thu, 06 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-06-79255-b02567a57.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-06-79255-b02567a57.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>回收站功能在 Linux 中的实现</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;本文仿照 Windows 回收站的功能，运用 Bash 脚本在 Linux 上做了实现，创建 delete 脚本代替 rm 命令对文件或目录进行删除操做。该脚本实现了以下功能：对大于 2G 的文件或目录直接删除，否则放入$HOME/trash 目录下；恢复 trash 目录中的被删除文件到原目录下；文件存放在 trash 目录中超过七天被自动删除。&lt;/p&gt;
&lt;h2 id=&quot;2.概述 |outline&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;删除是危险系数很高的操作，一旦误删可能会造成难以估计的损失。在 Linux 系统中这种危险尤为明显，一条简单的语句：rm –rf /* 就会把整个系统全部删除，而 Linux 并不会因为这条语句的不合理而拒绝执行。 在 Windows 中，为了防止误删，系统提供了回收站功能。用户在执行删除操作后，文件并不会直接从硬盘中删除，而是被放到回收站中。在清空回收站前，如果发现有文件被误删，用户可以将回收站中的文件恢复到原来的位置。而 Linux 并没有提供类似功能，删除命令 rm 一旦确认执行，文件就会直接从系统中删除，很难恢复。&lt;/p&gt;
&lt;h2 id=&quot;3.回收站构成 |outline&quot;&gt;回收站构成&lt;/h2&gt;
&lt;p&gt;本文共用三个脚本实现了回收站的主要功能：Delete 脚本、logTrashDir 脚本和 restoreTrash 脚本。其中 Delete 脚本是核心脚本，其作用是重新封装 rm 命令。相对于 rm 的直接删除，该命令会先将文件或目录移动到$home/trash 目录下。如果用户想要将文件直接删除，可以用 -f 选项，delete 脚本会直接调用 rm –f 命令将文件从硬盘上删除。logTrashDir 脚本用于将被删除文件的信息记录到 trash 目录下的一个隐藏文件中。restoreTrash 脚本用来将放入 trash 中的文件或目录重新恢复到原路径下。在 Linux 系统中，只要将这三个脚本放到/bin/目录下，并用 chmod +X filename 赋予可执行权限，即可直接使用。下面将介绍每个脚本的主要部分&lt;/p&gt;
&lt;h2 id=&quot;4.Delete 脚本 |outline&quot;&gt;Delete 脚本&lt;/h2&gt;
&lt;h3 id=&quot;N1005A&quot;&gt;创建目录&lt;/h3&gt;
&lt;p&gt;首先要创建目录来存放被删除的文件，本文在用户根目录$HOME 下建立 trash 目录来存放文件。具体代码如下：&lt;/p&gt;
&lt;h5 id=&quot;N10063&quot;&gt;清单 1.创建回收站目录&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;realrm=&quot;/bin/rm&quot;
if [ ! -d ~/trash ]
 then
      mkdir -v ~/trash
      chmod 777 ~/trash
 fi&lt;/pre&gt;
&lt;p&gt;如上所示，先判断目录是否已建立，如未建立，即第一次运行该脚本，则创建 trash 目录。变量 realrm 存放了 Linux 的 rm 脚本位置，用于在特定条件下调用以直接删除文件或目录。&lt;/p&gt;
&lt;h3 id=&quot;N1006A&quot;&gt;输出帮助信息&lt;/h3&gt;
&lt;p&gt;该脚本在用户仅输入脚本名而未输入参数执行时，输出简要帮助信息，代码如下：&lt;/p&gt;
&lt;h5 id=&quot;N10073&quot;&gt;清单 2.输出帮助信息&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;if [ $# -eq 0 ]
  then
      echo &quot;Usage:delete file1 [file2 file3....]&quot;
      echo &quot;If the options contain -f,then the script will exec &#39;rm&#39; directly&quot;&lt;/pre&gt;
&lt;p&gt;如代码所示，该脚本的运用格式是 delete 后跟要删除的文件或目录的路径，中间用空格隔开。&lt;/p&gt;
&lt;h3 id=&quot;N1007A&quot;&gt;直接删除文件&lt;/h3&gt;
&lt;p&gt;有些用户确认失效并想直接删除的文件，不应放入回收站中，而应直接从硬盘中删除。Delete 脚本提供了-f 选项来执行这项操作：&lt;/p&gt;
&lt;h5 id=&quot;N10083&quot;&gt;清单 3.直接删除文件&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;while getopts &quot;dfiPRrvW&quot; opt
      do
        case $opt in
            f)
               exec $realrm &quot;$@&quot;
                ;;
            *)
               
               # do nothing     
                ;;
        esac
      done&lt;/pre&gt;
&lt;p&gt;如果用户在命令中加入了-f 选项，则 delete 脚本会直接调用 rm 命令将文件或目录直接删除。如代码中所示，所有的参数包括选项都会传递给 rm 命令。所以只要选项中包括选项-f 就等于调用 rm 命令，可以使用 rm 的所有功能。如：delete –rfv filename 等于 rm –rfv filename。&lt;/p&gt;
&lt;h3 id=&quot;N1008A&quot;&gt;用户交互&lt;/h3&gt;
&lt;p&gt;需要与用户确认是否将文件放入回收站。相当于 Windows 的弹窗提示，防止用户误操作。&lt;/p&gt;
&lt;h5 id=&quot;N10093&quot;&gt;清单 4.用户交互&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;echo -ne &quot;Are you sure you want to move the files to the trash?[Y/N]:\a&quot;
 read reply
if [ $reply = &quot;y&quot; -o $reply = &quot;Y&quot; ]
  then #####&lt;/pre&gt;
&lt;h3 id=&quot;N10098&quot;&gt;判断文件类型并直接删除大于 2G 文件&lt;/h3&gt;
&lt;p&gt;本脚本只对普通文件和目录做操作，其他类型文件不做处理。先对每个参数做循环，判断他们的类型，对于符合的类型再判断他们的大小是否超过 2G，如果是则直接从系统中删除，避免回收站占用太大的硬盘空间。&lt;/p&gt;
&lt;h5 id=&quot;N100A1&quot;&gt;清单 5.删除大于 2G 的文件&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;for file in $@
 do
if [ -f &quot;$file&quot; –o –d &quot;$file&quot; ]
then
if [ -f &quot;$file&quot; ] &amp;amp;&amp;amp; [ `ls –l $file|awk &#39;{print $5}&#39;` -gt 2147483648 ]
   then
      echo &quot;$file size is larger than 2G,will be deleted directly&quot;
        `rm –rf $file`
elif [ -d &quot;$file&quot; ] &amp;amp;&amp;amp; [ `du –sb $file|awk &#39;{print $1}&#39;` -gt 2147483648 ]
   then
      echo &quot;The directory:$file is larger than 2G,will be deleted directly&quot;
        `rm –rf $file`&lt;/pre&gt;
&lt;p&gt;如以上代码所示，该脚本用不同的命令分别判断目录和文件的大小。鉴于目录的大小应该是包含其中的文件以及子目录的总大小，所以运用了’du -sb’命令。两种情况都使用了 awk 来获取特定输出字段的值来作比较。&lt;/p&gt;
&lt;h3 id=&quot;N100A8&quot;&gt;移动文件到回收站并做记录&lt;/h3&gt;
&lt;p&gt;该部分是 Delete 脚本的主要部分，主要完成以下几个功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取参数的文件名。因为用户指定的参数中可能包含路径，所以要从中获取到文件名，用来生成 mv 操作的参数。该脚本中运用了字符串正则表达式’${file##*/}’来获取。&lt;/li&gt;
&lt;li&gt;生成新文件名。在原文件名中加上日期时间后缀以生成新的文件名，这样用户在浏览回收站时，对于每个文件的删除日期即可一目了然。&lt;/li&gt;
&lt;li&gt;生成被删文件的绝对路径。为了以后可能对被删文件进行的恢复操作，要从相对路径生成绝对路径并记录。用户输入的参数可能有三种情况：只包含文件名的相对路径，包含点号的相对路径以及绝对路径，脚本中用字符串处理对三种情况进行判断，并进行相应的处理。&lt;/li&gt;
&lt;li&gt;调用 logTrashDir 脚本，将回收站中的新文件名、原文件名、删除时间、原文件绝对路径记录到隐藏文件中&lt;/li&gt;
&lt;li&gt;将文件通过 mv 命令移动到 Trash 目录下。详细代码如下所示：&lt;br&gt;
&lt;h5 id=&quot;N100BE&quot;&gt;清单 6.移动文件到回收站并做记录&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;now=`date +%Y%m%d_%H_%M_%S`
filename=&quot;${file##*/}&quot;
newfilename=&quot;${file##*/}_${now}&quot;
mark1=&quot;.&quot;
mark2=&quot;/&quot;
if  [ &quot;$file&quot; = ${file/$mark2} ]
 then
  fullpath=&quot;$(pwd)/$file&quot;
elif [ &quot;$file&quot; != ${file/$mark1} ]
 then
  fullpath=&quot;$(pwd)${file/$mark1}&quot;
else
  fullpath=&quot;$file&quot;
fi	    
echo &quot;the full path of this file is :$fullpath&quot;
if mv -f $file ~/trash/$newfilename
 then
  $(/logTrashDir &quot;$newfilename $filename $now $fullpath&quot;)
   echo &quot;files: $file is deleted&quot;
 else
  echo &quot;the operation is failed&quot;
 fi&lt;/pre&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2 id=&quot;5.logTrashDir 脚本 |outline&quot;&gt;logTrashDir 脚本&lt;/h2&gt;
&lt;p&gt;该脚本较简单，仅是一个简单的文件写入操作，之所以单独作为一个脚本，是为了以后扩展的方便，具体代码如下：&lt;/p&gt;
&lt;h5 id=&quot;N100CC&quot;&gt;清单 7.logTrashDir 代码&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;if [ ! -f ~/trash/.log ]
  then
     touch ~/trash/.log
     chmod 700~/trash/.log
fi
   echo $1 $2 $3 $4&amp;gt;&amp;gt; ~/trash/.log&lt;/pre&gt;
&lt;p&gt;该脚本先建立.log 隐藏文件，然后往里添加删除文件的记录。&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2 id=&quot;6.restoreTrash 脚本 |outline&quot;&gt;restoreTrash 脚本&lt;/h2&gt;
&lt;p&gt;该脚本主要完成以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从.log 文件中找到用户想要恢复的文件对应的记录。此处依然使用 awk，通过正表达式匹配找到包含被删除文件名的一行&lt;/li&gt;
&lt;li&gt;从记录中找到记录原文件名的字段，以给用户提示&lt;/li&gt;
&lt;li&gt;将回收站中的文件移动到原来的位置，在这里运用了 mv –b 移动文件，之所以加入-b 选项是为了防止原位置有同名文件的情况。&lt;/li&gt;
&lt;li&gt;将.log 文件中与被恢复文件相对应的记录删除&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;N100E5&quot;&gt;清单 8.获取相应记录&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;originalPath=$(awk /$filename/&#39;{print $4}&#39; &quot;$HOME/trash/.log&quot;)&lt;/pre&gt;
&lt;h5 id=&quot;N100EC&quot;&gt;清单 9.查找原文件名及现文件名字段&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;filenameNow=$(awk /$filename/&#39;{print $1}&#39; ~/trash/.log)
filenamebefore=$(awk /$filename/&#39;{print $2}&#39; ~/trash/.log)
echo &quot;you are about to restore $filenameNow,original name is $filenamebefore&quot;
echo &quot;original path is $originalPath&quot;&lt;/pre&gt;
&lt;h5 id=&quot;N100F3&quot;&gt;清单 10.恢复文件到原来位置并删除相应记录&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;echo &quot;Are you sure to do that?[Y/N]&quot;
  read reply
  if [ $reply = &quot;y&quot; ] || [ $reply = &quot;Y&quot; ]
   then
$(mv -b &quot;$HOME/trash/$filename&quot; &quot;$originalPath&quot;)
$(sed -i /$filename/&#39;d&#39; &quot;$HOME/trash/.log&quot;)
  else
    echo &quot;no files restored&quot;
  fi&lt;/pre&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2 id=&quot;7.自动定期清理 trash 目录 |outline&quot;&gt;自动定期清理 trash 目录&lt;/h2&gt;
&lt;p&gt;因为 delete 操作并不是真正删除文件，而是移动操作，经过一段时间的积累，trash 目录可能会占用大量的硬盘空间，造成资源浪费，所以定期自动清理 trash 目录下的文件是必须得。本文的清理规则是：在回收站中存在 7 天以上的文件及目录将会被自动从硬盘中删除。运用的工具是 Linux 自带的 crontab。&lt;/p&gt;
&lt;p&gt;Crontab 是 Linux 用来定期执行程序的命令。当安装完成操作系统之后，默认便会启动此任务调度命令。Crontab 命令会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。而 Linux 任务调度的工作主要分为以下两类：&lt;/p&gt;
&lt;p&gt;1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存&lt;/p&gt;
&lt;p&gt;2、个人执行的工作：某个用户定期要做的工作，例如每隔 10 分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置。&lt;/p&gt;
&lt;p&gt;首先编写 crontab 执行时要调用的脚本 cleanTrashCan.如清单 10 所示，该脚本主要完成两项功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断回收站中的文件存放时间是否已超过 7 天，如果超过则从回收站中删除。&lt;/li&gt;
&lt;li&gt;将删除文件在.log 文件中相应的记录删除，保持其中数据的有效性，提高查找效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;N1010E&quot;&gt;清单 11.删除存在回收站超过 7 天的文件并删除.log 中相应记录&lt;/h5&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;arrayA=($(find ~/trash/* -mtime +7 | awk &#39;{print $1}&#39;))
   for file in ${arrayA[@]}
    do
      $(rm -rf &quot;${file}&quot;)
      filename=&quot;${file##*/}&quot;
      echo $filename
      $(sed -i /$filename/&#39;d&#39; &quot;$HOME/trash/.log&quot;)
    done&lt;/pre&gt;
&lt;p&gt;脚本编写完成后通过 chmod 命令赋予其执行权限，然后运过 crontab –e 命令添加一条新的任务调度：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt; 10 18 * * * /bin/ cleanTrashCan&lt;/pre&gt;
&lt;p&gt;该语句的含义为，在每天的下午 6 点 10 分执行 cleanTrashCan 脚本&lt;/p&gt;
&lt;p&gt;通过这条任务调度，trash 的大小会得到有效的控制，不会持续增大以致影响用户的正常操作。&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2 id=&quot;8.实际应用 |outline&quot;&gt;实际应用&lt;/h2&gt;
&lt;p&gt;首先要将 delete 脚本，logTrashDir 脚本，restoreTrash 脚本和 cleanTrashCan 放到/bin 目录下，然后用 chmod +x delete restoreTrash logTrashDir cleanTrashCan 命令赋予这三个脚本可执行权限。&lt;/p&gt;
&lt;p&gt;运用 delete 脚本删除文件，例如要删除在/usr 目录下的 useless 文件。根据用户目前所在的位置，可以用相对路径或绝对路径来指定参数，如：delete useless，delete ./useless 或者 delete /usr/useless。执行过程如图 1 所示：&lt;/p&gt;
&lt;h5 id=&quot;N10127&quot;&gt;图 1.delete 脚本执行过程&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/1488ffe8dd392a8caf548028f6ee49ff.jpg&quot; rel=&quot;lightbox[79313]&quot; title=&quot;回收站功能在 Linux 中的实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-79397&quot; alt=&quot;image003&quot; src=&quot;/images/jobbole.com/9bf0193aaae730616666828d81018cfe.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;执行之后，useless 文件会从原目录中删除，被移动到$HOME/trash 下，并被重命名，如图 2.所示：&lt;/p&gt;
&lt;h5 id=&quot;N10135&quot;&gt;图 2.回收站目录&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/c62874c0b0fb36caec0c9c26d00f6301.jpg&quot; rel=&quot;lightbox[79313]&quot; title=&quot;回收站功能在 Linux 中的实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-79398&quot; alt=&quot;image005&quot; src=&quot;/images/jobbole.com/5e42f2c8e37cb677ed7962b7be5d6792.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/6df787e911e282b998946f932177ffaa.jpg&quot; rel=&quot;lightbox[79313]&quot; title=&quot;回收站功能在 Linux 中的实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-79399&quot; alt=&quot;image007&quot; src=&quot;/images/jobbole.com/5ed7d99913240815f1e8cb98a9482af3.jpg&quot;&gt;&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;生成的.log 记录如图 3.所示：&lt;/p&gt;
&lt;h5 id=&quot;N1014E&quot;&gt;图 3.log 记录&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/fb3cc01aca176dac4b8de5003863ba39.jpg&quot; rel=&quot;lightbox[79313]&quot; title=&quot;回收站功能在 Linux 中的实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-79400&quot; alt=&quot;image009&quot; src=&quot;/images/jobbole.com/4bad97bdbf03ecc07c57738085e6c2f7.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果用户在七天之内发现该文件还有使用价值，则可以使用 restoreTrash 命令将被删除文件恢复到原路径下：restoreTrash ~/trash/useless_20140923_06_28_57。具体执行情况如图 4 所示：&lt;/p&gt;
&lt;h5 id=&quot;N1015C&quot;&gt;图 4.restoreTrash 脚本执行情况&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/a647a44bbc8b903dec781d0417b2c587.jpg&quot; rel=&quot;lightbox[79313]&quot; title=&quot;回收站功能在 Linux 中的实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-79401&quot; alt=&quot;image011&quot; src=&quot;/images/jobbole.com/fd13b0000d0ab6c74919fb9cd121f79a.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看/usr 目录，可以发现 useless 文件已经被恢复至此。&lt;/p&gt;
&lt;h5 id=&quot;N1016A&quot;&gt;图 5.useless 文件被恢复&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://jbcdn2.b0.upaiyun.com/2014/11/7b09d2a61e3388cf5918859e9f8197cc.jpg&quot; rel=&quot;lightbox[79313]&quot; title=&quot;回收站功能在 Linux 中的实现&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-79402&quot; alt=&quot;image013&quot; src=&quot;/images/jobbole.com/eeee368634807fbdf6270628e50ae8a8.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2 id=&quot;9.总结 |outline&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文仿照 Windows 中回收站的功能，在 Linux 中做了实现，可以有效的防止由于误删而造成的损失。读者只需要将四个脚本拷到/bin 目录下，并配置 crontab 即可使用 Linux 版回收站。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Wed, 05 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-05-79313-559cf949a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-05-79313-559cf949a.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>使用共享网口方式访问管理控制器</title>
        <description>

                &lt;p&gt;发现没有你的服务器会额外多出一个以太网口来，那个网口是专门用来访问管理控制器（BMC）的，当然也可以通过普通网口的共享模式访问BMC。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是共享网口方式？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里要简单地提到NC-SI（Network Controller – Sideband Interface）技术，即网络控制器边带接口技术。这一技术是用来实现BMC芯片和以太网控制器之间信息传递的，它使得BMC芯片能够像使用独立管理网口那样使用主板上的网络接口。以下是共享访问模式的实现结构图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://noops.me/wp-content/uploads/2014/11/NCSI.png&quot;&gt;&lt;img class=&quot;wp-image-1719 alignnone&quot; alt=&quot;NCSI&quot; src=&quot;/images/noops.me/e9e2dbaca60b8e9f6f7652441345c7ac.jpg&quot; width=&quot;363&quot; height=&quot;398&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单理解：&lt;/strong&gt;BMC其实是一个单片机，它有自己独立的IO设备，而独立网口就是其中之一。将BMC芯片和网络控制器互联，通过NC-SI技术使得BMC芯片能够使用网络控制器上的接口。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为何要使用共享网口访问管理控制器？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、减少物料成本：共享访问模式能够为单机节省一根网线；&lt;/p&gt;
&lt;p&gt;2、减少人力成本：如果业务网只需要接一根网线，共享方案可以减少一半的布线人力支出；&lt;/p&gt;
&lt;p&gt;3、减少交换机投入：独立网口会多占用一个交换机端口，增加交换机采购数量，使用共享模式减少了这部分的支出和额外的交换机运维成本；&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何实现共享网口模式？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、BIOS或者WEB bmc界面中将IPMI访问方式修改为share（共享模式）；&lt;/p&gt;
&lt;p&gt;2、为共享网口独立分配一个VLAN号和IP地址，以便和业务网剥离；&lt;/p&gt;
&lt;p&gt;3、在交换机端开启802.1q协议，并分配相同的VLAN号。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
            

</description>
        <pubDate>Wed, 05 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-05--p=1717-4732406e0.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-05--p=1717-4732406e0.html</guid>
        
        
        <category>noops</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（12）：无向图相关算法基础</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;从这篇文章开始介绍图相关的算法，这也是&lt;a href=&quot;http://algs4.cs.princeton.edu/home/&quot; target=&quot;_blank&quot;&gt;Algorithms&lt;/a&gt;在线课程&lt;a href=&quot;https://www.coursera.org/#course/algs4partII?from_restricted_preview=1&amp;amp;course_id=971968&amp;amp;r=https%3A%2F%2Fclass.coursera.org%2Falgs4partII-003%2Fclass&quot; target=&quot;_blank&quot;&gt;第二部分&lt;/a&gt;的第一次课程笔记。 图的应用很广泛，也有很多非常有用的算法，当然也有很多待解决的问题，根据性质，图可以分为无向图和有向图。本文先介绍无向图，后文再介绍有向图。 之所以要研究图，是因为图在生活中应用比较广泛： &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/281a402386e50e0176a1b28df5bd6fe3.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;无向图&lt;/h1&gt;
&lt;p&gt;图是若干个顶点(Vertices)和边(Edges)相互连接组成的。边仅由两个顶点连接，并且没有方向的图称为无向图。 在研究图之前，有一些定义需要明确，下图中表示了图的一些基本属性的含义，这里就不多说明。 &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1d0f2fd14ae888242892157aa71b825d.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;图的API 表示&lt;/h1&gt;
&lt;p&gt;在研究图之前，我们需要选用适当的数据结构来表示图，有时候，我们常被我们的直觉欺骗,如下图，这两个其实是一样的，这其实也是一个研究问题，就是如何判断图的形态。 &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f3a626a25d4cd54d624731988722b5dc.jpg&quot;&gt; 要用计算机处理图，我们可以抽象出以下的表示图的API： &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/19981f4ad3e90b0558cff6bb0cfa20d0.jpg&quot;&gt;   Graph的API的实现可以由多种不同的数据结构来表示，最基本的是维护一系列边的集合，如下： &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e25bb88a24d263587cca56c2ef6b7af0.jpg&quot;&gt; 还可以使用邻接矩阵来表示： &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/eeff167cf0bd7ae3fb245b661110e0b1.jpg&quot;&gt; 也可以使用邻接列表来表示： &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f6177ca2f5abc5100f28de044d980f76.jpg&quot;&gt; 由于采用如上方式具有比较好的灵活性，采用邻接列表来表示的话，可以定义如下数据结构来表示一个Graph对象。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public class Graph
{
    private readonly int verticals;//顶点个数
    private int edges;//边的个数
    private List&amp;lt;int&amp;gt;[] adjacency;//顶点联接列表

    public Graph(int vertical)
    {
        this.verticals = vertical;
        this.edges = 0;
        adjacency=new List&amp;lt;int&amp;gt;[vertical];
        for (int v = 0; v &amp;lt; vertical; v++)
        {
            adjacency[v]=new List&amp;lt;int&amp;gt;();
        }
    }

    public int GetVerticals ()
    {
        return verticals;
    }

    public int GetEdges()
    {
        return edges;
    }

    public void AddEdge(int verticalStart, int verticalEnd)
    {
        adjacency[verticalStart].Add(verticalEnd);
        adjacency[verticalEnd].Add(verticalStart);
        edges++;
    }

    public List&amp;lt;int&amp;gt; GetAdjacency(int vetical)
    {
        return adjacency[vetical];
    }
}&lt;/pre&gt;
&lt;p&gt;图也分为稀疏图和稠密图两种，如下图： 在这两个图中，顶点个数均为50，但是稀疏图中只有200个边，稠密图中有1000个边。在现实生活中，大部分都是稀疏图，即顶点很多，但是顶点的平均度比较小。 &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c528c9c220f06d0f3c84be6a573a9ded.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;采用以上三种表示方式的效率如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a3251c7332283fc3944e2551158a2b49.jpg&quot;&gt; 在讨论完图的表示之后，我们来看下在图中比较重要的一种算法，即深度优先算法：&lt;/p&gt;
&lt;h1&gt;深度优先算法&lt;/h1&gt;
&lt;p&gt;在谈论深度优先算法之前，我们可以先看看迷宫探索问题。下面是一个迷宫和图之间的对应关系： 迷宫中的每一个交会点代表图中的一个顶点，每一条通道对应一个边。 &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/772ba6c055bcce743a46bbf68e238f62.jpg&quot;&gt; 迷宫探索可以采用Trémaux绳索探索法。即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在身后放一个绳子&lt;/li&gt;
&lt;li&gt;访问到的每一个地方放一个绳索标记访问到的交会点和通道&lt;/li&gt;
&lt;li&gt;当遇到已经访问过的地方，沿着绳索回退到之前没有访问过的地方：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d85748347edf8e7b27d1ad48a8a92477.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面是迷宫探索的一个小动画：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a15724ee425637bccfa97971e3e3dcbf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;深度优先搜索算法模拟迷宫探索。在实际的图处理算法中，我们通常将图的表示和图的处理逻辑分开来。所以算法的整体设计模式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个Graph对象&lt;/li&gt;
&lt;li&gt;将Graph对象传给图算法处理对象，如一个Paths对象&lt;/li&gt;
&lt;li&gt;然后查询处理后的结果来获取信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是深度优先的基本代码，我们可以看到，递归调用dfs方法，在调用之前判断该节点是否已经被访问过。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public class DepthFirstSearch
{
    private bool[] marked;//记录顶点是否被标记
    private int count;//记录查找次数

    private DepthFirstSearch(Graph g, int v)
    {
        marked = new bool[g.GetVerticals()];
        dfs(g, v);
    }

    private void dfs(Graph g, int v)
    {
        marked[v] = true;
        count++;
        foreach (int vertical in g.GetAdjacency(v))
        {
            if (!marked[vertical])
                dfs(g,vertical);
        }
    }

    public bool IsMarked(int vertical)
    {
        return marked[vertical];
    }

    public int Count()
    {
        return count;
    }
}&lt;/pre&gt;
&lt;p&gt;试验一个算法最简单的办法是找一个简单的例子来实现。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/67090c38f1ab5433d6518fa0202a8530.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;深度优先路径查询&lt;/h1&gt;
&lt;p&gt;有了这个基础，我们可以实现基于深度优先的路径查询，要实现路径查询，我们必须定义一个变量来记录所探索到的路径。 所以在上面的基础上定义一个edgesTo变量来后向记录所有到s的顶点的记录，和仅记录从当前节点到起始节点不同，我们记录图中的&lt;strong&gt;每一个节点到开始节点的路径&lt;/strong&gt;。为了完成这一日任务，通过设置edgesTo[w]=v，我们记录从v到w的边，换句话说，v-w是做后一条从s到达w的边。 edgesTo[]其实是一个指向其父节点的树。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public class DepthFirstPaths
{
    private bool[] marked;//记录是否被dfs访问过
    private int[] edgesTo;//记录最后一个到当前节点的顶点
    private int s;//搜索的起始点

    public DepthFirstPaths(Graph g, int s)
    {
        marked = new bool[g.GetVerticals()];
        edgesTo = new int[g.GetVerticals()];
        this.s = s;
        dfs(g, s);
    }

    private void dfs(Graph g, int v)
    {
        marked[v] = true;
        foreach (int w in g.GetAdjacency(v))
        {
            if (!marked[w])
            {
                edgesTo[w] = v;
                dfs(g,w);
            }
        }
    }

    public bool HasPathTo(int v)
    {
        return marked[v];
    }

    public Stack&amp;lt;int&amp;gt; PathTo(int v)
    {

        if (!HasPathTo(v)) return null;
        Stack&amp;lt;int&amp;gt; path = new Stack&amp;lt;int&amp;gt;();

        for (int x = v; x!=s; x=edgesTo[x])
        {
            path.Push(x);
        }
        path.Push(s);
        return path;
    }
}&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/15a5e0ed8a1fab0165648706de7b1f99.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图中是黑色线条表示 深度优先搜索中，所有定点到原点0的路径， 他是通过edgeTo[]这个变量记录的，可以从右边可以看出，他其实是一颗树，树根即是原点，每个子节点到树根的路径即是从原点到该子节点的路径。 下图是深度优先搜索算法的一个简单例子的追踪。 &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9ebef2022ae76b87c7232cd4a4116fea.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;广度优先算法&lt;/h1&gt;
&lt;p&gt;通常我们更关注的是一类单源最短路径的问题，那就是给定一个图和一个源S，是否存在一条从s到给定定点v的路径，如果存在，找出最短的那条(这里最短定义为边的条数最小) 深度优先算法是将未被访问的节点放到一个堆中(stack)，虽然在上面的代码中没有明确在代码中写stack，但是 递归 间接的利用递归堆实现了这一原理。 和深度优先算法不同， 广度优先是将所有未被访问的节点放到了队列中。其主要原理是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 s放到FIFO中，并且将s标记为已访问&lt;/li&gt;
&lt;li&gt;重复直到队列为空&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;移除最近最近添加的顶点v&lt;/li&gt;
&lt;li&gt;将v未被访问的节点添加到队列中&lt;/li&gt;
&lt;li&gt;标记他们为已经访问&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;广度优先是以距离递增的方式来搜索路径的。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;class BreadthFirstSearch
{
    private bool[] marked;
    private int[] edgeTo;
    private int sourceVetical;//Source vertical

    public BreadthFirstSearch(Graph g, int s)
    {
        marked=new bool[g.GetVerticals()];
        edgeTo=new int[g.GetVerticals()];
        this.sourceVetical = s;
        bfs(g, s);
    }

    private void bfs(Graph g, int s)
    {
        Queue&amp;lt;int&amp;gt; queue = new Queue&amp;lt;int&amp;gt;();
        marked[s] = true;
        queue.Enqueue(s);
        while (queue.Count()!=0)
        {
            int v = queue.Dequeue();
            foreach (int w in g.GetAdjacency(v))
            {
                if (!marked[w])
                {
                    edgeTo[w] = v;
                    marked[w] = true;
                    queue.Enqueue(w);
                }
            }
        }
    }

    public bool HasPathTo(int v)
    {
        return marked[v];
    }

    public Stack&amp;lt;int&amp;gt; PathTo(int v)
    {
        if (!HasPathTo(v)) return null;

        Stack&amp;lt;int&amp;gt; path = new Stack&amp;lt;int&amp;gt;();
        for (int x = v; x!=sourceVetical; x=edgeTo[x])
        {
            path.Push(x);
        }
        path.Push(sourceVetical);
        return path;
    }

}&lt;/pre&gt;
&lt;p&gt;广度优先算法的搜索步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e73dcd5baceb57c2e5f9e1c7674a283b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;广度优先搜索首先是在距离起始点为1的范围内的所有邻接点中查找有没有到达目标结点的对象，如果没有，继续前进在距离起始点为2的范围内查找，依次向前推进。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bf29793cf204df37d99cd2b7b31bce5e.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;本文简要介绍了无向图中的深度优先和广度优先算法，这两种算法时图处理算法中的最基础算法，也是后续更复杂算法的基础。其中图的表示，图算法与表示的分离这种思想在后续的算法介绍中会一直沿用，下文将讲解无向图中深度优先和广度优先的应用，以及利用这两种基本算法解决实际问题的应用。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79314-87f96d168.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79314-87f96d168.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（10）：平衡查找树之B树</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;前面讲解了平衡查找树中的&lt;a href=&quot;http://blog.jobbole.com/79307/&quot; target=&quot;_blank&quot;&gt;2-3树&lt;/a&gt;以及其实现&lt;a href=&quot;http://blog.jobbole.com/79309/&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。&lt;/p&gt;
&lt;p&gt;维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化&lt;strong&gt;大块数据的读和写操作&lt;/strong&gt;。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在&lt;strong&gt;数据库&lt;/strong&gt;和&lt;strong&gt;文件系统&lt;/strong&gt;。”&lt;/p&gt;
&lt;h1&gt;定义&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;B 树&lt;/strong&gt;可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点至少有两个子节点&lt;/li&gt;
&lt;li&gt;每个节点有M-1个key，并且以升序排列&lt;/li&gt;
&lt;li&gt;位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间&lt;/li&gt;
&lt;li&gt;其它节点至少有M/2个子节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图是一个M=4 阶的B树:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/45405cb08b86ee13196ebd8be311063b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。&lt;/p&gt;
&lt;p&gt;B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;的演示动画：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a282c705ffbdda75d8418d001e96acf2.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B+&lt;/strong&gt;树是对B树的一种变形树，它与B树的差异在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有k个子结点的结点必然有k个关键码；&lt;/li&gt;
&lt;li&gt;非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。&lt;/li&gt;
&lt;li&gt;树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图，是一个B+树:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/31957106a84f5266130e197e34b1db63.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图是B+树的插入动画：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/99ce9d77c0d1f06671a272d22172f100.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。&lt;/p&gt;
&lt;p&gt;B+ 树的优点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。&lt;/li&gt;
&lt;li&gt;B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。下面是B 树和B+树的区别图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8ce4d99d4e222c7d6547373d3dabae39.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;分析&lt;/h1&gt;
&lt;p&gt;对B树和B+树的分析和对前面讲解的2-3树的分析类似，&lt;/p&gt;
&lt;p&gt;对于一颗节点为N度为M的子树，查找和插入需要log&lt;sub&gt;M-1&lt;/sub&gt;N ~ log&lt;sub&gt;M/2&lt;/sub&gt;N次比较。这个很好证明，对于度为M的B树，每一个节点的子节点个数为M/2 到 M-1之间，所以树的高度在log&lt;sub&gt;M-1&lt;/sub&gt;N至log&lt;sub&gt;M/&lt;/sub&gt;2N之间。&lt;/p&gt;
&lt;p&gt;这种效率是很高的，对于N=62*1000000000个节点，如果度为1024，则log&lt;sub&gt;M/2&lt;/sub&gt;N &amp;lt;=4，即在620亿个元素中，如果这棵树的度为1024，则只需要小于4次即可定位到该节点，然后再采用二分查找即可找到要找的值。&lt;/p&gt;
&lt;h1&gt;应用&lt;/h1&gt;
&lt;p&gt;B树和B+广泛应用于文件存储系统以及数据库系统中，在讲解应用之前，我们看一下常见的存储结构：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/80f04c9de87ecb82347fb7b7e18a9e1e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们计算机的主存基本都是随机访问存储器(Random-Access Memory，RAM)，他分为两类：静态随机访问存储器（SRAM）和动态随机访问存储器（DRAM）。SRAM比DRAM快，但是也贵的多，一般作为CPU的高速缓存，DRAM通常作为内存。这类存储器他们的结构和存储原理比较复杂，基本是使用电信号来保存信息的，不存在机器操作，所以访问速度非常快，具体的访问原理可以查看CSAPP，另外，他们是易失的，即如果断电，保存DRAM和SRAM保存的信息就会丢失。&lt;/p&gt;
&lt;p&gt;我们使用的更多的是使用磁盘，磁盘能够保存大量的数据，从GB一直到TB级，但是 他的读取速度比较慢，因为涉及到机器操作，读取速度为毫秒级，从DRAM读速度比从磁盘度快10万倍，从SRAM读速度比从磁盘读快100万倍。下面来看下磁盘的结构：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5bfaa0a35335326691c55ccf7797c122.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图，磁盘由盘片构成,每个盘片有两面，又称为盘面(Surface)，这些盘面覆盖有磁性材料。盘片中央有一个可以旋转的主轴(spindle)，他使得盘片以固定的旋转速率旋转，通常是5400转每分钟(Revolution Per Minute,RPM)或者是7200RPM。磁盘包含一个多多个这样的盘片并封装在一个密封的容器内。上图左，展示了一个典型的磁盘表面结构。每个表面是由一组成为磁道(track)的同心圆组成的，每个磁道被划分为了一组扇区(sector).每个扇区包含相等数量的数据位，通常是（512）子节。扇区之间由一些间隔(gap)隔开,不存储数据。&lt;/p&gt;
&lt;p&gt;以上是磁盘的物理结构，现在来看下磁盘的读写操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/cced6145f7fdc77ed5a55f88bdf54997.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图，磁盘用读/写头来读写存储在磁性表面的位，而读写头连接到一个传动臂的一端。通过沿着半径轴前后移动传动臂，驱动器可以将读写头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到位的值，也可以修改值。对磁盘的访问时间分为 &lt;strong&gt;寻道时间&lt;/strong&gt;，&lt;strong&gt;旋转时间&lt;/strong&gt;，以及&lt;strong&gt;传送时间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘I/O，减少读写操作。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：&lt;/p&gt;
&lt;p&gt;当一个数据被用到时，其附近的数据也通常会马上被使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序运行期间所需要的数据通常比较集中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。&lt;/p&gt;
&lt;p&gt;预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。&lt;/p&gt;
&lt;p&gt;文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：&lt;/p&gt;
&lt;p&gt;每次新建一个节点的同时，直接申请一个页的空间( 512或者1024)，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。如，将B树的度M设置为1024，这样在前面的例子中，600亿个元素中只需要小于4次查找即可定位到某一存储位置。&lt;/p&gt;
&lt;p&gt;同时在B+树中，内节点只存储导航用到的key，并不存储具体值，这样内节点个数较少，能够全部读取到主存中，外接点存储key及值，并且顺序排列，具有良好的空间局部性。所以B及B+树比较适合与文件系统的数据结构。下面是一颗B树，用来进行内容存储。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2bcae2e929d78399ca504b86b717897b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;另外B/B+树也经常用做数据库的索引，这方面推荐您直接看张洋的&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot; target=&quot;_blank&quot;&gt;MySQL索引背后的数据结构及算法原理&lt;/a&gt; 这篇文章，这篇文章对MySQL中的如何使用B+树进行索引有比较详细的介绍，推荐阅读。&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;在前面两篇文章介绍了平衡查找树中的&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html&quot; target=&quot;_blank&quot;&gt;2-3树&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;之后，本文介绍了文件系统和数据库系统中常用的B/B+ 树，他通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。他广泛用于文件系统及数据库中，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows：HPFS文件系统&lt;/li&gt;
&lt;li&gt;Mac：HFS，HFS+文件系统&lt;/li&gt;
&lt;li&gt;Linux：ResiserFS，XFS，Ext3FS，JFS文件系统&lt;/li&gt;
&lt;li&gt;数据库：ORACLE，MYSQL，SQLSERVER等中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;希望本文对您了解B/B+ 树有所帮助。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79311-2c84273c9.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79311-2c84273c9.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（9）：平衡查找树之红黑树</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;前面一篇文章介绍了&lt;a href=&quot;http://blog.jobbole.com/79307/&quot; target=&quot;_blank&quot;&gt;2-3查找树&lt;/a&gt;，可以看到，2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgN，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，本文介绍一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）&lt;/p&gt;
&lt;h1&gt;定义&lt;/h1&gt;
&lt;p&gt;红黑树的主要是像是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/28aa41a637d1006eeab4a0d5646e8772.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据以上描述，红黑树定义如下：&lt;/p&gt;
&lt;p&gt;红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;红色节点向左倾斜&lt;/li&gt;
&lt;li&gt;一个节点不可能有两个红色链接&lt;/li&gt;
&lt;li&gt;整个书完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4bf7d2d9bb2125c80b18807fd67e6df7.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;表示&lt;/h1&gt;
&lt;p&gt;我们可以在二叉查找树的每一个节点上增加一个新的表示颜色的标记。该标记指示该节点指向其父节点的颜色。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private const bool RED = true;
private const bool BLACK = false;

private Node root;

class Node
{
    public Node Left { get; set; }
    public Node Right { get; set; }
    public TKey Key { get; set; }
    public TValue Value { get; set; }
    public int Number { get; set; }
    public bool Color { get; set; }

    public Node(TKey key, TValue value,int number, bool color)
    {
        this.Key = key;
        this.Value = value;
        this.Number = number;
        this.Color = color;
    }
}

private bool IsRed(Node node)
{
    if (node == null) return false;
    return node.Color == RED;
}&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2a47f60d785e94f98bff38bcfbfe186e.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;实现&lt;/h1&gt;
&lt;h2&gt;查找&lt;/h2&gt;
&lt;p&gt;红黑树是一种特殊的二叉查找树，他的查找方法也和二叉查找树一样，不需要做太多更改。&lt;/p&gt;
&lt;p&gt;但是由于红黑树比一般的二叉查找树具有更好的平衡，所以查找起来更快。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;//查找获取指定的值
public override TValue Get(TKey key)
{
    return GetValue(root, key);
}

private TValue GetValue(Node node, TKey key)
{
    if (node == null) return default(TValue);
    int cmp = key.CompareTo(node.Key);
    if (cmp == 0) return node.Value;
    else if (cmp &amp;gt; 0) return GetValue(node.Right, key);
    else return GetValue(node.Left, key);
}&lt;/pre&gt;
&lt;h2&gt;平衡化&lt;/h2&gt;
&lt;p&gt;在介绍插入之前，我们先介绍如何让红黑树保持平衡，因为一般的，我们插入完成之后，需要对树进行平衡化操作以使其满足平衡化。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;旋转&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;旋转又分为&lt;strong&gt;左旋&lt;/strong&gt;和&lt;strong&gt;右旋&lt;/strong&gt;。通常左旋操作用于将一个向右倾斜的红色链接旋转为向左链接。对比操作前后，可以看出，该操作实际上是将红线链接的两个节点中的一个较大的节点移动到根节点上。&lt;/p&gt;
&lt;p&gt;左旋操作如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c4cd388f923e4006f290a201ae0abea3.jpg&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5c53a9577f6ef26f85efd9a247c7810e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;//左旋转
private Node RotateLeft(Node h)
{
    Node x = h.Right;
    //将x的左节点复制给h右节点
    h.Right = x.Left;
    //将h复制给x右节点
    x.Left = h;
    x.Color = h.Color;
    h.Color = RED;
    return x;
}&lt;/pre&gt;
&lt;p&gt;左旋的动画效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/55da041aa81e6064285ac15780434d53.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;右旋&lt;/strong&gt;是左旋的逆操作，过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/deeb271473f65db02630ef9b33dbc18f.jpg&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/86c949f8f7744e2c9a65c1c67823c1d6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;//右旋转
private Node RotateRight(Node h)
{
    Node x = h.Left;
    h.Left = x.Right;
    x.Right = h;

    x.Color = h.Color;
    h.Color = RED;
    return x;
}&lt;/pre&gt;
&lt;p&gt;右旋的动画效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8ab520971ea5069cedb4e991ce176639.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;颜色反转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当出现一个临时的4-node的时候，即一个节点的两个子节点均为红色，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c55879bd093896d9e89bf07c37e76be1.jpg&quot;&gt; &lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7676d3d76d32fac7130c612599628ef7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这其实是个A，E，S 4-node连接，我们需要将E提升至父节点，操作方法很简单，就是把E对子节点的连线设置为黑色，自己的颜色设置为红色。&lt;/p&gt;
&lt;p&gt;有了以上基本操作方法之后，我们现在对应之前对&lt;strong&gt;2-3树的平衡操作来对红黑树进行平衡操作，&lt;/strong&gt;这两者是可以一一对应的，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/373226b08bdeb834ea0051a6e363bbec.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在来讨论各种情况：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Case 1 &lt;/strong&gt;&lt;strong&gt;往一个2-node&lt;/strong&gt;&lt;strong&gt;节点底部插入新的节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先热身一下，首先我们看对于只有一个节点的红黑树，插入一个新的节点的操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a9938d92aaf6be1f971192bc7ad25ece.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种情况很简单，只需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准的二叉查找树遍历即可。新插入的节点标记为红色&lt;/li&gt;
&lt;li&gt;如果新插入的节点在父节点的右子节点，则需要进行左旋操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Case 2&lt;/strong&gt;&lt;strong&gt;往一个3-node&lt;/strong&gt;&lt;strong&gt;节点底部插入新的节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先热身一下，假设我们往一个只有两个节点的树中插入元素，如下图，根据待插入元素与已有元素的大小，又可以分为如下三种情况：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ffb7726e434b2804f5c6ca6693962f78.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果带插入的节点比现有的两个节点都大，这种情况最简单。我们只需要将新插入的节点连接到右边子树上即可，然后将中间的元素提升至根节点。这样根节点的左右子树都是红色的节点了，我们只需要调研FlipColor方法即可。其他情况经过反转操作后都会和这一样。&lt;/li&gt;
&lt;li&gt;如果插入的节点比最小的元素要小，那么将新节点添加到最左侧，这样就有两个连接红色的节点了，这是对中间节点进行右旋操作，使中间结点成为根节点。这是就转换到了第一种情况，这时候只需要再进行一次FlipColor操作即可。&lt;/li&gt;
&lt;li&gt;如果插入的节点的值位于两个节点之间，那么将新节点插入到左侧节点的右子节点。因为该节点的右子节点是红色的，所以需要进行左旋操作。操作完之后就变成第二种情况了，再进行一次右旋，然后再调用FlipColor操作即可完成平衡操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了以上基础，我们现在来总结一下往一个3-node节点底部插入新的节点的操作步骤，下面是一个典型的操作过程图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/18cc2768938907b0016a95c90ff53f70.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看出，操作步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行标准的二叉查找树插入操作，新插入的节点元素用红色标识。&lt;/li&gt;
&lt;li&gt;如果需要对4-node节点进行旋转操作&lt;/li&gt;
&lt;li&gt;如果需要，调用FlipColor方法将红色节点提升&lt;/li&gt;
&lt;li&gt;如果需要，左旋操作使红色节点左倾。&lt;/li&gt;
&lt;li&gt;在有些情况下，需要递归调用Case1 Case2，来进行递归操作。如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/39033694fa182478baef59a2a1ec384c.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;代码实现&lt;/h2&gt;
&lt;p&gt;经过上面的平衡化讨论，现在就来实现插入操作，一般地插入操作就是先执行标准的二叉查找树插入，然后再进行平衡化。对照2-3树，我们可以通过前面讨论的，左旋，右旋，FlipColor这三种操作来完成平衡化。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3f8b9da7561e25a5c6e86acbcdab5ac3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体操作方式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果节点的右子节点为红色，且左子节点位黑色，则进行左旋操作&lt;/li&gt;
&lt;li&gt;如果节点的左子节点为红色，并且左子节点的左子节点也为红色，则进行右旋操作&lt;/li&gt;
&lt;li&gt;如果节点的左右子节点均为红色，则执行FlipColor操作，提升中间结点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据这一逻辑，我们就可以实现插入的Put方法了。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public override void Put(TKey key, TValue value)
{
    root = Put(root, key, value);
    root.Color = BLACK;
}

private Node Put(Node h, TKey key, TValue value)
{
    if (h == null) return new Node(key, value, 1, RED);
    int cmp = key.CompareTo(h.Key);
    if (cmp &amp;lt; 0) h.Left = Put(h.Left, key, value);
    else if (cmp &amp;gt; 0) h.Right = Put(h.Right, key, value);
    else h.Value = value;

    //平衡化操作
    if (IsRed(h.Right) &amp;amp;&amp;amp; !IsRed(h.Left)) h = RotateLeft(h);
    if (IsRed(h.Right) &amp;amp;&amp;amp; IsRed(h.Left.Left)) h = RotateRight(h);
    if (IsRed(h.Left) &amp;amp;&amp;amp; IsRed(h.Right)) h = FlipColor(h);

    h.Number = Size(h.Left) + Size(h.Right) + 1;
    return h;
}

private int Size(Node node)
{
    if (node == null) return 0;
    return node.Number;
}&lt;/pre&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;对红黑树的分析其实就是对2-3查找树的分析，红黑树能够保证符号表的所有操作即使在最坏的情况下都能保证对数的时间复杂度，也就是树的高度。&lt;/p&gt;
&lt;p&gt;在分析之前，为了更加直观，下面是以升序，降序和随机构建一颗红黑树的动画：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以升序插入构建红黑树：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/220447ab4207dbbeb4f4bbd018f8308a.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以降序插入构建红黑树：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/de01067afe1c7d96b8d04b5555298fa6.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随机插入构建红黑树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8fe88b6bc08b80b835bd5f0d0daca65a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上面三张动画效果中，可以很直观的看出，红黑树在各种情况下都能维护良好的平衡性，从而能够保证最差情况下的查找，插入效率。&lt;/p&gt;
&lt;p&gt;下面来详细分析下红黑树的效率：&lt;/p&gt;
&lt;h2&gt;1. 在最坏的情况下，红黑树的高度不超过2lgN&lt;/h2&gt;
&lt;p&gt;最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即&lt;strong&gt;红黑相间的路径长度是全黑路径长度的&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;倍&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下图是一个典型的红黑树，从中可以看到最长的路径(红黑相间的路径)是最短路径的2倍：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f8dd64a41535dfe6de1b44332054c8a8.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;2. 红黑树的平均高度大约为lgN&lt;/h2&gt;
&lt;p&gt;下图是红黑树在各种情况下的时间复杂度，可以看出红黑树是2-3查找树的一种实现，他能保证最坏情况下仍然具有对数的时间复杂度。&lt;/p&gt;
&lt;p&gt;下图是红黑树各种操作的时间复杂度。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e7962e34bcc8c72e4ca43e4d4c1f0bed.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;应用&lt;/h1&gt;
&lt;p&gt;红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java中的java.util.TreeMap,java.util.TreeSet&lt;/li&gt;
&lt;li&gt;C++ STL中的：map,multimap,multiset&lt;/li&gt;
&lt;li&gt;.NET中的：&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/f7fta44c(v=vs.110).aspx&quot;&gt;SortedDictionary&lt;/a&gt;,&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/dd412070(v=vs.110).aspx&quot; target=&quot;_blank&quot;&gt;SortedSet&lt;/a&gt; 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面以.NET中为例，通过Reflector工具，我们可以看到SortedDictionary的Add方法如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public void Add(T item)
{
    if (this.root == null)
    {
        this.root = new Node&amp;lt;T&amp;gt;(item, false);
        this.count = 1;
    }
    else
    {
        Node&amp;lt;T&amp;gt; root = this.root;
        Node&amp;lt;T&amp;gt; node = null;
        Node&amp;lt;T&amp;gt; grandParent = null;
        Node&amp;lt;T&amp;gt; greatGrandParent = null;
        int num = 0;
        while (root != null)
        {
            num = this.comparer.Compare(item, root.Item);
            if (num == 0)
            {
                this.root.IsRed = false;
                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);
            }
            if (TreeSet&amp;lt;T&amp;gt;.Is4Node(root))
            {
                TreeSet&amp;lt;T&amp;gt;.Split4Node(root);
                if (TreeSet&amp;lt;T&amp;gt;.IsRed(node))
                {
                    this.InsertionBalance(root, ref node, grandParent, greatGrandParent);
                }
            }
            greatGrandParent = grandParent;
            grandParent = node;
            node = root;
            root = (num &amp;lt; 0) ? root.Left : root.Right;
        }
        Node&amp;lt;T&amp;gt; current = new Node&amp;lt;T&amp;gt;(item);
        if (num &amp;gt; 0)
        {
            node.Right = current;
        }
        else
        {
            node.Left = current;
        }
        if (node.IsRed)
        {
            this.InsertionBalance(current, ref node, grandParent, greatGrandParent);
        }
        this.root.IsRed = false;
        this.count++;
        this.version++;
    }
}&lt;/pre&gt;
&lt;p&gt;可以看到，内部实现也是一个红黑树，其操作方法和本文将的大同小异，感兴趣的话，您可以使用Reflector工具跟进去查看源代码。&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/79307/&quot; target=&quot;_blank&quot;&gt;前文&lt;/a&gt;讲解了自平衡查找树中的&lt;a href=&quot;http://blog.jobbole.com/79307/&quot; target=&quot;_blank&quot;&gt;2-3查找树&lt;/a&gt;，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。&lt;/p&gt;
&lt;p&gt;希望本文对您了解红黑树有所帮助，下文将介绍在文件系统以及数据库系统中应用非常广泛的另外一种平衡树结构：B树。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79309-123b3cd4a.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79309-123b3cd4a.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（8）：平衡查找树之2-3树</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;前面介绍了&lt;a href=&quot;http://blog.jobbole.com/79305/&quot; target=&quot;_blank&quot;&gt;二叉查找树&lt;/a&gt;(Binary Search Tree)，他对于大多数情况下的查找和插入在效率上来说是没有问题的，但是他在最差的情况下效率比较低。本文及后面文章介绍的平衡查找树的数据结构能够保证在最差的情况下也能达到lgN的效率，要实现这一目标我们需要保证树在插入完成之后始终保持平衡状态，这就是平衡查找树(Balanced Search Tree)。在一棵具有N 个节点的树中，我们希望该树的高度能够维持在lgN左右，这样我们就能保证只需要lgN次比较操作就可以查找到想要的值。不幸的是，每次插入元素之后维持树的平衡状态太昂贵。所以这里会介绍一些新的数据结构来保证在最坏的情况下插入和查找效率都能保证在对数的时间复杂度内完成。本文首先介绍2-3查找树(2-3 Search Tree)，后面会在此基础上介绍红黑树和B树。&lt;/p&gt;
&lt;h1&gt;定义&lt;/h1&gt;
&lt;p&gt;和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：&lt;/p&gt;
&lt;p&gt;1. 要么为空，要么：&lt;/p&gt;
&lt;p&gt;2. 对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key有效，有节点也是一个2-3节点，所有的值比key要大。&lt;/p&gt;
&lt;p&gt;3. 对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。&lt;/p&gt;
&lt;p&gt;如果中序遍历2-3查找树，就可以得到排好序的序列。在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/1dae559238b660dc53506946a1d6455c.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;查找&lt;/h1&gt;
&lt;p&gt;在进行2-3树的平衡之前，我们先假设已经处于平衡状态，我们先看基本的查找操作。&lt;/p&gt;
&lt;p&gt;2-3树的查找和二叉查找树类似，要确定一个树是否属于2-3树，我们首先和其跟节点进行比较，如果相等，则查找成功；否则根据比较的条件，在其左中右子树中递归查找，如果找到的节点为空，则未找到，否则返回。查找过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f811368729b661c7432fc50c01ec3bea.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;插入&lt;/h1&gt;
&lt;h2&gt;往一个2-node节点插入&lt;/h2&gt;
&lt;p&gt;往2-3树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点上。2-3树之所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一个2-node节点，那么很容易，我们只需要将新的元素放到这个2-node节点里面使其变成一个3-node节点即可。但是如果查找的节点结束于一个3-node节点，那么可能有点麻烦。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8514a08fed0310d65f9eea43a9557766.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;往一个3-node节点插入&lt;/h2&gt;
&lt;p&gt;往一个3-node节点插入一个新的节点可能会遇到很多种不同的情况，下面首先从一个最简单的只包含一个3-node节点的树开始讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只包含一个3-node&lt;/strong&gt;&lt;strong&gt;节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/f984feb6b40e299ba54d2676f7f9d1d3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;如上图，假设2-3树只包含一个3-node节点，这个节点有两个key，没有空间来插入第三个key了，最自然的方式是我们假设这个节点能存放三个元素，暂时使其变成一个4-node节点，同时他包含四个子节点。然后，我们将这个4-node节点的中间元素提升，左边的节点作为其左节点，右边的元素作为其右节点。插入完成，变为平衡2-3查找树，树的高度从0变为1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点是3-node&lt;/strong&gt;&lt;strong&gt;，父节点是2-node&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和第一种情况一样，我们也可以将新的元素插入到3-node节点中，使其成为一个临时的4-node节点，然后，将该节点中的中间元素提升到父节点即2-node节点中，使其父节点成为一个3-node节点，然后将左右节点分别挂在这个3-node节点的恰当位置。操作如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7d45989e4a87a1cd487287d5d1c5545a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点是3-node&lt;/strong&gt;&lt;strong&gt;，父节点也是3-node&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们插入的节点是3-node的时候，我们将该节点拆分，中间元素提升至父节点，但是此时父节点是一个3-node节点，插入之后，父节点变成了4-node节点，然后继续将中间元素提升至其父节点，直至遇到一个父节点是2-node节点，然后将其变为3-node，不需要继续进行拆分。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/23eaaea6f71e831e35fe5dc1170aef2b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根节点分裂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当根节点到字节点都是3-node节点的时候，这是如果我们要在字节点插入新的元素的时候，会一直查分到跟节点，在最后一步的时候，跟节点变成了一个4-node节点，这个时候，就需要将跟节点查分为两个2-node节点，树的高度加1，这个操作过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/50f65359375d741e528eeeb032a29d5e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将一个4-node拆分为2-3node涉及到6种可能的操作。这4-node可能在跟节点，也可能是2-node的左子节点或者右子节点。或者是一个3-node的左，中，右子节点。所有的这些改变都是本地的，不需要检查或者修改其他部分的节点。所以只需要常数次操作即可完成2-3树的平衡。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ca57f77f761dd476fc9cb88879de0157.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性质&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些本地操作保持了2-3树的平衡。对于4-node节点变形为2-3节点，变形前后树的高度没有发生变化。只有当跟节点是4-node节点，变形后树的高度才加一。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8773a457a44fc42a3aaecdbab8850b96.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h1&gt;分析&lt;/h1&gt;
&lt;p&gt;完全平衡的2-3查找树如下图，每个根节点到叶子节点的距离是相同的：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b53b2a71de190c5a5a6ad0cdee2e4954.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2-3树的查找效率与树的高度是息息相关的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN&lt;/li&gt;
&lt;li&gt;在最好的情况下，所有的节点都是3-node节点，查找效率为log&lt;sub&gt;3&lt;/sub&gt;N约等于0.631lgN&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。&lt;/p&gt;
&lt;p&gt;对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。下面是2-3查找树的效率：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0908b5e2c1cd5a6366715f827c73a459.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;实现&lt;/h1&gt;
&lt;p&gt;直接实现2-3树比较复杂，因为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要处理不同的节点类型，非常繁琐&lt;/li&gt;
&lt;li&gt;需要多次比较操作来将节点下移&lt;/li&gt;
&lt;li&gt;需要上移来拆分4-node节点&lt;/li&gt;
&lt;li&gt;拆分4-node节点的情况有很多种&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2-3查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。在2-3查找树基础上改进的红黑树不仅具有较高的效率，并且实现起来较2-3查找树简单。&lt;/p&gt;
&lt;p&gt;但是2-3查找树作为一种比较重要的概念和思路对于后文要讲到的红黑树和B树非常重要。希望本文对您了解2-3查找树有所帮助。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79307-715a10deb.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79307-715a10deb.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（7）：二叉查找树</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/79303/&quot; target=&quot;_blank&quot;&gt;前文&lt;/a&gt;介绍了符号表的两种实现，无序链表和有序数组，无序链表在插入的时候具有较高的灵活性，而有序数组在查找时具有较高的效率，本文介绍的二叉查找树(Binary Search Tree，BST)这一数据结构综合了以上两种数据结构的优点。&lt;/p&gt;
&lt;p&gt;二叉查找树具有很高的灵活性，对其优化可以生成平衡二叉树，红黑树等高效的查找和插入数据结构，后文会一一介绍。&lt;/p&gt;
&lt;h1&gt;一 定义&lt;/h1&gt;
&lt;p&gt;二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：&lt;/p&gt;
&lt;p&gt;1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；&lt;/p&gt;
&lt;p&gt;2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；&lt;/p&gt;
&lt;p&gt;3. 任意节点的左、右子树也分别为二叉查找树。&lt;/p&gt;
&lt;p&gt;4. 没有键值相等的节点（no duplicate nodes）。&lt;/p&gt;
&lt;p&gt;如下图，这个是普通的二叉树：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a66bbf9c00307aad82c461c62b7bd733.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在此基础上，加上节点之间的大小关系，就是二叉查找树：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/27f0746a9341b33e139fba8791525828.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;二 实现&lt;/h1&gt;
&lt;p&gt;在实现中，我们需要定义一个内部类Node，它包含两个分别指向左右节点的Node，一个用于排序的Key，以及该节点包含的值Value，还有一个记录该节点及所有子节点个数的值Number。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public class BinarySearchTreeSymbolTable&amp;lt;TKey, TValue&amp;gt; : SymbolTables&amp;lt;TKey, TValue&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt;, IEquatable&amp;lt;TValue&amp;gt;
{
    private Node root;
    private class Node
    {
        public Node Left { get; set; }
        public Node Right { get; set; }
        public int Number { get; set; }
        public TKey Key { get; set; }
        public TValue Value { get; set; }

        public Node(TKey key, TValue value, int number)
        {
            this.Key = key;
            this.Value = value;
            this.Number = number;
        }
    }
...
}&lt;/pre&gt;
&lt;h2&gt;查找&lt;/h2&gt;
&lt;p&gt;查找操作和二分查找类似，将key和节点的key比较，如果小于，那么就在Left Node节点查找,如果大于，则在Right Node节点查找，如果相等，直接返回Value。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/86343544d5f8b664890d863246a7394f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;该方法实现有迭代和递归两种。&lt;/p&gt;
&lt;p&gt;递归的方式实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public override TValue Get(TKey key)
{
    TValue result = default(TValue);
    Node node = root;
    while (node != null)
    {

        if (key.CompareTo(node.Key) &amp;gt; 0)
        {
            node = node.Right;
        }
        else if (key.CompareTo(node.Key) &amp;lt; 0)
        {
            node = node.Left;
        }
        else
        {
            result = node.Value;
            break;
        }
    }
    return result;
}&lt;/pre&gt;
&lt;p&gt;迭代的如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public TValue Get(TKey key)
{
    return GetValue(root, key);
}

private TValue GetValue(Node root, TKey key)
{
    if (root == null) return default(TValue);
    int cmp = key.CompareTo(root.Key);
    if (cmp &amp;gt; 0) return GetValue(root.Right, key);
    else if (cmp &amp;lt; 0) return GetValue(root.Left, key);
    else return root.Value;
}&lt;/pre&gt;
&lt;h2&gt;插入&lt;/h2&gt;
&lt;p&gt;插入和查找类似，首先查找有没有和key相同的，如果有，更新；如果没有找到，那么创建新的节点。并更新每个节点的Number值，代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public override void Put(TKey key, TValue value)
{
    root = Put(root, key, value);
}

private Node Put(Node x, TKey key, TValue value)
{
    //如果节点为空，则创建新的节点，并返回
    //否则比较根据大小判断是左节点还是右节点，然后继续查找左子树还是右子树
    //同时更新节点的Number的值
    if (x == null) return new Node(key, value, 1);
    int cmp = key.CompareTo(x.Key);
    if (cmp &amp;lt; 0) x.Left = Put(x.Left, key, value);
    else if (cmp &amp;gt; 0) x.Right = Put(x.Right, key, value);
    else x.Value = value;
    x.Number = Size(x.Left) + Size(x.Right) + 1;
    return x;
}

private int Size(Node node)
{
    if (node == null) return 0;
    else return node.Number;
}&lt;/pre&gt;
&lt;p&gt;插入操作图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d6285894101ea84ef776e0b8112fe790.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面是插入动画效果：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6527ae528666e9f85d4d80f4b080057b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;随机插入形成树的动画如下，可以看到，插入的时候树还是能够保持近似平衡状态：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e64a1ac9db0a8be1d19e5e43f396be99.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;最大最小值&lt;/h2&gt;
&lt;p&gt;如下图可以看出，二叉查找树的最大最小值是有规律的：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4ad01544a97a509336e45257d8bf970f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出，二叉查找树中，最左和最右节点即为最小值和最大值，所以我们只需迭代调用即可。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public override TKey GetMax()
{
    TKey maxItem = default(TKey);
    Node s = root;
    while (s.Right != null)
    {
        s = s.Right;
    }
    maxItem = s.Key;
    return maxItem;
}

public override TKey GetMin()
{
    TKey minItem = default(TKey);
    Node s = root;
    while (s.Left != null)
    {
        s = s.Left;
    }
    minItem = s.Key;
    return minItem;
}&lt;/pre&gt;
&lt;p&gt;以下是递归的版本：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public TKey GetMaxRecursive()
{
    return GetMaxRecursive(root);
}

private TKey GetMaxRecursive(Node root)
{
    if (root.Right == null) return root.Key;
    return GetMaxRecursive(root.Right);
}

public TKey GetMinRecursive()
{
    return GetMinRecursive(root);
}

private TKey GetMinRecursive(Node root)
{
    if (root.Left == null) return root.Key;
    return GetMinRecursive(root.Left);
}&lt;/pre&gt;
&lt;h2&gt;Floor和Ceiling&lt;/h2&gt;
&lt;p&gt;查找Floor(key)的值就是所有&amp;lt;=key的最大值，相反查找Ceiling的值就是所有&amp;gt;=key的最小值，下图是Floor函数的查找示意图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/89ef9bdc5db1c8abe8656f4011fadb8a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;以查找Floor为例，我们首先将key和root元素比较，如果key比root的key小，则floor值一定在左子树上；如果比root的key大，则有可能在右子树上，当且仅当其右子树有一个节点的key值要小于等于该key；如果和root的key相等，则floor值就是key。根据以上分析，Floor方法的代码如下，Ceiling方法的代码类似，只需要把符号换一下即可：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public TKey Floor(TKey key)
{
    Node x = Floor(root, key);
    if (x != null) return x.Key;
    else return default(TKey);
}

private Node Floor(Node x, TKey key)
{
    if (x == null) return null;
    int cmp = key.CompareTo(x.Key);
    if (cmp == 0) return x;
    if (cmp &amp;lt; 0) return Floor(x.Left, key);
    else
    {
        Node right = Floor(x.Right, key);
        if (right == null) return x;
        else return right;
    }
}&lt;/pre&gt;
&lt;h2&gt;删除&lt;/h2&gt;
&lt;p&gt;删除元素操作在二叉树的操作中应该是比较复杂的。首先来看下比较简单的删除最大最小值得方法。&lt;/p&gt;
&lt;p&gt;以删除最小值为例，我们首先找到最小值，及最左边左子树为空的节点，然后返回其右子树作为新的左子树。操作示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b3f61f765ae8aec1b115c56cd0afea1b.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public void DelMin()
{
    root = DelMin(root);
}

private Node DelMin(Node root)
{
    if (root.Left == null) return root.Right;
    root.Left = DelMin(root.Left);
    root.Number = Size(root.Left) + Size(root.Right) + 1;
    return root;
}&lt;/pre&gt;
&lt;p&gt;删除最大值也是类似。&lt;/p&gt;
&lt;p&gt;现在来分析一般情况，假定我们要删除指定key的某一个节点。这个问题的难点在于：删除最大最小值的操作，删除的节点只有1个子节点或者没有子节点，这样比较简单。但是如果删除任意节点，就有可能出现删除的节点有0个，1 个，2个子节点的情况，现在来逐一分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当删除的节点没有子节点时&lt;/strong&gt;，直接将该父节点指向该节点的link设置为null。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7ec417dd5d32a175eb0088dfb506aefb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当删除的节点只有1个子节点时&lt;/strong&gt;，将该自己点替换为要删除的节点即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/db8c7aa31a92f7b30e71220e484a5492.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当删除的节点有2个子节点时，问题就变复杂了。&lt;/p&gt;
&lt;p&gt;假设我们删除的节点t具有两个子节点。因为t具有右子节点，所以我们需要找到其右子节点中的最小节点，替换t节点的位置。这里有四个步骤：&lt;/p&gt;
&lt;p&gt;1. 保存带删除的节点到临时变量t&lt;/p&gt;
&lt;p&gt;2. 将t的右节点的最小节点min(t.right)保存到临时节点x&lt;/p&gt;
&lt;p&gt;3. 将x的右节点设置为deleteMin(t.right)，该右节点是删除后，所有比x.key最大的节点。&lt;/p&gt;
&lt;p&gt;4. 将x的做节点设置为t的左节点。&lt;/p&gt;
&lt;p&gt;整个过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bc09c2af51c7324749963461f457e6de.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;对应代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public void Delete(TKey key)
{
    root =Delete(root, key);
        
}

private Node Delete(Node x, TKey key)
{
    int cmp = key.CompareTo(x.Key);
    if (cmp &amp;gt; 0) x.Right = Delete(x.Right, key);
    else if (cmp &amp;lt; 0) x.Left = Delete(x.Left, key);
    else
    {
        if (x.Left == null) return x.Right;
        else if (x.Right == null) return x.Left;
        else
        {
            Node t = x;
            x = GetMinNode(t.Right);
            x.Right = DelMin(t.Right);
            x.Left = t.Left;
        }
    }
    x.Number = Size(x.Left) + Size(x.Right) + 1;
    return x;
}

private Node GetMinNode(Node x)
{
    if (x.Left == null) return x;
    else return GetMinNode(x.Left); 
}&lt;/pre&gt;
&lt;p&gt;以上二叉查找树的删除节点的算法不是完美的，因为随着删除的进行，二叉树会变得不太平衡，下面是动画演示。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b3ea3ad453cd52a56643600521632111.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;三 分析&lt;/h1&gt;
&lt;p&gt;二叉查找树的运行时间和树的形状有关，树的形状又和插入元素的顺序有关。在最好的情况下，节点完全平衡，从根节点到最底层叶子节点只有lgN个节点。在最差的情况下，根节点到最底层叶子节点会有N各节点。在一般情况下，树的形状和最好的情况接近。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7d88c12fab625fbd9c21022856994301.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在分析二叉查找树的时候，我们通常会假设插入的元素顺序是随机的。对BST的分析类似与快速排序中的查找：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0eb0437b708913046b55b6e64bea33f0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;BST中位于顶部的元素就是快速排序中的第一个划分的元素，该元素左边的元素全部小于该元素，右边的元素均大于该元素。&lt;/p&gt;
&lt;p&gt;对于N个不同元素，随机插入的二叉查找树来说，其平均查找/插入的时间复杂度大约为2lnN，这个和快速排序的分析一样，具体的证明方法不再赘述，参照快速排序。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h1&gt;四 总结&lt;/h1&gt;
&lt;p&gt;有了前篇文章 &lt;a href=&quot;http://blog.jobbole.com/79303/&quot; target=&quot;_blank&quot;&gt;二分查找&lt;/a&gt;的分析，对二叉查找树的理解应该比较容易。下面是二叉查找树的时间复杂度：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/881e6bacd8fb405fe37a4e6d5f55d7f9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;它和二分查找一样，插入和查找的时间复杂度均为lgN，但是在最坏的情况下仍然会有N的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是后面要讲的平衡查找树的内容了。下文首先讲解平衡查找树的最简单的一种：2-3查找树。&lt;/p&gt;
&lt;p&gt;希望本文对您了解二叉查找树有所帮助。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79305-ecaa57b9e.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79305-ecaa57b9e.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（6）：符号表及其基本实现</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;前面几篇文章介绍了基本的排序算法，排序通常是查找的前奏操作。从本文开始介绍基本的查找算法。&lt;/p&gt;
&lt;p&gt;在介绍查找算法，首先需要了解符号表这一抽象数据结构，本文首先介绍了什么是符号表，以及这一抽象数据结构的的API，然后介绍了两种简单的符号表的实现方式。&lt;/p&gt;
&lt;h1&gt;一符号表&lt;/h1&gt;
&lt;p&gt;在开始介绍查找算法之前，我们需要定义一个名为符号表（Symbol Table）的抽象数据结构，该数据结构类似我们再C#中使用的Dictionary，他是对具有键值对元素的一种抽象，每一个元素都有一个key和value，我们可以往里面添加key，value键值对，也可以根据key来查找value。在现实的生活中，我们经常会遇到各种需要根据key来查找value的情况，比如DNS根据域名查找IP地址，图书馆根据索引号查找图书等等：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/473003421e1c4851991cf4fab26f2bf6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了实现这一功能，我们定义一个抽象数据结构，然后选用合适的数据结构来实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public class ST&amp;lt;Key, Value&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;ST()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;创建一个查找表对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;void Put(Key key, Value val)&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;往集合中插入一条键值对记录，如果value为空，不添加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;Value Get(Key key)&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;根据key查找value，如果没找到返回null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;void Delete(Key key)&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;删除键为key的记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;boolean Contains(Key key)&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;判断集合中是否存在键为key的记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;boolean IsEmpty()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;判断查找表是否为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;int Size()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;返回集合中键值对的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;&lt;strong&gt;Iterable&amp;lt;Key&amp;gt; Keys()&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;295&quot;&gt;返回集合中所有的键&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;二实现&lt;/h1&gt;
&lt;h2&gt;1 使用无序链表实现查找表&lt;/h2&gt;
&lt;p&gt;查找表的实现关键在于数据结构的选择，最简单的一种实现是使用无序链表来实现，每一个节点记录key值，value值以及指向下一个记录的对象。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/fd72a641177de3b21c00aa5a9c4be9f2.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图，当我们往链表中插入元素的时候，从表头开始查找，如果找到，则更新value，否则，在表头插入新的节点元素。&lt;/p&gt;
&lt;p&gt;实现起来也很简单：&lt;/p&gt;
&lt;pre&gt;public class SequentSearchSymbolTable&amp;lt;TKey, TValue&amp;gt; : SymbolTables&amp;lt;TKey, TValue&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt;, IEquatable&amp;lt;TKey&amp;gt;
{
    private int length = 0;
    Node first;
    private class Node
    {
        public TKey key { get; set; }
        public TValue value { get; set; }
        public Node next { get; set; }

        public Node(TKey key, TValue value, Node next)
        {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public override TValue Get(TKey key)
    {
        TValue result = default(TValue);
        Node temp = first;
        while (temp != null)
        {
            if (temp.key.Equals(key))
            {
                result = temp.value;
                break;
            }
            temp = temp.next;
        }

        return result;
    }

    public override void Put(TKey key, TValue value)
    {
        Node temp = first;
        while (temp != null)
        {
            if (temp.key.Equals(key))
            {
                temp.value = value;
                return;
            }
            temp = temp.next;
        }
        first = new Node(key, value, first);
        length++;
    }

    ....
}&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从图或者代码中分析可知，插入的时候先要查找，如果存在则更新value，查找的时候需要从链表头进行查找，所以插入和查找的平均时间复杂度均为O(n)。那么有没有效率更好的方法呢，下面就介绍二分查找。&lt;/p&gt;
&lt;h2&gt;2 使用二分查找实现查找表&lt;/h2&gt;
&lt;p&gt;和采用无序链表实现不同，二分查找的思想是在内部维护一个按照key排好序的二维数组，每一次查找的时候，跟中间元素进行比较，如果该元素小，则继续左半部分递归查找，否则继续右半部分递归查找。整个实现代码如下：&lt;/p&gt;
&lt;pre&gt;class BinarySearchSymbolTable&amp;lt;TKey, TValue&amp;gt; : SymbolTables&amp;lt;TKey, TValue&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt;, IEquatable&amp;lt;TKey&amp;gt;
{
    private TKey[] keys;
    private TValue[] values;
    private int length;
    private static readonly int INIT_CAPACITY = 2;
    public BinarySearchSymbolTable(int capacity)
    {
        keys = new TKey[capacity];
        values = new TValue[capacity];
        length = capacity;
    }
    public BinarySearchSymbolTable() : this(INIT_CAPACITY)
    {
    }
    /// &amp;lt;summary&amp;gt;
    /// 根据key查找value。
    /// 首先查找key在keys中所处的位置，如果在length范围内，且存在该位置的值等于key，则返回值
    /// 否则，不存在
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public override TValue Get(TKey key)
    {
        int i = Rank(key);
        if (i &amp;lt; length &amp;amp;&amp;amp; keys[i].Equals(key))
            return values[i];
        else
            return default(TValue);
    }

    /// &amp;lt;summary&amp;gt;
    /// 向符号表中插入key，value键值对。
    /// 如果存在相等的key，则直接更新value，否则将该key，value插入到合适的位置
    ///  1.首先将该位置往后的元素都往后移以为
    ///  2.然后再讲该元素放到为i的位置上
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public override void Put(TKey key, TValue value)
    {
        int i = Rank(key);
        if (i &amp;lt; length &amp;amp;&amp;amp; keys[i].Equals(key))
        {
            values[i] = value;
            return;
        }
        //如果长度相等，则扩容
        if (length == keys.Length) Resize(2 * keys.Length);

        for (int j = length; j &amp;gt; i; j--)
        {
            keys[j] = keys[j - 1];
            values[j] = values[j - 1];
        }

        keys[i] = key;
        values[i] = value;
        length++;
    }

    /// &amp;lt;summary&amp;gt;
    /// 返回key在数组中的位置
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private int Rank(TKey key)
    {
        int lo = 0;
        int hi = length - 1;
        while (lo &amp;lt;= hi)
        {
            int mid = lo + (hi - lo) / 2;
            if (key.CompareTo(keys[mid]) &amp;gt; 0) lo = mid + 1;
            else if (key.CompareTo(keys[mid]) &amp;lt; 0) hi = mid - 1;
            else return mid;
        }
        return lo;
    }
    。。。
}&lt;/pre&gt;
&lt;p&gt;这里面重点是Rank方法，我们可以看到首先获取mid位置，然后将当前元素和mid位置元素比较，然后更新lo或者hi的位置用mid来替换，如果找到相等的，则直接返回mid，否则返回该元素在集合中应该插入的合适位置。上面是使用迭代的方式来实现的，也可以改写为递归：&lt;/p&gt;
&lt;pre&gt;private int Rank(TKey key, int lo, int hi)
{
    if (lo &amp;gt;= hi) return lo;

    int mid = lo + (hi - lo) / 2;
    if (key.CompareTo(keys[mid]) &amp;gt; 0)
        return Rank(key, mid + 1, hi);
    else if (key.CompareTo(keys[mid]) &amp;lt; 0)
        return Rank(key, lo, hi - 1);
    else
        return mid;
}&lt;/pre&gt;
&lt;p&gt;二分查找的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6685d34476ebf804e5d0a5e5c1ee127f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用有序的二维数组来实现查找表可以看出，采用二分查找只需要最多lgN+1次的比较即可找到对应元素，所以查找效率比较高。&lt;/p&gt;
&lt;p&gt;但是对于插入元素来说，每一次插入不存在的元素，需要将该元素放到指定的位置，然后，将他后面的元素依次后移，所以平均时间复杂度O(n)，对于插入来说效率仍然比较低。&lt;/p&gt;
&lt;h1&gt;三 总结&lt;/h1&gt;
&lt;p&gt;本文介绍了符号表这一抽象数据结构，然后介绍了两种基本实现：基于无序链表的实现和基于有序数组的实现，两种实现的时间复杂度如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4652ed9a0a74bed42b99a42950f2bcec.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，使用有序数组的二分查找法提高了符号表的查找速度，但是插入效率仍旧没有得到提高，而且在要维护数组有序，还需要进行排序操作。这两种实现方式简单直观，但是无法同时达到较高查找和插入效率。那么有没有一种数据结构既能够在查找的时候有较高的效率，在插入的时候也有较好的效率呢，本文只是一个引子，后面的系列文章将会介绍二叉查找树，平衡查找树以及哈希表。&lt;/p&gt;
&lt;p&gt;希望本文对您了解查找表的基本概念以及两种基本实现有所帮助。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79303-6eeba4ca4.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79303-6eeba4ca4.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（5）：优先级队列与堆排序</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;在很多应用中，我们通常需要按照优先级情况对待处理对象进行处理，比如首先处理优先级最高的对象，然后处理次高的对象。最简单的一个例子就是，在手机上玩游戏的时候，如果有来电，那么系统应该优先处理打进来的电话。&lt;/p&gt;
&lt;p&gt;在这种情况下，我们的数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新的对象。这种数据结构就是优先级队列(Priority Queue) 。&lt;/p&gt;
&lt;p&gt;本文首先介绍优先级队列的定义，有序和无序数组以及堆数据结构实现优先级队列，最后介绍了基于优先级队列的堆排序(Heap Sort)&lt;/p&gt;
&lt;h1&gt;一 定义&lt;/h1&gt;
&lt;p&gt;优先级队列和通常的栈和队列一样，只不过里面的每一个元素都有一个”优先级”，在处理的时候，首先处理优先级最高的。如果两个元素具有相同的优先级，则按照他们插入到队列中的先后顺序处理。&lt;/p&gt;
&lt;p&gt;优先级队列可以通过链表，数组，堆或者其他数据结构实现。&lt;/p&gt;
&lt;h1&gt;二 实现&lt;/h1&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;p&gt;最简单的优先级队列可以通过有序或者无序数组来实现，当要获取最大值的时候，对数组进行查找返回即可。代码实现起来也比较简单，这里就不列出来了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/91f309ae855ca5194d788e000f5b1f5a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图：&lt;/p&gt;
&lt;p&gt;· 如果使用无序数组，那么每一次插入的时候，直接在数组末尾插入即可，时间复杂度为O(1)，但是如果要获取最大值，或者最小值返回的话，则需要进行查找，这时时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;· 如果使用有序数组，那么每一次插入的时候，通过插入排序将元素放到正确的位置，时间复杂度为O(n)，但是如果要获取最大值的话，由于元阿苏已经有序，直接返回数组末尾的 元素即可，所以时间复杂度为O(1).&lt;/p&gt;
&lt;p&gt;所以采用普通的数组或者链表实现，无法使得插入和排序都达到比较好的时间复杂度。所以我们需要采用新的数据结构来实现。下面就开始介绍如何采用二叉堆(binary heap)来实现优先级队列&lt;/p&gt;
&lt;h2&gt;二叉堆&lt;/h2&gt;
&lt;p&gt;二叉堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 有了这一性质，那么二叉堆上最大值就是根节点了。&lt;/p&gt;
&lt;p&gt;二叉堆的表现形式：我们可以使用数组的索引来表示元素在二叉堆中的位置。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images.cnitblog.com/blog/94031/201403/022349560186587.png&quot; rel=&quot;lightbox[79300]&quot; title=&quot;Heap representation&quot;&gt;&lt;img title=&quot;Heap representation&quot; alt=&quot;Heap representation&quot; src=&quot;/images/jobbole.com/abb7339d8fdffb01b32e6c0fe45d471d.jpg&quot; width=&quot;515&quot; height=&quot;458&quot; border=&quot;0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从二叉堆中，我们可以得出：&lt;/p&gt;
&lt;p&gt;· 元素k的父节点所在的位置为[k/2]&lt;/p&gt;
&lt;p&gt;· 元素k的子节点所在的位置为2k和2k+1&lt;/p&gt;
&lt;p&gt;跟据以上规则，我们可以使用二维数组的索引来表示二叉堆。通过二叉堆，我们可以实现插入和删除最大值都达到O(nlogn)的时间复杂度。&lt;/p&gt;
&lt;p&gt;对于堆来说，最大元素已经位于根节点，那么删除操作就是移除并返回根节点元素，这时候二叉堆就需要重新排列；当插入新的元素的时候，也需要重新排列二叉堆以满足二叉堆的定义。现在就来看这两种操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从下至上的重新建堆&lt;/strong&gt;操作: 如果一个节点的值大于其父节点的值，那么该节点就需要上移，一直到满足该节点大于其两个子节点，而小于其根节点为止，从而达到使整个堆实现二叉堆的要求。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e61f2bba269f8acd641b6f1a6f5ce7bb.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看到，我们只需要将该元素k和其父元素k/2进行比较，如果比父元素大，则交换，然后迭代，一直到比父元素小为止。&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Swim(int k)
{
    //如果元素比其父元素大，则交换
    while (k &amp;gt; 1 &amp;amp;&amp;amp; pq[k].CompareTo(pq[k / 2]) &amp;gt; 0)
    {
        Swap(pq, k, k / 2);
        k = k / 2;
    }
}&lt;/pre&gt;
&lt;p&gt;这样，往堆中插入新元素的操作变成了，将该元素从下往上重新建堆操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dcb09d1b1fc75143f1956505c55a080c.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public static void Insert(T s)
{
    //将元素添加到数组末尾
    pq[++N] = s;
    //然后让该元素从下至上重建堆
    Swim(N);
}&lt;/pre&gt;
&lt;p&gt;动画如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/7c1c4dfbb9aae2eca806b9d0f8ccba57.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由上至下的重新建堆操作：&lt;/strong&gt;当某一节点比其子节点要小的时候，就违反了二叉堆的定义，需要和其子节点进行交换以重新建堆，直到该节点都大于其子节点为止：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0a4a45b9afe1ef2f5ad550d2db2d4040.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码实现如下:&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Sink(int k)
{
    while (2 * k &amp;lt; N)
    {
        int j = 2 * k;
        //去左右子节点中，稍大的那个元素做比较
        if (pq[j].CompareTo(pq[j + 1]) &amp;lt; 0) j++;
        //如果父节点比这个较大的元素还大，表示满足要求，退出
        if (pq[k].CompareTo(pq[j]) &amp;gt; 0) break;
        //否则，与子节点进行交换
        Swap(pq, k, j);
        k = j;
    }
}&lt;/pre&gt;
&lt;p&gt;这样，移除并返回最大元素操作DelMax可以变为：&lt;/p&gt;
&lt;p&gt;1. 移除二叉堆根节点元素，并返回&lt;/p&gt;
&lt;p&gt;2. 将数组中最后一个元素放到根节点位置&lt;/p&gt;
&lt;p&gt;3. 然后对新的根节点元素进行Sink操作，直到满足二叉堆要求。&lt;/p&gt;
&lt;p&gt;移除最大值并返回的操作如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/91c38a3809ebb8b683932b182e7d81d4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上操作的实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public static T DelMax()
{
    //根元素从1开始，0不存放值
    T max = pq[1];
    //将最后一个元素和根节点元素进行交换
    Swap(pq, 1, N--);
    //对根节点从上至下重新建堆
    Sink(1);
    //将最后一个元素置为空
    pq[N + 1] = default(T);
    return max;
}&lt;/pre&gt;
&lt;p&gt;动画如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/9099b6078d5a1f463cde85262b7f2fe7.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;三 堆排序&lt;/h1&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/698df477bd913a53dba46cb4ad6b1941.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;概念&lt;/h2&gt;
&lt;p&gt;运用二叉堆的性质，可以利用它来进行一种就地排序，该排序的步骤为：&lt;/p&gt;
&lt;p&gt;1. 使用序列的所有元素，创建一个最大堆。&lt;/p&gt;
&lt;p&gt;2. 然后重复删除最大元素。&lt;/p&gt;
&lt;p&gt;如下图，以对S O R T E X A M P L E 排序为例，首先本地构造一个最大堆，即对节点进行Sink操作，使其符合二叉堆的性质。&lt;/p&gt;
&lt;p&gt;然后再重复删除根节点，也就是最大的元素，操作方法与之前的二叉堆的删除元素类似。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/05228c8c0bbcd8216512b2b83dbfb4d7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建最大二叉堆&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;使用至下而上的方法创建二叉堆的方法为，分别对叶子结点的上一级节点以重上之下的方式重建堆。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;for (int k = N / 2; k &amp;gt;= 1; k--)
{
    Sink(pq, k, N);
}&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b235c9f9745fdf744dcf07cc2b9a4666.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用二叉堆排序其实就是循环移除顶部元素到数组末尾，然后利用Sink重建堆的操作。如下图，实现代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;while (N &amp;gt; 1)
{
    Swap(pq, 1, N--);
    Sink(pq, 1, N);
}&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e6bf5bc88e4aec9e316665194d7a9847.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;堆排序的动画如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2462a354605cbda295eaa1c8cf6d9d9f.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;1. 在构建最大堆的时候，最多需要2N次比较和交换&lt;/p&gt;
&lt;p&gt;2. 堆排序最多需要2NlgN次比较和交换操作&lt;/p&gt;
&lt;p&gt;优点：堆排序最显著的优点是，他是就地排序，并且其最坏情况下时间复杂度为NlogN。经典的合并排序不是就地排序，它需要线性长度的额外空间，而快速排序其最坏时间复杂度为N&lt;sup&gt;2&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bebc1cc802723e67d821dde0c821c5d4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;缺点：堆排序对时间和空间都进行了优化，但是：&lt;/p&gt;
&lt;p&gt;1. 其内部循环要比快速排序要长。&lt;/p&gt;
&lt;p&gt;2. 并且其操作在N和N/2之间进行比较和交换，当数组长度比较大的时候，对CPU缓存利用效率比较低。&lt;/p&gt;
&lt;p&gt;3. 非稳定性排序。&lt;/p&gt;
&lt;h1&gt;四 排序算法的小结&lt;/h1&gt;
&lt;p&gt;本文及前面文章介绍了&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduction-Insertion-and-Selection-and-Shell-Sort.html&quot; target=&quot;_blank&quot;&gt;选择排序&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduction-Insertion-and-Selection-and-Shell-Sort.html&quot; target=&quot;_blank&quot;&gt;插入排序&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduction-Insertion-and-Selection-and-Shell-Sort.html&quot; target=&quot;_blank&quot;&gt;希尔排序&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Merge-Sort.html&quot; target=&quot;_blank&quot;&gt;合并排序&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Quick-Sort.html&quot; target=&quot;_blank&quot;&gt;快速排序&lt;/a&gt;以及本文介绍的堆排序。各排序的稳定性，平均，最坏，最好的时间复杂度如下表：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/77829d78f3e260b750759f4c4ac94994.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，不同的排序方法有不同的特征，有的速度快，但是不稳定，有的稳定，但是不是就地排序，有的是就地排序，但是最坏情况下时间复杂度不好。那么有没有一种排序能够集合以上所有的需求呢?&lt;/p&gt;
&lt;h1&gt;五 结语&lt;/h1&gt;
&lt;p&gt;本文介绍了二叉堆，以及基于二叉堆的堆排序，他是一种就地的非稳定排序，其最好和平均时间复杂度和快速排序相当，但是最坏情况下的时间复杂度要优于快速排序。但是由于他对元素的操作通常在N和N/2之间进行，所以对于大的序列来说，两个操作数之间间隔比较远，对CPU缓存利用不太好，故速度没有快速排序快。&lt;/p&gt;
&lt;p&gt;下文将开始介绍查找算法，并介绍二叉查找树。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79300-fdfad903b.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79300-fdfad903b.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（4）：快速排序</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;上篇文章介绍了时间复杂度为O(nlgn)的合并排序，本篇文章介绍时间复杂度同样为O(nlgn)但是排序速度比合并排序更快的快速排序(Quick Sort)。&lt;/p&gt;
&lt;p&gt;快速排序是&lt;a href=&quot;http://www.siam.org/pdf/news/637.pdf&quot; target=&quot;_blank&quot;&gt;20世纪科技领域的十大算法之一&lt;/a&gt; ，他由&lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare&quot; target=&quot;_blank&quot;&gt;C. A. R. Hoare&lt;/a&gt;于1960年提出的一种划分交换排序。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d935cb65339153442501ddbf340c0a08.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;快速排序也是一种采用分治法解决问题的一个典型应用。在很多编程语言中，对数组，列表进行的非稳定排序在内部实现中都使用的是快速排序。而且快速排序在面试中经常会遇到。&lt;/p&gt;
&lt;p&gt;本文首先介绍快速排序的思路，算法的实现、分析、优化及改进，最后分析了.NET 中列表排序的内部实现。&lt;/p&gt;
&lt;h1&gt;一 原理&lt;/h1&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/35c7307cbbc2497295a8f5830583ceff.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;快速排序的基本思想如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对数组进行随机化。&lt;/li&gt;
&lt;li&gt;从数列中取出一个数作为中轴数(pivot)。&lt;/li&gt;
&lt;li&gt;将比这个数大的数放到它的右边，小于或等于它的数放到它的左边。&lt;/li&gt;
&lt;li&gt;再对左右区间重复第三步，直到各区间只有一个数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3cc32516c98cefe540b70cd7573dd297.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示快速排序的一个重要步骤是对序列进行以中轴数进行划分，左边都小于这个中轴数，右边都大于该中轴数，然后对左右的子序列继续这一步骤直到子序列长度为1。&lt;/p&gt;
&lt;p&gt;下面来看某一次划分的步骤，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6c6d8af6e8c29e81d14dcbc2b57170ef.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图中的划分操作可以分为以下5个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取中轴元素&lt;/li&gt;
&lt;li&gt;i从左至右扫描，如果小于基准元素，则i自增，否则记下a[i]&lt;/li&gt;
&lt;li&gt;j从右至左扫描，如果大于基准元素，则i自减，否则记下a[j]&lt;/li&gt;
&lt;li&gt;交换a[i]和a[j]&lt;/li&gt;
&lt;li&gt;重复这一步骤直至i和j交错，然后和基准元素比较，然后交换。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;划分过程的代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 快速排序中的划分过程
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;array&quot;&amp;gt;待划分的数组&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;lo&quot;&amp;gt;最左侧位置&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;hi&quot;&amp;gt;最右侧位置&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;中间元素位置&amp;lt;/returns&amp;gt;
private static int Partition(T[] array, int lo, int hi)
{
    int i = lo, j = hi + 1;
    while (true)
    {
        //从左至右扫描，如果碰到比基准元素array[lo]小，则该元素已经位于正确的分区，i自增，继续比较i+1；
        //否则，退出循环，准备交换
        while (array[++i].CompareTo(array[lo]) &amp;lt; 0)
        {
            //如果扫描到了最右端，退出循环
            if (i == hi) break;
        }

        //从右自左扫描，如果碰到比基准元素array[lo]大，则该元素已经位于正确的分区，j自减，继续比较j-1
        //否则，退出循环，准备交换
        while (array[--j].CompareTo(array[lo]) &amp;gt; 0)
        {
            //如果扫描到了最左端，退出循环
            if (j == lo) break;
        }

        //如果相遇，退出循环
        if (i &amp;gt;= j) break;

        //交换左a[i],a[j]右两个元素，交换完后他们都位于正确的分区
        Swap(array, i, j);
    }
    //经过相遇后，最后一次a[i]和a[j]的交换
    //a[j]比a[lo]小，a[i]比a[lo]大，所以将基准元素与a[j]交换
    Swap(array, lo, j);
    //返回扫描相遇的位置点
    return j;
}&lt;/pre&gt;
&lt;p&gt;划分前后，元素在序列中的分布如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/00014a047728a750923a530152e28117.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;二 实现&lt;/h1&gt;
&lt;p&gt;与合并算法基于合并这一过程一样，快速排序基于分割(Partition)这一过程。只需要递归调用Partition这一操作，每一次以Partition返回的元素位置来划分为左右两个子序列，然后继续这一过程直到子序列长度为1，代码的实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public class QuickSort&amp;lt;T&amp;gt; where T : IComparable&amp;lt;T&amp;gt;
{
    public static void Sort(T[] array)
    {
        Sort(array, 0, array.Length - 1);
    }

    private static void Sort(T[] array, int lo, int hi)
    {
        //如果子序列为1，则直接返回
        if (lo &amp;gt;= hi) return;
        //划分，划分完成之后，分为左右序列，左边所有元素小于array[index]，右边所有元素大于array[index]
        int index = Partition(array, lo, hi);

       //对左右子序列进行排序完成之后，整个序列就有序了
        //对左边序列进行递归排序
        Sort(array, lo, index - 1);
        //对右边序列进行递归排序
        Sort(array, index + 1, hi);
    }
}&lt;/pre&gt;
&lt;p&gt;下图说明了快速排序中，每一次划分之后的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3d72ba13c788fdd4241ed0809ed5cf73.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;一般快速排序的动画如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/321b865ecac4ef38c4ac3d39d7ed7161.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;三 分析&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;在最好的情况下，快速排序只需要大约nlgn次比较操作，在最坏的情况下需要大约1/2 n&lt;sup&gt;2 &lt;/sup&gt;次比较操作。在最好的情况下，每次的划分都会恰好从中间将序列划分开来，那么只需要lgn次划分即可划分完成，是一个标准的分治算法Cn=2Cn/2+N，每一次划分都需要比较N次，大家可以回想下我们是如何证明合并排序的时间复杂度的。
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6ee4f64ac2f8f98d9b0cde65acc6d307.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在最坏的情况下，即序列已经排好序的情况下，每次划分都恰好把数组划分成了0，n两部分，那么需要n次划分，但是比较的次数则变成了n, n-1, n-2,….1, 所以整个比较次数约为n(n-1)/2~n&lt;sup&gt;2&lt;/sup&gt;/2.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;快速排序平均需要大约2NlnN次比较，来对长度为n的排序关键字唯一的序列进行排序。 证明也比较简单：假设C&lt;sub&gt;N&lt;/sub&gt;为快速排序平均花在比较上的时间，初始C&lt;sub&gt;0&lt;/sub&gt;=C&lt;sub&gt;1&lt;/sub&gt;=0，对于N&amp;gt;1的情况，有：&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/74da1f49a1d53ce5741f1df4548567e2.jpg&quot;&gt;
&lt;p&gt;其中N+1是分割时的比较次数，&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/5b161b304ade8da0f2b0118f913e0d33.jpg&quot;&gt; 表示将序列分割为0，和N-1左右两部分的概率为1/N, 划分为1，N-2左右两部分的概率也为1/N，都是等概率的。&lt;/p&gt;
&lt;p&gt;然后对上式左右两边同时乘以N，整理得到：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/df2c192117e078b3e2485a1f2cb000b0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后，对于N为N-1的情况：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c10fd6c8b225ac2955fd8bc8d619dc14.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;两式相减，然后整理得到：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/460257636e7efafdb1b852131e3b61a5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后左右两边同时除以N(N+1)，得到:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/4b1987b05a0b2298259d4179b889795e.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这是一个递归式，我们将&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/e660704b5b32193bef39a2a6fb36b583.jpg&quot;&gt; 递归展开得到：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3c170538abf537886904603a86ae2826.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后处理一下得到：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;平均情况下，快速排序需要大约1.39NlgN次比较，这比合并排序多了39%的比较，但是由于涉及了较少的数据交换和移动操作，他要比合并排序更快。&lt;/li&gt;
&lt;li&gt;为了避免出现最坏的情况，导致序列划分不均，我们可以首先对序列进行随机化排列然后再进行排序就可以避免这一情况的出现。&lt;/li&gt;
&lt;li&gt;快速排序是一种就地(in-place)排序算法。在分割操作中只需要常数个额外的空间。在递归中，也只需要对数个额外空间。&lt;/li&gt;
&lt;li&gt;另外，快速排序是非稳定性排序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/342d3315291ed3f2432d7a22437830f3.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;四 改进&lt;/h1&gt;
&lt;p&gt;对一般快速排序进行一些改进可以提高其效率。&lt;/p&gt;
&lt;p&gt;1. 当划分到较小的子序列时，通常可以使用插入排序替代快速排序&lt;/p&gt;
&lt;p&gt;对于较小的子序列（通常序列元素个数为10个左右），我们就可以采用插入排序直接进行排序而不用继续递归，算法改造如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private const int CUTTOFF = 10;
private static void Sort(T[] array, int lo, int hi)
{
    //如果子序列为1，则直接返回
    if (lo &amp;gt;= hi) return;
    //对于小序列，直接采用插入排序替代
    if (hi - lo &amp;lt;= CUTTOFF - 1) 
    {
        Sort&amp;lt;int&amp;gt;.InsertionSort(array, lo, hi);
        return;
    }
    //划分，划分完成之后，分为左右序列，左边所有元素小于array[index]，右边所有元素大于array[index]
    int index = Partition(array, lo, hi);

    //对左右子序列进行排序完成之后，整个序列就有序了

    //对左边序列进行递归排序
    Sort(array, lo, index - 1);
    //对右边序列进行递归排序
    Sort(array, index + 1, hi);
}&lt;/pre&gt;
&lt;p&gt;2. 三平均分区法(Median of three partitioning)&lt;/p&gt;
&lt;p&gt;在一般的的快速排序中，选择的是第一个元素作为中轴(pivot),这会出现某些分区严重不均的极端情况，比如划分为了1和n-1两个序列，从而导致出现最坏的情况。三平均分区法与一般的快速排序方法不同，它并不是选择待排数组的第一个数作为中轴，而是选用待排数组最左边、最右边和最中间的三个元素的中间值作为中轴。这一改进对于原来的快速排序算法来说，主要有两点优势：&lt;/p&gt;
&lt;p&gt;（1） 首先，它使得最坏情况发生的几率减小了。&lt;/p&gt;
&lt;p&gt;（2） 其次，未改进的快速排序算法为了防止比较时数组越界，在最后要设置一个哨点。如果在分区排序时，中间的这个元素（也即中轴）是与最右边数过来第二个元素进行交换的话，那么就可以省略与这一哨点值的比较。&lt;/p&gt;
&lt;p&gt;对于三平均分区法还可以进一步扩展，在选取中轴值时，可以从由左中右三个中选取扩大到五个元素中或者更多元素中选取，一般的，会有（2t＋1）平均分区法（median-of-(2t+1)。常用的一个改进是，当序列元素小于某个阈值N时，采用三平均分区，当大于时采用5平均分区。&lt;/p&gt;
&lt;p&gt;采用三平均分区法对快速排序的改进如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Sort(T[] array, int lo, int hi)
{
    //对于小序列，直接采用插入排序替代
    if (hi - lo &amp;lt;= CUTTOFF - 1) 
    {
        //Sort&amp;lt;int&amp;gt;.InsertionSort(array, lo, hi);
        return;
    }
    //采用三平均分区法查找中轴
    int m = MedianOf3(array, lo, lo + (hi - lo) / 2, hi);
    Swap(array, lo, m);
    //划分，划分完成之后，分为左右序列，左边所有元素小于array[index]，右边所有元素大于array[index]
    int index = Partition(array, lo, hi);

    //对左右子序列进行排序完成之后，整个序列就有序了

    //对左边序列进行递归排序
    Sort(array, lo, index - 1);
    //对右边序列进行递归排序
    Sort(array, index + 1, hi);
}

/// &amp;lt;summary&amp;gt;
/// 查找三个元素中位于中间的那个元素
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;array&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;lo&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;center&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;hi&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
private static int MedianOf3(T[] array, int lo, int center, int hi)
{
    return (Less(array[lo], array[center]) ?
           (Less(array[center], array[hi]) ? center : Less(array[lo], array[hi]) ? hi : lo) :
           (Less(array[hi], array[center]) ? center : Less(array[hi], array[lo]) ? hi : lo));
}

private static bool Less(T t1, T t2)
{
    return t1.CompareTo(t2) &amp;lt; 0;
}&lt;/pre&gt;
&lt;p&gt;使用插入排序对小序列进行排序以及使用三平均分区法对一般快速排序进行改进后运行结果示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/bea7a3ee1344088671686ee8caf747a5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;3. 三分区(3-way partitioning) 快速排序&lt;/p&gt;
&lt;p&gt;通常，我们的待排序的序列关键字中会有很多重复的值，比如我们想对所有的学生按照年龄进行排序，按照性别进行排序等，这样每一类别中会有很多的重复的值。理论上，这些重复的值只需要处理一次就行了。但是一般的快速排序会递归进行划分，因为一般的快速排序只是将序列划分为了两部分，小于或者大于等于这两部分。&lt;/p&gt;
&lt;p&gt;既然要利用连续、相等的元素不需要再参与排序这个事实，一个直接的想法就是通过划分让相等的元素连续地摆放：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/01eecd8a247b351703c03b642ed483cf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后只对左侧小于V的序列和右侧大于V对的序列进行排序。这种三路划分与计算机科学中无处不在，它与Dijkstra提出的“荷兰国旗问题”(&lt;a href=&quot;http://www.iis.sinica.edu.tw/~scm/ncs/2010/10/dutch-national-flag-problem/&quot;&gt;The Dutch National Flag Problem&lt;/a&gt;)非常相似。&lt;/p&gt;
&lt;p&gt;Dijkstra的方法如上图：&lt;/p&gt;
&lt;p&gt;从左至右扫描数组，维护一个指针lt使得[lo…lt-1]中的元素都比v小，一个指针gt使得所有[gt+1….hi]的元素都大于v，以及一个指针i，使得所有[lt…i-1]的元素都和v相等。元素[i…gt]之间是还没有处理到的元素，i从lo开始，从左至右开始扫描：&lt;/p&gt;
&lt;p&gt;· 如果a[i]&amp;lt;v: 交换a[lt]和a[i],lt和i自增&lt;/p&gt;
&lt;p&gt;· 如果a[i]&amp;gt;v:交换a[i]和a[gt], gt自减&lt;/p&gt;
&lt;p&gt;· 如果a[i]=v: i自增&lt;/p&gt;
&lt;p&gt;下面是使用Dijkstra的三分区快速排序代码：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Sort(T[] array, int lo, int hi)
{
    //对于小序列，直接采用插入排序替代
    if (hi - lo &amp;lt;= CUTTOFF - 1)
    {
        Sort&amp;lt;int&amp;gt;.InsertionSort(array, lo, hi);
        return;
    }
    //三分区
    int lt = lo, i = lo + 1, gt = hi;
    T v = array[lo];
    while (i&amp;lt;=gt)
    {
        int cmp = array[i].CompareTo(v);
        if (cmp &amp;lt; 0) Swap(array, lt++, i++);
        else if (cmp &amp;gt; 0) Swap(array, i, gt--);
        else i++;
    }

    //对左边序列进行递归排序
    Sort(array, lo, lt - 1);
    //对右边序列进行递归排序
    Sort(array, gt + 1, hi);
}&lt;/pre&gt;
&lt;p&gt;三分区快速排序的每一步如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d299a5969c55fa3358cf40dade233218.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;三分区快速排序的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/14e24fbcac1855e930f401ffb3a4b878.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;Dijkstra的三分区快速排序虽然在快速排序发现不久后就提出来了，但是对于序列中重复值不多的情况下，它比传统的2分区快速排序需要更多的交换次数。&lt;/p&gt;
&lt;p&gt;Bentley 和D. McIlroy在普通的三分区快速排序的基础上，对一般的快速排序进行了改进。在划分过程中，i遇到的与v相等的元素交换到最左边，j遇到的与v相等的元素交换到最右边，i与j相遇后再把数组两端与v相等的元素交换到中间&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d7b1bbbd5645aa59f93215949850239f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个方法不能完全满足只扫描一次的要求，但它有两个好处：首先，如果数据中没有重复的值，那么该方法几乎没有额外的开销；其次，如果有重复值，那么这些重复的值不会参与下一趟排序，减少了无用的划分。&lt;/p&gt;
&lt;p&gt;下面是采用 Bentley&amp;amp;D. McIlroy 三分区快速排序的算法改进：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Sort(T[] array, int lo, int hi)
{
    //对于小序列，直接采用插入排序替代
    if (hi - lo &amp;lt;= CUTTOFF - 1)
    {
        Sort&amp;lt;int&amp;gt;.InsertionSort(array, lo, hi);
        return;
    }
    // Bentley-McIlroy 3-way partitioning
    int i = lo, j = hi + 1;
    int p = lo, q = hi + 1;
    T v = array[lo];
    while (true)
    {
        while (Less(array[++i], v))
            if (i == hi) break;
        while (Less(v, array[--j]))
            if (j == lo) break;

        // pointers cross
        if (i == j &amp;amp;&amp;amp; Equal(array[i], v))
            Swap(array, ++p, i);
        if (i &amp;gt;= j) break;

        Swap(array, i, j);
        if (Equal(array[i], v)) Swap(array, ++p, i);
        if (Equal(array[j], v)) Swap(array, --q, j);
    }

    //将相等的元素交换到中间
    i = j + 1;
    for (int k = lo; k &amp;lt;= p; k++) Swap(array, k, j--);
    for (int k = hi; k &amp;gt;= q; k--) Swap(array, k, i++);

    Sort(array, lo, j);
    Sort(array, i, hi);
}&lt;/pre&gt;
&lt;p&gt;三分区快速排序的动画如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/dff16aa526ebc2a2cd259152f15f35f4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;4.并行化&lt;/p&gt;
&lt;p&gt;和前面讨论对合并排序的改进一样，对所有使用分治法解决问题的算法其实都可以进行并行化，快速排序的并行化改进我在之前的&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Something-about-Concurrent-and-Parallel-Programming.html&quot; target=&quot;_blank&quot;&gt;浅谈并发与并行&lt;/a&gt;这篇文章中已经有过介绍，这里不再赘述。&lt;/p&gt;
&lt;h1&gt;五 .NET 中元素排序的内部实现&lt;/h1&gt;
&lt;p&gt;快速排序作为一种优秀的排序算法，在很多编程语言的元素内部排序中均有实现，比如Java中对基本数据类型(primitive type)的排序,C++，Matlab，Python，FireFox Javascript等语言中均将快速排序作为其内部元素排序的算法。同样.NET中亦是如此。&lt;/p&gt;
&lt;p&gt;.NET这种对List&amp;lt;T&amp;gt;数组元素进行排序是通过调用Sort方法实现的，其内部则又是通过Array.Sort实现，MSDN上说在&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/b0zbh7b6(v=vs.100).aspx&quot; target=&quot;_blank&quot;&gt;.NET 4.0及之前的版本&lt;/a&gt;，Array.Sort采用的是快速排序，然而在&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/b0zbh7b6(v=vs.110).aspx&quot; target=&quot;_blank&quot;&gt;.NET 4.5&lt;/a&gt;中，则对这一算法进行了改进，采用了名为&lt;a href=&quot;http://en.wikipedia.org/wiki/Introsort&quot; target=&quot;_blank&quot;&gt;Introspective sort&lt;/a&gt; 的算法，即保证在一般情况下达到最快排序速度，又能保证能够在出现最差情况是进行优化。他其实是一种混合算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当待分区的元素个数小于16个时，采用插入排序&lt;/li&gt;
&lt;li&gt;当分区次数超过2*logN，N是输入数组的区间大小，则使用堆排序(Heapsort)&lt;/li&gt;
&lt;li&gt;否则，使用快速排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了Reflector这一神器，我们可以查看.NET中的ArraySort的具体实现:&lt;/p&gt;
&lt;p&gt;Array.Sort这一方法在mscorlib这一程序集中，具体的实现方法有分别针对泛型和普通类型的SortedGenericArray和SortedObjectArray，里面的实现大同小异，我们以SortedGenericArray这个类来作为例子看:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/3e0e104b96e27175301547c8616fcc88.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先要看的是Sort方法，其实现如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ab589de170f1ef1fde592fddba686b3a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;该方法中，首先判断运行的.NET对的版本，如果是4.5及以上版本，则用IntrospectiveSort算法，否则采用限定深度的快速排序算法DepthLimitedQuickSort。先看IntrospectiveSort：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/529a6e89c21c0c842a1777bd92b5c93d.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;该方法第一个元素为数组的最左边元素位置，第二个参数为最右边元素位置，第三个参数为2*log&lt;sub&gt;2&lt;/sub&gt;N，继续看方法内部：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/d76d814acd660d0f83baaa92cd7cd48f.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，当num&amp;lt;=16时，如果元素个数为1,2,3，则直接调用SwapIfGreaterWithItem进行排序了。否则直接调用InsertSort进行插入排序。&lt;/p&gt;
&lt;p&gt;这里面也是一个循环，每循环一下depthLimit就减小1个，如果为0表示划分的次数超过了2logN，则直接调用基排序(HeapSort)，这里面的划分方法PickPivortAndPartitin的实现如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/990eb3ac466db2e76cd6c1e76db1b3a5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;它其实是一个标准的三平均快速排序。可以看到在.NET 4.5中对Quick进行优化的部分主要是在元素个数比较少的时候采用选择插入，并且在递归深度超过2logN的时候，采用基排序。&lt;/p&gt;
&lt;p&gt;下面再来看下在.NET 4.0及以下平台下排序DepthLimitedQuickSort方法的实现：&lt;/p&gt;
&lt;p&gt;从名称中可以看出这是限定深度的快速排序，在第三个参数传进去的是0×20，也就是32。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/a12cc44e5cde66e8db48d5c418c836aa.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，当划分的次数大于固定的32次的时候，采用了基排序，其他的部分是普通的快速排序。&lt;/p&gt;
&lt;h1&gt;六 总结&lt;/h1&gt;
&lt;p&gt;由于快速排序在排序算法中具有排序速度快，而且是就地排序等优点，使得在许多编程语言的内部元素排序实现中采用的就是快速排序，本问首先介绍了一般的快速排序，分析了快速排序的时间复杂度，然后就分析了对快速排序的几点改进，包括对小序列采用插入排序替代，三平均划分，三分区划分等改进方法。最后介绍了.NET不同版本下的对元素内部排序的实现。&lt;/p&gt;
&lt;p&gt;快速排序很重要，希望本文对您了解快速排序有所帮助。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79298-f84dd203d.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79298-f84dd203d.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
      <item>
        <title>浅谈算法和数据结构（3）：合并排序</title>
        <description>

					
		
&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
google_ad_client = &quot;ca-pub-7056282119617872&quot;;
google_ad_slot = &quot;6645040531&quot;;
google_ad_width = 300;
google_ad_height = 250;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;http://pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;
&lt;/div&gt;
&lt;br/ --&gt;

&lt;p&gt;合并排序，顾名思义，就是通过将两个有序的序列合并为一个大的有序的序列的方式来实现排序。合并排序是一种典型的分治算法：首先将序列分为两部分，然后对每一部分进行循环递归的排序，然后逐个将结果进行合并。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/ef06ab6f3727fa0cac92c29b56d4a97a.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;合并排序最大的优点是它的时间复杂度为O(nlgn)，这个是我们之前的选择排序和插入排序所达不到的。他还是一种稳定性排序，也就是相等的元素在序列中的相对位置在排序前后不会发生变化。他的唯一缺点是，需要利用额外的N的空间来进行排序。&lt;/p&gt;
&lt;h1&gt;一 原理&lt;/h1&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/c7e68ec4106cd05782cdc4382a0f1c80.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;合并排序依赖于合并操作，即将两个已经排序的序列合并成一个序列，具体的过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;申请空间，使其大小为两个已经排序序列之和，然后将待排序数组复制到该数组中。&lt;/li&gt;
&lt;li&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/li&gt;
&lt;li&gt;比较复制数组中两个指针所指向的元素，选择相对小的元素放入到原始待排序数组中，并移动指针到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3直到某一指针达到序列尾&lt;/li&gt;
&lt;li&gt;将另一序列剩下的所有元素直接复制到原始数组末尾&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该过程实现如下，注释比较清楚：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Merge(T[] array, int lo, int mid, int hi)
{
    int i = lo, j = mid + 1;
    //把元素拷贝到辅助数组中
    for (int k = lo; k &amp;lt;= hi; k++)
    {
        aux[k] = array[k];
    }
    //然后按照规则将数据从辅助数组中拷贝回原始的array中
    for (int k = lo; k &amp;lt;= hi; k++)
    {
        //如果左边元素没了， 直接将右边的剩余元素都合并到到原数组中
        if (i &amp;gt; mid)
        {
            array[k] = aux[j++];
        }//如果右边元素没有了，直接将所有左边剩余元素都合并到原数组中
        else if (j &amp;gt; hi)
        {
            array[k] = aux[i++];
        }//如果左边右边小，则将左边的元素拷贝到原数组中
        else if (aux[i].CompareTo(aux[j]) &amp;lt; 0)
        {
            array[k] = aux[i++];
        }
        else
        {
            array[k] = aux[j++];
        }
    }
}&lt;/pre&gt;
&lt;p&gt;下图是使用以上方法将ＥＥＧＭＲ和ＡＣＥＲＴ这两个有序序列合并为一个大的序列的过程演示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/2a103137bb585aa2c3c13bdeab551941.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;二 实现&lt;/h1&gt;
&lt;p&gt;合并排序有两种实现，一种是至上而下(Top-Down)合并，一种是至下而上 (Bottom-Up)合并，两者算法思想差不多，这里仅介绍至上而下的合并排序。&lt;/p&gt;
&lt;p&gt;至上而下的合并是一种典型的分治算法(Divide-and-Conquer)，如果两个序列已经排好序了，那么采用合并算法，将这两个序列合并为一个大的序列也就是对大的序列进行了排序。&lt;/p&gt;
&lt;p&gt;首先我们将待排序的元素均分为左右两个序列，然后分别对其进去排序，然后对这个排好序的序列进行合并，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;public class MergeSort&amp;lt;T&amp;gt; where T : IComparable&amp;lt;T&amp;gt;
{
    private static T[] aux; // 用于排序的辅助数组
    public static void Sort(T[] array)
    {
        aux = new T[array.Length]; // 仅分配一次
        Sort(array, 0, array.Length - 1);
    }
    private static void Sort(T[] array, int lo, int hi)
    {
        if (lo &amp;gt;= hi) return; //如果下标大于上标，则返回
        int mid = lo + (hi - lo) / 2;//平分数组
        Sort(array, lo, mid);//循环对左侧元素排序
        Sort(array, mid + 1, hi);//循环对右侧元素排序
        Merge(array, lo, mid, hi);//对左右排好的序列进行合并
    }
    ...
}&lt;/pre&gt;
&lt;p&gt;以排序一个具有15个元素的数组为例，其调用堆栈为：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/453fadd4224adc75a1b59855e7d48a70.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们单独将Merge步骤拿出来，可以看到合并的过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/b78a9a3c29e118684b30c0dbd2159e31.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;三 图示及动画&lt;/h1&gt;
&lt;p&gt;如果以排序38,27,43,3,9,82,10为例，将合并排序画出来的话，可以看到如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/970e639deb85e6250a2e48c60115bfaf.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图是合并排序的可视化效果图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/6743e85ecf9cb686663fbb92cbe02cca.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;对6 5 3 1 8 7 24 进行合并排序的动画效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/8ffe489ec7890cc127cc60e0e5e6b925.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图演示了合并排序在不同的情况下的效率：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/666e11db508e5f15bcea4e3003df2de9.jpg&quot;&gt;&lt;/p&gt;
&lt;h1&gt;四 分析&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;/strong&gt;&lt;strong&gt;合并排序的平均时间复杂度为&lt;/strong&gt;&lt;strong&gt;O(nlgn)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;证明：合并排序是目前我们遇到的第一个时间复杂度不为n&lt;sup&gt;2&lt;/sup&gt;的时间复杂度为nlgn(这里lgn代表log&lt;sub&gt;2&lt;/sub&gt;n)的排序算法，下面给出对合并排序的时间复杂度分析的证明：&lt;/p&gt;
&lt;p&gt;假设D(N)为对整个序列进行合并排序所用的时间，那么一个合并排序又可以二分为两个D(N/2)进行排序，再加上与N相关的比较和计算中间数所用的时间。整个合并排序可以用如下递归式表示：&lt;/p&gt;
&lt;p&gt;D(N)=2D(N/2)+N,N&amp;gt;1;&lt;/p&gt;
&lt;p&gt;D(N)=0,N=1; (当N=1时，数组只有1个元素，已排好序，时间为0)&lt;/p&gt;
&lt;p&gt;因为在分治算法中经常会用到递归式，所以在&lt;a href=&quot;http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844&quot; target=&quot;_blank&quot;&gt;CLRS&lt;/a&gt;中有一章专门讲解递归式的求解和证明，使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Master_theorem&quot; target=&quot;_blank&quot;&gt;主定理(master theorem)&lt;/a&gt;可以直接求解出该递归式的值，后面我会简单介绍。这里简单的列举两种证明该递归式时间复杂度为O(nlgn)的方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prof1&lt;/strong&gt;：处于方便性考虑，我们假设数组N为2的整数幂，这样根据递归式我们可以画出一棵树：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0c78ab7b84d4f83312f7de75e50c90e0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们对数组N进行MergeSort的时候，是逐级划分的，这样就形成了一个&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;满二叉树&lt;/a&gt;，树的每一及子节点都为N，树的深度即为层数lgN+1，满二叉树的深度的计算可以查阅相关资料，上图中最后一层子节点没有画出来。这样，这棵树有lgN+1层，每一层有N个节点，所以&lt;/p&gt;
&lt;p&gt;D(N)=(lgN+1)N=NlgN+N=NlgN&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prof2&lt;/strong&gt;：我们在为递归表达式求解的时候，还有一种常用的方法就是数学归纳法，&lt;/p&gt;
&lt;p&gt;首先根据我们的递归表达式的初始值以及观察，我们猜想D(N)=NlgN.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当N=1 时，D(1)=0,满足初始条件。&lt;/li&gt;
&lt;li&gt;为便于推导，假设N是2的整数次幂N=2&lt;sup&gt;k&lt;/sup&gt;, 即D(2&lt;sup&gt;k&lt;/sup&gt;)=2&lt;sup&gt;k&lt;/sup&gt;lg2&lt;sup&gt;k&lt;/sup&gt; = k*2&lt;sup&gt;k&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;在N+1 的情况下D(N+1)=D(2&lt;sup&gt;k+1&lt;/sup&gt;)=2&lt;sup&gt;k+1&lt;/sup&gt;lg2&lt;sup&gt;k+1&lt;/sup&gt;=(k+1) * 2&lt;sup&gt;k+1&lt;/sup&gt;,所以假设成立，D(N)=NlgN.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;strong&gt;合并排序需要额外的长度为&lt;/strong&gt;&lt;strong&gt;N&lt;/strong&gt;&lt;strong&gt;的辅助空间来完成排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果对长度为N的序列进行排序需要&amp;lt;=clogN 的额外空间，认为就是&lt;a href=&quot;http://en.wikipedia.org/wiki/In-place_algorithm&quot; target=&quot;_blank&quot;&gt;就地排序&lt;/a&gt;(in place排序)也就是完成该排序操作需要较小的，固定数量的额外辅助内存空间。之前学习过的选择排序，插入排序，希尔排序都是原地排序。&lt;/p&gt;
&lt;p&gt;但是在合并排序中，我们要创建一个大小为N的辅助排序数组来存放初始的数组或者存放合并好的数组，所以需要长度为N的额外辅助空间。当然也有前人已经将合并排序改造为了&lt;a href=&quot;http://www.diku.dk/hjemmesider/ansatte/jyrki/Paper/mergesort_NJC.ps&quot; target=&quot;_blank&quot;&gt;就地合并排序&lt;/a&gt;，但是算法的实现变得比较复杂。&lt;/p&gt;
&lt;p&gt;需要额外N的空间来辅助排序是合并排序的最大缺点，如果在内存比较关心的环境中可能需要采用其他算法。&lt;/p&gt;
&lt;h1&gt;五 几点改进&lt;/h1&gt;
&lt;p&gt;对合并排序进行一些改进可以提高合并排序的效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 当划分到较小的子序列时，通常可以使用插入排序替代合并排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于较小的子序列（通常序列元素个数为7个左右），我们就可以采用插入排序直接进行排序而不用继续递归了），算法改造如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private const int CUTOFF = 7;//采用插入排序的阈值
private static void Sort(T[] array, int lo, int hi)
{
    if (lo &amp;gt;= hi) return; //如果下标大于上标，则返回
    if (hi &amp;lt;= lo + CUTOFF - 1) Sort&amp;lt;T&amp;gt;.SelectionSort(array, lo, hi);
    int mid = lo + (hi - lo) / 2;//平分数组
    Sort(array, lo, mid);//循环对左侧元素排序
    Sort(array, mid + 1, hi);//循环对右侧元素排序
    Merge(array, lo, mid, hi);//对左右排好的序列进行合并
}&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 如果已经排好序了就不用合并了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当已排好序的左侧的序列的最大值&amp;lt;=右侧序列的最小值的时候，表示整个序列已经排好序了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/images/jobbole.com/0c647e875f5dfc7bc7855e2d8cba9eff.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;算法改动如下：&lt;/p&gt;
&lt;pre class=&quot;brush: actionscript3; gutter: true&quot;&gt;private static void Sort(T[] array, int lo, int hi)
{
    if (lo &amp;gt;= hi) return; //如果下标大于上标，则返回
    if (hi &amp;lt;= lo + CUTOFF - 1) Sort&amp;lt;T&amp;gt;.SelectionSort(array, lo, hi);
    int mid = lo + (hi - lo) / 2;//平分数组
    Sort(array, lo, mid);//循环对左侧元素排序
    Sort(array, mid + 1, hi);//循环对右侧元素排序
   if (array[mid].CompareTo(array[mid + 1]) &amp;lt;= 0) return;
    Merge(array, lo, mid, hi);//对左右排好的序列进行合并
}&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. 并行化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分治算法通常比较容易进行并行化，在&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Something-about-Concurrent-and-Parallel-Programming.html&quot; target=&quot;_blank&quot;&gt;浅谈并发与并行&lt;/a&gt;这篇文章中已经展示了如何对快速排序进行并行化（快速排序在下一篇文章中讲解），合并排序一样，因为我们均分的左右两侧的序列是独立的，所以可以进行并行，值得注意的是，并行化也有一个阈值，当序列长度小于某个阈值的时候，停止并行化能够提高效率，这些详细的讨论在&lt;a href=&quot;http://www.cnblogs.com/yangecnu/p/Something-about-Concurrent-and-Parallel-Programming.html&quot; target=&quot;_blank&quot;&gt;浅谈并发与并行&lt;/a&gt;这篇文章中有详细的介绍了，这里不再赘述。&lt;/p&gt;
&lt;h1&gt;六 用途&lt;/h1&gt;
&lt;p&gt;合并排序和快速排序一样都是时间复杂度为nlgn的算法，但是和快速排序相比，合并排序是一种稳定性排序，也就是说排序关键字相等的两个元素在整个序列排序的前后，相对位置不会发生变化，这一特性使得合并排序是稳定性排序中效率最高的一个。在Java中对引用对象进行排序，Perl、C++、Python的稳定性排序的内部实现中，都是使用的合并排序。&lt;/p&gt;
&lt;h1&gt;七 结语&lt;/h1&gt;
&lt;p&gt;本文介绍了分治算法中比较典型的一个合并排序算法，这也是我们遇到的第一个时间复杂度为nlgn的排序算法，并简要对算法的复杂度进行的分析，希望本文对您理解合并排序有所帮助，下文将介绍快速排序算法。&lt;/p&gt;


&lt;!-- div id=&quot;ad1&quot;&gt;
&lt;/div --&gt;


	


	

</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://iftti.com/posts/2014/2014-11-03-79293-2f987b0c8.html</link>
        <guid isPermaLink="true">http://iftti.com/posts/2014/2014-11-03-79293-2f987b0c8.html</guid>
        
        
        <category>jobbole</category>
        
      </item>
    
  </channel>
</rss>
