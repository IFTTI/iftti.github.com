---
layout: post
title: 'Interacting with C Pointers'
time: 2014-07-28 00:00:00 +0800
site_name: developer.apple.com/swift/blog
source_url: https://developer.apple.com/swift/blog/?id=6
---
{% raw %}
<p>Objective-C and C APIs often require the use of pointers. Data types in Swift are designed to feel natural when working with pointer-based Cocoa APIs, and Swift automatically handles several of the most common use cases for pointers as arguments. In this post we’ll look at how pointer parameters in C can be used with the variables, arrays, and strings in Swift.</p> <h3>Pointers as In/Out Parameters</h3> <p>C and Objective-C don’t support multiple return values, so Cocoa APIs frequently use pointers as a way of passing additional data in and out of functions. Swift allows pointer parameters to be treated like <span class="keyword">inout</span> parameters, so you can pass a reference to a <span class="keyword">var</span> as a pointer argument by using the same <span class="keyword">&amp;</span> syntax. For instance, <span class="keyword">UIColor</span>’s <span class="keyword">getRed(_:green:blue:alpha:)</span> method takes four <span class="keyword">CGFloat*</span> pointers to receive the components of the color. We can use <span class="keyword">&amp;</span> to collect these components into local variables:</p> <pre><code><span class="key">var</span> r: <span class="title">CGFloat</span> = <span class="number">0</span>, g: <span class="title">CGFloat</span> = <span class="numner">0</span>, b: <span class="title">CGFloat</span> = <span class="number">0</span>, a: <span class="title">CGFloat</span> = <span class="number">0</span>
color.getRed(&amp;<span class="pointer">r</span>, green: &amp;<span class="pointer">g</span>, blue: &amp;<span class="pointer">b</span>, alpha: &amp;<span class="pointer">a</span>)</code></pre> <p>Another common case is the Cocoa <span class="keyword">NSError</span> idiom. Many methods take an <span class="keyword">NSError**</span> parameter to save an error in case of failure. For instance, we can list the contents of a directory using <span class="keyword">NSFileManager</span>’s <span class="keyword">contentsOfDirectoryAtPath(_:error:)</span> method, saving the potential error directly to an <span class="keyword">NSError?</span> variable:</p> <pre><code><span class="key">var</span> maybeError: <span class="title">NSError</span>?
<span class="key">if let</span> contents = <span class="title">NSFileManager</span>.<span class="method">defaultManager</span>()
	.<span class="method">contentsOfDirectoryAtPath</span>(<span class="string">"/usr/bin"</span>, error: &amp;<span class="pointer">maybeError</span>) {
	<span class="comment">// Work with the directory contents</span>
} <span class="key">else if let</span> error = <span class="pointer">maybeError</span> {
	<span class="comment">// Handle the error</span>
}</code></pre> <p>For safety, Swift requires the variables to be initialized before being passed with <span class="keyword">&amp;</span>. This is because it cannot know whether the method being called tries to read from a pointer before writing to it.</p> <h3>Pointers as Array Parameters</h3> <p>Pointers are deeply intertwined with arrays in C, and Swift facilitates working with array-based C APIs by allowing <span class="keyword">Array</span> to be used as a pointer argument. An immutable array value can be passed directly as a <span class="keyword">const</span> pointer, and a mutable array can be passed as a non-<span class="keyword">const</span> pointer argument using the <span class="keyword">&amp;</span> operator, just like an <span class="keyword">inout</span> parameter. For instance, we can add two arrays <span class="keyword">a</span> and <span class="keyword">b</span> using the <span class="keyword">vDSP_vadd</span> function from the Accelerate framework, writing the result to a third <span class="keyword">result</span> array:</p> <pre><code><span class="key">import</span> Accelerate

<span class="key">let</span> a: [<span class="title">Float</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]
<span class="key">let</span> b: [<span class="title">Float</span>] = [<span class="number">0.5</span>, <span class="number">0.25</span>, <span class="number">0.125</span>, <span class="number">0.0625</span>]
<span class="key">var</span> result: [<span class="title">Float</span>] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]

<span class="method">vDSP_vadd</span>(a, <span class="number">1</span>, b, <span class="number">1</span>, &amp;<span class="pointer">result</span>, <span class="number">1</span>, <span class="number">4</span>)

<span class="comment">// result now contains [1.5, 2.25, 3.125, 4.0625]</span></code></pre> <h3>Pointers as String Parameters</h3> <p>C uses <span class="keyword">const char*</span> pointers as the primary way to pass around strings. A Swift <span class="keyword">String</span> can be used as a <span class="keyword">const char*</span> pointer, which will pass the function a pointer to a null-terminated, UTF–8-encoded representation of the string. For instance, we can pass strings directly to standard C and POSIX library functions:</p> <pre><code><span class="method">puts</span>(<span class="string">"Hello from libc"</span>)
<span class="key">let</span> fd = <span class="method">open</span>(<span class="string">"/tmp/scratch.txt"</span>, <span class="title">O_WRONLY</span>|<span class="title">O_CREAT</span>, <span class="number">0o666</span>)

<span class="key">if</span> <span class="pointer">fd</span> &lt; <span class="number">0</span> {
	<span class="method">perror</span>(<span class="string">"could not open /tmp/scratch.txt"</span>)
} <span class="key">else</span> {
	<span class="key">let</span> text = <span class="string">"Hello World"</span>
	<span class="method">write</span>(<span class="pointer">fd</span>, text, <span class="method">strlen</span>(text))
	<span class="method">close</span>(<span class="pointer">fd</span>)
}</code></pre> <h3>Safety with Pointer Argument Conversions</h3> <p>Swift works hard to make interaction with C pointers convenient, because of their pervasiveness within Cocoa, while providing some level of safety. However, interaction with C pointers is inherently unsafe compared to your other Swift code, so care must be taken. In particular:</p> <ul> <li>These conversions cannot safely be used if the callee saves the pointer value for use after it returns. The pointer that results from these conversions is only guaranteed to be valid for the duration of a call. Even if you pass the same variable, array, or string as multiple pointer arguments, you could receive a different pointer each time. An exception to this is global or static stored variables. You can safely use the address of a global variable as a persistent unique pointer value, e.g.: as a KVO context parameter.</li> <li>Bounds checking is not enforced when a pointer to an <span class="keyword">Array</span> or <span class="keyword">String</span> is passed. A C-based API can’t grow the array or string, so you must ensure that the array or string is of the correct size before passing it over to the C-based API.</li>
</ul> <p>If you need to work with pointer-based APIs that don’t follow these guidelines, or you need to override Cocoa methods that accept pointer parameters, then you can work directly with raw memory in Swift using unsafe pointers. We’ll look at a more advanced case in a future post.</p>
{% endraw %}
