---
layout: post
title: '用HAProxy和KeepAlived构建高可用的反向代理系统'
time: 2011-11-06 00:00:00 +0800
site_name: weizhifeng.net
source_url: http://weizhifeng.net/HA-with-HAProxy-and-KeepAlived.html
---
{% raw %}

	
	

	<h3>前言</h3>

<p>对于访问量较大的网站来说，随着流量的增加单台服务器已经无法处理所有的请求，这时候需要多台服务器对大量的请求进行分流处理，即负载均衡。而如果实现负载均衡，必须在网站的入口部署服务器（不只是一台）对这些请求进行分发，这台服务器即反向代理。由于反向代理服务器是网站的入口，其负载压力大且易遭到攻击，存在单点故障的风险，所以我们需要一个高可用的方案来实现当一台反向代理服务器宕机的时候，另一台服务器会自动接管服务。基于以上要求，我们使用HAProxy，KeepAlived来构建高可用的反向代理系统。</p>

<h3>介绍</h3>

<p><a href="http://haproxy.1wt.eu/" title="HAProxy">HAProxy</a>是高性能的代理服务器，其可以提供7层和4层代理，具有healthcheck，负载均衡等多种特性，性能卓越，包括Twitter，Reddit，StackOverflow，GitHub在内的多家知名互联网公司在<a href="http://haproxy.1wt.eu/they-use-it.html" title="they use haproxy">使用</a>。</p>

<p><a href="http://www.keepalived.org/" title="keepalived">KeepAlived</a>是一个高可用方案，通过VIP(即虚拟IP)和心跳检测来实现高可用。其原理是存在一组（两台）服务器，分别赋予Master,Backup两个角色，默认情况下Master会绑定VIP到自己的网卡上，对外提供服务。Master,Backup会在一定的时间间隔向对方发送心跳数据包来检测对方的状态，这个时间间隔一般为2秒钟，如果Backup发现Master宕机，那么Backup会发送ARP包到网关，把VIP绑定到自己的网卡，此时Backup对外提供服务，实现自动化的故障转移，当Master恢复的时候会重新接管服务。</p>

<h3>环境</h3>

<p>OS: CentOS Linux release 6.0 (Final) 2.6.32-71.29.1.el6.x86_64  <br>
HAProxy: 1.4.18 <br>
KeepAlived: 1.2.2 <br>
VIP: 192.168.1.99 <br>
M: 192.168.1.222 <br>
S: 192.168.1.189</p>

<h3>架构</h3>

<pre><code>                    192.168.1.99
             +-----------VIP----------+   
             |                        |
             |                        |
           Master                   Backup
        192.168.1.189            192.168.1.222
        +----------+             +----------+
        | HAProxy  |             | HAProxy  |
        |keepalived|             |keepalived|
        +----------+             +----------+
             |  
             v  
    +--------+---------+ 
    |        |         |
    |        |         |
    v        v         v
+------+  +------+  +------+
| WEB1 |  | WEB2 |  | WEB3 |
+------+  +------+  +------+
</code></pre>

<h3>安装HAProxy</h3>

<p>安装pcre</p>

<pre><code>$ yum install pcre
$ wget http://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.18.tar.gz
$ tar -zxvf haproxy-1.4.18.tar.gz
$ cd haproxy-1.4.18
</code></pre>

<p>注意编译参数：   <br>
TARGET是指自己系统的内核版本 ARCH指定系统是32位还是64位   <br>
CPU=native: use the build machine's specific processor optimizations  <br>
更多编译参数内容见源码中的README  <br>
    $ make TARGET=linux26 ARCH=x86_64 USE_PCRE=1 CPU=native
    $ make install</p>

<p>配置文件 /etc/haproxy.cfg</p>

<pre><code>global
    log 127.0.0.1   local3
    maxconn 20000   
    uid 535  #uid和gid按照实际情况进行配置
    gid 520  
    chroot /var/chroot/haproxy
    daemon 
    nbproc 1 

defaults
   log     127.0.0.1       local3
   mode    http            
   option  httplog
   option  httpclose
   option  dontlognull
   option  forwardfor
   retries 2
   balance roundrobin 
   stats   uri     /haproxy-stats
   contimeout      5000
   clitimeout      50000
   srvtimeout      50000

frontend http-in
        bind *:80 
        default_backend pool1

backend pool1
        option httpchk HEAD / HTTP/1.0
        stats refresh 2
        server WEB1 192.168.1.189:81 weight 3 maxconn 10000 check 
        server WEB2 192.168.1.222:81 weight 3 maxconn 10000 check
</code></pre>

<p>查看HAProxy的状态：http://192.168.1.99/haproxy-stats，这个页面会显示HAProxy本身以及后端服务器的状态。</p>

<h3>日志</h3>

<p>haproxy会把日志记录发送到syslog server(CentOS6下是rsyslogd，UDP514端口)， 编辑/etc/rsyslog.conf文件，添加如下内容：</p>

<pre><code>$ModLoad imudp
$UDPServerRun 514
$UDPServerAddress 127.0.0.1
local3.*                /var/log/haproxy.log
</code></pre>

<p>重启rsyslog</p>

<pre><code>$ /etc/init.d/rsyslog restart
</code></pre>

<p>自动轮转日志，编辑/etc/logrotate.d/haproxy.cfg，添加如下内容：</p>

<pre><code>/var/log/haproxy.log
{
    rotate 4
    daily
    missingok
    notifempty
    compress
    delaycompress
    sharedscripts
    postrotate
    reload rsyslog &gt; /dev/null 2&gt;&amp;1 || true
    endscript
}
</code></pre>

<p>启动脚本</p>

<pre><code>$ wget -O haproxy https://raw.github.com/gist/3665034/4125bd5b81977a72e5eec30650fb21f3034782a0/haproxy-init.d 
$ cp haproxy /etc/init.d/haproxy
$ chmod +x /etc/init.d/haproxy
#使用方式
$ /etc/init.d/haproxy start|stop|restart
</code></pre>

<h3>安装KeepAlived</h3>

<p>安装依赖库</p>

<pre><code>$ yum install popt popt-devel
</code></pre>

<p>安装KeepAlived</p>

<pre><code>$ wget http://www.keepalived.org/software/keepalived-1.2.2.tar.gz
$ tar -zxvf keepalived-1.2.2.tar.gz
$ cd keepalived-1.2.2
$ ./configure --prefix=/usr/local/keepalived
$ make &amp;&amp; make install

$ cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalived
$ cp /usr/local/keepalived/sbin/keepalived /usr/sbin/
$ cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/
$ mkdir -p /etc/keepalived/
$ cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf 
$ chmod +x /etc/init.d/keepalived
</code></pre>

<p>使用方式</p>

<pre><code>$ /etc/init.d/keepalived start|stop|restart
</code></pre>

<p>Master服务器上的配置 /etc/keepalived/keepalived.conf</p>

<pre><code>global_defs {

   notification_email {
       user@example.com
   }

   notification_email_from mail@example.org
   smtp_server 192.168.x.x
   smtp_connect_timeout 30
   router_id LVS_DEVEL
}

#监测haproxy进程状态，每2秒执行一次
vrrp_script chk_haproxy {
    script "/usr/local/keepalived/chk_haproxy.sh"
    interval 2
    weight 2
}

vrrp_instance VI_1 {
    state MASTER #标示状态为MASTER
    interface eth0
    virtual_router_id 51
    priority 101   #MASTER权重要高于BACKUP
    advert_int 1
    mcast_src_ip 192.168.1.189 #Master服务器IP

    authentication {
        auth_type PASS #主从服务器验证方式
        auth_pass 1111
    }

    track_script {
        chk_haproxy #监测haproxy进程状态
    }

    #VIP
    virtual_ipaddress {
        192.168.1.99 #虚拟IP
    }
}
</code></pre>

<p>Bakcup服务器上的配置 /etc/keepalived/keepalived.conf</p>

<pre><code>global_defs {
   notification_email {
   user@example.com
   }

   notification_email_from mail@example.org
   smtp_server 192.168.x.x
   smtp_connect_timeout 30
   router_id LVS_DEVEL
}

#监测haproxy进程状态，每2秒执行一次
vrrp_script chk_haproxy {
    script "/usr/local/keepalived/chk_haproxy.sh"
    interval 2
    weight 2
}

vrrp_instance VI_1 {
    state BACKUP #状态为BACKUP
    interface eth0
    virtual_router_id 51
    priority 100  #权重要低于MASTER
    advert_int 1
    mcast_src_ip 192.168.1.222 #Backup服务器的IP

    authentication {
        auth_type PASS
        auth_pass 1111
    }

    track_script {
        chk_haproxy #监测haproxy进程状态
    }

    #VIP
    virtual_ipaddress {
        192.168.1.99 #虚拟IP
    }
}
</code></pre>

<p>chk_haproxy.sh内容</p>

<pre><code>#!/bin/bash
#
# author: weizhifeng
# description: 
# 定时查看haproxy是否存在，如果不存在则启动haproxy，
# 如果启动失败，则停止keepalived
# 
status=$(ps aux|grep haproxy | grep -v grep | grep -v bash | wc -l)
if [ "${status}" = "0" ]; then
    /etc/init.d/haproxy start

    status2=$(ps aux|grep haproxy | grep -v grep | grep -v bash |wc -l)

    if [ "${status2}" = "0"  ]; then
            /etc/init.d/keepalived stop
    fi
fi
</code></pre>

<h3>高可用测试</h3>

<ol>
<li>
<p>在Master上停止keepalived，查看系统日志，发现MASTER释放了VIP</p>

<pre><code> $ /etc/init.d/keepalived stop
 $ tail -f /var/log/message
 Keepalived: Terminating on signal Keepalived: Stopping Keepalived v1.2.2 (11/03,2011) 
 Keepalived_vrrp: Terminating VRRP child process on signal 
 Keepalived_vrrp: VRRP_Instance(VI_1) removing protocol VIPs.
</code></pre>
</li>
<li>
<p>在Backup上查看系统日志，发现Backup已经进入MASTER角色，并且绑定了VIP 192.168.1.99</p>

<pre><code> $ tail -f /var/log/message
 Keepalived_vrrp: VRRP_Instance(VI_1) Entering MASTER STATE
 Keepalived_vrrp: VRRP_Instance(VI_1) setting protocol VIPs
 Keepalived_vrrp: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.99 #在Backup上查看VIP是否已经绑定
</code></pre>
</li>
<li>
<p>在Master上重新启动keepalived，查看系统日志，发现重新获得MASTER角色，并且绑定VIP 192.168.1.99</p>

<pre><code> $ /etc/init.d/keepalived start
 $ tail -f /var/log/message
 Keepalived_vrrp: VRRP_Instance(VI_1) Transition to MASTER STATE
 Keepalived_vrrp: VRRP_Instance(VI_1) Entering MASTER STATE
 Keepalived_vrrp: VRRP_Instance(VI_1) setting protocol VIPs.
 Keepalived_vrrp: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.99
</code></pre>
</li>
<li>
<p>在Backup上查看系统日志，发现其重新回到BACKUP角色，并且释放VIP</p>

<pre><code> $ tail -f /var/log/message
 Keepalived_vrrp: VRRP_Instance(VI_1) Received higher prio advert
 Keepalived_vrrp: VRRP_Instance(VI_1) Entering BACKUP STATE
 Keepalived_vrrp: VRRP_Instance(VI_1) removing protocol VIPs.
</code></pre>
</li>
</ol>


<h3>并发测试</h3>

<p>我们使用webbench来对HAProxy进行并发测试</p>

<pre><code>$ yum install ctags
$ wget http://home.tiscali.cz/~cz210552/distfiles/webbench-1.5.tar.gz
$ tar -zxvf webbench-1.5.tar.gz
$ cd webbench-1.5
$ make 
$ mkdir -p /usr/local/man &amp;&amp; make install
</code></pre>

<p>测试环境：  <br>
CPU：Intel 双核 x86_64 主频3191MHZ <br>
Mem：2G<br>
修改php-fpm.conf，设置PHP-FPM spawn的进程数量为100：</p>

<pre><code>pm.start_servers = 100
pm.max_spare_servers = 100
</code></pre>

<p>测试方法：</p>

<pre><code>$ webbench -c 100 -t 3000 http://192.168.1.99/check.txt
$ webbench -c 100 -t 3000 http://192.168.1.99/test.php
</code></pre>

<p>测试结果：</p>

<p>并发访问txt文件，HAProxy的session数量为10000左右，这说明HAProxy能够hold住10000个并发连接；并发访问php文件，HAProxy的session峰值为200左右，接近于后端PHP的并发处理能力(100x2)。</p>

<p>参考：</p>

<p><a href="http://haproxy.1wt.eu/download/1.4/doc/configuration.txt">http://haproxy.1wt.eu/download/1.4/doc/configuration.txt</a>
<a href="http://kevin.vanzonneveld.net/techblog/article/haproxy_logging/">http://kevin.vanzonneveld.net/techblog/article/haproxy_logging/</a></p>

	(完)

	<div class="post-info">
		06 Nov 2011  
	
		
	
		
	</div>
	
	<!-- disqus start -->
	
	
	
	
	<!-- disqus end -->

	<!-- related start -->
	
	<!-- related end -->
{% endraw %}
