---
layout: post
title: '实现一个键值对存储：目录'
time: 2014-08-26 00:00:00 +0800
site_name: jobbole.com
source_url: http://blog.jobbole.com/75842/
---
{% raw %}

					
		
<!-- div id="ad1">
<script type="text/javascript">
google_ad_client = "ca-pub-7056282119617872";
google_ad_slot = "6645040531";
google_ad_width = 300;
google_ad_height = 250;
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<br/ -->

<p>2014年7月8日更新：这个系列的文章仍在继续，我正在实现这个键值对存储并将在其差不多完成的时候写一篇文章。这些文章每一篇都花了我很长时间来写。为了在完成的时候获得更新通知，你可以在博客右上角订阅。</p>
<p>这篇文章是我今天开始的系列文章“实现一个键值对存储”（IKVS）的主条目。本文旨在以内容列表的形式总结系列中所有文章，可能在晚些时候有一些关于项目的笔记。</p>
<p>本文的内容可能随时间变化直到系列完成。特别是在目录里，各个部分的标题还没有写而顺序也有可能改变。随着内容逐渐完成，一些部分也有可能被移除或者有新的部分被添加进来。</p>
<p>项目中的更多信息可以在 “第一部分：什么是键值对存储，为什么要实现它”的1.3节中找到。</p>
<p><a href="http://codecapsule.com/2012/11/07/ikvs-part-1-what-are-key-value-stores-and-why-implement-one/" target="_blank">1 – </a><a href="http://blog.jobbole.com/75844/" target="_blank">什么是键值对存储，为什么要实现它？</a> （已翻成中文）</p>
<ul>
<li>1.1 – 键值对存储综述</li>
<li>1.2 –键值对存储 vs 关系型数据库</li>
<li>1.3 – 为什么要实现键值对存储</li>
<li>1.4 – 计划</li>
<li>1.5 – 引用</li>
</ul>
<p><span style="text-decoration: underline;"><a href="http://codecapsule.com/2012/12/03/implementing-a-key-value-store-part-2-using-existing-key-value-stores-as-models/">2 – 使用已存在的键值对存储作为模型</a></span><span style="text-decoration: underline;"><br>
</span></p>
<ul>
<li>2.1 – 不要重复发明轮子</li>
<li>2.2 – 候选模型和选择标准</li>
<li>2.3 – 所选的键值对存储的概览</li>
<li>2.4 – 引用</li>
</ul>
<p><a href="http://codecapsule.com/2012/12/30/implementing-a-key-value-store-part-3-comparative-analysis-of-the-architectures-of-kyoto-cabinet-and-leveldb/">3 – Kyoto Cabinet和LevelDB结构的比较分析</a></p>
<ul>
<li>3.1 – 结构分析的意图和方法</li>
<li>3.2 – 键值对存储组件的概览</li>
<li>3.3 – Kyoto Cabinet和LevelDB的结构与概念分析</li>
<li>3.4 – 代码审查</li>
<li>3.5 – 引用</li>
</ul>
<p><a href="http://codecapsule.com/2013/04/03/implementing-a-key-value-store-part-4-api-design/">4 – API设计</a></p>
<ul>
<li>4.1 – API设计的基本原则</li>
<li>4.2 – 定义FelixDB公共API的功能。</li>
<li>4.3 – 比较已存在数据库的API功能</li>
<li>4.4 – Conclusion 结论</li>
<li>4.5 – References 引用</li>
</ul>
<p><a href="http://codecapsule.com/2013/05/13/implementing-a-key-value-store-part-5-hash-table-implementations/">5 – 哈希表实现</a></p>
<ul>
<li>5.1 – Hash tables 哈希表</li>
<li>5.2 – Implementations 实现</li>
<li>5.3 – Conclusion 结论</li>
<li>5.4 – References 引用</li>
</ul>
<p>6 – 实现存储在文件系统中的高存储效率的哈希表</p>
<p>7 – 存储管理</p>
<p>8 – 网络</p>
<p>9 – 接口：REST, memcached等</p>
<p>10 – 更进一步</p>


<!-- div id="ad1">
</div -->


	


	
{% endraw %}
