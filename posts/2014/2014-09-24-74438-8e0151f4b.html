<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>常见面试之机器学习算法思想简单梳理 | IT技术干货</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="IT技术干货 KernelHacks 最好的技术站点 技术信息 纯干货">
    <link rel="canonical" href="http://iftti.com/posts/2014/2014-09-24-74438-8e0151f4b.html">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">

</head>


    <body>

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="/">IT技术干货</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
           viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
          
        
          <a class="page-link" href="/about/">About</a>
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>常见面试之机器学习算法思想简单梳理</h1>
    <p class="meta"><span class="time">Sep 24, 2014</span><span class="source_url"> • 来自 jobbole.com <a name="jobbole.com" href="http://blog.jobbole.com/74438/" target="_blank">[原文链接]</a></span></p>
  </header>

  <article class="post-content">
  

					
		
<!-- div id="ad1">
<script type="text/javascript">
google_ad_client = "ca-pub-7056282119617872";
google_ad_slot = "6645040531";
google_ad_width = 300;
google_ad_height = 250;
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<br/ -->

<p><strong>前言：</strong></p>
<p>找工作时（IT行业），除了常见的软件开发以外，机器学习岗位也可以当作是一个选择，不少计算机方向的研究生都会接触这个，如果你的研究方向是机器学习/数据挖掘之类，且又对其非常感兴趣的话，可以考虑考虑该岗位，毕竟在机器智能没达到人类水平之前，机器学习可以作为一种重要手段，而随着科技的不断发展，相信这方面的人才需求也会越来越大。</p>
<p>纵观IT行业的招聘岗位，机器学习之类的岗位还是挺少的，国内大点的公司里百度，阿里，腾讯，网易，搜狐，华为（华为的岗位基本都是随机分配，机器学习等岗位基本面向的是博士）等会有相关职位，另外一些国内的中小型企业和外企也会招一小部分。当然了，其中大部分还是百度北京要人最多，上百人。阿里的算法岗位很大一部分也是搞机器学习相关的。另外本人有幸签约了网易杭州研究院的深度学习算法岗位，打算从事机器学习领域至少5年。非常感谢小易收留了我！</p>
<p>下面是本人在找机器学习岗位工作时，总结的常见机器学习算法（主要是一些常规分类器）大概流程和主要思想，希望对大家找机器学习岗位时有点帮助。实际上在面试过程中，懂这些算法的基本思想和大概流程是远远不够的，那些面试官往往问的都是一些公司内部业务中的课题，往往要求你不仅要懂得这些算法的理论过程，而且要非常熟悉怎样使用它，什么场合用它，算法的优缺点，以及调参经验等等。说白了，就是既要会点理论，也要会点应用，既要有点深度，也要有点广度，否则运气不好的话很容易就被刷掉，因为每个面试官爱好不同。</p>
<p> </p>
<p><strong>朴素贝叶斯：</strong></p>
<p>有以下几个地方需要注意：</p>
<p>1. 如果给出的特征向量长度可能不同，这是需要归一化为通长度的向量（这里以文本分类为例），比如说是句子单词的话，则长度为整个词汇量的长度，对应位置是该单词出现的次数。</p>
<p>2. 计算公式如下：</p>
<p><img alt="" src="/images/jobbole.com/b8083cb5e9f6fc73bd4c31350d0463ab.jpg" width="214" height="69"></p>
<p align="left">其中一项条件概率可以通过朴素贝叶斯条件独立展开。要注意一点就是<img alt="" src="/images/jobbole.com/4c56b13fde8c16b7ddf93202cb6f1446.jpg">的计算方法，而由朴素贝叶斯的前提假设可知，<img alt="" src="/images/jobbole.com/21b0b4b9470a5a5c93616f233e3d8b60.jpg">=<img alt="" src="/images/jobbole.com/a2275101ca10e4966b0cab8a292eb00d.jpg">，因此一般有两种，一种是在类别为ci的那些样本集中，找到wj出现次数的总和，然后除以该样本的总和；第二种方法是类别为ci的那些样本集中，找到wj出现次数的总和，然后除以该样本中所有特征出现次数的总和。</p>
<p>3. 如果<img alt="" src="/images/jobbole.com/4c56b13fde8c16b7ddf93202cb6f1446.jpg">中的某一项为0，则其联合概率的乘积也可能为0，即2中公式的分子为0，为了避免这种现象出现，一般情况下会将这一项初始化为1，当然为了保证概率相等，分母应对应初始化为2（这里因为是2类，所以加2，如果是k类就需要加k，术语上叫做laplace光滑, 分母加k的原因是使之满足全概率公式）。</p>
<p><em><strong>朴素贝叶斯的优点：</strong></em></p>
<p>对小规模的数据表现很好，适合多分类任务，适合增量式训练。</p>
<p><strong><em>缺点</em>：</strong></p>
<p>对输入数据的表达形式很敏感。</p>
<p> </p>
<p><strong>决策树：</strong></p>
<p>决策树中很重要的一点就是选择一个属性进行分枝，因此要注意一下信息增益的计算公式，并深入理解它。</p>
<p>信息熵的计算公式如下:</p>
<p><img alt="" src="/images/jobbole.com/cd414a54f5e77b0eebd058c4dd8bd280.jpg"></p>
<p>其中的n代表有n个分类类别（比如假设是2类问题，那么n=2）。分别计算这2类样本在总样本中出现的概率p1和p2，这样就可以计算出未选中属性分枝前的信息熵。</p>
<p>现在选中一个属性xi用来进行分枝，此时分枝规则是：如果xi=vx的话，将样本分到树的一个分支；如果不相等则进入另一个分支。很显然，分支中的样本很有可能包括2个类别，分别计算这2个分支的熵H1和H2,计算出分枝后的总信息熵H’=p1*H1+p2*H2.，则此时的信息增益ΔH=H-H’。以信息增益为原则，把所有的属性都测试一边，选择一个使增益最大的属性作为本次分枝属性。</p>
<p><em><strong>决策树的优点：</strong></em></p>
<p>计算量简单，可解释性强，比较适合处理有缺失属性值的样本，能够处理不相关的特征；</p>
<p><em><strong>缺点：</strong></em></p>
<p>容易过拟合（后续出现了随机森林，减小了过拟合现象）；</p>
<p> </p>
<p><strong>Logistic回归：</strong></p>
<p>Logistic是用来分类的，是一种线性分类器，需要注意的地方有：</p>
<p>1. logistic函数表达式为：</p>
<p><img alt="" src="/images/jobbole.com/20d645eb987a3c33094186fe1964ec86.jpg" width="372" height="104"></p>
<p>其导数形式为：</p>
<p><img alt="" src="/images/jobbole.com/828a60323e7c280125c274e8fd34d095.jpg" width="273" height="154"></p>
<p>2. logsitc回归方法主要是用最大似然估计来学习的，所以单个样本的后验概率为：</p>
<p><img alt="" src="/images/jobbole.com/e95dc64a6bceb2e7315fab4d63432469.jpg" width="342" height="47"></p>
<p>到整个样本的后验概率：</p>
<p><img alt="" src="/images/jobbole.com/7c493852ff0a2dc402c7244891da04e3.jpg" width="328" height="141"></p>
<p>其中：</p>
<p><img alt="" src="/images/jobbole.com/bf2054e251ff31be712fe68a21c3455c.jpg" width="265" height="64"></p>
<p>通过对数进一步化简为：</p>
<p><img alt="" src="/images/jobbole.com/09c1f28f198bc9578dc8b1e7fd13cd31.jpg" width="449" height="89"></p>
<p>3. 其实它的loss function为-l(θ)，因此我们需使loss function最小，可采用梯度下降法得到。梯度下降法公式为:</p>
<p><img alt="" src="/images/jobbole.com/eeb652d69cf54cb4f6ef590abc28cf61.jpg" width="475" height="129"></p>
<p><img alt="" src="/images/jobbole.com/00d8651e45c69d31591c40994e238a24.jpg" width="277" height="44"></p>
<p align="left"><em><strong>Logistic回归优点：</strong></em></p>
<p align="left">1、实现简单；</p>
<p align="left">2、分类时计算量非常小，速度很快，存储资源低；</p>
<p align="left"><em><strong>缺点：</strong></em></p>
<p align="left">1、容易欠拟合，一般准确度不太高</p>
<p align="left">2、只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须线性可分；</p>
<p> </p>
<p><strong>线性回归：</strong></p>
<p>线性回归才是真正用于回归的，而不像logistic回归是用于分类，其基本思想是用梯度下降法对最小二乘法形式的误差函数进行优化，当然也可以用normal equation直接求得参数的解，结果为：</p>
<p><img alt="" src="/images/jobbole.com/58c9408336b88e2ac396eb8f3f3b0b83.jpg" width="175" height="51"></p>
<p>而在LWLR（局部加权线性回归）中，参数的计算表达式为:</p>
<p><img alt="" src="/images/jobbole.com/524d23873126bdc590eb2d0438736b7a.jpg" width="246" height="53"></p>
<p>因为此时优化的是：</p>
<p><img alt="" src="/images/jobbole.com/c2d064a957f65a1fe4a7bb50f4b5db7e.jpg" width="389" height="78"></p>
<p>由此可见LWLR与LR不同，LWLR是一个非参数模型，因为每次进行回归计算都要遍历训练样本至少一次。</p>
<p><em><strong>线性回归优点：</strong></em></p>
<p>实现简单，计算简单；</p>
<p><strong><em>缺点：</em></strong></p>
<p>不能拟合非线性数据；</p>
<p> </p>
<p><strong>KNN</strong><strong>算法：</strong></p>
<p>KNN即最近邻算法，其主要过程为：</p>
<p>1. 计算训练样本和测试样本中每个样本点的距离（常见的距离度量有欧式距离，马氏距离等）；</p>
<p>2. 对上面所有的距离值进行排序；</p>
<p>3. 选前k个最小距离的样本；</p>
<p>4. 根据这k个样本的标签进行投票，得到最后的分类类别；</p>
<p>如何选择一个最佳的K值，这取决于数据。一般情况下，在分类时较大的K值能够减小噪声的影响。但会使类别之间的界限变得模糊。一个较好的K值可通过各种启发式技术来获取，比如，交叉验证。另外噪声和非相关性特征向量的存在会使K近邻算法的准确性减小。</p>
<p>近邻算法具有较强的一致性结果。随着数据趋于无限，算法保证错误率不会超过贝叶斯算法错误率的两倍。对于一些好的K值，K近邻保证错误率不会超过贝叶斯理论误差率。</p>
<p>注：马氏距离一定要先给出样本集的统计性质，比如均值向量，协方差矩阵等。关于马氏距离的介绍如下：</p>
<p><img alt="" src="/images/jobbole.com/d3ff6709b6fffe23f47046a2dcdabd51.jpg" width="978" height="270"></p>
<p><em><strong>KNN算法的优点：</strong></em></p>
<p>1. 思想简单，理论成熟，既可以用来做分类也可以用来做回归；</p>
<p>2. 可用于非线性分类；</p>
<p>3. 训练时间复杂度为O(n)；</p>
<p>4. 准确度高，对数据没有假设，对outlier不敏感；</p>
<p><em><strong>缺点：</strong></em></p>
<p>1. 计算量大；</p>
<p>2. 样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）；</p>
<p>3. 需要大量的内存；</p>
<p> </p>
<p><strong>SVM</strong><strong>：</strong></p>
<p>要学会如何使用libsvm以及一些参数的调节经验，另外需要理清楚svm算法的一些思路：</p>
<p>1. svm中的最优分类面是对所有样本的几何裕量最大（为什么要选择最大间隔分类器，请从数学角度上说明？网易深度学习岗位面试过程中有被问到。答案就是几何间隔与样本的误分次数间存在关系：<img alt="" src="/images/jobbole.com/0f747083f984f607d9d27dfa08c13d19.jpg" width="113" height="43">，其中的分母就是样本到分类间隔距离，分子中的R是所有样本中的最长向量值），即：</p>
<p><img alt="" src="/images/jobbole.com/8c8db41026303a2b79c57050f9395f3e.jpg" width="364" height="85"></p>
<p>经过一系列推导可得为优化下面原始目标：</p>
<p><img alt="" src="/images/jobbole.com/3e9d73851204cb5036ebde77a8239384.jpg"></p>
<p>2. 下面来看看拉格朗日理论：</p>
<p><img alt="" src="/images/jobbole.com/39fb79050fd8a64b773662cfca03be14.jpg" width="426" height="157"></p>
<p>可以将1中的优化目标转换为拉格朗日的形式（通过各种对偶优化，KKD条件），最后目标函数为：</p>
<p><img alt="" src="/images/jobbole.com/c1e40c1e06abc7c66da00e81b3bd7165.jpg"></p>
<p>我们只需要最小化上述目标函数，其中的α为原始优化问题中的不等式约束拉格朗日系数。</p>
<p>3. 对2中最后的式子分别w和b求导可得：</p>
<p><img alt="" src="/images/jobbole.com/1cc9dd4cac61d47e71d65dab3e7faa8f.jpg"></p>
<p><img alt="" src="/images/jobbole.com/9b22731a6e39eac8bad74bd575e6b543.jpg"></p>
<p>由上面第1式子可以知道，如果我们优化出了α，则直接可以求出w了，即模型的参数搞定。而上面第2个式子可以作为后续优化的一个约束条件。</p>
<p>4. 对2中最后一个目标函数用对偶优化理论可以转换为优化下面的目标函数：</p>
<p><img alt="" src="/images/jobbole.com/bc6f9efec5200fb36f5524048050d570.jpg" width="394" height="136"></p>
<p>而这个函数可以用常用的优化方法求得α，进而求得w和b。</p>
<p>5. 按照道理，svm简单理论应该到此结束。不过还是要补充一点，即在预测时有：</p>
<p><img alt="" src="/images/jobbole.com/f7acf5a6a5844a5149bce2dc0298a295.jpg" width="291" height="121"></p>
<p>那个尖括号我们可以用核函数代替，这也是svm经常和核函数扯在一起的原因。</p>
<p>6. 最后是关于松弛变量的引入，因此原始的目标优化公式为：</p>
<p><img alt="" src="/images/jobbole.com/5b769689705749a5db1621498a025cb2.jpg" width="389" height="114"></p>
<p>此时对应的对偶优化公式为：</p>
<p><img alt="" src="/images/jobbole.com/16d9a4b55cc7e6cdb8f3db3712017c5f.jpg" width="382" height="132"></p>
<p>与前面的相比只是α多了个上界。</p>
<p><em><strong>SVM算法优点：</strong></em></p>
<p>可用于线性/非线性分类，也可以用于回归；</p>
<p>低泛化误差；</p>
<p>容易解释；</p>
<p>计算复杂度较低；</p>
<p><em><strong>缺点：</strong></em></p>
<p>对参数和核函数的选择比较敏感；</p>
<p>原始的SVM只比较擅长处理二分类问题；</p>
<p> </p>
<p><strong>Boosting</strong><strong>：</strong></p>
<p>主要以Adaboost为例，首先来看看Adaboost的流程图，如下：</p>
<p><img alt="" src="/images/jobbole.com/4c1db6a8672bc7b05ca34e98759931ad.jpg" width="366" height="281"></p>
<p>从图中可以看到，在训练过程中我们需要训练出多个弱分类器（图中为3个），每个弱分类器是由不同权重的样本（图中为5个训练样本）训练得到（其中第一个弱分类器对应输入样本的权值是一样的），而每个弱分类器对最终分类结果的作用也不同，是通过加权平均输出的，权值见上图中三角形里面的数值。那么这些弱分类器和其对应的权值是怎样训练出来的呢？</p>
<p>下面通过一个例子来简单说明。</p>
<p>书中（machine learning in action）假设的是5个训练样本，每个训练样本的维度为2，在训练第一个分类器时5个样本的权重各为0.2. 注意这里样本的权值和最终训练的弱分类器组对应的权值α是不同的，样本的权重只在训练过程中用到，而α在训练过程和测试过程都有用到。</p>
<p>现在假设弱分类器是带一个节点的简单决策树，该决策树会选择2个属性（假设只有2个属性）的一个，然后计算出这个属性中的最佳值用来分类。</p>
<p>Adaboost的简单版本训练过程如下：</p>
<p>1. 训练第一个分类器，样本的权值D为相同的均值。通过一个弱分类器，得到这5个样本（请对应书中的例子来看，依旧是machine learning in action）的分类预测标签。与给出的样本真实标签对比，就可能出现误差(即错误)。如果某个样本预测错误，则它对应的错误值为该样本的权重，如果分类正确，则错误值为0. 最后累加5个样本的错误率之和，记为ε。</p>
<p>2. 通过ε来计算该弱分类器的权重α，公式如下：</p>
<p><img alt="" src="/images/jobbole.com/9b96480798fabb5e957e460b2eccab4e.jpg" width="165" height="71"></p>
<p>3. 通过α来计算训练下一个弱分类器样本的权重D，如果对应样本分类正确，则减小该样本的权重，公式为：</p>
<p><img alt="" src="/images/jobbole.com/e8bf668342cf3a21585a9baf15f8cb6c.jpg" width="178" height="79"></p>
<p>如果样本分类错误，则增加该样本的权重，公式为：</p>
<p><img alt="" src="/images/jobbole.com/b496bd79b4a357b608628d041ec3172a.jpg" width="166" height="67"></p>
<p>4. 循环步骤1,2,3来继续训练多个分类器，只是其D值不同而已。</p>
<p>测试过程如下：</p>
<p>输入一个样本到训练好的每个弱分类中，则每个弱分类都对应一个输出标签，然后该标签乘以对应的α，最后求和得到值的符号即为预测标签值。</p>
<p><em><strong>Boosting算法的优点：</strong></em></p>
<p>低泛化误差；</p>
<p>容易实现，分类准确率较高，没有太多参数可以调；</p>
<p><em><strong>缺点：</strong></em></p>
<p>对outlier比较敏感；</p>
<p> </p>
<p><strong>聚类：</strong></p>
<p>根据聚类思想划分：</p>
<p>1. 基于划分的聚类:</p>
<p>K-means, k-medoids(每一个类别中找一个样本点来代表),CLARANS.</p>
<p>k-means是使下面的表达式值最小：</p>
<p><img alt="" src="/images/jobbole.com/07649c2bc46e9feb1e30be7962d5bb30.jpg"></p>
<p><em><strong>k-means算法的优点：</strong></em></p>
<p>（1）k-means算法是解决聚类问题的一种经典算法，算法简单、快速。</p>
<p>（2）对处理大数据集，该算法是相对可伸缩的和高效率的，因为它的复杂度大约是O(nkt)，其中n是所有对象的数目，k是簇的数目,t是迭代的次数。通常k&lt;&lt;n。这个算法通常局部收敛。</p>
<p>（3）算法尝试找出使平方误差函数值最小的k个划分。当簇是密集的、球状或团状的，且簇与簇之间区别明显时，聚类效果较好。</p>
<p><em><strong>缺点：</strong></em></p>
<p>（1）k-平均方法只有在簇的平均值被定义的情况下才能使用，且对有些分类属性的数据不适合。</p>
<p>（2）要求用户必须事先给出要生成的簇的数目k。</p>
<p>（3）对初值敏感，对于不同的初始值，可能会导致不同的聚类结果。</p>
<p>（4）不适合于发现非凸面形状的簇，或者大小差别很大的簇。</p>
<p>（5）对于”噪声”和孤立点数据敏感，少量的该类数据能够对平均值产生极大影响。</p>
<p>2. 基于层次的聚类：</p>
<p>自底向上的凝聚方法，比如AGNES。</p>
<p>自上向下的分裂方法，比如DIANA。</p>
<p>3. 基于密度的聚类：</p>
<p>DBSACN,OPTICS,BIRCH(CF-Tree),CURE.</p>
<p>4. 基于网格的方法：</p>
<p>STING, WaveCluster.</p>
<p>5. 基于模型的聚类：</p>
<p>EM,SOM,COBWEB.</p>
<p>以上这些算法的简介可参考<a href="http://baike.baidu.com/view/31801.htm">聚类（百度百科）。</a></p>
<p> </p>
<p><strong>推荐系统：</strong></p>
<p>推荐系统的实现主要分为两个方面：基于内容的实现和协同滤波的实现。</p>
<p>基于内容的实现：</p>
<p>不同人对不同电影的评分这个例子，可以看做是一个普通的回归问题，因此每部电影都需要提前提取出一个特征向量(即x值)，然后针对每个用户建模，即每个用户打的分值作为y值，利用这些已有的分值y和电影特征值x就可以训练回归模型了(最常见的就是线性回归)。这样就可以预测那些用户没有评分的电影的分数。（值得注意的是需对每个用户都建立他自己的回归模型）</p>
<p>从另一个角度来看，也可以是先给定每个用户对某种电影的喜好程度（即权值），然后学出每部电影的特征，最后采用回归来预测那些没有被评分的电影。</p>
<p>当然还可以是同时优化得到每个用户对不同类型电影的热爱程度以及每部电影的特征。具体可以参考Ng在coursera上的ml教程：<a href="https://www.coursera.org/course/ml">https://www.coursera.org/course/ml</a></p>
<p>基于协同滤波的实现：</p>
<p>协同滤波（CF）可以看做是一个分类问题，也可以看做是矩阵分解问题。协同滤波主要是基于每个人自己的喜好都类似这一特征，它不依赖于个人的基本信息。比如刚刚那个电影评分的例子中，预测那些没有被评分的电影的分数只依赖于已经打分的那些分数，并不需要去学习那些电影的特征。</p>
<p>SVD将矩阵分解为三个矩阵的乘积，公式如下所示：</p>
<p><img alt="" src="/images/jobbole.com/70b15f485732721065229e4fbd513afc.jpg"></p>
<p>中间的矩阵sigma为对角矩阵，对角元素的值为Data矩阵的奇异值(注意奇异值和特征值是不同的)，且已经从大到小排列好了。即使去掉特征值小的那些特征，依然可以很好的重构出原始矩阵。如下图所示：</p>
<p><img alt="" src="/images/jobbole.com/98d03f9faad8dde7e137ec02b4c5979b.jpg" width="431" height="173"></p>
<p>其中更深的颜色代表去掉小特征值重构时的三个矩阵。</p>
<p>果m代表商品的个数，n代表用户的个数，则U矩阵的每一行代表商品的属性，现在通过降维U矩阵（取深色部分）后，每一个商品的属性可以用更低的维度表示（假设为k维）。这样当新来一个用户的商品推荐向量X，则可以根据公式X’*U1*inv(S1)得到一个k维的向量，然后在V’中寻找最相似的那一个用户（相似度测量可用余弦公式等），根据这个用户的评分来推荐（主要是推荐新用户未打分的那些商品）。具体例子可以参考网页：<a href="http://blog.csdn.net/wuyanyi/article/details/7964883">SVD在推荐系统中的应用</a>。</p>
<p>另外关于SVD分解后每个矩阵的实际含义可以参考google吴军的《数学之美》一书（不过个人感觉吴军解释UV两个矩阵时好像弄反了，不知道大家怎样认为）。或者参考machine learning in action其中的svd章节。</p>
<p> </p>
<p><strong>pLSA:</strong></p>
<p>pLSA由LSA发展过来，而早期LSA的实现主要是通过SVD分解。pLSA的模型图如下：</p>
<p><img alt="" src="/images/jobbole.com/5e66a98d735208a96823ac94a18b2049.jpg"></p>
<p>公式中的意义如下：</p>
<p><img alt="" src="/images/jobbole.com/f01167e3a30550ef633892b3a625c039.jpg"></p>
<p>具体可以参考<a href="http://bcmi.sjtu.edu.cn/ds/download.html">2010龙星计划：机器学习中对应的主题模型那一讲</a></p>
<p> </p>
<p><strong>LDA</strong><strong>：</strong></p>
<p>主题模型，概率图如下：</p>
<p><img alt="" src="/images/jobbole.com/3b068ec4f6d0abbb1b29c4ac03c7201e.jpg" width="257" height="208"></p>
<p>和pLSA不同的是LDA中假设了很多先验分布，且一般参数的先验分布都假设为Dirichlet分布，其原因是共轭分布时先验概率和后验概率的形式相同。</p>
<p><strong>GDBT</strong><strong>：</strong></p>
<p>GBDT(Gradient Boosting Decision Tree) 又叫 MART（Multiple Additive Regression Tree)，好像在阿里内部用得比较多（所以阿里算法岗位面试时可能会问到），它是一种迭代的决策树算法，该算法由多棵决策树组成，所有树的输出结果累加起来就是最终答案。它在被提出之初就和SVM一起被认为是泛化能力（generalization)较强的算法。近些年更因为被用于搜索排序的机器学习模型而引起大家关注。</p>
<p>GBDT是回归树，不是分类树。其核心就在于，每一棵树是从之前所有树的残差中来学习的。为了防止过拟合，和Adaboosting一样，也加入了boosting这一项。</p>
<p>关于GDBT的介绍可以可以参考：<a href="http://hi.baidu.com/hehehehello/item/96cc42e45c16e7265a2d64ee">GBDT（MART） 迭代决策树入门教程 | 简介</a>。</p>
<p> </p>
<p><strong>Regularization:</strong></p>
<p>作用是（网易电话面试时有问到）：</p>
<p>1. 数值上更容易求解；</p>
<p>2. 特征数目太大时更稳定；</p>
<p>3. 控制模型的复杂度，光滑性。复杂性越小且越光滑的目标函数泛化能力越强。而加入规则项能使目标函数复杂度减小，且更光滑。</p>
<p>4. 减小参数空间；参数空间越小，复杂度越低。</p>
<p>5. 系数越小，模型越简单，而模型越简单则泛化能力越强（Ng宏观上给出的解释）。</p>
<p>6. 可以看出是权值的高斯先验。</p>
<p> </p>
<p><strong>异常检测：</strong></p>
<p>可以估计样本的密度函数，对于新样本直接计算其密度，如果密度值小于某一阈值，则表示该样本异常。而密度函数一般采用多维的高斯分布。如果样本有n维，则每一维的特征都可以看作是符合高斯分布的，即使这些特征可视化出来不太符合高斯分布，也可以对该特征进行数学转换让其看起来像高斯分布，比如说x=log(x+c), x=x^(1/c)等。异常检测的算法流程如下：</p>
<p><img alt="" src="/images/jobbole.com/8b8d0032d9f883a5caa2b93c4993c9f1.jpg" width="482" height="290"></p>
<p>其中的ε也是通过交叉验证得到的，也就是说在进行异常检测时，前面的p(x)的学习是用的无监督，后面的参数ε学习是用的有监督。那么为什么不全部使用普通有监督的方法来学习呢（即把它看做是一个普通的二分类问题）？主要是因为在异常检测中，异常的样本数量非常少而正常样本数量非常多，因此不足以学习到好的异常行为模型的参数，因为后面新来的异常样本可能完全是与训练样本中的模式不同。</p>
<p align="left">另外，上面是将特征的每一维看成是相互独立的高斯分布，其实这样的近似并不是最好的，但是它的计算量较小，因此也常被使用。更好的方法应该是将特征拟合成多维高斯分布，这时有特征之间的相关性，但随之计算量会变复杂，且样本的协方差矩阵还可能出现不可逆的情况（主要在样本数比特征数小，或者样本特征维数之间有线性关系时）。</p>
<p align="left">上面的内容可以参考Ng的<a href="https://www.coursera.org/course/ml">https://www.coursera.org/course/ml</a></p>
<p><strong>EM</strong><strong>算法：</strong></p>
<p align="left">有时候因为样本的产生和隐含变量有关（隐含变量是不能观察的），而求模型的参数时一般采用最大似然估计，由于含有了隐含变量，所以对似然函数参数求导是求不出来的，这时可以采用EM算法来求模型的参数的（对应模型参数个数可能有多个），EM算法一般分为2步：</p>
<p align="left">E步：选取一组参数，求出在该参数下隐含变量的条件概率值；</p>
<p align="left">M步：结合E步求出的隐含变量条件概率，求出似然函数下界函数（本质上是某个期望函数）的最大值。</p>
<p align="left">重复上面2步直至收敛。</p>
<p align="left">公式如下所示：</p>
<p align="left"><img alt="" src="/images/jobbole.com/cf4fd695f67722fb350963498da9b2de.jpg" width="400" height="150"></p>
<p align="left">M步公式中下界函数的推导过程：</p>
<p align="left"><img alt="" src="/images/jobbole.com/28ea30f56c7f1d9fbb6baa305cb8d99f.jpg" width="434" height="145"></p>
<p align="left">EM算法一个常见的例子就是GMM模型，每个样本都有可能由k个高斯产生，只不过由每个高斯产生的概率不同而已，因此每个样本都有对应的高斯分布（k个中的某一个），此时的隐含变量就是每个样本对应的某个高斯分布。</p>
<p align="left">GMM的E步公式如下（计算每个样本对应每个高斯的概率）：</p>
<p align="left"><img alt="" src="/images/jobbole.com/213bce677dafac18f097a52b25caac73.jpg" width="381" height="71"></p>
<p align="left">更具体的计算公式为：</p>
<p align="left"><img alt="" src="/images/jobbole.com/73377ff094f50d0b5e7ca768fa68849d.jpg" width="509" height="56"></p>
<p align="left">M步公式如下（计算每个高斯的比重，均值，方差这3个参数）：</p>
<p align="left"><img alt="" src="/images/jobbole.com/0f680b38ad728be00844b8957f106e3a.jpg" width="363" height="192"></p>
<p align="left">关于EM算法可以参考<a href="http://cs229.stanford.edu/">Ng的cs229课程资料</a>或者网易公开课：<a href="http://v.163.com/special/opencourse/machinelearning.html">斯坦福大学公开课 ：机器学习课程</a>。</p>
<p><strong>Apriori:</strong></p>
<p align="left">Apriori是关联分析中比较早的一种方法，主要用来挖掘那些频繁项集合。其思想是：</p>
<p align="left">1. 如果一个项目集合不是频繁集合，那么任何包含它的项目集合也一定不是频繁集合；</p>
<p align="left">2. 如果一个项目集合是频繁集合，那么它的任何非空子集也是频繁集合；</p>
<p align="left">Aprioir需要扫描项目表多遍，从一个项目开始扫描，舍去掉那些不是频繁的项目，得到的集合称为L，然后对L中的每个元素进行自组合，生成比上次扫描多一个项目的集合，该集合称为C，接着又扫描去掉那些非频繁的项目，重复…</p>
<p align="left">看下面这个例子：</p>
<p align="left">元素项目表格：</p>
<p align="left"><img alt="" src="/images/jobbole.com/7d14e78300024a017d3c4b0f8c888568.jpg" width="448" height="90"></p>
<p align="left">如果每个步骤不去掉非频繁项目集，则其扫描过程的树形结构如下：</p>
<p align="left"><img alt="" src="/images/jobbole.com/967c4b6d4992d5a3734b8bc523e50340.jpg" width="252" height="227"></p>
<p align="left">在其中某个过程中，可能出现非频繁的项目集，将其去掉（用阴影表示）为：</p>
<p align="left"><img alt="" src="/images/jobbole.com/ef1d35aacb6051a6d976398982a508d6.jpg" width="261" height="248"></p>
<p align="left">上面的内容主要参考的是machine learning in action这本书。</p>
<p><strong>FP Growth:</strong></p>
<p align="left">FP Growth是一种比Apriori更高效的频繁项挖掘方法，它只需要扫描项目表2次。其中第1次扫描获得当个项目的频率，去掉不符合支持度要求的项，并对剩下的项排序。第2遍扫描是建立一颗FP-Tree(frequent-patten tree)。</p>
<p>接下来的工作就是在FP-Tree上进行挖掘。</p>
<p align="left">比如说有下表：</p>
<p align="left"><img alt="" src="/images/jobbole.com/d6380ab9e623777db1f74efd2fa86ca8.jpg" width="339" height="151"></p>
<p align="left">它所对应的FP_Tree如下：</p>
<p align="left"><img alt="" src="/images/jobbole.com/8fb9c89aa17e70bdc67c07d907718c9e.jpg" width="405" height="214"></p>
<p align="left">然后从频率最小的单项P开始，找出P的条件模式基，用构造FP_Tree同样的方法来构造P的条件模式基的FP_Tree，在这棵树上找出包含P的频繁项集。</p>
<p align="left">依次从m,b,a,c,f的条件模式基上挖掘频繁项集，有些项需要递归的去挖掘，比较麻烦，比如m节点，具体的过程可以参考博客：<a href="http://blog.sina.com.cn/s/blog_68ffc7a40100uebg.html">Frequent Pattern 挖掘之二(FP Growth算法)</a>，里面讲得很详细。</p>
<p align="left">
</p>
<p><strong>参考资料：</strong></p>
<ol>
<li>Harrington, P. (2012). Machine Learning in Action, Manning Publications Co.</li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%9C%80%E8%BF%91%E9%84%B0%E5%B1%85%E6%B3%95">最近邻算法（维基百科）</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E9%A9%AC%E6%B0%8F%E8%B7%9D%E7%A6%BB">马氏距离（维基百科）</a></li>
<li><a href="http://baike.baidu.com/view/31801.htm">聚类（百度百科）</a></li>
<li><a href="https://www.coursera.org/course/ml">https://www.coursera.org/course/ml</a></li>
<li><a href="http://blog.csdn.net/wuyanyi/article/details/7964883">SVD在推荐系统中的应用</a></li>
<li>吴军 and 谷歌 (2012).数学之美, 人民邮电出版社.</li>
<li>
<a href="http://bcmi.sjtu.edu.cn/ds/download.html">2010龙星计划：机器学习</a>对应的视频教程：<a href="http://pan.baidu.com/share/link?shareid=3053312914&amp;uk=2620399451"> 2010龙星计划机器学习视频教程</a>
</li>
<li><a href="http://hi.baidu.com/hehehehello/item/96cc42e45c16e7265a2d64ee">GBDT（MART） 迭代决策树入门教程 | 简介</a></li>
<li><a href="http://cs229.stanford.edu/">Ng的cs229课程资料</a></li>
<li><a href="http://v.163.com/special/opencourse/machinelearning.html">斯坦福大学公开课 ：机器学习课程</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_68ffc7a40100uebg.html">Frequent Pattern 挖掘之二(FP Growth算法)</a></li>
</ol>


<!-- div id="ad1">
</div -->


	


	


  </article>

  <div class="meta">
  
    <a class="basic-alignment left" href="/posts/2014/2014-09-24-howto-use-custom-rubygem-in-logstash-205f7f438.html" title="Previous Post: 在 logstash 里使用其他 RubyGems 模块" data-instant>&laquo; 在 logstash 里使用其他 RubyGems 模块</a>
  
  
    <a class="basic-alignment right" href="/posts/2014/2014-09-24-77247-7dc4d49c7.html" title="Next Post: 无损数据压缩算法的历史" data-instant>无损数据压缩算法的历史 &raquo;</a>
  
</div>
  <div id="related">
  <h2 class="subheader">Related Posts <small>They might be useful</small></h2>
  <ul class="posts">
    
      <li><span>14 May 2018</span> &raquo; <a href="http://iftti.com/posts/2018/2018-05-14-113985-6dc6e9281.html">给初学者看的 shuf 命令教程</a></li>
    
      <li><span>13 May 2018</span> &raquo; <a href="http://iftti.com/posts/2018/2018-05-13-113977-b56537dc0.html">常用排序算法总结（2）</a></li>
    
      <li><span>13 May 2018</span> &raquo; <a href="http://iftti.com/posts/2018/2018-05-13-113953-957e4ea5a.html">10 个常用的软件架构模式</a></li>
    
  </ul>
</div>

  
<comments>

<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1936498"></script>
<!-- UY END -->

</comments>

</div>
      <!-- JiaThis Button BEGIN -->
<div class="jiathis_share_slide jiathis_share_24x24" id="jiathis_share_slide">
<div class="jiathis_share_slide_top" id="jiathis_share_title"></div>
<div class="jiathis_share_slide_inner">
<div class="jiathis_style_24x24">
<a class="jiathis_button_tsina"></a>
<a class="jiathis_button_googleplus"></a>
<a class="jiathis_button_twitter"></a>
<a class="jiathis_button_linkedin"></a>
<a class="jiathis_button_weixin"></a>
<a class="jiathis_button_cqq"></a>
<a class="jiathis_button_renren"></a>
<a class="jiathis_button_evernote"></a>
<a class="jiathis_button_pocket"></a>
<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'
	,slide:{
		divid:'wrap',
		pos:'left',
		gt:'true'
	}
};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1936498" charset="utf-8"></script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_slide.js" charset="utf-8"></script>
</div></div></div>
<!-- JiaThis Button END -->
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">

    <h2 class="footer-heading">IT技术干货</h2>

    <div class="footer-col-1 column">
      <p class="text">IT技术干货 KernelHacks 最好的技术站点 技术信息 纯干货</p>
      <ul>
        <li>汇集最好的科技与互联网信息</li>
        <li>Liu Lantao</li>
        <li><a href="mailto:iftti@iftti.com">iftti@iftti.com</a></li>
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        <li>
          <a href="https://github.com/Lax">
            <span class="icon github">
              <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            <span class="username">Lax</span>
          </a>
        </li>
        <li>
          <a href="https://twitter.com/liulantao">
            <span class="icon twitter">
              <svg version="1.1" class="twitter-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
              </svg>
            </span>
            <span class="username">@liulantao</span>
          </a>
        </li>
        <li>
          <a href="https://plus.google.com/+LiuLantao">
            <span class="icon googleplus">
              <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                width="16px" height="16px" viewBox="0 0 134.658 131.646" enable-background="new 0 0 134.658 131.646"
                xml:space="preserve">
                <g>
                  <path fill="#C2C2C2" d="M126.515,4.109H8.144c-2.177,0-3.94,1.763-3.94,3.938v115.546c0,2.179,1.763,3.942,3.94,3.942h118.371
                  c2.177,0,3.94-1.764,3.94-3.942V8.048C130.455,5.872,128.691,4.109,126.515,4.109z"/>
                  <g>
                    <path fill="#FFFFFF" d="M70.479,71.845l-3.983-3.093c-1.213-1.006-2.872-2.334-2.872-4.765c0-2.441,1.659-3.993,3.099-5.43
                    c4.64-3.652,9.276-7.539,9.276-15.73c0-8.423-5.3-12.854-7.84-14.956h6.849l7.189-4.517H60.418
                    c-5.976,0-14.588,1.414-20.893,6.619c-4.752,4.1-7.07,9.753-7.07,14.842c0,8.639,6.633,17.396,18.346,17.396
                    c1.106,0,2.316-0.109,3.534-0.222c-0.547,1.331-1.1,2.439-1.1,4.32c0,3.431,1.763,5.535,3.317,7.528
                    c-4.977,0.342-14.268,0.893-21.117,5.103c-6.523,3.879-8.508,9.525-8.508,13.51c0,8.202,7.731,15.842,23.762,15.842
                    c19.01,0,29.074-10.519,29.074-20.932C79.764,79.709,75.344,75.943,70.479,71.845z M56,59.107
                    c-9.51,0-13.818-12.294-13.818-19.712c0-2.888,0.547-5.87,2.428-8.199c1.773-2.218,4.861-3.657,7.744-3.657
                    c9.168,0,13.923,12.404,13.923,20.382c0,1.996-0.22,5.533-2.762,8.09C61.737,57.785,58.762,59.107,56,59.107z M56.109,103.65
                    c-11.826,0-19.452-5.657-19.452-13.523c0-7.864,7.071-10.524,9.504-11.405c4.64-1.561,10.611-1.779,11.607-1.779
                    c1.105,0,1.658,0,2.538,0.111c8.407,5.983,12.056,8.965,12.056,14.629C72.362,98.542,66.723,103.65,56.109,103.65z"/>
                    <polygon fill="#FFFFFF" points="98.393,58.938 98.393,47.863 92.923,47.863 92.923,58.938 81.866,58.938 81.866,64.469
                    92.923,64.469 92.923,75.612 98.393,75.612 98.393,64.469 109.506,64.469 109.506,58.938"/>
                  </g>
                </g>
              </svg>
            </span>
            <span class="username">+LiuLantao</span>
          </a>
        </li>
      </ul>
    </div>

    <div class="footer-col-3 column">
      
<!--以下是QQ邮件列表订阅嵌入代码--><script >var nId = "6be92ef3590ee662cd5e6381ab2044c328716364f684cf3e",nWidth="auto",sColor="light",sText="填写您的邮件地址，订阅我们的精彩内容：" ;</script><script src="http://list.qq.com/zh_CN/htmledition/js/qf/page/qfcode.js" charset="gb18030"></script>

    </div>

  </div>

  <div class="wrap">
    <div>
      <a href="http://blog.liulantao.com">Blog</a> | <a href="http://1000bit.com">铅笔特评 1000bit</a> | <a href="http://visplanet.com">VisPlanet</a> | <a href="http://iftti.com">IT技术干货</a> | <a href="http://relax.org.cn">Relax</a> | <a href="http://hangzhou.io">杭州城市指南</a>
    </div>
  </div>

  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1658815-7', 'iftti.com');
  ga('require', 'displayfeatures');
  ga('send', 'pageview');

</script>


</footer>


    </body>
</html>