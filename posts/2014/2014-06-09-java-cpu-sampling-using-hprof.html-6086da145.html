<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Java CPU Sampling Using hprof | IT技术干货</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="IT技术干货 KernelHacks 最好的技术站点 技术信息 纯干货">
    <link rel="canonical" href="http://iftti.com/posts/2014/2014-06-09-java-cpu-sampling-using-hprof.html-6086da145.html">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">

</head>


    <body>

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="/">IT技术干货</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
           viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
          
        
          <a class="page-link" href="/about/">About</a>
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>Java CPU Sampling Using hprof</h1>
    <p class="meta"><span class="time">Jun 9, 2014</span><span class="source_url"> • 来自 brendangregg.com <a name="brendangregg.com" href="http://www.brendangregg.com/blog/2014-06-09/java-cpu-sampling-using-hprof.html" target="_blank">[原文链接]</a></span></p>
  </header>

  <article class="post-content">
  

<p>hprof is a free profiler shipped with Java, for heap, CPU, and monitor profiling. It is a powerful and well presented tool, however, its CPU sampling mode doesn't work properly, as it can produce misleading or inaccurate results. I'm also not sure its CPU sampling mode has <em>ever worked</em>.</p>

<p>In this post I'll describe some of the problems, which should be helpful for anyone trying to use hprof CPU sampling. It's tempting to discuss other profilers in detail as well, but to keep this short I'll stick to hprof.</p>

<h2>CPU Sampling Example</h2>

<p>Here's hprof CPU sampling of <a href="http://vertx.io">vert.x</a>, an application platform for the JVM. Excerpts from the hprof report:</p>

<pre>
TRACE 301366: (thread=200009)
        sun.nio.ch.EPollArrayWrapper.epollWait(EPollArrayWrapper.java:Unknown line)
        sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)
        sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:79)
        sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
        sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
        io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:605)
        io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:306)
        io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:116)
        java.lang.Thread.run(Thread.java:744)
[...]
CPU SAMPLES BEGIN (total = 3310) Mon Jun  9 20:33:05 2014
rank   self  accum   count trace method
   1 <b>48.70%</b> 48.70%    1612 301366 <b>sun.nio.ch.EPollArrayWrapper.epollWait</b>
   2 32.08% 80.79%    1062 301340 sun.nio.ch.EPollArrayWrapper.epollWait
   3  3.05% 83.84%     101 301526 sun.nio.ch.NativeThread.current
   4  2.48% 86.31%      82 301457 sun.nio.ch.FileDispatcherImpl.write0
   5  0.88% 87.19%      29 301460 sun.nio.ch.FileDispatcherImpl.read0
   6  0.57% 87.76%      19 301484 sun.misc.Unsafe.copyMemory
   7  0.42% 88.19%      14 301546 io.netty.buffer.AbstractByteBuf.setIndex
[...]
</pre>

<p>The output begins with many stack traces, enumerated, and then a sorted summary showing which stacks were most often sampled. Multiply the "count" column with the sampling interval (in this case, I used 20 ms), to get a rough measure of total time spent in these methods.</p>

<p>Stack trace 301366, in method epollWait, was sampled 48.7% of the time. The second highest stack trace is in the same method, bringing the total to 80.79%. Why is epollWait so hot on-CPU? We should fix it – this app could run 5x faster!</p>

<p>There have been cases of <a href="https://github.com/netty/netty/issues/327">epollWait consuming 100% CPU</a>, due to a bug, in which case hprof would be reporting the truth. But that's not the case here – these threads aren't running on CPU at all.</p>

<p>These hprof results are actually bogus.</p>

<h2>Using hprof cpu=samples</h2>

<p>Here is how hprof can be invoked to perform "CPU" sampling:</p>

<pre>
java <b>-agentlib:hprof=cpu=samples,depth=100,interval=20,lineno=y,thread=y,file=out.hprof</b> myclass
</pre>

<p>This samples stacks up to 100 frames deep, every 20 ms, and writes a report to out.hprof when the program exits, or when java receives a SIGQUIT.</p>

<p>This was previously available in the JVM as the -Xrunhprof option, which still works today, but may be removed in a future version of the JDK (it's still there as of 1.8.0_05). You can check what options are currently available by using hprof=help. Selected lines below:</p>

<pre>
$ <b>java -agentlib:hprof=help</b>

     HPROF: Heap and CPU Profiling Agent (JVMTI Demonstration Code)

hprof usage: java -agentlib:hprof=[help]|[&lt;option&gt;=&lt;value&gt;, ...]

Option Name and Value  Description                    Default
---------------------  -----------                    -------
heap=dump|sites|all    heap profiling                 all
cpu=samples|times|old  CPU usage                      off
monitor=y|n            monitor contention             n
format=a|b             text(txt) or binary output     a
file=&lt;file&gt;            write data to file             java.hprof[{.txt}]
net=&lt;host&gt;:&lt;port&gt;      send data over a socket        off
depth=&lt;size&gt;           stack trace depth              4
interval=&lt;ms&gt;          sample interval in ms          10
cutoff=&lt;value&gt;         output cutoff point            0.0001
lineno=y|n             line number in traces?         y
thread=y|n             thread in traces?              n
[...]
Examples
--------
  - Get sample cpu information every 20 millisec, with a stack depth of 3:
      java -agentlib:hprof=cpu=samples,interval=20,depth=3 classname
[...]
Warnings
--------
  - This is demonstration code for the JVMTI interface and use of BCI,
    it is not an official product or formal part of the JDK.
[...]
</pre>

<p>Note that the output mentions twice that this is demonstration code for JVMTI. That may help explain why the issues have gone unnoticed and unfixed. Neither the output nor the <a href="http://docs.oracle.com/javase/7/docs/technotes/samples/hprof.html">hprof documentation</a> warns that the results can also be inaccurate. Maybe the developers never discovered this, since for some simple programs it appears to work fine. (And if they did discover it, well, it is only a "demo" and not a product.)</p>

<h2>Idle Test</h2>

<p>To better understand the problem, I profiled vert.x when it was completely idle, and checked CPU usage:</p>

<pre>
$ <b>top -p 10515</b>
[...]
  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                                              
30515 root      20   0 4273m 108m  12m S    0  1.5   0:14.33 java   

$ <b>mpstat 1</b>
[...]
08:50:53 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest   %idle
08:50:54 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
08:50:54 PM    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
08:50:54 PM    1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
</pre>

<p>vert.x is completely idle, yet hprof still reports "CPU SAMPLES" in epollWait, at a rate of around 2000ms every second – indicating two CPU-bound threads running in parallel.</p>

<p>jstack(1) can help explain what is happening. Showing the thread that is supposed to be hot on-CPU:</p>

<pre>
"vert.x-eventloop-thread-0" #10 daemon prio=5 os_prio=0 tid=0x00007f5398256000 nid=0x774a runnable [0x00007f53a76ec000]
   java.lang.Thread.State: <b>RUNNABLE</b>
    at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
    at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)
    at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:79)
    at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
    - locked  (a io.netty.channel.nio.SelectedSelectionKeySet)
    - locked  (a java.util.Collections$UnmodifiableSet)
    - locked  (a sun.nio.ch.EPollSelectorImpl)
    at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
    at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:605)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:306)
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:116)
    at java.lang.Thread.run(Thread.java:745)
</pre>

<p>epollWait is RUNNABLE according to the JVM – not the kernel scheduler (it's really asleep!).</p>

<h2>Internals</h2>

<p>hprof is sampling the Java RUNNABLE state. From jvmti/hprof/hprof_trace.c:</p>

<pre>
/* Get traces for all threads in list (traces[i]==0 if thread not running) */
void
trace_get_all_current(jint thread_count, jthread *threads,
[...]
        /* If thread has frames, is runnable, and isn't suspended, we care */
        if ( always_care ||
             ( stack_info[i].frame_count &gt; 0
               &amp;&amp; (stack_info[i].state &amp; <b>JVMTI_THREAD_STATE_RUNNABLE</b>)!=0
               &amp;&amp; (stack_info[i].state &amp; JVMTI_THREAD_STATE_SUSPENDED)==0
               &amp;&amp; (stack_info[i].state &amp; JVMTI_THREAD_STATE_INTERRUPTED)==0 )
            ) {
[...do sampling...]
</pre>

<p>JVMTI_THREAD_STATE_RUNNABLE maps to the Java <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Thread.State.html">RUNNABLE Thread.State</a>, which is documented as:</p>

<blockquote>A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</blockquote>

<p>Runnable does not mean <em>running</em>. It is also not the same as what the kernel scheduler calls "runnable". Sampling Java runnable threads is not the same thing as CPU sampling, but hprof documents it as "CPU SAMPLES". It would be better described as "JVM RUNNABLE SAMPLES".</p>

<p>This fact doesn't seem to be well known. The best reference I found <a href="https://www.java.net/node/645002">said</a> (from 2005):</p>

<blockquote>When you have Java threads that are somehow not using the CPU, but managing to stay active, then it will appear as if those stack traces are consuming large amounts of CPU time when they aren't.</blockquote>

<p>This was written by Kelly O'Hair, who wrote hprof. He references the source, and speculates on how to fix this based on examining more Java thread states. I think it needs to go further than that...</p>

<h2>Inaccurate Timing</h2>

<p>There's another issue with hprof worth mentioning. The paper "Evaluating the Accuracy of Java Profilers" [<a href="http://dl.acm.org/citation.cfm?id=1806618">Mytkowicz 10</a>] shows that different Java profilers, including hprof, produce conflicting profiles. The reason the authors identified was that hprof only samples on <em>yield points</em>, which may not align with the interval specified. They included a sample program which hprof profiles incorrectly, to prove their point.</p>

<p>I find this issue really hard to believe, but I profiled their sample program and saw results that also didn't make sense. I'd need to study some more to confirm that this really is yield, and not another profiling issue that the authors have stumbled upon.</p>

<p>UPDATE: The JVM term for these are <em>safepoints</em> (see comments).</p>

<h2>Why hprof Isn't Used</h2>

<p>If hprof was in common usage for CPU sampling, these problems should have been fixed long ago. But it isn't. I've heard various reasons as to why, including:</p>

<ol>
<li>Other (commercial) profilers have more features. Eg: YourKit, JProfiler, JRocket Flight Recorder, etc.</li>
<li>IDE profilers (incl. NetBeans Profiler, etc.) are easier for developers than the CLI hprof.</li>
<li>hprof can't be turned on and off when needed, so the output contains everything since startup.</li>
<li>The hprof overhead for CPU profiling is too high.</li>
</ol>

<p>(3) is true, but there seem to be <a href="https://github.com/rjpower/java-profiler">fixes</a> for that. hprof uses the JVMTI interface, and while hprof doesn't currently provide on/off capabilities, the JVMTI interface does have them: the NetBeans profiler uses JVMTI for on-demand profiling, as does the VisualVM profiler (which uses the NetBeans profiler).</p>

<p>A simple workaround (ignoring overheads for a moment) could be fashioned using SIGQUIT. With hprof running, a SIGQUIT signal causes hprof to write out its report, and reset profiler data. And so, a second SIGQUIT will only show profile data since the first. This isn't on-demand, since the profiler is always running, but it does let us collect data for an interval of interest.</p>

<p>(4) is definitely true for the "cpu=times" mode, which instruments every method call, and can slow the target application by 1000x (I saw 480x, last time I tried). As an aside, I've been <em>stunned</em> to see products describe this as providing "highly accurate" times, while at the <em>same time</em> warning that it may massively slow the target. Heard of <strong>observer effect</strong>?</p>

<p>The "cpu=samples" mode has much less overhead, and the interval is tunable. For an app I'm testing (vert.x), profiling at 20 ms reduced its request rate by 2%, and increased JVM CPU consumption by 4%. I imagine if this server was out of CPU headroom, the total reduction in request rate would be around 6%. If I had a lot more threads, I may need to increase the sample rate to 50ms or higher to keep the overhead this low.</p>

<p>The most compelling reason not to use hprof for CPU sampling is that the output can be inaccurate. I asked a coworker, a Java performance expert, whether he used hprof, and his answer was to the point: "No, it includes blocking time so the results are misleading".</p>

<h2>Fixing hprof</h2>

<p>The runnable state issue and yield-based sampling could both be fixed at the same time, by profiling <em>from</em> the system. The best example was developed by Sun: the jstack() action for DTrace, which can sample Java stack traces based on the kernel's understanding of running CPUs, and using reliable system timers. This approach can sample not just Java methods, but also JVM internals and the kernel, providing the most complete picture possible of CPU consumption. Since it was launched around the same time as hprof, it may further explain why hprof wasn't fixed earlier: Sun's attention was on DTrace, not hprof. (I'd use DTrace myself, although I've hit an issue with <a href="http://www.listbox.com/member/archive/184261/2014/06/sort/time_rev/page/1/entry/3:9/20140609133236:09A381BE-EFFC-11E3-84AB-F10000B4036A/">incomplete jstacks</a>.)</p>

<p>Aside from system profiling, the runnable issue may be fixable by reading kernel state (eg, via /proc on Linux), to associate actual CPU state with Java thread state. I haven't looked inside commercial profilers, but this may be how they work. One would need to keep the overheads for reading OS state in check.</p>

<p>Assuming the yield issue hasn't distorted our results too much, a dumb fix may be to create an exclude list of methods that are known to block yet stay in the Java RUNNABLE state, and to filter these from the hprof results. I saw an implementation of this by <a href="https://github.com/jnorris/conf/blob/master/bin/hprof#L113">jnorris</a>:</p>

<pre>
    ignore_set = set([
        'java.net.SocketInputStream.socketRead0',
        'java.net.SocketOutputStream.socketWrite0',
        'java.net.PlainSocketImpl.socketAvailable',
        'java.net.PlainSocketImpl.socketAccept',
        'sun.nio.ch.EPollArrayWrapper.epollWait',
    ])
</pre>

<p>I feel dirty just looking at it. While this is an enormous kludge, it may also be a pragmatic workaround.</p>

<p>Of course, I could (and should) also ask Oracle to fix hprof in the JVM. Although I'm not sure how much of a priority that would be, given that Java Flight Recorder is also a revenue stream.</p>

<h2>Conclusion</h2>

<p>Don't trust any performance observability tools you use, without double (or triple) checking their results. Including tools that are bundled and seem standard.</p>

<p>In this case, the bundled Java hprof profiler may not sample CPU usage correctly, depending on your program. It samples based on Java's notion of a thread being runnable, rather than the kernel's notion of a thread <em>actually running on a CPU</em>. These can differ, such as in epollWait, leading to profiles that blame the wrong methods for CPU consumption. Seasoned hprof users may have learned to look past such blocking methods, knowing that the profiler is sampling them incorrectly.</p>

<p>Another reported hprof issue involves CPU sampling based on yield points, rather than intervals, which can also severely skew results.</p>

<p>If hprof, and its JVMTI infrastructure, could be fixed, we'd have a free bundled profiler for Java. However, I'm not sure if anyone wants to do that work. The status quo for Java is to pay for commercial profilers. I'm tempted to take this on myself, because I don't believe I should need to pay for <em>basic</em> CPU profiling.</p>

<h2>Update</h2>

<p>I didn't want to get into other profilers too much, but I just found this, and it's worth mentioning since it was written to address the same issues, and is also free and opensource: Google's <a href="https://code.google.com/p/lightweight-java-profiler/wiki/GettingStarted">lightweight java profiler</a>. It is described on slides 26-30 of a <a href="http://www.oracle.com/technetwork/java/jvmls2013manson-2013920.pdf">2013 talk</a> by Jeremy Manson, which has the awesome slide "Why Profiling Doesn't work", with the reasons:</p>

<ul>
<li>Profiling happens at safe points</li>
<li>Doesn't say what's actually running</li>
<li>Doesn't account for GC time</li>
</ul>

<p>The first two are what I discussed. Not accounting GC time would be a third problem.</p>

<p>This led Jeremy to create a profiler that operated asynchronously (like one would expect), using the Hotspot JVM's AsyncGetCallTrace interface. You can read about it more in his <a href="http://jeremymanson.blogspot.co.uk/2013/07/lightweight-asynchronous-sampling.html">blog post</a>. I just tried it on a few programs, and so far it appears to be working correctly.</p>

<p>As mentioned in the comments, Richard Warburton's <a href="https://github.com/RichardWarburton/honest-profiler">honest-profiler</a> also uses the AsyncGetCallTrace interface, building upon Jeremy Manson's approach. This version is on github, and described recently in his <a href="http://insightfullogic.com/blog/2014/mar/2/open-source-jvm-sampling-profiler/">An open source JVM Sampling Profiler</a> blog post. Like the google profiler and hprof, these may not be production ready as they are more demos than products. Some assembly may be needed.</p>

<h2>Resources</h2>

<ul>
<li>
<a href="http://docs.oracle.com/javase/7/docs/technotes/samples/hprof.html">hprof Documentation</a> on docs.oracle.com.</li>
<li>Java <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Thread.State.html">thread states</a> on docs.oracle.com.</li>
<li>
<a href="http://dl.acm.org/citation.cfm?id=1806618">Mytkowicz 10</a>: T Mytkowicz, A Diwan, M Hauswirth, PF Sweeney. "Evaluating the Accuracy of Java Profilers," <em>ACM Sigplan Notices</em> 45 (6), 187-197</li>
<li>Kelly O'Hair on the hprof <a href="https://www.java.net/node/645002">runnable issue</a>.</li>
<li>Jeremy Manson on his <a href="https://code.google.com/p/lightweight-java-profiler/wiki/GettingStarted">Lightweight Asynchronous Sampling Profiler</a>, and <a href="http://jeremymanson.blogspot.com/2010/07/why-many-profilers-have-serious.html">Why Many Profilers have Serious Problems</a>.</li>
<li>Richard Warburton's <a href="https://github.com/RichardWarburton/honest-profiler">honest-profiler</a>, which may be the most up to date, working, free, and open source Java CPU profiler.</li>
</ul>



  </article>

  <div class="meta">
  
    <a class="basic-alignment left" href="/posts/2014/2014-06-08-perl-script-for-avbot-37881c7d4.html" title="Previous Post: 配合 avbot 的 HTTP 接口做自动应答的 Perl 脚本" data-instant>&laquo; 配合 avbot 的 HTTP 接口做自动应答的 Perl 脚本</a>
  
  
    <a class="basic-alignment right" href="/posts/2014/2014-06-09-e6-94-b9-e9-80-a0-mojolicious-e8-ae-a9-e6-97-a5-e5-bf-97-e6-98-be-e7-a4-ba-e5-bd-93-e5-89-8d-e6-a8-a1-e5-9d-97-e5-92-8c-e8-a1-8c-e5-8f-b7.html-641ecdef9.html" title="Next Post: 改造 Mojolicious 让日志显示当前模块和行号" data-instant>改造 Mojolicious 让日志显示当前模块和行号 &raquo;</a>
  
</div>
  <div id="related">
  <h2 class="subheader">Related Posts <small>They might be useful</small></h2>
  <ul class="posts">
    
      <li><span>21 May 2018</span> &raquo; <a href="http://iftti.com/posts/2018/2018-05-21-114016-1b3612333.html">分布式之消息队列复习精讲</a></li>
    
      <li><span>20 May 2018</span> &raquo; <a href="http://iftti.com/posts/2018/2018-05-20-114009-9d318dfaa.html">分布式之延时任务方案解析</a></li>
    
      <li><span>19 May 2018</span> &raquo; <a href="http://iftti.com/posts/2018/2018-05-19-114012-06b67f2d6.html">分布式之缓存击穿</a></li>
    
  </ul>
</div>

  
<comments>

<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1936498"></script>
<!-- UY END -->

</comments>

</div>
      <!-- JiaThis Button BEGIN -->
<div class="jiathis_share_slide jiathis_share_24x24" id="jiathis_share_slide">
<div class="jiathis_share_slide_top" id="jiathis_share_title"></div>
<div class="jiathis_share_slide_inner">
<div class="jiathis_style_24x24">
<a class="jiathis_button_tsina"></a>
<a class="jiathis_button_googleplus"></a>
<a class="jiathis_button_twitter"></a>
<a class="jiathis_button_linkedin"></a>
<a class="jiathis_button_weixin"></a>
<a class="jiathis_button_cqq"></a>
<a class="jiathis_button_renren"></a>
<a class="jiathis_button_evernote"></a>
<a class="jiathis_button_pocket"></a>
<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'
	,slide:{
		divid:'wrap',
		pos:'left',
		gt:'true'
	}
};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1936498" charset="utf-8"></script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_slide.js" charset="utf-8"></script>
</div></div></div>
<!-- JiaThis Button END -->
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">

    <h2 class="footer-heading">IT技术干货</h2>

    <div class="footer-col-1 column">
      <p class="text">IT技术干货 KernelHacks 最好的技术站点 技术信息 纯干货</p>
      <ul>
        <li>汇集最好的科技与互联网信息</li>
        <li>Liu Lantao</li>
        <li><a href="mailto:iftti@iftti.com">iftti@iftti.com</a></li>
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        <li>
          <a href="https://github.com/Lax">
            <span class="icon github">
              <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            <span class="username">Lax</span>
          </a>
        </li>
        <li>
          <a href="https://twitter.com/liulantao">
            <span class="icon twitter">
              <svg version="1.1" class="twitter-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
              </svg>
            </span>
            <span class="username">@liulantao</span>
          </a>
        </li>
        <li>
          <a href="https://plus.google.com/+LiuLantao">
            <span class="icon googleplus">
              <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                width="16px" height="16px" viewBox="0 0 134.658 131.646" enable-background="new 0 0 134.658 131.646"
                xml:space="preserve">
                <g>
                  <path fill="#C2C2C2" d="M126.515,4.109H8.144c-2.177,0-3.94,1.763-3.94,3.938v115.546c0,2.179,1.763,3.942,3.94,3.942h118.371
                  c2.177,0,3.94-1.764,3.94-3.942V8.048C130.455,5.872,128.691,4.109,126.515,4.109z"/>
                  <g>
                    <path fill="#FFFFFF" d="M70.479,71.845l-3.983-3.093c-1.213-1.006-2.872-2.334-2.872-4.765c0-2.441,1.659-3.993,3.099-5.43
                    c4.64-3.652,9.276-7.539,9.276-15.73c0-8.423-5.3-12.854-7.84-14.956h6.849l7.189-4.517H60.418
                    c-5.976,0-14.588,1.414-20.893,6.619c-4.752,4.1-7.07,9.753-7.07,14.842c0,8.639,6.633,17.396,18.346,17.396
                    c1.106,0,2.316-0.109,3.534-0.222c-0.547,1.331-1.1,2.439-1.1,4.32c0,3.431,1.763,5.535,3.317,7.528
                    c-4.977,0.342-14.268,0.893-21.117,5.103c-6.523,3.879-8.508,9.525-8.508,13.51c0,8.202,7.731,15.842,23.762,15.842
                    c19.01,0,29.074-10.519,29.074-20.932C79.764,79.709,75.344,75.943,70.479,71.845z M56,59.107
                    c-9.51,0-13.818-12.294-13.818-19.712c0-2.888,0.547-5.87,2.428-8.199c1.773-2.218,4.861-3.657,7.744-3.657
                    c9.168,0,13.923,12.404,13.923,20.382c0,1.996-0.22,5.533-2.762,8.09C61.737,57.785,58.762,59.107,56,59.107z M56.109,103.65
                    c-11.826,0-19.452-5.657-19.452-13.523c0-7.864,7.071-10.524,9.504-11.405c4.64-1.561,10.611-1.779,11.607-1.779
                    c1.105,0,1.658,0,2.538,0.111c8.407,5.983,12.056,8.965,12.056,14.629C72.362,98.542,66.723,103.65,56.109,103.65z"/>
                    <polygon fill="#FFFFFF" points="98.393,58.938 98.393,47.863 92.923,47.863 92.923,58.938 81.866,58.938 81.866,64.469
                    92.923,64.469 92.923,75.612 98.393,75.612 98.393,64.469 109.506,64.469 109.506,58.938"/>
                  </g>
                </g>
              </svg>
            </span>
            <span class="username">+LiuLantao</span>
          </a>
        </li>
      </ul>
    </div>

    <div class="footer-col-3 column">
      
<!--以下是QQ邮件列表订阅嵌入代码--><script >var nId = "6be92ef3590ee662cd5e6381ab2044c328716364f684cf3e",nWidth="auto",sColor="light",sText="填写您的邮件地址，订阅我们的精彩内容：" ;</script><script src="http://list.qq.com/zh_CN/htmledition/js/qf/page/qfcode.js" charset="gb18030"></script>

    </div>

  </div>

  <div class="wrap">
    <div>
      <a href="http://blog.liulantao.com">Blog</a> | <a href="http://1000bit.com">铅笔特评 1000bit</a> | <a href="http://visplanet.com">VisPlanet</a> | <a href="http://iftti.com">IT技术干货</a> | <a href="http://relax.org.cn">Relax</a> | <a href="http://hangzhou.io">杭州城市指南</a>
    </div>
  </div>

  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1658815-7', 'iftti.com');
  ga('require', 'displayfeatures');
  ga('send', 'pageview');

</script>


</footer>


    </body>
</html>