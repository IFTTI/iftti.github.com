<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>我的MYSQL学习心得（4） ： 数据类型 | IT技术干货</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="IT技术干货 KernelHacks 最好的技术站点 技术信息 纯干货">
    <link rel="canonical" href="http://iftti.com/posts/2015/2015-06-03-87324-2984cd4fb.html">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">

</head>


    <body>

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="/">IT技术干货</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
           viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
          
        
          <a class="page-link" href="/about/">About</a>
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>我的MYSQL学习心得（4） ： 数据类型</h1>
    <p class="meta"><span class="time">Jun 3, 2015</span><span class="source_url"> • 来自 jobbole.com <a name="jobbole.com" href="http://blog.jobbole.com/87324/" target="_blank">[原文链接]</a></span></p>
  </header>

  <article class="post-content">
  


        <span style="display:block;margin-bottom:10px;"></span>
		<ul>
<li><a href="http://blog.jobbole.com/87315/" target="_blank">我的MYSQL学习心得（1） ：简单语法</a></li>
<li><a href="http://blog.jobbole.com/87318/" target="_blank">我的MYSQL学习心得（2） ：数据类型宽度</a></li>
<li><a href="http://blog.jobbole.com/87322/" target="_blank">我的MYSQL学习心得（3） ： 查看字段长度</a></li>
</ul>
<p><strong>MYSQL</strong>里的BLOB数据类型</p>
<p>BLOB是一个二进制大对象，用来存储可变数量的数据。BLOB类型分为4种：TinyBlob、Blob、MediumBlob、LongBlob，</p>
<p>这几个类型之间的唯一区别是在存储文件的最大大小上不同。</p>
<p>MySQL的四种BLOB类型     类型 大小(单位：字节)</p>
<p>TinyBlob                            最大 255<br>
Blob                                  最大 65K<br>
MediumBlob                       最大 16M<br>
LongBlob                           最大 4G</p>
<p>BLOB列存储的是二进制字符串（字节字符串）；TEXT列存储的是非二进制字符串（字符字符串）。</p>
<p>BLOB列没有字符集，并且排序和比较基于列值字节的数值；TEXT列有一个字符集，并且根据字符集对值进行排序和比较</p>
<p>BLOB是二进制字符串，TEXT是非二进制字符串，两者均可存放大容量的信息。<strong>BLOB主要存储图片、音频信息等</strong>，</p>
<p>而TEXT只能存储文本文件。</p>
<hr>
<p><strong>SQLSERVER</strong></p>
<p>SQLSERVER并没有BLOB数据类型，只有大型对象数据类型（BLOB）：</p>
<p>text,ntext,image,nvarchar(max),varchar(max),varbinary(max)和xml数据类型</p>
<p>这些数据类型的数据都存放在LOB类型的数据页面里</p>
<p><strong>如有不对的地方，欢迎大家拍砖o(∩_∩)o </strong></p>
<p><strong>其他类型</strong></p>
<h2>第11章：列类型</h2>
<p><strong>目录</strong></p>
<dl>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#column-type-overview">11.1. 列类型概述</a></dt>
<dd>
<dl>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-type-overview">11.1.1. 数值类型概述</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#date-and-time-type-overview">11.1.2. 日期和时间类型概述</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#string-type-overview">11.1.3. 字符串类型概述</a></dt>
</dl>
</dd>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-types">11.2. 数值类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#date-and-time-types">11.3. 日期和时间类型</a></dt>
<dd>
<dl>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#datetime">11.3.1. DATETIME、DATE和TIMESTAMP类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#time">11.3.2. TIME类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#year">11.3.3. YEAR类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#y2k-issues">11.3.4. Y2K事宜和日期类型</a></dt>
</dl>
</dd>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#string-types">11.4. String类型</a></dt>
<dd>
<dl>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#char">11.4.1. CHAR和VARCHAR类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#binary-varbinary">11.4.2. BINARY和VARBINARY类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#blob">11.4.3. BLOB和TEXT类型<code></code></a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#enum">11.4.4. ENUM类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#set">11.4.5. SET类型</a></dt>
</dl>
</dd>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements">11.5. 列类型存储需求</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#choosing-types">11.6. 选择正确的列类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#other-vendor-column-types">11.7. 使用来自其他数据库引擎的列类型</a></dt>
</dl>
<p>MySQL支持多种列类型：数值类型、日期/时间类型和字符串(字符)类型。本章首先对这些列类型进行了概述，然后更加详细地描述了各种列的类型，以及列类型存储需求的总结。概述很简单。关于具体列类型的详细信息应查阅详细的描述，例如指定值时允许使用的格式。</p>
<p>MySQL支持处理空间数据的扩展名。关于空间类型的信息参见<a href="http://dev.mysql.com/doc/refman/5.1/zh/spatial-extensions-in-mysql.html">第19章：</a><a title="Chapter 19. Spatial Extensions in MySQL" href="http://dev.mysql.com/doc/refman/5.1/zh/spatial-extensions-in-mysql.html"><em>MySQL中的空间扩展</em></a>。</p>
<p>几种列类型描述使用了下述惯例：</p>
<p>·         <em>M</em></p>
<p>表示最大显示宽度。最大有效显示宽度是255。</p>
<p>·         <em>D</em></p>
<p>适用于浮点和定点类型，并表示小数点后面的位数。最大可能的值是30，但不应大于<em>M</em>-2。</p>
<p>·         方括号(‘[’和‘]’)表示可选部分。</p>
<h2>
<a name="column-type-overview"></a>11.1. 列类型概述</h2>
<dl>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-type-overview">11.1.1. 数值类型概述</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#date-and-time-type-overview">11.1.2. 日期和时间类型概述</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#string-type-overview">11.1.3. 字符串类型概述</a></dt>
</dl>
<p><a name="id2844482"></a></p>
<h3>
<a name="numeric-type-overview"></a>11.1.1. 数值类型概述</h3>
<p>下面为数值列类型的概述。详细信息参见<a title="11.2. Numeric Types" href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-types">11.2节，“数值类型”</a>。列存储需求参见<a title="11.5. Column Type Storage Requirements" href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements">11.5节，“列类型存储需求”</a>。</p>
<p><em>M</em>指示最大显示宽度。最大有效显示宽度是255。显示宽度与存储大小或类型包含的值的范围无关，相关描述见<a title="11.2. Numeric Types" href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-types">11.2节，“数值类型”</a>。</p>
<p>如果为一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性。</p>
<p>SERIAL是BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE的一个别名。</p>
<p>在整数列定义中，SERIAL DEFAULT VALUE是NOT NULL AUTO_INCREMENT UNIQUE的一个别名。</p>
<p><strong>警告：</strong>应当清楚，当使用在整数值（其中一个是UNSIGNED类型）之间使用减号时，结果是无符号。参见<a title="12.8. Cast Functions and Operators" href="http://dev.mysql.com/doc/refman/5.1/zh/functions.html#cast-functions">12.8节，“Cast函数和操作符”</a>。</p>
<p>·         BIT[(<em>M</em>)]</p>
<p>位字段类型。<em>M</em>表示每个值的位数，范围为从1到64。如果<em>M</em>被省略， 默认为1。</p>
<p>·         TINYINT[(<em>M</em>)] [UNSIGNED] [ZEROFILL]</p>
<p>很小的整数。带符号的范围是-128到127。无符号的范围是0到255。</p>
<p>·         BOOL，BOOLEAN</p>
<p>是TINYINT(1)的同义词。zero值被视为假。非zero值视为真。</p>
<p>在将来，将根据标准SQL引入完全布尔类型的处理。</p>
<p>·         SMALLINT[(<em>M</em>)] [UNSIGNED] [ZEROFILL]</p>
<p>小的整数。带符号的范围是-32768到32767。无符号的范围是0到65535。</p>
<p>·         MEDIUMINT[(<em>M</em>)] [UNSIGNED] [ZEROFILL]</p>
<p>中等大小的整数。带符号的范围是-8388608到8388607。无符号的范围是0到16777215。</p>
<p>·         INT[(<em>M</em>)] [UNSIGNED] [ZEROFILL]</p>
<p>普通大小的整数。带符号的范围是-2147483648到2147483647。无符号的范围是0到4294967295。</p>
<p>·         INTEGER[(<em>M</em>)] [UNSIGNED] [ZEROFILL]</p>
<p>这是INT的同义词。</p>
<p>·         BIGINT[(<em>M</em>)] [UNSIGNED] [ZEROFILL]</p>
<p>大整数。带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615。</p>
<p>应清楚BIGINT列的下述内容：</p>
<p>o        使用带符号的BIGINT或DOUBLE值进行所有算法，因此除了位函数，不应使用大于9223372036854775807(63位)的无符号的大整数! 如果这样做，结果中的最后几位可能出错，这是由于将BIGINT值转换为DOUBLE进行四舍五入时造成的错误。</p>
<p>MySQL可以在以下情况下处理BIGINT：</p>
<p>§         当使用整数在一个BIGINT列保存大的无符号的值时。</p>
<p>§         在MIN(<em>col_name</em>)或MAX(<em>col_name</em>)中，其中<em>col_name</em>指BIGINT列。</p>
<p>§         使用操作符(+，-，*等等)并且两个操作数均为整数时。</p>
<p>o        总是可以使用一个字符串在BIGINT列中保存严格整数值。在这种情况下，MySQL执行字符串-数字转换，其间不存在双精度表示。</p>
<p>o        当两个操作数均为整数值时，-、+和* 操作符使用BIGINT算法。这说明如果乘两个大整数(或来自返回整数的函数)，当结果大于9223372036854775807时，会得到意想不到的结果。</p>
<p>·         FLOAT[(<em>M</em>,<em>D</em>)] [UNSIGNED] [ZEROFILL]</p>
<p>小(单精度)浮点数。允许的值是-3.402823466E+38到-1.175494351E-38、0和1.175494351E-38到3.402823466E+38。这些是理论限制，基于IEEE标准。实际的范围根据硬件或操作系统的不同可能稍微小些。</p>
<p><em>M</em>是小数纵位数，<em>D</em>是小数点后面的位数。如果<em>M</em>和<em>D</em>被省略，根据硬件允许的限制来保存值。单精度浮点数精确到大约7位小数位。</p>
<p>如果指定UNSIGNED，不允许负值。</p>
<p>使用浮点数可能会遇到意想不到的问题，因为在MySQL中的所有计算用双精度完成。参见<a title="A.5.7. Solving Problems with No Matching Rows" href="http://dev.mysql.com/doc/refman/5.1/zh/problems.html#no-matching-rows">A.5.7节，“解决与不匹配行有关的问题”</a>。</p>
<p>·         DOUBLE[(<em>M</em>,<em>D</em>)] [UNSIGNED] [ZEROFILL]</p>
<p>普通大小(双精度)浮点数。允许的值是-1.7976931348623157E+308到-2.2250738585072014E-308、0和2.2250738585072014E-308到 1.7976931348623157E+308。这些是理论限制，基于IEEE标准。实际的范围根据硬件或操作系统的不同可能稍微小些。</p>
<p><em>M</em>是小数总位数，<em>D</em>是小数点后面的位数。如果<em>M</em>和<em>D</em>被省略，根据硬件允许的限制来保存值。双精度浮点数精确到大约15位小数位。</p>
<p>如果指定UNSIGNED，不允许负值。</p>
<p>·         DOUBLE PRECISION[(<em>M</em>,<em>D</em>)] [UNSIGNED] [ZEROFILL], REAL[(<em>M</em>,<em>D</em>)] [UNSIGNED] [ZEROFILL]</p>
<p>为DOUBLE的同义词。除了：如果SQL服务器模式包括REAL_AS_FLOAT选项，REAL是FLOAT的同义词而不是DOUBLE的同义词。</p>
<p>·         FLOAT(<em>p</em>) [UNSIGNED] [ZEROFILL]</p>
<p>浮点数。<em>p</em>表示精度（以位数表示），但MySQL只使用该值来确定是否结果列的数据类型为FLOAT或DOUBLE。如果<em>p</em>为从0到24，数据类型变为没有<em>M</em>或<em>D</em>值的FLOAT。如果<em>p</em>为从25到53，数据类型变为没有<em>M</em>或<em>D</em>值的DOUBLE。结果列范围与本节前面描述的单精度FLOAT或双精度DOUBLE数据类型相同。</p>
<p>FLOAT(<em>p</em>)语法与ODBC兼容。</p>
<p>·         DECIMAL[(<em>M</em>[,<em>D</em>])] [UNSIGNED] [ZEROFILL]</p>
<p>压缩的“严格”定点数。<em>M</em>是小数位数(精度)的总数，<em>D</em>是小数点(标度)后面的位数。小数点和(负数)的‘-’符号不包括在<em>M</em>中。如果<em>D</em>是0，则值没有小数点或分数部分。DECIMAL整数最大位数(<em>M</em>)为65。支持的十进制数的最大位数(<em>D</em>)是30。如果<em>D</em>被省略， 默认是0。如果<em>M</em>被省略， 默认是10。</p>
<p>如果指定UNSIGNED，不允许负值。</p>
<p>所有DECIMAL列的基本计算(+，-，*，/)用65位精度完成。</p>
<p>·         DEC[(<em>M</em>[,<em>D</em>])] [UNSIGNED] [ZEROFILL], NUMERIC[(<em>M</em>[,<em>D</em>])] [UNSIGNED] [ZEROFILL], FIXED[(<em>M</em>[,<em>D</em>])] [UNSIGNED] [ZEROFILL]</p>
<p>是DECIMAL的同义词。FIXED同义词适用于与其它服务器的兼容性。</p>
<h3>
<a name="date-and-time-type-overview"></a>11.1.2. 日期和时间类型概述</h3>
<p>本节综合讨论了临时列类型。详细信息，参见<a title="11.3. Date and Time Types" href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#date-and-time-types">11.3节，“日期和时间类型”</a>。列存储需求参见<a title="11.5. Column Type Storage Requirements" href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements">11.5节，“列类型存储需求”</a>。</p>
<p>·         DATE</p>
<p>日期。支持的范围为’1000-01-01′到’9999-12-31′。MySQL以’YYYY-MM-DD’格式显示DATE值，但允许使用字符串或数字为DATE列分配值。</p>
<p>·         DATETIME</p>
<p>日期和时间的组合。支持的范围是’1000-01-01 00:00:00′到’9999-12-31 23:59:59′。MySQL以’YYYY-MM-DD HH:MM:SS’格式显示DATETIME值，但允许使用字符串或数字为DATETIME列分配值。</p>
<p>·         TIMESTAMP[(<em>M</em>)]</p>
<p>时间戳。范围是’1970-01-01 00:00:00′到2037年。</p>
<p>TIMESTAMP列用于INSERT或UPDATE操作时记录日期和时间。如果你不分配一个值，表中的第一个TIMESTAMP列自动设置为最近操作的日期和时间。也可以通过分配一个NULL值，将TIMESTAMP列设置为当前的日期和时间。</p>
<p>TIMESTAMP值返回后显示为’YYYY-MM-DD HH:MM:SS’格式的字符串，显示宽度固定为19个字符。如果想要获得数字值，应在TIMESTAMP 列添加+0。</p>
<p><strong>注释：</strong>MySQL 4.1以前使用的TIMESTAMP格式在MySQL 5.1中不支持；关于旧格式的信息参见<em>MySQL 4.1 参考手册</em>。</p>
<p>·         TIME</p>
<p>时间。范围是’-838:59:59′到’838:59:59′。MySQL以’HH:MM:SS’格式显示TIME值，但允许使用字符串或数字为TIME列分配值。</p>
<p>·         YEAR[(2|4)]</p>
<p>两位或四位格式的年。默认是四位格式。在四位格式中，允许的值是1901到2155和0000。在两位格式中，允许的值是70到69，表示从1970年到2069年。MySQL以YYYY 格式显示YEAR值，但允许使用字符串或数字为YEAR列分配值。</p>
<h3>
<a name="string-type-overview"></a>11.1.3. 字符串类型概述</h3>
<p>本节综合讨论了字符串列类型。详细信息参见<a title="11.4. String Types" href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#string-types">11.4节，“String类型”</a>。列存储需求参见<a title="11.5. Column Type Storage Requirements" href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements">11.5节，“列类型存储需求”</a>。</p>
<p>在某些情况中，MySQL可以将一个字符串列更改为不同于CREATE TABLE或ALTER TABLE语句中所给出的类型。参见<a title="13.1.5.1. Silent Column Specification Changes" href="http://dev.mysql.com/doc/refman/5.1/zh/sql-syntax.html#silent-column-changes">13.1.5.1节，“沉寂的列规格变更”</a>。</p>
<p>MySQL 5.1字符串数据类型包括部分在MySQL 4.1之前的版本中没有的特性：</p>
<p>·         许多字符串数据类型的列定义可以包括指定字符集的CHARACTER SET属性，也可能包括校对规则。(CHARSET是CHARACTER SET的一个同义词）。这些属性适用于CHAR、VARCHAR、TEXT类型、ENUM和SET。例如：</p>
<pre class="brush: sql; gutter: true">CREATE TABLE t
(
  c1 CHAR(20) CHARACTER SET utf8,
  c2 CHAR(20) CHARACTER SET latin1 COLLATE  latin1_bin
);</pre>
<p>该表定义创建了一个名为c1的列，具有一个utf8字符集和该字符集的默认 校对规则，和一个名为c2的列以及latin1字符集和该字符集的二元 校对规则。二元校对规则对大小写不敏感。</p>
<p>·         MySQL 5.1用字符单位解释在字符列定义中的长度规范。(以前的一些MySQL版本以字节解释长度）。</p>
<p>·         对于CHAR、VARCHAR和TEXT类型，BINARY属性可以为列分配该列字符集的 校对规则。</p>
<p>·         字符列的排序和比较基于分配给列的字符集。在以前的版本中，排序和比较基于服务器字符集的校对规则。对于CHAR和VARCHAR 列，你可以用BINARY属性声明列让排序和 校对规则使用当前的字符代码值而不是词汇顺序。</p>
<p>关于MySQL 5.1中字符集的支持，参见<a href="http://dev.mysql.com/doc/refman/5.1/zh/charset.html">第10章：</a><a title="Chapter 10. Character Set Support" href="http://dev.mysql.com/doc/refman/5.1/zh/charset.html"><em>字符集支持</em></a>。</p>
<p>·         [NATIONAL] CHAR(<em>M</em>) [BINARY| ASCII | UNICODE]</p>
<p>固定长度字符串，当保存时在右侧填充空格以达到指定的长度。<em>M</em>表示列长度。<em>M</em>的范围是0到255个字符。</p>
<p><strong>注释：</strong>当检索CHAR值时尾部空格被删除。</p>
<p>如果想要将某个CHAR的长度设为大于255，执行的CREATE TABLE或ALTER TABLE语句将失败并提示错误：</p>
<pre class="brush: sql; gutter: true">mysql&gt; CREATE TABLE c1 (col1 INT, col2 CHAR(500));
ERROR 1074 (42000): Column length too big for column 'col' (max = 255); use BLOB or TEXT instead
mysql&gt; SHOW CREATE TABLE c1;
ERROR 1146 (42S02): Table 'test.c1' doesn't exist</pre>
<p>CHAR是CHARACTER的简写。NATIONAL CHAR(或其等效短形式NCHAR)是标准的定义CHAR列应使用 默认字符集的SQL方法。这在MySQL中为默认值。</p>
<p>BINARY属性是指定列字符集的二元 校对规则的简写。排序和比较基于数值字符值。</p>
<p>列类型CHAR BYTE是CHAR BINARY的一个别名。这是为了保证兼容性。</p>
<p>可以为CHAR指定ASCII属性。它分配latin1字符集。</p>
<p>可以为CHAR指定UNICODE属性。它分配ucs2字符集。</p>
<p>MySQL允许创建类型CHAR(0)的列。这主要用于必须有一个列但实际上不使用值的旧版本的应用程序相兼容。当你需要只能取两个值的列时也很好：没有定义为NOT NULL的一个CHAR(0)列只占用一位，只可以取值NULL和”(空字符串)。</p>
<p>·         CHAR</p>
<p>这是CHAR(1)的同义词。</p>
<p>·         [NATIONAL] VARCHAR(<em>M</em>) [BINARY]</p>
<p>变长字符串。<em>M</em> 表示最大列长度。<em>M</em>的范围是0到65,535。(VARCHAR的最大实际长度由最长的行的大小和使用的字符集确定。最大<em>有效</em>长度是65,532字节）。</p>
<p><strong>注释：</strong>MySQL 5.1遵从标准SQL规范，并且不删除VARCHAR值的尾部空格。</p>
<p>VARCHAR是字符VARYING的简写。</p>
<p>BINARY属性是指定列的字符集的二元 校对规则的简写。排序和比较基于数值字符值。</p>
<p>VARCHAR保存时用一个字节或两个字节长的前缀+数据。如果VARCHAR列声明的长度大于255，长度前缀是两个字节。</p>
<p>·         BINARY(<em>M</em>)</p>
<p>BINARY类型类似于CHAR类型，但保存二进制字节字符串而不是非二进制字符串。</p>
<p>·         VARBINARY(<em>M</em>)</p>
<p>VARBINARY类型类似于VARCHAR类型，但保存二进制字节字符串而不是非二进制字符串。</p>
<p>·         TINYBLOB</p>
<p>最大长度为255(2<sup>8</sup>–1)字节的BLOB列。</p>
<p>·         TINYTEXT</p>
<p>最大长度为255(2<sup>8</sup>–1)字符的TEXT列。</p>
<p>·         BLOB[(<em>M</em>)]</p>
<p>最大长度为65,535(2<sup>16</sup>–1)字节的BLOB列。</p>
<p>可以给出该类型的可选长度<em>M</em>。如果给出，则MySQL将列创建为最小的但足以容纳<em>M</em>字节长的值的BLOB类型。</p>
<p>·         TEXT[(<em>M</em>)]</p>
<p>最大长度为65,535(2<sup>16</sup>–1)字符的TEXT列。</p>
<p>可以给出可选长度<em>M</em>。则MySQL将列创建为最小的但足以容纳<em>M</em>字符长的值的TEXT类型。</p>
<p>·         MEDIUMBLOB</p>
<p>最大长度为16,777,215(2<sup>24</sup>–1)字节的BLOB列。</p>
<p>·         MEDIUMTEXT</p>
<p>最大长度为16,777,215(2<sup>24</sup>–1)字符的TEXT列。</p>
<p>·         LONGBLOB</p>
<p>最大长度为4,294,967,295或4GB(2<sup>32</sup>–1)字节的BLOB列。LONGBLOB列的最大<em>有效</em>(允许的)长度取决于客户端/服务器协议中配置最大包大小和可用的内存。</p>
<p>·         LONGTEXT</p>
<p>最大长度为4,294,967,295或4GB(2<sup>32</sup>–1)字符的TEXT列。LONGTEXT列的最大<em>有效</em>(允许的)长度取决于客户端/服务器协议中配置最大包大小和可用的内存。</p>
<p>·         ENUM(‘<em>value1</em>‘,’<em>value2</em>‘,…)</p>
<p>枚举类型。只能有一个值的字符串，从值列’<em>value1</em>‘，’<em>value2</em>‘，…，NULL中或特殊 ”错误值中选出。ENUM列最多可以有65,535个截然不同的值。ENUM值在内部用整数表示。</p>
<p>·         SET(‘<em>value1</em>‘,’<em>value2</em>‘,…)</p>
<p>一个设置。字符串对象可以有零个或多个值，每个值必须来自列值’<em>value1</em>‘，’<em>value2</em>‘，…SET列最多可以有64个成员。SET值在内部用整数表示。</p>
<h2>
<a name="numeric-types"></a>11.2. 数值类型</h2>
<p>MySQL支持所有标准SQL数值数据类型。这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p>
<p>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p>
<p>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p>
<table id="table1" border="1" cellpadding="0">
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>字节</strong></td>
<td><strong>最小值</strong></td>
<td><strong>最大值</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>(带符号的/无符号的)</strong></td>
<td><strong>(带符号的/无符号的)</strong></td>
</tr>
<tr>
<td>TINYINT</td>
<td>1</td>
<td>-128</td>
<td>127</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0</td>
<td>255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>-32768</td>
<td>32767</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0</td>
<td>65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>-8388608</td>
<td>8388607</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0</td>
<td>16777215</td>
</tr>
<tr>
<td>INT</td>
<td>4</td>
<td>-2147483648</td>
<td>2147483647</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0</td>
<td>4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>-9223372036854775808</td>
<td>9223372036854775807</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0</td>
<td>18446744073709551615</td>
</tr>
</tbody>
</table>
<p>MySQL还支持选择在该类型关键字后面的括号内指定整数值的显示宽度(例如，INT(4))。该可选显示宽度规定用于显示宽度小于指定的列宽度的值时从左侧填满宽度。</p>
<p>显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。</p>
<p>当结合可选扩展属性ZEROFILL使用时， 默认补充的空格用零代替。例如，对于声明为INT(5) ZEROFILL的列，值4检索为00004。请注意如果在整数列保存超过显示宽度的一个值，当MySQL为复杂联接生成临时表时会遇到问题，因为在这些情况下MySQL相信数据适合原列宽度。</p>
<p>所有整数类型可以有一个可选(非标准)属性UNSIGNED。当你想要在列内只允许非负数和该列需要较大的上限数值范围时可以使用无符号值。</p>
<p>浮点和定点类型也可以为UNSIGNED。同数类型，该属性防止负值保存到列中。然而，与整数类型不同的是，列值的上范围保持不变。</p>
<p>如果为一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性。</p>
<p>对于浮点列类型，在MySQL中单精度值使用4个字节，双精度值使用8个字节。</p>
<p>FLOAT类型用于表示近似数值数据类型。SQL标准允许在关键字FLOAT后面的括号内选择用位指定精度(但不能为指数范围)。MySQL还支持可选的只用于确定存储大小的精度规定。0到23的精度对应FLOAT列的4字节单精度。24到53的精度对应DOUBLE列的8字节双精度。</p>
<p>MySQL允许使用非标准语法：FLOAT(<em>M</em>,<em>D</em>)或REAL(<em>M</em>,<em>D</em>)或DOUBLE PRECISION(<em>M</em>,<em>D</em>)。这里，“(<em>M</em>,<em>D</em>)”表示该值一共显示<em>M</em>位整数，其中<em>D</em>位位于小数点后面。例如，定义为FLOAT(7,4)的一个列可以显示为-999.9999。MySQL保存值时进行四舍五入，因此如果在FLOAT(7,4)列内插入999.00009，近似结果是999.0001。</p>
<p>MySQL将DOUBLE视为DOUBLE PRECISION(非标准扩展)的同义词。MySQL还将REAL视为DOUBLE PRECISION(非标准扩展)的同义词，除非SQL服务器模式包括REAL_AS_FLOAT选项。</p>
<p>为了保证最大可能的可移植性，需要使用近似数值数据值存储的代码应使用FLOAT或DOUBLE PRECISION，不规定精度或位数。</p>
<p>DECIMAL和NUMERIC类型在MySQL中视为相同的类型。它们用于保存必须为确切精度的值，例如货币数据。当声明该类型的列时，可以(并且通常要)指定精度和标度；例如：</p>
<pre class="brush: sql; gutter: true">salary DECIMAL(5,2)</pre>
<p>在该例子中，5是精度，2是标度。精度表示保存值的主要位数，标度表示小数点后面可以保存的位数。</p>
<p>在MySQL 5.1中以二进制格式保存DECIMAL和NUMERIC值。</p>
<p>标准SQL要求salary列能够用5位整数位和两位小数保存任何值。因此，在这种情况下可以保存在salary列的值的范围是从-999.99到999.99。</p>
<p>在标准SQL中，语法DECIMAL(<em>M</em>)等价于DECIMAL(<em>M</em>,0)。同样，语法DECIMAL等价于DECIMAL(<em>M</em>,0)，可以通过计算确定<em>M</em>的值。在MySQL 5.1中支持DECIMAL和NUMERIC数据类型的变量形式。<em>M</em>默认值是10。</p>
<p>DECIMAL或NUMERIC的最大位数是65，但具体的DECIMAL或NUMERIC列的实际范围受具体列的精度或标度约束。如果此类列分配的值小数点后面的位数超过指定的标度允许的范围，值被转换为该标度。(具体操作与操作系统有关，但一般结果均被截取到允许的位数）。</p>
<p>BIT数据类型可用来保存位字段值。BIT(<em>M</em>)类型允许存储<em>M</em>位值。<em>M</em>范围为1到64。</p>
<p>要指定位值，可以使用b’<em>value</em>‘符。<em>value</em>是一个用0和1编写的二进制值。例如，b’111′和b’100000000′分别表示7和128。参见<a title="9.1.5. Bit-Field Values" href="http://dev.mysql.com/doc/refman/5.1/zh/language-structure.html#bit-field-values">9.1.5节，“位字段值”</a>。</p>
<p>如果为BIT(M)列分配的值的长度小于<em>M</em>位，在值的左边用0填充。例如，为BIT(6)列分配一个值b’101′，其效果与分配b’000101′相同。</p>
<p>当要在一个数值列内保存一个超出该列允许范围的值时，MySQL的操作取决于此时有效的SQL模式。如果模式未设置，MySQL将值裁剪到范围的相应端点，并保存裁减好的值。但是，如果模式设置为traditional(“严格模式”)，超出范围的值将被拒绝并提示错误，并且根据SQL标准插入会失败。参见<a title="5.3.2. The Server SQL Mode" href="http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode">5.3.2节，“SQL服务器模式”</a>。</p>
<p>如果INT列是UNSIGNED，列范围的大小相同，但其端点会变为到0和4294967295。如果你试图保存-9999999999和9999999999，以非严格模式保存到列中的值是0和4294967296。</p>
<p>如果在浮点或定点列中分配的值超过指定(或默认)精度和标度规定的范围，MySQL以非严格模式保存表示范围相应端点的值。</p>
<p>当MySQL没有工作在严格模式时，对于ALTER TABLE、LOAD DATA INFILE、UPDATE和多行INSERT语句，由于裁剪发生的转换将报告为警告。当MySQL工作在严格模式时，这些语句将失败，并且部分或全部值不会插入或更改，取决于是否表为事务表和其它因素。详情参见<a title="5.3.2. The Server SQL Mode" href="http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode">5.3.2节，“SQL服务器模式”</a>。</p>
<h2>
<a name="date-and-time-types"></a>11.3. 日期和时间类型</h2>
<dl>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#datetime">11.3.1. DATETIME、DATE和TIMESTAMP类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#time">11.3.2. TIME类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#year">11.3.3. YEAR类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#y2k-issues">11.3.4. Y2K事宜和日期类型</a></dt>
</dl>
<p><a name="id2849193"></a><a name="id2849203"></a>表示时间值的DATE和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。每个时间类型有一个有效值范围和一个“零”值，当指定不合法的MySQL不能表示的值时使用“零”值。TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p>
<p>如果试图插入一个不合法的日期，MySQL将给出警告或错误。可以使用ALLOW_INVALID_DATES SQL模式让MySQL接受某些日期，例如’1999-11-31′。当你想要保存一个“可能错误的”用户已经在数据库中指定(例如，以web形式)用于将来处理的值时很有用。在这种模式下，MySQL只验证月范围为从0到12，日范围为从0到31。这些范围可以包括零，因为MySQL允许在DATE或DATETIME列保存日/月和日是零的日期。这在应用程序需要保存一个你不知道确切日期的生日时非常有用。在这种情况下，只需要将日期保存为’1999-00-00′或’1999-01-00′。如果保存此类日期，DATE_SUB()或DATE_ADD等需要完整日期的函数不会得到正确的结果。(如果你不想在日期中出现零，可以使用NO_ZERO_IN_DATE SQL模式)。</p>
<p>MySQL还允许将’0000-00-00′保存为“伪日期”(如果不使用NO_ZERO_DATE SQL模式)。这在某些情况下比使用NULL值更方便(并且数据和索引占用的空间更小)。</p>
<p>将sql_mode系统变量设置为相应模式值，可以更确切你想让MySQL支持哪种日期。参见<a title="5.3.2. The Server SQL Mode" href="http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode">5.3.2节，“SQL服务器模式”</a>。</p>
<p>当使用日期和时间类型时应记住以下几点：</p>
<p>·         MySQL以标准输出格式检索给定日期或时间类型的值，但它尽力解释你指定的各种输入值格式(例如，当你指定一个分配给或与日期或时间类型进行比较的值时)。只支持下面章节中描述的格式。期望你能提供有效值。如果你使用其它格式的值会发生意想不到的结果。</p>
<p>·         包含两位年值的日期会令人模糊，因为世纪不知道。MySQL使用以下规则解释两位年值：</p>
<p>o        70-99范围的年值转换为1970-1999。</p>
<p>o        00-69范围的年值转换为2000-2069。</p>
<p>·         尽管MySQL尝试解释几种格式的值，日期总是以年-月-日顺序(例如，’98-09-04′)，而不是其它地方常用的月-日-年或日-月-年顺序(例如，’09-04-98′，’04-09-98′)。</p>
<p>·         如果值用于数值上下文中，MySQL自动将日期或时间类型的值转换为数字，反之亦然。</p>
<p>·         当 MySQL遇到一个日期或时间类型的超出范围或对于该类型不合法的值时(如本节开始所描述)，它将该值转换为该类的“零”值。一个例外是超出范围的TIME值被裁剪到TIME范围的相应端点。</p>
<p>下面的表显示了各类“零”值的格式。请注意如果启用NO_ZERO_DATE SQL模式，使用这些值会产生警告。</p>
<table id="table2" border="1" cellpadding="0">
<tbody>
<tr>
<td><strong>列类型</strong></td>
<td>
<strong>“</strong><strong>零</strong><strong>”值</strong>
</td>
</tr>
<tr>
<td>DATETIME</td>
<td>’0000-00-00 00:00:00′</td>
</tr>
<tr>
<td>DATE</td>
<td>’0000-00-00′</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>00000000000000</td>
</tr>
<tr>
<td>TIME</td>
<td>’00:00:00′</td>
</tr>
<tr>
<td>YEAR</td>
<td>0000</td>
</tr>
</tbody>
</table>
<p>·         “零”值是特殊值，但你可以使用表内显示的值显式保存或引用它们。你也可以使用值’0′或0来保存或引用，写起来更容易。</p>
<p>·         MyODBC中使用的“零”日期或时间值在MyODBC 2.50.12和以上版本中被自动转换为NULL，因为ODBC不能处理此类值。</p>
<h3>
<a name="datetime"></a>11.3.1. DATETIME、DATE和TIMESTAMP类型</h3>
<dl>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#timestamp-4-1">11.3.1.1. 自MySQL 4.1以来的TIMESTAMP属性</a></dt>
</dl>
<p><a name="id2849637"></a><a name="id2849646"></a><a name="id2849655"></a><a name="id2849664"></a><a name="id2849677"></a><a name="id2849689"></a>DATETIME、DATE和TIMESTAMP类型是相关的。该节描述了它们的特征，它们的相似点和不同点。</p>
<p>当你需要同时包含日期和时间信息的值时则使用DATETIME类型。MySQL以’YYYY-MM-DD HH:MM:SS’格式检索和显示DATETIME值。支持的范围为’1000-01-01 00:00:00′到’9999-12-31 23:59:59′。(“支持”表示尽管先前的值可能工作，但没有保证)。</p>
<p>当你只需要日期值而不需要时间部分时应使用DATE类型。MySQL用’YYYY-MM-DD’格式检索和显示DATE值。支持的范围是’1000-01-01′到 ’9999-12-31′。</p>
<p>TIMESTAMP列类型的属性不固定，取决于MySQL版本和服务器运行的SQL模式。这些属性将在本节后面描述。</p>
<p>可以使用任何常见格式指定DATETIME、DATE和TIMESTAMP值：</p>
<p>·         ’YYYY-MM-DD HH:MM:SS’或’YY-MM-DD HH:MM:SS’格式的字符串。允许“不严格”语法：任何标点符都可以用做日期部分或时间部分之间的间割符。例如，’98-12-31 11:30:45′、’98.12.31 11+30+45′、’98/12/31 11*30*45′和’98@12@31 11^30^45′是等价的。</p>
<p>·         ’YYYY-MM-DD’或’YY-MM-DD’格式的字符串。这里也允许使用“不严格的”语法。例如，’98-12-31′、’98.12.31′、’98/12/31′和’98@12@31′是等价的。</p>
<p>·         ’YYYYMMDDHHMMSS’或’YYMMDDHHMMSS’格式的没有间割符的字符串，假定字符串对于日期类型是有意义的。例如，’19970523091528′和’970523091528′被解释为’1997-05-23 09:15:28′，但’971122129015′是不合法的(它有一个没有意义的分钟部分)，将变为’0000-00-00 00:00:00′。</p>
<p>·         ’YYYYMMDD’或’YYMMDD’格式的没有间割符的字符串，假定字符串对于日期类型是有意义的。例如，’19970523′和’970523′被解释为 ’1997-05-23′，但’971332′是不合法的(它有一个没有意义的月和日部分)，将变为’0000-00-00′。</p>
<p>·         YYYYMMDDHHMMSS或YYMMDDHHMMSS格式的数字，假定数字对于日期类型是有意义的。例如，19830905132800和830905132800被解释为 ’1983-09-05 13:28:00′。</p>
<p>·         YYYYMMDD或YYMMDD格式的数字，假定数字对于日期类型是有意义的。例如，19830905和830905被解释为’1983-09-05′。</p>
<p>·         函数返回的结果，其值适合DATETIME、DATE或者TIMESTAMP上下文，例如NOW()或CURRENT_DATE。</p>
<p>无效DATETIME、DATE或者TIMESTAMP值被转换为相应类型的“零”值(’0000-00-00 00:00:00′、’0000-00-00′或者00000000000000)。</p>
<p>对于包括日期部分间割符的字符串值，如果日和月的值小于10，不需要指定两位数。’1979-6-9′与’1979-06-09′是相同的。同样，对于包括时间部分间割符的字符串值，如果时、分和秒的值小于10，不需要指定两位数。’1979-10-30 1:2:3′与’1979-10-30 01:02:03′相同。</p>
<p>数字值应为6、8、12或者14位长。如果一个数值是8或14位长，则假定为YYYYMMDD或YYYYMMDDHHMMSS格式，前4位数表示年。如果数字 是6或12位长，则假定为YYMMDD或YYMMDDHHMMSS格式，前2位数表示年。其它数字被解释为仿佛用零填充到了最近的长度。</p>
<p>指定为非限定符字符串的值使用给定的长度进行解释。如果字符串为8或14字符长，前4位数表示年。否则，前2位数表示年。从左向右解释字符串内出现的各部分，以发现年、月、日、小时、分和秒值。这说明不应使用少于6字符的字符串。例如，如果你指定’9903′，认为它表示1999年3月，MySQL将在你的表内插入一个“零”日期值。这是因为年和月值是99和03，但日部分完全丢失，因此该值不是一个合法的日期。但是，可以明显指定一个零值来代表缺少的月或日部分。例如，可以使用’990300′来插入值’1999-03-00′。</p>
<p>在一定程度上，可以将一个日期类型的值分配给一个不同的日期类型。但是，值可能会更改或丢失一些信息：</p>
<p>·         如果你为一个DATETIME或TIMESTAMP对象分配一个DATE值，结果值的时间部分被设置为’00:00:00′，因为DATE值未包含时间信息。</p>
<p>·         如果你为一个DATE对象分配一个DATETIME或TIMESTAMP值，结果值的时间部分被删除，因为DATE值未包含时间信息。</p>
<p>·         记住尽管可以使用相同的格式指定DATETIME、DATE和TIMESTAMP值，不同类型的值的范围却不同。例如，TIMESTAMP值不能早于1970或晚于2037。这说明一个日期，例如’1968-01-01′，虽然对于DATETIME或DATE值是有效的，但对于TIMESTAMP值却无效，如果分配给这样一个对象将被转换为0。</p>
<p>当指定日期值时请注意某些缺陷：</p>
<p>·         指定为字符串的值允许的非严格格式可能会欺骗。例如，值’10:11:12′由于‘:’间割符看上去可能象时间值，但如果用于日期上下文值则被解释为年’2010-11-12′。值’10:45:15′被转换为’0000-00-00′因为’45′不是合法月。</p>
<p>·         在非严格模式，MySQL服务器只对日期的合法性进行基本检查：年、月和日的范围分别是1000到9999、00到12和00到31。任何包含超出这些范围的部分的日期被转换成’0000-00-00′。请注意仍然允许你保存非法日期，例如’2002-04-31′。要想确保不使用严格模式时日期有效，应检查应用程序。</p>
<p>在严格模式，非法日期不被接受，并且不转换。</p>
<p>详细信息参见<a title="5.3.2. The Server SQL Mode" href="http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode">5.3.2节，“SQL服务器模式”</a>。</p>
<p>·         包含两位年值的日期会令人模糊，因为世纪不知道。MySQL使用以下规则解释两位年值：</p>
<p>o        00-69范围的年值转换为2000-2069。</p>
<p>o        70-99范围的年值转换为1970-1999。</p>
<h4>
<a name="timestamp-4-1"></a>11.3.1.1. 自MySQL 4.1以来的TIMESTAMP属性</h4>
<p><strong>注释：在</strong>旧版本的MySQL中(4.1之前)，TIMESTAMP列类型的属性在许多方面于本节所描述的大大不同。如果你需要对旧的TIMESTAMP数据进行转化以便在MySQL 5.1中工作，详情请参见<em>MySQL 4.1 参考手册</em>。</p>
<p>TIMESTAMP列的显示格式与DATETIME列相同。换句话说，显示宽度固定在19字符，并且格式为YYYY-MM-DD HH:MM:SS。</p>
<p>MySQL服务器也可以以MAXDB模式运行。当服务器以该模式运行时，TIMESTAMP与DATETIME相等。也就是说，如果创建表时服务器以MAXDB模式运行，TIMESTAMP列创建为DATETIME列。结果是，该列使用DATETIME显示格式，有相同的值范围，并且没有自动对当前的日期和时间进行初始化或更新。</p>
<p>要想启用MAXDB模式，在启动服务器时使用–sql-mode=MAXDB服务器选项或在运行时通过设置全局sql_mode变量将SQL服务器模式设置为MAXDB：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SET GLOBAL sql_mode=MAXDB；&lt;/strong&gt;</pre>
<p>客户端可以按照下面方法让服务器为它的连接以MAXDB模式运行：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SET SESSION sql_mode=MAXDB;&lt;/strong&gt;</pre>
<p>MySQL不接受在日或月列包括一个零或包含非法日期值的时间戳值。该规则的唯一例外是特殊值’0000-00-00 00:00:00′。</p>
<p>你可以非常灵便地确定什么时候初始化和更新TIMESTAMP和对哪些列进行初始化和更新：</p>
<p>·         你可以将当前的时间戳指定为默认值和自动更新的值。但只能选择一个，或者两者都不选。(不可能一个列选择一个行为而另一个列选择另一个行为）。</p>
<p>·         你可以指定哪个TIMESTAMP列自动初始化或更新为当前的日期和时间。不再需要为第1个TIMESTAMP列。</p>
<p>请注意下面讨论所信息只适用于创建时未启用MAXDB模式的表的TIMESTAMP列。(如上所述，MAXDB模式使列创建为DATETIME列）。控制TIMESTAMP列的初始化和更新的规则如下所示：</p>
<p>·         如果一个表内的第1个TIMESTAMP列指定为一个DEFAULT值，则不能忽略。 默认值可以为CURRENT_TIMESTAMP或常量日期和时间值。</p>
<p>·         DEFAULT NULL与第1个<em>TIMESTAMP</em> 列的DEFAULT CURRENT_TIMESTAMP相同。对于其它TIMESTAMP列，DEFAULT NULL被视为DEFAULT 0。</p>
<p>·         表内的任何一个TIMESTAMP列可以设置为自动初始化为当前时间戳和/或更新。</p>
<p>·         在CREATE TABLE语句中，可以用下面的任何一种方式声明第1个TIMESTAMP列：</p>
<p>o        用DEFAULT CURRENT_TIMESTAMP和ON UPDATE CURRENT_TIMESTAMP子句，列为默认值使用当前的时间戳，并且自动更新。</p>
<p>o        不使用DEFAULT或ON UPDATE子句，与DEFAULT CURRENT_TIMESTAMP ON UPDATECURRENT_TIMESTAMP相同。</p>
<p>o        用DEFAULT CURRENT_TIMESTAMP子句不用ON UPDATE子句，列为默认值使用当前的时间戳但是不自动更新。</p>
<p>o        不用DEFAULT子句但用ON UPDATE CURRENT_TIMESTAMP子句，列有默认值0并自动更新。</p>
<p>o        用常量DEFAULT值，列有给出的 默认值。如果列有一个ON UPDATE CURRENT_TIMESTAMP子句，它自动更新，否则不。</p>
<p>换句话说，你可以为初始值和自动更新的值使用当前的时间戳，或者其中一个使用，或者两个皆不使用。(例如，你可以指定ON UPDATE来启用自动更新而不让列自动初始化）。</p>
<p>·         在DEFAULT和ON UPDATE子句中可以使用CURRENT_TIMESTAMP、CURRENT_TIMESTAMP()或者NOW()。它们均具有相同的效果。</p>
<p>两个属性的顺序并不重要。如果一个TIMESTAMP列同时指定了DEFAULT和ON UPDATE，任何一个可以在另一个的前面。</p>
<p>例子，下面这些语句是等效的：</p>
<pre class="brush: sql; gutter: true">CREATE TABLE t (ts TIMESTAMP);
CREATE TABLE t (ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t (ts TIMESTAMP ON UPDATE CURRENT_TIMESTAMP DEFAULT CURRENT_TIMESTAMP);</pre>
<p>·         要为TIMESTAMP列而不是第1列指定自动默认或更新，必须通过将第1个TIMESTAMP列显式分配一个常量DEFAULT值来禁用自动初始化和更新。(例如，DEFAULT 0或DEFAULT’2003-01-01 00:00:00′)。然后，对于其它TIMESTAMP列，规则与第1个TIMESTAMP列相同，例外情况是不能忽略DEFAULT和ON UPDATE子句。如果这样做，则不会自动进行初始化或更新。</p>
<p>例如：下面这些语句是等效的：</p>
<pre class="brush: sql; gutter: true">CREATE TABLE t (
    ts1 TIMESTAMP DEFAULT 0,
    ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                  ON UPDATE CURRENT_TIMESTAMP);</pre>
<pre class="brush: sql; gutter: true">CREATE TABLE t (
    ts1 TIMESTAMP DEFAULT 0,
    ts2 TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                  DEFAULT CURRENT_TIMESTAMP);</pre>
<p>可以对每个连接设置当前的时区，相关描述参见<a title="5.10.8. MySQL Server Time Zone Support" href="http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#time-zone-support">5.10.8节，“MySQL服务器时区支持”</a>。TIMESTAMP值以UTC格式保存，存储时对当前的时区进行转换，检索时再转换回当前的时区。只要时区设定值为常量，便可以得到保存时的值。如果保存一个TIMESTAMP值，应更改时区然后检索该值，它与你保存的值不同。这是因为在两个方向的转换中没有使用相同的时区。当前的时区可以用作time_zone系统变量的值。</p>
<p>可以在TIMESTAMP列的定义中包括NULL属性以允许列包含NULL值。例如：</p>
<pre class="brush: sql; gutter: true">CREATE TABLE t
(
  ts1 TIMESTAMP NULL DEFAULT NULL,
  ts2 TIMESTAMP NULL DEFAULT 0,
  ts3 TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP
);</pre>
<p>如果未指定NULL属性，将列设置为NULL设置则会将它设置为当前的时间戳。请注意允许NULL值的TIMESTAMP列不会采用当前的时间戳，除非要么其 默认值定义为CURRENT_TIMESTAMP，或者NOW()或CURRENT_TIMESTAMP被插入到该列内。换句话说，只有使用如下定义创建，定义为 NULL的TIMESTAMP列才会自动更新：</p>
<pre class="brush: sql; gutter: true">CREATE TABLE t (ts NULLDEFAULT CURRENT_TIMESTAMP)；</pre>
<p>否则-也就是说，如果使用NULL而不是DEFAULT TIMESTAMP来定义TIMESTAMP列，如下所示…</p>
<pre class="brush: sql; gutter: true">CREATE TABLE t1 (ts NULL DEFAULT NULL);
CREATE TABLE t2 (ts NULL DEFAULT '0000-00-00 00:00:00');</pre>
<p>…则必须显式插入一个对应当前日期和时间的值。例如：</p>
<pre class="brush: sql; gutter: true">INSERT INTO t1 VALUES (NOW());
INSERT INTO t2 VALUES (CURRENT_TIMESTAMP);</pre>
<h3>
<a name="time"></a>11.3.2. TIME类型</h3>
<p><a name="id2851158"></a><a name="id2851167"></a></p>
<p>MySQL以’HH:MM:SS’格式检索和显示TIME值(或对于大的小时值采用’HHH:MM:SS’格式)。TIME值的范围可以从’-838:59:59′到’838:59:59′。小时部分会因此大的原因是TIME类型不仅可以用于表示一天的时间(必须小于24小时)，还可能为某个事件过去的时间或两个事件之间的时间间隔(可以大于24小时，或者甚至为负)。</p>
<p>你可以用各种格式指定TIME值：</p>
<p>·         ’D HH:MM:SS.fraction’格式的字符串。还可以使用下面任何一种“非严格”语法：’HH:MM:SS.fraction’、’HH:MM:SS’、’HH:MM’、’D HH:MM:SS’、’D HH:MM’、’D HH’或’SS’。这里D表示日，可以取0到34之间的值。请注意MySQL还不保存分数。</p>
<p>·         ’HHMMSS’格式的没有间割符的字符串，假定是有意义的时间。例如，’101112′被理解为’10:11:12′，但’109712′是不合法的(它有一个没有意义的分钟部分)，将变为’00:00:00′。</p>
<p>·         HHMMSS格式的数值，假定是有意义的时间。例如，101112被理解为’10:11:12′。下面格式也可以理解：SS、MMSS、HHMMSS、HHMMSS.fraction。请注意MySQL还不保存分数。</p>
<p>·         函数返回的结果，其值适合TIME上下文，例如CURRENT_TIME。</p>
<p>对于指定为包括时间部分间割符的字符串的TIME值，如果时、分或者秒值小于10，则不需要指定两位数。’8:3:2′与’08:03:02′相同。</p>
<p>为TIME列分配简写值时应注意。没有冒号，MySQL解释值时假定最右边的两位表示秒。(MySQL解释TIME值为过去的时间而不是当天的时间）。例如，你可能认为’1112′和1112表示’11:12:00′(11点过12分)，但MySQL将它们解释为’00:11:12′(11分，12 秒)。同样，’12′和12 被解释为 ’00:00:12′。相反，TIME值中使用冒号则肯定被看作当天的时间。也就是说，’11:12′表示’11:12:00′，而不是’00:11:12′。</p>
<p>超出TIME范围但合法的值被裁为范围最接近的端点。例如，’-850:00:00′和’850:00:00′被转换为’-838:59:59′和’838:59:59′。</p>
<p>无效TIME值被转换为’00:00:00′。请注意由于’00:00:00′本身是一个合法TIME值，只从表内保存的一个’00:00:00′值还不能说出原来的值是 ’00:00:00′还是不合法的值。</p>
<h3>
<a name="year"></a>11.3.3. YEAR类型</h3>
<p><a name="id2851517"></a><a name="id2851526"></a></p>
<p>YEAR类型是一个单字节类型用于表示年。</p>
<p>MySQL以YYYY格式检索和显示YEAR值。范围是1901到2155。</p>
<p>可以指定各种格式的YEAR值：</p>
<p>·         四位字符串，范围为’1901′到’2155′。</p>
<p>·         四位数字，范围为1901到2155。</p>
<p>·         两位字符串，范围为’00′到’99′。’00′到’69′和’70′到’99′范围的值被转换为2000到2069和1970到1999范围的YEAR值。</p>
<p>·         两位整数，范围为1到99。1到69和70到99范围的值被转换为2001到2069和1970到1999范围的YEAR值。请注意两位整数范围与两位字符串范围稍有不同，因为你不能直接将零指定为数字并将它解释为2000。你必须将它指定为一个字符串’0′或’00′或它被解释为0000。</p>
<p>·         函数返回的结果，其值适合YEAR上下文，例如NOW()。</p>
<p>非法YEAR值被转换为0000。</p>
<h3>
<a name="y2k-issues"></a>11.3.4. Y2K事宜和日期类型</h3>
<p><a name="id2851772"></a><a name="id2851779"></a>MySQL本身对于2000年(Y2K)是安全的(参见<a title="1.4.5. Year 2000 Compliance" href="http://dev.mysql.com/doc/refman/5.1/zh/introduction.html#year-2000-compliance">1.4.5节，“2000年兼容性”</a>)，但输入给MySQL的值可能不安全。任何包含两位年值的输入都会令人模糊，因为世纪不知道。这些值必须解释为四位形式，因为MySQL内部使用四位来保存年。</p>
<p>对于DATETIME、DATE、TIMESTAMP和YEAR类型，MySQL使用以下规则解释含模糊年值的日期：</p>
<p>·         00-69范围的年值转换为2000-2069。</p>
<p>·         70-99范围的年值转换为1970-1999。</p>
<p>请记住这些规则只是合理猜测数据值表示什么。如果MySQL使用的启发不能产生正确的值，你应提供包含四位年值的确切输入。</p>
<p>ORDER BY可以正确排序有两位年的TIMESTAMP或YEAR值。</p>
<p>部分函数如MIN()和MAX()将TIMESTAMP或YEAR转换为一个数字。这说明使用有两位年值的值，这些函数不能工作正确。在这种情况下的修复方法是将TIMESTAMP或YEAR转换为四位年格式或使用MIN(DATE_ADD(TIMESTAMP,INTERVAL 0 DAYS))。</p>
<h2>
<a name="string-types"></a>11.4. String类型</h2>
<dl>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#char">11.4.1. CHAR和VARCHAR类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#binary-varbinary">11.4.2. BINARY和VARBINARY类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#blob">11.4.3. BLOB和TEXT类型<code></code></a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#enum">11.4.4. ENUM类型</a></dt>
<dt><a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#set">11.4.5. SET类型</a></dt>
</dl>
<p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p>
<h3>
<a name="char"></a>11.4.1. CHAR和VARCHAR类型</h3>
<p>CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>CHAR和VARCHAR类型声明的长度表示你想要保存的最大字符数。例如，CHAR(30)可以占用30个字符。</p>
<p>CHAR列的长度固定为创建表时声明的长度。长度可以为从0到255的任何值。当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。</p>
<p>VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值。(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。</p>
<p>同CHAR对比，VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。</p>
<p>VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。</p>
<p>如果分配给CHAR或VARCHAR列的值超过列的最大长度，则对值进行裁剪以使其适合。如果被裁掉的字符不是空格，则会产生一条警告。如果裁剪非空格字符，则会造成错误(而不是警告)并通过使用严格SQL模式禁用值的插入。参见<a title="5.3.2. The Server SQL Mode" href="http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode">5.3.2节，“SQL服务器模式”</a>。</p>
<p>下面的表显示了将各种字符串值保存到CHAR(4)和VARCHAR(4)列后的结果，说明了CHAR和VARCHAR之间的差别：</p>
<table id="table3" border="1" cellpadding="0">
<tbody>
<tr>
<td><strong>值</strong></td>
<td>CHAR(4)</td>
<td><strong>存储需求</strong></td>
<td>VARCHAR(4)</td>
<td><strong>存储需求</strong></td>
</tr>
<tr>
<td>”</td>
<td>‘    ’</td>
<td>4个字节</td>
<td>”</td>
<td>1个字节</td>
</tr>
<tr>
<td>‘ab’</td>
<td>‘ab  ’</td>
<td>4个字节</td>
<td>‘ab ‘</td>
<td>3个字节</td>
</tr>
<tr>
<td>‘abcd’</td>
<td>‘abcd’</td>
<td>4个字节</td>
<td>‘abcd’</td>
<td>5个字节</td>
</tr>
<tr>
<td>‘abcdefgh’</td>
<td>‘abcd’</td>
<td>4个字节</td>
<td>‘abcd’</td>
<td>5个字节</td>
</tr>
</tbody>
</table>
<p>请注意上表中最后一行的值只适用<em>不使用严格模式</em>时；如果MySQL运行在严格模式，超过列长度不的值<em>不<em>保存</em></em>，并且会出现错误。</p>
<p>从CHAR(4)和VARCHAR(4)列检索的值并不总是相同，因为检索时从CHAR列删除了尾部的空格。通过下面的例子说明该差别：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;CREATE TABLE vc (v VARCHAR(4), c CHAR(4));
&lt;/strong&gt;Query OK, 0 rows affected (0.02 sec)</pre>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;INSERT INTO vc VALUES ('ab  ', 'ab  ');
&lt;/strong&gt;Query OK, 1 row affected (0.00 sec)</pre>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SELECT CONCAT(v, '+'), CONCAT(c, '+') FROM vc;
&lt;/strong&gt;+----------------+----------------+
| CONCAT(v, '+') | CONCAT(c, '+') |
+----------------+----------------+
| ab  +          | ab+            |
+----------------+----------------+
1 row in set (0.00 sec)</pre>
<p>根据分配给列的字符集校对规则对CHAR和VARCHAR列中的值进行排序和比较。</p>
<p>请注意所有MySQL校对规则属于PADSPACE类。这说明在MySQL中的所有CHAR和VARCHAR值比较时不需要考虑任何尾部空格。例如：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;CREATE TABLE names (myname CHAR(10), yourname VARCHAR(10));
&lt;/strong&gt;Query OK, 0 rows affected (0.09 sec)</pre>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;INSERT INTO names VALUES ('Monty ', 'Monty ');
&lt;/strong&gt;Query OK, 1 row affected (0.00 sec)</pre>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SELECT myname = 'Monty  ', yourname = 'Monty  ' FROM names;
&lt;/strong&gt;+--------------------+----------------------+
| myname = 'Monty  ' | yourname = 'Monty  ' |
+--------------------+----------------------+
|                  1 |                    1 |
+--------------------+----------------------+
1 row in set (0.00 sec)</pre>
<p>请注意所有MySQL版本均如此，并且它不受SQL服务器模式的影响。</p>
<p>对于尾部填充字符被裁剪掉或比较时将它们忽视掉的情形，如果列的索引需要唯一的值，在列内插入一个只是填充字符数不同的值将会造成复制键值错误。</p>
<p>CHAR BYTE是CHAR BINARY的别名。这是为了保证兼容性。</p>
<p>ASCII属性为CHAR列分配latin1字符集。UNICODE属性分配ucs2字符集。</p>
<h3>
<a name="binary-varbinary"></a>11.4.2. BINARY和VARBINARY类型</h3>
<p><a name="id2852527"></a><a name="id2852536"></a><a name="id2852545"></a><a name="id2852558"></a>BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p>
<p>BINARY和VARBINARY允许的最大长度一样，如同CHAR和VARCHAR，不同的是BINARY和VARBINARY的长度是字节长度而不是字符长度。</p>
<p>BINARY和VARBINARY数据类型不同于CHAR BINARY和VARCHAR BINARY数据类型。对于后一种类型，BINARY属性不会将列视为二进制字符串列。相反，它致使使用列字符集的二元 校对规则，并且列自身包含非二进制字符字符串而不是二进制字节字符串。例如CHAR(5) BINARY被视为CHAR(5) CHARACTER SET latin1 COLLATE latin1_bin，假定默认字符集是latin1。这不同于BINARY(5)，它保存5字节二进制字符串，没有字符集或 校对规则。</p>
<p>当保存BINARY值时，在它们右边填充值以达到指定长度。填充值是0×00(零字节)。插入值时在右侧添加0×00 on，并且选择时不删除尾部的字节。比较时所有字节很重要，包括ORDER BY和DISTINCT操作。比较时0×00字节和空格是不同的，0×00&lt;空格。</p>
<p>例如：对于一个BINARY(3)列，当插入时 ’a' 变为 ’a ’。’a'插入时变为’a'。当选择时两个插入的值均不更改。</p>
<p>对于VARBINARY，插入时不填充字符，选择时不裁剪字节。比较时所有字节很重要，包括ORDER BY和DISTINCT操作。比较时0×00字节和空格是不同的，0×00&lt;空格。</p>
<p>对于尾部填充字符被裁剪掉或比较时将它们忽视掉的情形，如果列的索引需要唯一的值，在列内插入一个只是填充字符数不同的值将会造成复制键值错误。</p>
<p>如果你计划使用这些数据类型来保存二进制数据并且需要检索的值与保存的值完全相同，应考虑前面所述的填充和裁剪特征。下面的例子说明了用0×00填充的BINARY值如何影响列值比较：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;CREATE TABLE t (c BINARY(3));
&lt;/strong&gt;Query OK, 0 rows affected (0.01 sec)</pre>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;INSERT INTO t SET c = 'a';
&lt;/strong&gt;Query OK, 1 row affected (0.01 sec)</pre>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SELECT HEX(c), c = 'a', c = 'a' from t;
&lt;/strong&gt;+--------+---------+-------------+
| HEX(c) | c = 'a' | c = 'a' |
+--------+---------+-------------+
| 610000 |       0 |           1 |
+--------+---------+-------------+
1 row in set (0.09 sec)</pre>
<p>如果检索的值必须与指定进行存储而没有填充的值相同，最好使用BLOB数据类型。</p>
<p>创建表时，MySQL可以默默更改BINARY或VARBINARY列的类型。参见<a title="13.1.5.1. Silent Column Specification Changes" href="http://dev.mysql.com/doc/refman/5.1/zh/sql-syntax.html#silent-column-changes">13.1.5.1节，“沉寂的列规格变更”</a>。</p>
<h3>
<a name="blob"></a>11.4.3. BLOB和TEXT类型<code></code>
</h3>
<p><a name="id2852869"></a><a name="id2852878"></a><a name="id2852887"></a><a name="id2852900"></a><a name="id2852912"></a><a name="id2852921"></a>BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同。</p>
<p>有4种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些对应4种BLOB类型，有相同的最大长度和存储需求。</p>
<p>参见<a title="11.5. Column Type Storage Requirements" href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#storage-requirements">11.5节，“列类型存储需求”</a>。</p>
<p>BLOB 列被视为二进制字符串(字节字符串)。TEXT列被视为非二进制字符串(字符字符串)。BLOB列没有字符集，并且排序和比较基于列值字节的数值值。TEXT列有一个字符集，并且根据字符集的 校对规则对值进行排序和比较。</p>
<p>在TEXT或BLOB列的存储或检索过程中，不存在大小写转换。</p>
<p>当未运行在严格模式时，如果你为BLOB或TEXT列分配一个超过该列类型的最大长度的值值，值被截取以保证适合。如果截掉的字符不是空格，将会产生一条警告。使用严格SQL模式，会产生错误，并且值将被拒绝而不是截取并给出警告。参见<a title="5.3.2. The Server SQL Mode" href="http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-sql-mode">5.3.2节，“SQL服务器模式”</a>。</p>
<p>在大多数方面，可以将BLOB列视为能够足够大的VARBINARY列。同样，可以将TEXT列视为VARCHAR列。BLOB和TEXT在以下几个方面不同于VARBINARY和VARCHAR：</p>
<p>·         当保存或检索BLOB和TEXT列的值时不删除尾部空格。(这与VARBINARY和VARCHAR列相同）。</p>
<p>请注意比较时将用空格对TEXT进行扩充以适合比较的对象，正如CHAR和VARCHAR。</p>
<p>·         对于BLOB和TEXT列的索引，必须指定索引前缀的长度。对于CHAR和VARCHAR，前缀长度是可选的。参见<a title="7.4.3. Column Indexes" href="http://dev.mysql.com/doc/refman/5.1/zh/optimization.html#indexes">7.4.3节，“列索引”</a>。</p>
<p>·         BLOB和TEXT列不能有 默认值。</p>
<p>LONG和LONG VARCHAR对应MEDIUMTEXT数据类型。这是为了保证兼容性。如果TEXT列类型使用BINARY属性，将为列分配列字符集的二元 校对规则。</p>
<p>MySQL连接程序/ODBC将BLOB值定义为LONGVARBINARY，将TEXT值定义为LONGVARCHAR。</p>
<p>由于BLOB和TEXT值可能会非常长，使用它们时可能遇到一些约束：</p>
<p>·         当排序时只使用该列的前max_sort_length个字节。max_sort_length的 默认值是1024；该值可以在启动<strong>mysqld</strong>服务器时使用–max_sort_length选项进行更改。参见<a title="5.3.3. Server System Variables" href="http://dev.mysql.com/doc/refman/5.1/zh/database-administration.html#server-system-variables">5.3.3节，“服务器系统变量”</a>。</p>
<p>运行时增加max_sort_length的值可以在排序或组合时使更多的字节有意义。任何客户端可以更改其会话max_sort_length变量的值：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SET max_sort_length = 2000;&lt;/strong&gt;</pre>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SELECT id, comment FROM &lt;em&gt;tbl_name
&lt;/em&gt;&lt;/strong&gt;    -&amp;gt; &lt;strong&gt;ORDER BY comment;&lt;/strong&gt;</pre>
<p>当你想要使超过max_sort_length的字节有意义，对含长值的BLOB或TEXT列使用GROUP BY或ORDER BY的另一种方式是将列值转换为固定长度的对象。标准方法是使用SUBSTRING函数。例如，下面的语句对comment列的2000个字节进行排序：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SELECT id, SUBSTRING(comment,1,2000) FROM &lt;em&gt;tbl_name
&lt;/em&gt;&lt;/strong&gt;    -&amp;gt; &lt;strong&gt;ORDER BY SUBSTRING(comment,1,2000);&lt;/strong&gt;</pre>
<p>·         BLOB或TEXT对象的最大大小由其类型确定，但在客户端和服务器之间实际可以传递的最大值由可用内存数量和通信缓存区大小确定。你可以通过更改max_allowed_packet变量的值更改消息缓存区的大小，但必须同时修改服务器和客户端程序。例如，可以使用 <strong>mysql</strong>和<strong>mysqldump</strong>来更改客户端的max_allowed_packet值。参见<a title="7.5.2. Tuning Server Parameters" href="http://dev.mysql.com/doc/refman/5.1/zh/optimization.html#server-parameters">7.5.2节，“调节服务器参数”</a>、<a title="8.3. mysql — The MySQL Command-Line Tool" href="http://dev.mysql.com/doc/refman/5.1/zh/client-side-scripts.html#mysql">8.3节，“mysql：MySQL命令行工具”</a>和<a title="8.8. mysqldump — A Database Backup Program" href="http://dev.mysql.com/doc/refman/5.1/zh/client-side-scripts.html#mysqldump">8.8节，“mysqldump：数据库备份程序”</a>。</p>
<p>每个BLOB或TEXT值分别由内部分配的对象表示。这与其它列类型形成对比，后者是当打开表时为每1列分配存储引擎。</p>
<h3>
<a name="enum"></a>11.4.4. ENUM类型</h3>
<p><a name="id2853488"></a><a name="id2853497"></a></p>
<p>ENUM是一个字符串对象，其值来自表创建时在列规定中显式枚举的一列值。</p>
<p>在某些情况下，ENUM值也可以为空字符串(”)或NULL：</p>
<p>·         如果你将一个非法值插入ENUM(也就是说，允许的值列之外的字符串)，将插入空字符串以作为特殊错误值。该字符串与“普通”空字符串不同，该字符串有数值值0。后面有详细讨论。</p>
<p>·         如果将ENUM列声明为允许NULL，NULL值则为该列的一个有效值，并且 默认值为NULL。如果ENUM列被声明为NOT NULL，其默认值为允许的值列的第1个元素。</p>
<p>每个枚举值有一个索引：</p>
<p>·         来自列规定的允许的值列中的值从1开始编号。</p>
<p>·         空字符串错误值的索引值是0。这说明你可以使用下面的SELECT语句来找出分配了非法ENUM值的行：</p>
<pre class="brush: sql; gutter: true">·    mysql&amp;gt; &lt;strong&gt;SELECT * FROM &lt;em&gt;tbl_name&lt;/em&gt; WHERE &lt;em&gt;enum_col&lt;/em&gt;=0;&lt;/strong&gt;</pre>
<p>·         NULL值的索引是NULL。</p>
<p>例如，定义为ENUM的列(‘one’，’two’，’three’)可以有下面所示任何值。还显示了每个值的索引：</p>
<table id="table4" border="1" cellpadding="0">
<tbody>
<tr>
<td><strong>值</strong></td>
<td><strong>索引</strong></td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
</tr>
<tr>
<td>”</td>
<td>0</td>
</tr>
<tr>
<td>‘one’</td>
<td>1</td>
</tr>
<tr>
<td>‘two’</td>
<td>2</td>
</tr>
<tr>
<td>‘three’</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>枚举最多可以有65,535个元素。</p>
<p>当创建表时，ENUM成员值的尾部空格将自动被删除。</p>
<p>当检索时，保存在ENUM列的值使用列定义中所使用的大小写来显示。请注意可以为ENUM列分配字符集和 校对规则。对于二进制或大小写敏感的校对规则，当为列分配值时应考虑大小写。</p>
<p>如果在数值上下文中检索一个ENUM值，将返回列值的索引。例如，你可以这样从ENUM列搜索数值值：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SELECT &lt;em&gt;enum_col&lt;/em&gt;+0 FROM &lt;em&gt;tbl_name&lt;/em&gt;;&lt;/strong&gt;</pre>
<p>如果将一个数字保存到ENUM列，数字被视为索引，并且保存的值是该索引对应的枚举成员。(但是，这不适合LOAD DATA，它将所有输入视为字符串）。不建议使用类似数字的枚举值来定义一个ENUM列，因为这很容易引起混淆。例如，下面的列含有字符串值’0′、’1′和’2′的枚举成员，但数值索引值为1、2和3：</p>
<pre class="brush: sql; gutter: true">numbers ENUM('0','1','2')</pre>
<p>根据枚举成员在列定义中列出的顺序对ENUM值进行排序。(换句话说，ENUM值根据索引编号进行排序）。例如，对于ENUM(‘a’，’b')，’a'排在’b'前面，但对于ENUM(‘b’，’a')，’b'排在’a'前面。空字符串排在非空字符串前面，并且NULL值排在所有其它枚举值前面。要想防止意想不到的结果，按字母顺序规定ENUM列。还可以使用GROUP BY  CAST(col AS CHAR)或GROUP BY  CONCAT(col)来确保按照词汇对列进行排序而不是用索引数字。</p>
<p>如果你想要确定一个ENUM列的所有可能的值，使用SHOW COLUMNS FROM <em>tbl_name</em> LIKE <em>enum_col</em>，并解析输出中第2列的ENUM定义。</p>
<h3>
<a name="set"></a>11.4.5. SET类型</h3>
<p><a name="id2853953"></a><a name="id2853962"></a></p>
<p>SET是一个字符串对象，可以有零或多个值，其值来自表创建时规定的允许的一列值。指定包括多个SET成员的SET列值时各成员之间用逗号(‘,’)间隔开。这样SET成员值本身不能包含逗号。</p>
<p>例如，指定为SET(‘one’, ‘two’) NOT NULL的列可以有下面的任何值：</p>
<pre class="brush: sql; gutter: true">''
'one'
'two'
'one,two'</pre>
<p>SET最多可以有64个不同的成员。</p>
<p>当创建表时，SET成员值的尾部空格将自动被删除。</p>
<p>当检索时，保存在SET列的值使用列定义中所使用的大小写来显示。请注意可以为SET列分配字符集和 校对规则。对于二进制或大小写敏感的校对规则，当为列分配值时应考虑大小写。</p>
<p>MySQL用数字保存SET值，所保存值的低阶位对应第1个SET成员。如果在数值上下文中检索一个SET值，检索的值的位设置对应组成列值的SET成员。例如，你可以这样从一个SET列检索数值值：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SELECT &lt;em&gt;set_col&lt;/em&gt;+0 FROM &lt;em&gt;tbl_name&lt;/em&gt;;&lt;/strong&gt;</pre>
<p>如果将一个数字保存到SET列中，数字中二进制表示中的位确定了列值中的SET成员。对于指定为SET(‘a’,'b’,'c’,'d’)的列，成员有下面的十进制和二进制值：</p>
<table id="table5" border="1" cellpadding="0">
<tbody>
<tr>
<td>SET<strong>成员</strong>
</td>
<td><strong>十进制值</strong></td>
<td><strong>二进制值</strong></td>
</tr>
<tr>
<td>‘a’</td>
<td>1</td>
<td>0001</td>
</tr>
<tr>
<td>‘b’</td>
<td>2</td>
<td>0010</td>
</tr>
<tr>
<td>‘c’</td>
<td>4</td>
<td>0100</td>
</tr>
<tr>
<td>‘d’</td>
<td>8</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>如果你为该列分配一个值9，其二进制形式为1001，因此第1个和第4个SET值成员’a'和’d'被选择，结果值为 ’a,d’。</p>
<p>对于包含多个SET元素的值，当插入值时元素所列的顺序并不重要。在值中一个给定的元素列了多少次也不重要。当以后检索该值时，值中的每个元素出现一次，根据表创建时指定的顺序列出元素。例如，假定某个列指定为SET(‘a’,'b’,'c’,'d’)：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;CREATE TABLE myset (col SET('a', 'b', 'c', 'd'));&lt;/strong&gt;</pre>
<p>插入值’a,d’、’d,a’、’a,d,d’、’a,d,a’和’d,a,d’:</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;INSERT INTO myset (col) VALUES 
&lt;/strong&gt;-&amp;gt; ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');
Query OK, 5 rows affected (0.01 sec)
Records: 5  Duplicates: 0  Warnings: 0</pre>
<p>当检索时所有这些值显示为 ’a,d’：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SELECT col FROM myset;
&lt;/strong&gt;+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------
5 rows in set (0.04 sec)</pre>
<p>如果将SET列设置为一个不支持的值，则该值被忽略并发出警告：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;INSERT INTO myset (col) VALUES ('a,d,d,s');
&lt;/strong&gt;Query OK, 1 row affected, 1 warning (0.03 sec)</pre>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SHOW WARNINGS;
&lt;/strong&gt;+---------+------+------------------------------------------+
| Level   | Code | Message                                  |
+---------+------+------------------------------------------+
| Warning | 1265 | Data truncated for column 'col' at row 1 |
+---------+------+------------------------------------------+
1 row in set (0.04 sec)</pre>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SELECT col FROM myset;
&lt;/strong&gt;+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
6 rows in set (0.01 sec)</pre>
<p>SET值按数字顺序排序。NULL值排在非NULL SET值的前面。</p>
<p>通常情况，可以使用FIND_IN_SET()函数或LIKE操作符搜索SET值：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SELECT * FROM &lt;em&gt;tbl_name&lt;/em&gt; WHERE FIND_IN_SET('&lt;em&gt;value&lt;/em&gt;',&lt;em&gt;set_col&lt;/em&gt;)&amp;gt;0;
&lt;/strong&gt;mysql&amp;gt; &lt;strong&gt;SELECT * FROM &lt;em&gt;tbl_name&lt;/em&gt; WHERE &lt;em&gt;set_col&lt;/em&gt; LIKE '%&lt;em&gt;value&lt;/em&gt;%';&lt;/strong&gt;</pre>
<p>第1个语句找出<em>SET_col</em>包含<em>value</em> set成员的行。第2个类似，但有所不同：它在其它地方找出<em>set_col</em>包含<em>value</em>的行，甚至是在另一个SET成员的子字符串中。</p>
<p>下面的语句也是合法的：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;SELECT * FROM &lt;em&gt;tbl_name&lt;/em&gt; WHERE &lt;em&gt;set_col&lt;/em&gt; &amp;amp; 1;
&lt;/strong&gt;mysql&amp;gt; &lt;strong&gt;SELECT * FROM &lt;em&gt;tbl_name&lt;/em&gt; WHERE &lt;em&gt;set_col&lt;/em&gt; = '&lt;em&gt;val1&lt;/em&gt;,&lt;em&gt;val2&lt;/em&gt;';&lt;/strong&gt;</pre>
<p>第1个语句寻找包含第1个set成员的值。第2个语句寻找一个确切匹配的值。应注意第2类的比较。将set值与’<em>val1</em>,<em>val2</em>‘比较返回的结果与同’<em>val2</em>,<em>val1</em>‘比较返回的结果不同。指定值时的顺序应与在列定义中所列的顺序相同。</p>
<p>如果想要为SET列确定所有可能的值，使用SHOW COLUMNS FROM <em>tbl_name</em> LIKE <em>set_col</em>并解析输出中第2列的SET定义。</p>
<h2>
<a name="storage-requirements"></a>11.5. 列类型存储需求</h2>
<p><a name="id2854549"></a><a name="id2854559"></a>根据类别列出了MySQL支持的每个列类型的存储需求。</p>
<p>MyISAM表中行的最大大小为65,534字节。每个BLOB和TEXT列 账户只占其中的5至9个字节。</p>
<p>如果MyISAM表包括变长列类型，记录格式也是可变长度。当创建表时，在某些条件下，MySQL可以将一个列从变长类型改为固定长度的类型或反之亦然。详细信息参见<a title="13.1.5.1. Silent Column Specification Changes" href="http://dev.mysql.com/doc/refman/5.1/zh/sql-syntax.html#silent-column-changes">13.1.5.1节，“沉寂的列规格变更”</a>。</p>
<p><strong>数值类型存储需求</strong></p>
<table id="table6" border="1" cellpadding="0">
<tbody>
<tr>
<td><strong>列类型</strong></td>
<td><strong>存储需求</strong></td>
</tr>
<tr>
<td>TINYINT</td>
<td>1个字节</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2个字节</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3个字节</td>
</tr>
<tr>
<td>INT, INTEGER</td>
<td>4个字节</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8个字节</td>
</tr>
<tr>
<td>FLOAT(<em>p</em>)</td>
<td>如果0 &lt;= <em>p</em> &lt;= 24为4个字节, 如果25 &lt;= <em>p</em> &lt;= 53为8个字节</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4个字节</td>
</tr>
<tr>
<td>DOUBLE [PRECISION], item REAL</td>
<td>8个字节</td>
</tr>
<tr>
<td>DECIMAL(<em>M</em>,<em>D</em>), NUMERIC(<em>M</em>,<em>D</em>)</td>
<td>变长；参见下面的讨论</td>
</tr>
<tr>
<td>BIT(<em>M</em>)</td>
<td>大约(<em>M</em>+7)/8个字节</td>
</tr>
</tbody>
</table>
<p>DECIMAL(和NUMERIC)的存储需求与具体版本有关：</p>
<p>使用二进制格式将9个十进制(基于10)数压缩为4个字节来表示DECIMAL列值。每个值的整数和分数部分的存储分别确定。每个9位数的倍数需要4个字节，并且“剩余的”位需要4个字节的一部分。下表给出了超出位数的存储需求：</p>
<table id="table7" border="1" cellpadding="0">
<tbody>
<tr>
<td><strong>剩余的</strong></td>
<td><strong>字节</strong></td>
</tr>
<tr>
<td><strong>位数</strong></td>
<td><strong>数目</strong></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>4</td>
</tr>
</tbody>
</table>
<p><strong>日期和时间类型的存储需求</strong></p>
<table id="table8" border="1" cellpadding="0">
<tbody>
<tr>
<td><strong>列类型</strong></td>
<td><strong>存储需求</strong></td>
</tr>
<tr>
<td>DATE</td>
<td>3个字节</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8个字节</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4个字节</td>
</tr>
<tr>
<td>TIME</td>
<td>3个字节</td>
</tr>
<tr>
<td>YEAR</td>
<td>1个字节</td>
</tr>
</tbody>
</table>
<p><strong>字符串类型的存储需求</strong></p>
<table id="table9" border="1" cellpadding="0">
<tbody>
<tr>
<td><strong>列类型</strong></td>
<td><strong>存储需求</strong></td>
</tr>
<tr>
<td>CHAR(<em>M</em>)</td>
<td>
<em>M</em>个字节，0 &lt;= <em>M</em> &lt;= 255</td>
</tr>
<tr>
<td>VARCHAR(<em>M</em>)</td>
<td>
<em>L</em>+1个字节，其中<em>L</em> &lt;= <em>M </em>且0 &lt;= <em>M</em> &lt;= 65535(参见下面的注释)</td>
</tr>
<tr>
<td>BINARY(<em>M</em>)</td>
<td>
<em>M</em>个字节，0 &lt;= <em>M</em> &lt;= 255</td>
</tr>
<tr>
<td>VARBINARY(<em>M</em>)</td>
<td>
<em>L</em>+1个字节，其中<em>L</em> &lt;= <em>M </em>且0 &lt;= <em>M</em> &lt;= 255</td>
</tr>
<tr>
<td>TINYBLOB, TINYTEXT</td>
<td>
<em>L</em>+1个字节，其中<em>L</em> &lt; 2<sup>8</sup>
</td>
</tr>
<tr>
<td>BLOB, TEXT</td>
<td>
<em>L</em>+2个字节，其中<em>L</em> &lt; 2<sup>16</sup>
</td>
</tr>
<tr>
<td>MEDIUMBLOB, MEDIUMTEXT</td>
<td>
<em>L</em>+3个字节，其中<em>L</em> &lt; 2<sup>24</sup>
</td>
</tr>
<tr>
<td>LONGBLOB, LONGTEXT</td>
<td>
<em>L</em>+4个字节，其中<em>L</em> &lt; 2<sup>32</sup>
</td>
</tr>
<tr>
<td>ENUM(‘<em>value1</em>‘,’<em>value2</em>‘,…)</td>
<td>1或2个字节，取决于枚举值的个数(最多65,535个值)</td>
</tr>
<tr>
<td>SET(‘<em>value1</em>‘,’<em>value2</em>‘,…)</td>
<td>1、2、3、4或者8个字节，取决于set成员的数目(最多64个成员)</td>
</tr>
</tbody>
</table>
<p>VARCHAR、BLOB和TEXT类是变长类型。每个类型的存储需求取决于列值的实际长度(用前面的表中的<em>L</em>表示)，而不是该类型的最大可能的大小。例如，VARCHAR(10)列可以容纳最大长度为10的字符串。实际存储需求是字符串(<em>L</em>)的长度，加上一个记录字符串长度的字节。对于字符串’abcd’，<em>L</em>是4，存储需要5个字节。</p>
<p>对于CHAR、VARCHAR和TEXT类型，前面的表中的值<em>L</em>和<em>M</em>应解释为字符数目，并且列定义中的这些类型的长度表示字符数目。例如，要想保存一个TINYTEXT值需要<em>L</em>字符+ 1个字节。</p>
<p>要想计算用于保存具体CHAR、VARCHAR或者TEXT列值的字节数，需要考虑该列使用的字符集。在具体情况中，当使用Unicode时，必须记住所有Unicode字符使用相同的字节数。为了细分用于不同类Unicode字符使用的存储，参见<a title="10.5. Unicode Support" href="http://dev.mysql.com/doc/refman/5.1/zh/charset.html#charset-unicode">10.5节，“Unicode支持”</a>。</p>
<p><strong>注释：</strong>VARCHAR列的<em>有效</em>最大长度为65,532字符。</p>
<p>NDBCLUSTER引擎只支持固定宽度的列。这说明MySQL簇中的表中的VARCHAR列的行为如同类型CHAR(不同的是每个记录仍然有一个额外字节空间)。例如，在Cluster表中，声明为VARCHAR(100)的列中的<em>每个</em>记录存储时将占用101个字节，无论实际存储的记录中的字符串的长度为多少。</p>
<p>BLOB和TEXT类需要 1、2、3或者4个字节来记录列值的长度，取决于该类的最大可能的长度。参见<a title="11.4.3. The BLOB and TEXT Types" href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#blob">11.4.3节，“BLOB和TEXT类型<code></code>”</a>。</p>
<p>在NDB Cluster存储引擎中，TEXT和BLOB列的实施是不同的，其中TEXT列中的每个记录由两个单独部分组成。一个是固定大小(256字节)，并且实际上保存在原表中。另一个包括超出256字节的任何数据，保存在隐含的表中。第2个表中的记录总是2,000字节长。这说明如果<em>size</em>&lt;= 256，TEXT列的大小为256(其中<em>size</em>表示记录的大小)；否则，大小是256 +<em>size</em>+(2000–(<em>size</em>–256)%2000)。</p>
<p>ENUM对象的大小由不同的枚举值的数目确定。枚举用一个字节，可以有255个可能的值。当枚举的值位于256和65,535之间时，用两个字节。参见<a title="11.4.4. The ENUM Type" href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#enum">11.4.4节，“ENUM类型”</a>。</p>
<p>SET对象的大小由不同的set成员的数量确定。如果set大小是<em>N</em>，对象占(<em>N</em>+7)/8个字节，四舍五入到1、2、3、4或者8个字节。SET最多可以有64个成员。参见<a title="11.4.5. The SET Type" href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#set">11.4.5节，“SET类型”</a>。</p>
<h2>
<a name="choosing-types"></a>11.6. 选择正确的列类型</h2>
<p><a name="id2855781"></a><a name="id2855792"></a>为了优化存储，在任何情况下均应使用最精确的类型。例如，如果列的值的范围为从1到99999，若使用整数，则MEDIUMINT UNSIGNED是好的类型。在所有可以表示该列值的类型中，该类型使用的存储最少。</p>
<p>用精度为65位十进制数(基于10)对DECIMAL 列进行所有基本计算(+、-、*、/)。参见<a title="11.1.1. Overview of Numeric Types" href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html#numeric-type-overview">11.1.1节，“数值类型概述”</a>。</p>
<p>使用双精度操作对DECIMAL值进行计算。如果准确度不是太重要或如果速度为最高优先级，DOUBLE类型即足够了。为了达到高精度，可以转换到保存在BIGINT中的定点类型。这样可以用64位整数进行所有计算，根据需要将结果转换回浮点值。</p>
<h2>
<a name="other-vendor-column-types"></a>11.7. 使用来自其他数据库引擎的列类型</h2>
<p><a name="id2855869"></a><a name="id2855879"></a><a name="id2855890"></a><a name="id2855900"></a><a name="id2855912"></a>为了使用由其它卖方编写的SQL执行代码，MySQL按照下表所示对列类型进行映射。通过这些映射，可以很容易地从其它数据库引擎将表定义导入到MySQL中：</p>
<table id="table10" border="1" cellpadding="0">
<tbody>
<tr>
<td><strong>其它卖方类型</strong></td>
<td><strong>MySQL类型</strong></td>
</tr>
<tr>
<td>BOOL,</td>
<td>TINYINT</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>TINYINT</td>
</tr>
<tr>
<td>CHAR VARYING(<em>M</em>)</td>
<td>VARCHAR(<em>M</em>)</td>
</tr>
<tr>
<td>DEC</td>
<td>DECIMAL</td>
</tr>
<tr>
<td>FIXED</td>
<td>DECIMAL</td>
</tr>
<tr>
<td>FLOAT4</td>
<td>FLOAT</td>
</tr>
<tr>
<td>FLOAT8</td>
<td>DOUBLE</td>
</tr>
<tr>
<td>INT1</td>
<td>TINYINT</td>
</tr>
<tr>
<td>INT2</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>INT3</td>
<td>MEDIUMINT</td>
</tr>
<tr>
<td>INT4</td>
<td>INT</td>
</tr>
<tr>
<td>INT8</td>
<td>BIGINT</td>
</tr>
<tr>
<td>LONG VARBINARY</td>
<td>MEDIUMBLOB</td>
</tr>
<tr>
<td>LONG VARCHAR</td>
<td>MEDIUMTEXT</td>
</tr>
<tr>
<td>LONG</td>
<td>MEDIUMTEXT</td>
</tr>
<tr>
<td>MIDDLEINT</td>
<td>MEDIUMINT</td>
</tr>
<tr>
<td>NUMERIC</td>
<td>DECIMAL</td>
</tr>
</tbody>
</table>
<p>在创建表时对列类型进行映射，然后原来的类型定义被丢弃。如果你使用其它卖方的类型创建一个表，然后执行DESCRIBE <em>tbl_name</em>语句，MySQL使用等效的MySQL类型来报告表的结构。例如：</p>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;CREATE TABLE t (a BOOL, b FLOAT8, c LONG, d NUMERIC);
&lt;/strong&gt;Query OK, 0 rows affected (0.08 sec)</pre>
<pre class="brush: sql; gutter: true">mysql&amp;gt; &lt;strong&gt;DESCRIBE t;
&lt;/strong&gt;+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| a     | tinyint(1)    | YES  |     | NULL    |       
&lt;span style="font-family: Monaco, Consolas, 'Andale Mono', 'DejaVu Sans Mono', monospace; font-style: normal;"&gt;| b     | double        | YES  |     | NULL    |       |
&lt;/span&gt;| c     | mediumtext    | YES  |     | NULL    |       |
| d     | decimal(10,0) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
4 rows in set (0.00 sec)</pre>

        
        
    <div class="post-adds">
        <span data-post-id="87324" class="btn-bluet href-style vote-post-up   register-user-only "><i class="fa  fa-thumbs-o-up"></i> <h10 id="87324votetotal">1</h10> 赞</span>
        <span data-book-type="1" data-site-id="2" data-item-id="87324" data-item-type="1" class="btn-bluet href-style bookmark-btn  register-user-only "><i class="fa fa-bookmark-o  "></i>  收藏</span>

                <a href="#article-comment"><span class="btn-bluet href-style"><i class="fa fa-comments-o"></i>  评论</span></a>
        
            </div>


        <!-- BEGIN #author-bio -->


<!-- END #author-bio -->
	


  </article>

  <div class="meta">
  
    <a class="basic-alignment left" href="/posts/2015/2015-06-03-87278-b045c7e69.html" title="Previous Post: Tmux 入门介绍" data-instant>&laquo; Tmux 入门介绍</a>
  
  
    <a class="basic-alignment right" href="/posts/2015/2015-06-03-87327-81bd46d12.html" title="Next Post: 我的MYSQL学习心得（5） ： 运算符" data-instant>我的MYSQL学习心得（5） ： 运算符 &raquo;</a>
  
</div>
  <div id="related">
  <h2 class="subheader">Related Posts <small>They might be useful</small></h2>
  <ul class="posts">
    
      <li><span>21 May 2018</span> &raquo; <a href="http://iftti.com/posts/2018/2018-05-21-114016-1b3612333.html">分布式之消息队列复习精讲</a></li>
    
      <li><span>20 May 2018</span> &raquo; <a href="http://iftti.com/posts/2018/2018-05-20-114009-9d318dfaa.html">分布式之延时任务方案解析</a></li>
    
      <li><span>19 May 2018</span> &raquo; <a href="http://iftti.com/posts/2018/2018-05-19-114012-06b67f2d6.html">分布式之缓存击穿</a></li>
    
  </ul>
</div>

  
<comments>

<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1936498"></script>
<!-- UY END -->

</comments>

</div>
      <!-- JiaThis Button BEGIN -->
<div class="jiathis_share_slide jiathis_share_24x24" id="jiathis_share_slide">
<div class="jiathis_share_slide_top" id="jiathis_share_title"></div>
<div class="jiathis_share_slide_inner">
<div class="jiathis_style_24x24">
<a class="jiathis_button_tsina"></a>
<a class="jiathis_button_googleplus"></a>
<a class="jiathis_button_twitter"></a>
<a class="jiathis_button_linkedin"></a>
<a class="jiathis_button_weixin"></a>
<a class="jiathis_button_cqq"></a>
<a class="jiathis_button_renren"></a>
<a class="jiathis_button_evernote"></a>
<a class="jiathis_button_pocket"></a>
<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'
	,slide:{
		divid:'wrap',
		pos:'left',
		gt:'true'
	}
};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1936498" charset="utf-8"></script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_slide.js" charset="utf-8"></script>
</div></div></div>
<!-- JiaThis Button END -->
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">

    <h2 class="footer-heading">IT技术干货</h2>

    <div class="footer-col-1 column">
      <p class="text">IT技术干货 KernelHacks 最好的技术站点 技术信息 纯干货</p>
      <ul>
        <li>汇集最好的科技与互联网信息</li>
        <li>Liu Lantao</li>
        <li><a href="mailto:iftti@iftti.com">iftti@iftti.com</a></li>
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        <li>
          <a href="https://github.com/Lax">
            <span class="icon github">
              <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            <span class="username">Lax</span>
          </a>
        </li>
        <li>
          <a href="https://twitter.com/liulantao">
            <span class="icon twitter">
              <svg version="1.1" class="twitter-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
              </svg>
            </span>
            <span class="username">@liulantao</span>
          </a>
        </li>
        <li>
          <a href="https://plus.google.com/+LiuLantao">
            <span class="icon googleplus">
              <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                width="16px" height="16px" viewBox="0 0 134.658 131.646" enable-background="new 0 0 134.658 131.646"
                xml:space="preserve">
                <g>
                  <path fill="#C2C2C2" d="M126.515,4.109H8.144c-2.177,0-3.94,1.763-3.94,3.938v115.546c0,2.179,1.763,3.942,3.94,3.942h118.371
                  c2.177,0,3.94-1.764,3.94-3.942V8.048C130.455,5.872,128.691,4.109,126.515,4.109z"/>
                  <g>
                    <path fill="#FFFFFF" d="M70.479,71.845l-3.983-3.093c-1.213-1.006-2.872-2.334-2.872-4.765c0-2.441,1.659-3.993,3.099-5.43
                    c4.64-3.652,9.276-7.539,9.276-15.73c0-8.423-5.3-12.854-7.84-14.956h6.849l7.189-4.517H60.418
                    c-5.976,0-14.588,1.414-20.893,6.619c-4.752,4.1-7.07,9.753-7.07,14.842c0,8.639,6.633,17.396,18.346,17.396
                    c1.106,0,2.316-0.109,3.534-0.222c-0.547,1.331-1.1,2.439-1.1,4.32c0,3.431,1.763,5.535,3.317,7.528
                    c-4.977,0.342-14.268,0.893-21.117,5.103c-6.523,3.879-8.508,9.525-8.508,13.51c0,8.202,7.731,15.842,23.762,15.842
                    c19.01,0,29.074-10.519,29.074-20.932C79.764,79.709,75.344,75.943,70.479,71.845z M56,59.107
                    c-9.51,0-13.818-12.294-13.818-19.712c0-2.888,0.547-5.87,2.428-8.199c1.773-2.218,4.861-3.657,7.744-3.657
                    c9.168,0,13.923,12.404,13.923,20.382c0,1.996-0.22,5.533-2.762,8.09C61.737,57.785,58.762,59.107,56,59.107z M56.109,103.65
                    c-11.826,0-19.452-5.657-19.452-13.523c0-7.864,7.071-10.524,9.504-11.405c4.64-1.561,10.611-1.779,11.607-1.779
                    c1.105,0,1.658,0,2.538,0.111c8.407,5.983,12.056,8.965,12.056,14.629C72.362,98.542,66.723,103.65,56.109,103.65z"/>
                    <polygon fill="#FFFFFF" points="98.393,58.938 98.393,47.863 92.923,47.863 92.923,58.938 81.866,58.938 81.866,64.469
                    92.923,64.469 92.923,75.612 98.393,75.612 98.393,64.469 109.506,64.469 109.506,58.938"/>
                  </g>
                </g>
              </svg>
            </span>
            <span class="username">+LiuLantao</span>
          </a>
        </li>
      </ul>
    </div>

    <div class="footer-col-3 column">
      
<!--以下是QQ邮件列表订阅嵌入代码--><script >var nId = "6be92ef3590ee662cd5e6381ab2044c328716364f684cf3e",nWidth="auto",sColor="light",sText="填写您的邮件地址，订阅我们的精彩内容：" ;</script><script src="http://list.qq.com/zh_CN/htmledition/js/qf/page/qfcode.js" charset="gb18030"></script>

    </div>

  </div>

  <div class="wrap">
    <div>
      <a href="http://blog.liulantao.com">Blog</a> | <a href="http://1000bit.com">铅笔特评 1000bit</a> | <a href="http://visplanet.com">VisPlanet</a> | <a href="http://iftti.com">IT技术干货</a> | <a href="http://relax.org.cn">Relax</a> | <a href="http://hangzhou.io">杭州城市指南</a>
    </div>
  </div>

  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1658815-7', 'iftti.com');
  ga('require', 'displayfeatures');
  ga('send', 'pageview');

</script>


</footer>


    </body>
</html>